--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\AppConfig.java
--------------------
package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class AppConfig {

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\AuditAspect.java
--------------------
package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

@Component
@Aspect
public class AuditAspect {

    private static final Logger logger = LoggerFactory.getLogger("AUDIT_LOGGER");

    // Pointcut pro vĹˇechny metody ve sluĹľbĂˇch
    @Pointcut("within(cz.phsoft.hokej.models.services..*)")
    public void serviceMethods() {}

    // SpustĂ­ se pĹ™ed metodou
    @Before("serviceMethods()")
    public void logBefore(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().toShortString();
        String args = java.util.Arrays.toString(joinPoint.getArgs());
        logger.info("START {} at {} with args {}", methodName, LocalDateTime.now(), args);
    }

    // SpustĂ­ se po ĂşspÄ›ĹˇnĂ©m dokonÄŤenĂ­ metody
    @AfterReturning(pointcut = "serviceMethods()", returning = "result")
    public void logAfterReturning(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();

        Long userId = null;
        Long playerId = null;

        for (Object arg : args) {
            if (arg instanceof PlayerEntity player) {
                playerId = player.getId();
            } else if (arg instanceof MatchRegistrationEntity registration) {
                playerId = registration.getPlayer().getId();
            } else if (arg instanceof Long id) {
                // pokud mĂˇ metoda Long parametry, mĹŻĹľeĹˇ urÄŤit podle poĹ™adĂ­
                // tĹ™eba prvnĂ­ Long = matchId, druhĂ˝ = playerId
            }
        }

        // logovĂˇnĂ­
        logger.info("END {} - userId={} playerId={} returned [{}] at {}",
                methodName, userId, playerId, result, LocalDateTime.now());
    }
}

--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\CustomJsonLoginFilter.java
--------------------
package cz.phsoft.hokej.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.context.HttpSessionSecurityContextRepository;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

// filtr pro REST login
public class CustomJsonLoginFilter extends UsernamePasswordAuthenticationFilter {

    private final ObjectMapper objectMapper = new ObjectMapper();

    public CustomJsonLoginFilter(String loginUrl, AuthenticationManager authManager) {
        setFilterProcessesUrl(loginUrl);
        setAuthenticationManager(authManager);
    }

    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        try {
            // x-www-form-urlencoded i JSON
            String email = null;
            String password = null;

// x-www-form-urlencoded
            if (request.getContentType() != null &&
                    request.getContentType().contains("application/x-www-form-urlencoded")) {
                email = request.getParameter("username");
                password = request.getParameter("password");
            }

// JSON
            if ((email == null || password == null) &&
                    request.getContentType() != null &&
                    request.getContentType().contains("application/json")) {
                Map<String, String> json = objectMapper.readValue(request.getInputStream(), Map.class);
                email = json.get("email");
                password = json.get("password");
            }

            if (email == null || password == null || email.isBlank() || password.isBlank()) {
                throw new BadCredentialsException("ChybĂ­ pĹ™ihlaĹˇovacĂ­ Ăşdaje");
            }

            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(email, password);
            setDetails(request, authRequest);

            return this.getAuthenticationManager().authenticate(authRequest);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    // ĂšspÄ›ĹˇnĂ˝ login
    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
                                            FilterChain chain, Authentication authResult)
            throws IOException, ServletException {

        // UloĹľenĂ­ do SecurityContextHolder
        SecurityContextHolder.getContext().setAuthentication(authResult);

        // VytvoĹ™enĂ­ session a uloĹľenĂ­ SPRING_SECURITY_CONTEXT
        request.getSession(true).setAttribute(
                HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY,
                SecurityContextHolder.getContext()
        );

        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");

        Map<String, Object> result = new HashMap<>();
        result.put("status", "ok");
        result.put("user", authResult.getName());

        objectMapper.writeValue(response.getWriter(), result);
    }

    // NeĂşspÄ›ĹˇnĂ˝ login
    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException {
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");

        Map<String, Object> result = new HashMap<>();
        result.put("status", "error");

        // RozliĹˇenĂ­ neaktivovanĂ©ho ĂşÄŤtu
        if (failed.getCause() instanceof cz.phsoft.hokej.exceptions.AccountNotActivatedException) {
            result.put("message", failed.getCause().getMessage()); // napĹ™. "ĂšÄŤet nenĂ­ aktivovĂˇn. Zkontrolujte email."
        } else if (failed instanceof BadCredentialsException) {
            result.put("message", "NeplatnĂ© pĹ™ihlaĹˇovacĂ­ Ăşdaje");
        } else {
            result.put("message", "Chyba pĹ™i pĹ™ihlĂˇĹˇenĂ­");
        }

        objectMapper.writeValue(response.getWriter(), result);
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\CustomUserDetailsService.java
--------------------
package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import cz.phsoft.hokej.exceptions.AccountNotActivatedException;

import java.util.Set;
import java.util.stream.Collectors;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final AppUserRepository appUserRepository;

    public CustomUserDetailsService(AppUserRepository appUserRepository) {
        this.appUserRepository = appUserRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        AppUserEntity user = appUserRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("UĹľivatel nenalezen"));

        if (!user.isEnabled()) { // nebo podle status == PENDING
            throw new AccountNotActivatedException();
        }

        return org.springframework.security.core.userdetails.User.builder()
                .username(user.getEmail())
                .password(user.getPassword())
                .roles(user.getRole().name().replace("ROLE_", "")) // "ADMIN", "PLAYER", ...
                .disabled(!user.isEnabled()) // neaktivnĂ­ - nelze se pĹ™Ă­hlĂˇsit
                .build();
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\DataInitializer.java
--------------------
package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.*;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import jakarta.annotation.PostConstruct;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Component;
import org.springframework.jdbc.core.JdbcTemplate;


import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Component
public class DataInitializer {

    private final PlayerRepository playerRepository;
    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository matchRegistrationRepository;
    private final AppUserRepository appUserRepository;
    private final JdbcTemplate jdbcTemplate;

    public DataInitializer(PlayerRepository playerRepository,
                           MatchRepository matchRepository,
                           MatchRegistrationRepository matchRegistrationRepository,
                           AppUserRepository appUserRepository,
                           JdbcTemplate jdbcTemplate) {
        this.playerRepository = playerRepository;
        this.matchRepository = matchRepository;
        this.matchRegistrationRepository = matchRegistrationRepository;
        this.appUserRepository = appUserRepository;
        this.jdbcTemplate = jdbcTemplate;
    }

    @PostConstruct
    public void init() {
        // Pokud existuje alespoĹ 1 hrĂˇÄŤ, DB uĹľ byla inicializovanĂˇ
        if (playerRepository.count() > 0) {
            System.out.println("Data already initialized â€“ skipping DataInitializer.");
            return;
        }
        System.out.println("Initializing default data...");

        // --- Seznam hrĂˇÄŤĹŻ ---
        List<PlayerEntity> players = new ArrayList<>(List.of(
                new PlayerEntity("HrĂˇÄŤ_1", "Jedna", "", PlayerType.VIP, "+420776609956", Team.DARK, PlayerStatus.APPROVED),
                new PlayerEntity("HrĂˇÄŤ_2", "Dva", "", PlayerType.VIP, "+420776609956", Team.LIGHT, PlayerStatus.APPROVED),
                new PlayerEntity("HrĂˇÄŤ_3", "TĹ™i", "", PlayerType.VIP, "+420776609956", Team.LIGHT, PlayerStatus.APPROVED),
                new PlayerEntity("HrĂˇÄŤ_4", "ÄŚtyĹ™i", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT, PlayerStatus.APPROVED),
                new PlayerEntity("HrĂˇÄŤ_5", "PÄ›t", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT, PlayerStatus.PENDING),
                new PlayerEntity("HrĂˇÄŤ_6", "Ĺ est", "", PlayerType.STANDARD, "+420776609956", Team.DARK, PlayerStatus.PENDING),
                new PlayerEntity("HrĂˇÄŤ_7", "Sedm", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT, PlayerStatus.PENDING),
                new PlayerEntity("HrĂˇÄŤ_8", "Osum", "", PlayerType.BASIC, "+420776609956", Team.DARK, PlayerStatus.PENDING),
                new PlayerEntity("HrĂˇÄŤ_9", "DevÄ›t", "", PlayerType.BASIC, "+420776609956", Team.DARK, PlayerStatus.PENDING),
                new PlayerEntity("HrĂˇÄŤ_10", "Deset", "", PlayerType.BASIC, "+420776609956", Team.DARK, PlayerStatus.PENDING)
                // ... pĹ™Ă­padnÄ› dalĹˇĂ­ hrĂˇÄŤi
        ));

        // --- VytvoĹ™enĂ­ uĹľivatelĹŻ ke kaĹľdĂ©mu hrĂˇÄŤi ---

        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();

        // --- Default admin ---
        if (appUserRepository.findByEmail("admin@example.com").isEmpty()) {
            AppUserEntity admin = new AppUserEntity();
            admin.setName("admin");
            admin.setSurname("admin");
            admin.setEmail("admin@example.com");
            admin.setPassword(encoder.encode("Administrator123"));
            admin.setRole(Role.ROLE_ADMIN);
            admin.setEnabled(true);
            appUserRepository.save(admin);
            System.out.println("Default admin user created.");
        } else {
            System.out.println("Admin user already exists â€“ skipping.");
        }

        System.out.println("Data initialization completed.");

        int playerCounter = 1;
        for (PlayerEntity player : players) {
            // vytvoĹ™enĂ­ uĹľivatele
            String email = "player" + playerCounter + "@example.com";
            String password = "Player123";

            AppUserEntity user = new AppUserEntity();
            user.setName("HrĂˇÄŤ" + playerCounter);
            user.setSurname("ÄŚĂ­slo_" + playerCounter);
            user.setEmail(email);
            user.setPassword(encoder.encode(password));

            switch (playerCounter){
                case 1:
                    user.setRole(Role.ROLE_ADMIN);
                    System.out.println("Nastavena role: admin");
                    break;
                case 2:
                    user.setRole(Role.ROLE_MANAGER);
                    System.out.println("Nastavena role: manager");
                    break;
                default:
                    user.setRole(Role.ROLE_PLAYER);
                    System.out.println("Nastavena role: player");
            }
            user.setEnabled(true);
            // pĹ™iĹ™adit hrĂˇÄŤe k uĹľivateli
            System.out.println("VytvĂˇĹ™Ă­m uĹľivatele ÄŤ. " + playerCounter);
            player.setUser(user);

            // uloĹľit uĹľivatele (cascade uloĹľĂ­ i hrĂˇÄŤe, pokud je sprĂˇvnÄ› nastaven)
            appUserRepository.save(user);

            playerCounter++;
        }

        // --- UloĹľit hrĂˇÄŤe (uĹľ uloĹľen pĹ™i cascade, ale pro jistotu) ---
        playerRepository.saveAll(players);

        // --- VytvoĹ™enĂ­ zĂˇpasĹŻ ---
        LocalDateTime startDate = LocalDateTime.of(2025, 11, 21, 18, 45);
        for (int i = 0; i < 10; i++) {
            MatchEntity match = new MatchEntity();
            match.setDateTime(startDate.plusWeeks(i));
            match.setLocation("Ostravice");
            match.setDescription("");
            match.setMaxPlayers(12);
            match.setPrice(2200);
            matchRepository.save(match);
        }

        // --- Registrace hrĂˇÄŤĹŻ na zĂˇpas id 3 ---
        MatchEntity match3 = matchRepository.findById(3L)
                .orElseThrow(() -> new RuntimeException("Match with id 3 not found"));

        for (long playerId = 1; playerId <= 6; playerId++) {
            final long pid = playerId;
            PlayerEntity player = playerRepository.findById(playerId)
                    .orElseThrow(() -> new RuntimeException("Player with id " + pid + " not found"));

            MatchRegistrationEntity reg = new MatchRegistrationEntity();
            reg.setMatch(match3);
            reg.setPlayer(player);
            reg.setStatus(PlayerMatchStatus.REGISTERED);
            if (playerId <=3){
                reg.setTeam(Team.DARK);
            }else {
                reg.setTeam(Team.LIGHT);
            }
            reg.setTimestamp(LocalDateTime.now());
            reg.setCreatedBy("user");
            matchRegistrationRepository.save(reg);
        }

        // --- Default admin ---
        if (appUserRepository.findByEmail("admin@example.com").isEmpty()) {
            AppUserEntity admin = new AppUserEntity();
            admin.setEmail("admin@example.com");
            admin.setPassword(encoder.encode("Administrator123"));
            admin.setRole(Role.ROLE_ADMIN);
            appUserRepository.save(admin);
            System.out.println("Default admin user created.");
        } else {
            System.out.println("Admin user already exists â€“ skipping.");
        }

        // --- vytvoĹ™enĂ­ triggeru ---
        try {
            jdbcTemplate.execute("""
                           CREATE TRIGGER trg_match_reg_insert
                           AFTER INSERT ON match_registrations
                           FOR EACH ROW
                           BEGIN
                               INSERT INTO match_registration_history
                               (match_registration_id, match_id, player_id, status, excuse_reason,
                                excuse_note, admin_note, team, original_timestamp, created_by,
                                action, changed_at)
                               VALUES
                               (NEW.id, NEW.match_id, NEW.player_id, NEW.status, NEW.excuse_reason,
                                NEW.excuse_note, NEW.admin_note, NEW.team, NEW.timestamp, NEW.created_by,
                                'INSERT', NOW());
                           END
                    """);
            System.out.println("Trigger created successfully.");
        } catch (Exception e) {
            System.out.println("Trigger already exists or error: " + e.getMessage());
        }

        try {
            jdbcTemplate.execute("""
                    CREATE TRIGGER trg_match_reg_update
                    AFTER UPDATE ON match_registrations
                    FOR EACH ROW
                    BEGIN
                        INSERT INTO match_registration_history
                        (match_registration_id, match_id, player_id, status, excuse_reason,
                         excuse_note, admin_note, team, original_timestamp, created_by,
                         action, changed_at)
                        VALUES
                        (NEW.id, NEW.match_id, NEW.player_id, NEW.status, NEW.excuse_reason,
                         NEW.excuse_note, NEW.admin_note, NEW.team, NEW.timestamp, NEW.created_by,
                         'UPDATE', NOW());
                    END
                    """);
            System.out.println("Trigger created successfully.");
        } catch (Exception e) {
            System.out.println("Trigger already exists or error: " + e.getMessage());
        }

        try {
            jdbcTemplate.execute("""
        CREATE TRIGGER trg_match_reg_delete
        AFTER DELETE ON match_registrations
        FOR EACH ROW
                BEGIN
        INSERT INTO match_registration_history
                (match_registration_id, match_id, player_id, status, excuse_reason,
                        excuse_note, admin_note, team, original_timestamp, created_by,
                        action, changed_at)
        VALUES
                (OLD.id, OLD.match_id, OLD.player_id, OLD.status, OLD.excuse_reason,
                        OLD.excuse_note, OLD.admin_note, OLD.team, OLD.timestamp, OLD.created_by,
                        'DELETE', NOW());
        END
        """);
            System.out.println("Trigger created successfully.");
                } catch (Exception e) {
                    System.out.println("Trigger already exists or error: " + e.getMessage());
                }
        
        System.out.println("Data initialization completed.");
    

    }
}



--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\GlobalExceptionHandler.java
--------------------
package cz.phsoft.hokej.config;

import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.exceptions.ApiError;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import jakarta.servlet.http.HttpServletRequest;

@ControllerAdvice
public class GlobalExceptionHandler {

    // VlastnĂ­ business vyjĂ­mky - BusinessException
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ApiError> handleBusinessException(
            BusinessException ex,
            HttpServletRequest request) {

        ApiError error = new ApiError(
                ex.getStatus().value(),
                ex.getStatus().getReasonPhrase(),
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()
        );
        return ResponseEntity.status(ex.getStatus()).body(error);
    }

    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ApiError> handleAccessDenied(AccessDeniedException ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.FORBIDDEN.value(),
                "Forbidden",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // â† IP klienta);
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(error);
    }

    // --- NenalezenĂ© zdroje (404) ---
    @ExceptionHandler({
            MatchNotFoundException.class,
            PlayerNotFoundException.class,
            RegistrationNotFoundException.class
    })
    public ResponseEntity<ApiError> handleNotFound(RuntimeException ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.NOT_FOUND.value(),
                "Not Found",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // â† IP klienta
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    // --- Konflikty (409) ---
    @ExceptionHandler(DuplicateRegistrationException.class)
    public ResponseEntity<ApiError> handleConflict(DuplicateRegistrationException ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.CONFLICT.value(),
                "Conflict",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // â† IP klienta);
        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
    }

    // --- ObecnĂ© chyby (500) ---
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiError> handleAll(Exception ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // â† IP klienta);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\SecurityConfig.java
--------------------
package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.security.config.http.SessionCreationPolicy;


import java.util.List;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;

    @Value("${app.test-mode:false}")
    private boolean isTestMode;

    public SecurityConfig(CustomUserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    // Password encoder
    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    // Authentication provider
    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    // AuthenticationManager
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    // Security filter chain
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http, AuthenticationManager authManager) throws Exception {

        http.csrf(csrf -> csrf.disable())
                .cors(cors -> {
                });

        if (isTestMode) {
            // Test mode - vĹˇechno povoleno a HTTP Basic pro Postman
            http.authorizeHttpRequests(auth -> auth.anyRequest().permitAll())
                    .httpBasic();
        } else {
            // Produkce - REST login pĹ™es CustomJsonLoginFilter
            http
                    .authenticationProvider(authenticationProvider())
                    .authorizeHttpRequests(auth -> auth
                            .requestMatchers("/api/auth/register", "/api/auth/verify").permitAll()
                            .requestMatchers("/api/login").permitAll()
                            .requestMatchers("/api/logout").permitAll()
                            .requestMatchers("/api/matches").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/matches/upcoming", "/api/matches/past").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/matches/**").authenticated()
                            .requestMatchers("/api/players").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/players/**").authenticated()
                            .requestMatchers("/api/registrations/all",
                                    "/api/registrations/for-match/**",
                                    "/api/registrations/no-response/**").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/registrations/**").authenticated()
                            .requestMatchers("/api/inactivity/All",
                                    "/api/inactivity/**").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/inactivity/player/**").authenticated()
                            .anyRequest().authenticated()
                    )
                    //  TADY PĹESNÄš
                    .sessionManagement(sm ->
                            sm.sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
                    )
                    //  a TEPRVE PAK login filter
                    .addFilterAt(
                            new CustomJsonLoginFilter("/api/login", authManager),
                            UsernamePasswordAuthenticationFilter.class
                    )
                    .logout(logout -> logout
                            .logoutUrl("/api/logout")
                            .deleteCookies("JSESSIONID")
                            .logoutSuccessHandler((request, response, auth) -> {
                                request.getSession().removeAttribute("CURRENT_PLAYER_ID");
                                response.setContentType("application/json");
                                response.setCharacterEncoding("UTF-8");
                                response.getWriter().write("{\"status\":\"ok\",\"message\":\"OdhlĂˇĹˇeno\"}");
                            })
                    );
        }

        return http.build();
    }

    // CORS pro React dev server a cookies
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(List.of("http://localhost:5173"));
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AdminMatchController.java
--------------------
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.services.MatchService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/matches/admin")
@CrossOrigin(origins = "*")
public class AdminMatchController {
    private final MatchService matchService;
    private final CurrentPlayerService currentPlayerService;


    public AdminMatchController(MatchService matchService,
                           CurrentPlayerService currentPlayerService) {
        this.matchService = matchService;
        this.currentPlayerService = currentPlayerService;
    }

    // VĹˇechny zĂˇpasy
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getAllMatches() {
        return matchService.getAllMatches();
    }

    // VĹˇechny nadchĂˇzejĂ­cĂ­ zĂˇpasy
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    @GetMapping("/upcoming")
    public List<MatchDTO> getUpcomingMatches() {
        return matchService.getUpcomingMatches();
    }

    // UĹľ uskuteÄŤnÄ›nĂ© zĂˇpasy
    @GetMapping("/past")
    public List<MatchDTO> getPastMatches() {
        return matchService.getPastMatches();
    }

    // VytvoĹ™enĂ­ zĂˇpasu
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public MatchDTO createMatch(@Valid @RequestBody MatchDTO matchDTO) {
        return matchService.createMatch(matchDTO);
    }

    // ZĂ­skĂˇnĂ­ zĂˇpasu podle ID
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO getMatch(@PathVariable Long id) {
        return matchService.getMatchById(id);
    }

    // Editace zĂˇpasu
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO updateMatch(@PathVariable Long id, @Valid @RequestBody MatchDTO dto) {
        return matchService.updateMatch(id, dto);
    }

    // SmazĂˇnĂ­ zĂˇpasu
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SuccessResponseDTO> deleteMatch(@PathVariable Long id) {
        SuccessResponseDTO response = matchService.deleteMatch(id);
        return ResponseEntity.ok(response);
    }

    // DostupnĂ© zĂˇpasy pro hrĂˇÄŤe
    @GetMapping("/available-for-player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getAvailableMatchesForPlayer(@PathVariable Long playerId) {
        return matchService.getAvailableMatchesForPlayer(playerId);
    }

}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AdminMatchRegistrationController.java
--------------------
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/registrations/admin")
@CrossOrigin(origins = "*")
public class AdminMatchRegistrationController {
    private final MatchRegistrationService service;
    private final CurrentPlayerService currentPlayerService;

    public AdminMatchRegistrationController(MatchRegistrationService service,
                                       CurrentPlayerService currentPlayerService) {
        this.service = service;
        this.currentPlayerService = currentPlayerService;
    }

    @GetMapping("/all")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> getAllRegistrations() {
        return service.getAllRegistrations();
    }
    @GetMapping("/for-match/{matchId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> forMatch(@PathVariable Long matchId) {
        return service.getRegistrationsForMatch(matchId);
    }

    @GetMapping("/for-player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> forPlayer(@PathVariable Long playerId) {
        return service.getRegistrationsForPlayer(playerId);
    }
    @GetMapping("/no-response/{matchId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getNoResponse(@PathVariable Long matchId) {
        return service.getNoResponsePlayers(matchId);
    }


    // UNIVERZĂLNĂŤ ENDPOINT PRO REGISTRACE - za hrĂˇÄŤe


    @PostMapping("/upsert/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchRegistrationDTO upsert(@PathVariable Long playerId, @RequestBody MatchRegistrationRequest request) {

        return service.upsertRegistration(
                request.getMatchId(),
                request.getPlayerId(), // vybranĂ˝ hrĂˇÄŤ
                request.getTeam(),
                request.getAdminNote(),
                request.getExcuseReason(),
                request.getExcuseNote(),
                request.isUnregister()
        );
    }

}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AdminPlayerController.java
--------------------
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.services.PlayerService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/players/admin")
@CrossOrigin(origins = "*")
public class AdminPlayerController {

    private final PlayerService playerService;
    private final CurrentPlayerService currentPlayerService;

    public AdminPlayerController(PlayerService playerService, CurrentPlayerService currentPlayerService) {
        this.playerService = playerService;
        this.currentPlayerService = currentPlayerService;
    }
    // vĹˇichni hrĂˇÄŤi
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getAllPlayers() {
        return playerService.getAllPlayers();
    }

    // hrĂˇÄŤ dle id

    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public PlayerDTO getPlayerById(@PathVariable Long id) {
        return playerService.getPlayerById(id);
    }

    // vytvoĹ™enĂ­ hrĂˇÄŤe
    @PostMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
        public PlayerDTO createPlayer(@RequestBody PlayerDTO playerDTO) {
        return playerService.createPlayer(playerDTO);
    }

    // Ăşprava hrĂˇÄŤe administrĂˇtorem dle id hrĂˇÄŤe
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public PlayerDTO upatePlayerAdmin(@PathVariable Long id,  @RequestBody PlayerDTO dto) {

        return playerService.updatePlayer(id, dto);
    }
    // odstranĂ­ hrĂˇÄŤe
    @PreAuthorize("hasRole('ADMIN')")
    @DeleteMapping("/{id}")
    public ResponseEntity<SuccessResponseDTO> deletePlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.deletePlayer(id);
        return ResponseEntity.ok(response);
    }

    //
    // SCHVĂLENĂŤ HRĂÄŚE
    @PreAuthorize("hasRole('ADMIN')")
    @PutMapping("/approve/{id}")
    public ResponseEntity<SuccessResponseDTO> approvePlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.approvePlayer(id);
        return ResponseEntity.ok(response);

    }
    // ZAMĂŤTNUTĂŤ HRĂÄŚE
    @PreAuthorize("hasRole('ADMIN')")
    @PutMapping("/reject/{id}")
    public ResponseEntity<SuccessResponseDTO> rejectPlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.rejectPlayer(id);
        return ResponseEntity.ok(response);

    }





}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AppUserController.java
--------------------
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.ChangePasswordDTO;
import cz.phsoft.hokej.models.services.AppUserService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/users")
@CrossOrigin(origins = "*")
public class AppUserController {

    private final AppUserService appUserService;

    public AppUserController(AppUserService appUserService) {
        this.appUserService = appUserService;
    }

    // PĹ™ihlĂˇĹˇenĂ˝ uĹľivatel â€“ bezpeÄŤnĂ©
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public AppUserDTO getCurrentUser(Authentication authentication) {
        return appUserService.getCurrentUser(authentication.getName());
    }

    // ZmÄ›na hesla pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
    @PostMapping("/me/change-password")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> changePassword(Authentication authentication,
                                                 @RequestBody ChangePasswordDTO dto) {
        String email = authentication.getName();
        appUserService.changePassword(email, dto.getOldPassword(), dto.getNewPassword(), dto.getNewPasswordConfirm());
        return ResponseEntity.ok("Heslo ĂşspÄ›ĹˇnÄ› zmÄ›nÄ›no");
    }

    // ZmÄ›na pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
    @PutMapping("/me/update")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> updateUser(Authentication authentication,
                                                 @RequestBody AppUserDTO dto) {
        String email = authentication.getName();
        appUserService.updateUser(email, dto);

        return ResponseEntity.ok("uĹľivatel byl zmÄ›nÄ›n");
    }


    // reset hesla uĹľivatele
    @PostMapping("/{id}/reset-password")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<String> resetPassword(@PathVariable Long id) {
        appUserService.resetPassword(id);
        return ResponseEntity.ok("Heslo resetovĂˇno na 'Player123'");
    }

    // Seznam vĹˇech uĹľivatelĹŻ â€“ jen ADMIN
    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    public List<AppUserDTO> getAllUsers() {
        return appUserService.getAllUsers();
    }


}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AuthController.java
--------------------
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.EmailVerificationTokenEntity;
import cz.phsoft.hokej.data.repositories.EmailVerificationTokenRepository;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;
import cz.phsoft.hokej.models.services.AppUserService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/api/auth")
@CrossOrigin(origins = "*")
public class AuthController {

    private final AppUserService appUserService;
    private final AppUserRepository userRepository;
    private final EmailVerificationTokenRepository tokenRepository;

    public AuthController(AppUserService appUserService,
                          AppUserRepository userRepository,
                          EmailVerificationTokenRepository tokenRepository) {
        this.appUserService = appUserService;
        this.userRepository = userRepository;
        this.tokenRepository = tokenRepository;
    }

    // ===== Registrace =====
    @PostMapping("/register")
    public ResponseEntity<?> register(@Valid @RequestBody RegisterUserDTO dto) {
        appUserService.register(dto);
        return ResponseEntity.ok(
                Map.of("status", "ok", "message", "Registrace ĂşspÄ›ĹˇnĂˇ. Zkontrolujte email pro aktivaci ĂşÄŤtu.")
        );
    }

    // ===== ZĂ­skĂˇnĂ­ aktuĂˇlnĂ­ho uĹľivatele =====
    @GetMapping("/me")
    public ResponseEntity<AppUserDTO> getCurrentUser(Authentication authentication) {
        AppUserDTO dto = appUserService.getCurrentUser(authentication.getName());
        return ResponseEntity.ok(dto);
    }

    // ===== Aktivace ĂşÄŤtu =====
    @GetMapping("/verify")
    public ResponseEntity<String> verifyEmail(@RequestParam String token) {
        Optional<EmailVerificationTokenEntity> optionalToken = tokenRepository.findByToken(token);

        if (optionalToken.isEmpty()) {
            return ResponseEntity.badRequest().body("NeplatnĂ˝ aktivaÄŤnĂ­ odkaz.");
        }

        EmailVerificationTokenEntity verificationToken = optionalToken.get();

        if (verificationToken.getExpiresAt().isBefore(LocalDateTime.now())) {
            return ResponseEntity.badRequest().body("AktivaÄŤnĂ­ odkaz vyprĹˇel.");
        }

        AppUserEntity user = verificationToken.getUser();
        user.setEnabled(true);
        userRepository.save(user);

        tokenRepository.delete(verificationToken);

        return ResponseEntity.ok("ĂšÄŤet byl ĂşspÄ›ĹˇnÄ› aktivovĂˇn.");
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\CurrentPlayerController.java
--------------------
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.services.PlayerService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import jakarta.servlet.http.HttpSession;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

// aktuĂˇlnĂ­ hrĂˇÄŤ
@RestController
@RequestMapping("/api/current-player")
public class CurrentPlayerController {

    private final PlayerRepository playerRepository;
    private final AppUserRepository appUserRepository;
    private final CurrentPlayerService currentPlayerService;
    private final PlayerService playerService;

    public CurrentPlayerController(PlayerRepository playerRepository,
                                   AppUserRepository appUserRepository,
                                   CurrentPlayerService currentPlayerService,
                                   PlayerService playerService) {
        this.playerRepository = playerRepository;
        this.appUserRepository = appUserRepository;
        this.currentPlayerService = currentPlayerService;
        this.playerService = playerService;
    }

    // -----------------------------------------------------
    // NastavenĂ­ aktuĂˇlnĂ­ho hrĂˇÄŤe â€“ pokud uĹľivatel mĂˇ jen jednoho, vybere se automaticky
    // -----------------------------------------------------
    @PostMapping("/{playerId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> setCurrentPlayer(@PathVariable Long playerId,
                                 Authentication auth,
                                 HttpSession session) {

        AppUserEntity user = appUserRepository.findByEmail(auth.getName())
                .orElseThrow(() -> new RuntimeException("User not found"));

        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new RuntimeException("Player not found"));

        if (!player.getUser().getId().equals(user.getId())) {
            throw new RuntimeException("Player does not belong to user");
        }

        currentPlayerService.setCurrentPlayerId(player.getId());
        return ResponseEntity.ok("AktuĂˇlnĂ­ hrĂˇÄŤ nastaven na ID: " + player.getId());
    }

    // -----------------------------------------------------
    // AutomatickĂ˝ vĂ˝bÄ›r aktuĂˇlnĂ­ho hrĂˇÄŤe po loginu
    // Zavolat z frontendu /api/current-player/auto-select po pĹ™ihlĂˇĹˇenĂ­
    // -----------------------------------------------------
    @PostMapping("/auto-select")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> autoSelectCurrentPlayer(Authentication auth) {
        AppUserEntity user = appUserRepository.findByEmail(auth.getName())
                .orElseThrow(() -> new RuntimeException("User not found"));

        List<PlayerDTO> players = playerService.getPlayersByUser(user.getEmail());

        if (players.size() == 1) {
            PlayerDTO player = players.get(0);
            currentPlayerService.setCurrentPlayerId(player.getId());
            return ResponseEntity.ok("Automaticky nastaven hrĂˇÄŤ nastaven na ID: " + player.getId());
        } else {
            return ResponseEntity.ok("UĹľivatel mĂˇ vĂ­ce hrĂˇÄŤĹŻ, vĂ˝bÄ›r nutnĂ˝ ruÄŤnÄ›");
        }
    }

    // -----------------------------------------------------
    // ZĂ­skĂˇnĂ­ aktuĂˇlnĂ­ho hrĂˇÄŤe
    // -----------------------------------------------------
    @GetMapping
    @PreAuthorize("isAuthenticated()")
    public PlayerDTO getCurrentPlayer(HttpSession session) {

        Long playerId = currentPlayerService.getCurrentPlayerId();
        if (playerId == null) {
            System.out.println("Ĺ˝ĂˇdnĂ˝ aktuĂˇlnĂ­ hrĂˇÄŤ");
            return null;
        }

        PlayerDTO player = playerService.getPlayerById(playerId);
        System.out.println("AktuĂˇlnĂ­ hrĂˇÄŤ ID: " + playerId);
        return player;
    }

    // -----------------------------------------------------
    // PomocnĂ˝ endpoint â€“ seznam hrĂˇÄŤĹŻ aktuĂˇlnĂ­ho uĹľivatele
    // -----------------------------------------------------
    @GetMapping("/my-players")
    @PreAuthorize("isAuthenticated()")
    public List<PlayerDTO> getMyPlayers(Authentication auth, HttpSession session) {
        AppUserEntity user = appUserRepository.findByEmail(auth.getName())
                .orElseThrow(() -> new RuntimeException("User not found"));

        List<PlayerDTO> players = playerService.getPlayersByUser(user.getEmail());

        System.out.println("Seznam hrĂˇÄŤĹŻ uĹľivatele " + user.getEmail() + ": " +
                players.stream().map(PlayerDTO::getId).toList());

        return players;
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\DebugController.java
--------------------
package cz.phsoft.hokej.controllers;

import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class DebugController {

    @GetMapping("/api/debug/me")
    public Object me(Authentication auth) {
        return auth;
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\MatchController.java
--------------------
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;
import cz.phsoft.hokej.models.dto.MatchOverviewDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.services.MatchService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;


@RestController
@RequestMapping("/api/matches")
@CrossOrigin(origins = "*")
public class MatchController {

    private final MatchService matchService;
    private final CurrentPlayerService currentPlayerService;


    public MatchController(MatchService matchService,
                           CurrentPlayerService currentPlayerService) {
        this.matchService = matchService;
        this.currentPlayerService = currentPlayerService;
    }

    // Detail zĂˇpasu
    @PreAuthorize("isAuthenticated()")
    @GetMapping("/matchDetail/{id}")
    public MatchDetailDTO getMatchDetail(@PathVariable Long id) {
        return matchService.getMatchDetail(id);
    }

    // NadchĂˇzejĂ­cĂ­ zĂˇpas - NEPOUĹ˝ĂŤVAT - NENĂŤ TAM PLAYER TYPE
    @PreAuthorize("isAuthenticated()")
    @GetMapping("/next")
    public MatchDTO getNextMatch() {
        return matchService.getNextMatch();
    }

    // NadchĂˇzejĂ­cĂ­ zĂˇpasy pro pĹ™ihlĂˇĹˇenĂ©ho hrĂˇÄŤe
    @GetMapping("/me/upcoming")
    @PreAuthorize("isAuthenticated()")
    public List<MatchDTO> getUpcomingMatchesForMe(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getUpcomingMatchesForPlayer(currentPlayerId);
    }

    @GetMapping("/me/upcoming-overview")
    @PreAuthorize("isAuthenticated()")
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForMe(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getUpcomingMatchesOverviewForPlayer(currentPlayerId);
    }

    @GetMapping("/me/all-passed")
    @PreAuthorize("isAuthenticated()")
    public List<MatchOverviewDTO> getAllMatchesForPlayer(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getAllPassedMatchesForPlayer(currentPlayerId);
    }





}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\MatchRegistrationController.java
--------------------
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import org.springframework.web.bind.annotation.*;
import org.springframework.security.access.prepost.PreAuthorize;

import java.util.List;

@RestController
@RequestMapping("/api/registrations")
@CrossOrigin(origins = "*")
public class MatchRegistrationController {

    private final MatchRegistrationService service;
    private final CurrentPlayerService currentPlayerService;

    public MatchRegistrationController(MatchRegistrationService service,
                                       CurrentPlayerService currentPlayerService) {
        this.service = service;
        this.currentPlayerService = currentPlayerService;
    }


    // UNIVERZĂLNĂŤ ENDPOINT PRO REGISTRACE


    @PostMapping("/me/upsert")
    @PreAuthorize("isAuthenticated()")
    public MatchRegistrationDTO upsert(@RequestBody MatchRegistrationRequest request) {
        // automaticky bere vybranĂ©ho hrĂˇÄŤe
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        return service.upsertRegistration(
                request.getMatchId(),
                currentPlayerId, // vĹľdy aktuĂˇlnĂ­ hrĂˇÄŤ
                request.getTeam(),
                request.getAdminNote(),
                request.getExcuseReason(),
                request.getExcuseNote(),
                request.isUnregister()
        );
    }

    // registrace na zĂˇpasy pĹ™ihlĂˇĹˇenĂ©ho hrĂˇÄŤe
    @GetMapping("/me/for-current-player")
    @PreAuthorize("isAuthenticated()")
    public List<MatchRegistrationDTO> forCurrentPlayer() {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return service.getRegistrationsForPlayer(currentPlayerId);
    }


}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerController.java
--------------------
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.PlayerService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/players")
@CrossOrigin(origins = "*")
public class PlayerController {

    private final PlayerService playerService;
    private final CurrentPlayerService currentPlayerService;

    public PlayerController(PlayerService playerService, CurrentPlayerService currentPlayerService) {
        this.playerService = playerService;
        this.currentPlayerService = currentPlayerService;
    }

    // vytvoĹ™enĂ­ hrĂˇÄŤe pro pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
    @PostMapping("/me")
    @PreAuthorize("isAuthenticated()") // kaĹľdĂ˝ pĹ™ihlĂˇĹˇenĂ˝ uĹľivatel
    public PlayerDTO createMyPlayer(@RequestBody PlayerDTO playerDTO, Authentication authentication) {
        String email = authentication.getName(); // email pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
        return playerService.createPlayerForUser(playerDTO, email);
    }

    // zĂ­skĂˇnĂ­ hrĂˇÄŤĹŻ pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public List<PlayerDTO> getMyPlayers(Authentication authentication) {
        String email = authentication.getName();
        return playerService.getPlayersByUser(email);
    }

    // Ăşprava hrĂˇÄŤe pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
    @PutMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public PlayerDTO updatePlayer(@RequestBody PlayerDTO dto) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        return playerService.updatePlayer(currentPlayerId, dto);
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerInactivityPeriodController.java
--------------------
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import cz.phsoft.hokej.models.services.PlayerInactivityPeriodService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/inactivity/Admin")
@CrossOrigin(origins = "*")
public class PlayerInactivityPeriodController {

    private final PlayerInactivityPeriodService service;

    public PlayerInactivityPeriodController(PlayerInactivityPeriodService service) {
        this.service = service;
    }

    // vĹˇechny zĂˇznamy o neaktivitÄ› hrĂˇÄŤĹŻ
    @GetMapping("/all")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getAll() {
        return service.getAll();
    }

    // neaktivita hrĂˇÄŤĹŻ dle id neaktivity
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<PlayerInactivityPeriodDTO> getById(@PathVariable Long id) {
        PlayerInactivityPeriodDTO dto = service.getById(id);
        return ResponseEntity.ok(dto);
    }

    // zĂ­skĂˇ zĂˇznamy o periodÄ› neaktivity dle id hrĂˇÄŤe
    @GetMapping("/player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getByPlayer(@PathVariable Long playerId) {
        return service.getByPlayer(playerId);
    }

    // vytvoĹ™Ă­ zĂˇznam o neaktivitÄ› hrĂˇÄŤe
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<PlayerInactivityPeriodDTO> create(@RequestBody PlayerInactivityPeriodDTO dto) {
        PlayerInactivityPeriodDTO created = service.create(dto);
        return ResponseEntity.ok(created);
    }

    // zmÄ›nĂ­ zĂˇznam o neaktivitÄ› hrĂˇÄŤe dle id
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<PlayerInactivityPeriodDTO> update(
            @PathVariable Long id,
            @RequestBody PlayerInactivityPeriodDTO dto) {

        PlayerInactivityPeriodDTO updated = service.update(id, dto);
        return ResponseEntity.ok(updated);
    }

    // vymaĹľe zĂˇznam o neaktivitÄ› hrĂˇÄŤe dle id zĂˇznamu
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        service.delete(id);
        return ResponseEntity.noContent().build();
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestController.java
--------------------
package cz.phsoft.hokej.controllers;

import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/test")
@CrossOrigin(origins = "*")
public class TestController {

    @GetMapping
    public String hello() {
        return "Backend je online!";
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestEmailController.java
--------------------
package cz.phsoft.hokej.controllers;


import cz.phsoft.hokej.models.services.email.EmailService;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/email/test")
public class TestEmailController {
    private final EmailService emailService;

    public TestEmailController(EmailService emailService) {
        this.emailService = emailService;
    }

    @PostMapping("/send-mail")
    public String sendTestMail() {
        emailService.sendSimpleEmail(
                "petrhlista@seznam.cz",
                "APP - TestovacĂ­ email",
                "Ahoj, toto je test z backendu."
        );
        return "Email odeslĂˇn";
    }

}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestSmsController.java
--------------------
/*
package cz.phsoft.hokej.controllers;


import cz.phsoft.hokej.models.services.sms.SmsTextBeeService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TestSmsController {

    private final SmsTextBeeService smsTextBeeService;

    public TestSmsController(SmsTextBeeService smsTextBeeService) {
        this.smsTextBeeService = smsTextBeeService;
    }

    /**
     * TestovacĂ­ endpoint pro odeslĂˇnĂ­ SMS na testovacĂ­ ÄŤĂ­slo.
     * Zavolej: GET /api/test-sms
     */
/*
    @GetMapping("/api/test-sms")
    public String sendTestSms() {
        smsTextBeeService.sendSms("+420776609956", "testovacĂ­ sms app-sg");
        return "SMS byla odeslĂˇna na testovacĂ­ ÄŤĂ­slo +420776609956";
    }
}

        */
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\AppUserEntity.java
--------------------
package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.Role;
import jakarta.persistence.*;

import java.util.Set;

@Entity
@Table(name = "app_users")
public class AppUserEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String surname;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role;

    @Column(nullable = false)
    private boolean enabled = false; // vĂ˝chozĂ­ hodnota false


    // One-to-Many: jeden uĹľivatel â†’ vĂ­ce hrĂˇÄŤĹŻ
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<PlayerEntity> players;

    // gettery/settery


    public Long getId() {return id;}

    public void setId(Long id) {this.id = id;}

    public String getName() {return name;}

    public void setName(String name) {this.name = name;}

    public String getSurname() { return surname; }

    public void setSurname(String surname) { this.surname = surname; }

    public String getEmail() {return email;}

    public void setEmail(String email) {this.email = email;}

    public String getPassword() {return password;}

    public void setPassword(String password) {this.password = password;}

    public Role getRole() {return role;}

    public void setRole(Role role) {this.role = role;}

    public boolean isEnabled() {    return enabled;    }

    public void setEnabled(boolean enabled) {  this.enabled = enabled;    }

    public Set<PlayerEntity> getPlayers() {return players;}

    public void setPlayers(Set<PlayerEntity> players) {this.players = players;}
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\EmailVerificationTokenEntity.java
--------------------
package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDateTime;


@Entity
@Table(name = "email_verification_tokens")
public class EmailVerificationTokenEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 64)
    private String token;

    @Column(nullable = false)
    private LocalDateTime expiresAt;

    @OneToOne
    @JoinColumn(name = "user_id", nullable = false)
    private AppUserEntity user;

    // gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getToken() { return token; }
    public void setToken(String token) { this.token = token; }

    public LocalDateTime getExpiresAt() { return expiresAt; }
    public void setExpiresAt(LocalDateTime expiresAt) { this.expiresAt = expiresAt; }

    public AppUserEntity getUser() { return user; }
    public void setUser(AppUserEntity user) { this.user = user; }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchEntity.java
--------------------
package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;
import java.time.LocalDateTime;

/**
 * tĹ™Ă­da pro vklĂˇdĂˇnĂ­ Entity zĂˇpasu do db
 */
@Entity
@Table(name = "matches")
public class MatchEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private LocalDateTime dateTime;

    @Column(nullable = false)
    private String location;

    private String description;

    // maximĂˇlnĂ­ poÄŤet hrĂˇÄŤĹŻ - vyuĹľĂ­vĂˇ se pro ovÄ›Ĺ™enĂ­ kapacity pĹ™i pĹ™ihlĂˇĹˇenĂ­
    @Column(nullable = false)
    private Integer maxPlayers;

    @Column(nullable = false)
    private Integer price;

    public MatchEntity() {}

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }

    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() { return price; }

    public void setPrice(Integer price) { this.price = price; }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationEntity.java
--------------------
package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * tĹ™Ă­da reprezentuje registracei hrĂˇÄŤe k zĂˇpasu
 */
@Entity
@Table(name = "match_registrations")
public class MatchRegistrationEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "match_id", nullable = false)
    private MatchEntity match;

    @ManyToOne
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerMatchStatus status;

    @Enumerated(EnumType.STRING)
    private ExcuseReason excuseReason;

    private String excuseNote;

    // admin mĹŻĹľe vloĹľit poznĂˇmku, napĹ™. kdyĹľ se nÄ›kdo zaregistruje a potĂ© nepĹ™Ă­jde
    private String adminNote;

    @Enumerated(EnumType.STRING)
    @Column(name = "team")
    private Team team;

    // datÄŤas vytvoĹ™enĂ­ registrace - musĂ­ se mÄ›nit aby nebyl hrĂˇÄŤ i po zruĹˇenĂ­ registrace
    // v poĹ™adĂ­ pĹ™ed hrĂˇÄŤi kteĹ™Ă­ se registrovali po zruĹˇenĂ­ registrace
    @Column(nullable = false, updatable = true)
    private LocalDateTime timestamp = LocalDateTime.now();

    // systĂ©m automaticky vytvĂˇĹ™Ă­ reserved/registered dle kapacity - maxPlayers
    @Column(nullable = false, updatable = true)
    private String createdBy; // "user" nebo "system"

    public MatchRegistrationEntity() {
    }

    // Gettery a Settery


    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public MatchEntity getMatch() {
        return match;
    }

    public void setMatch(MatchEntity match) {
        this.match = match;
    }

    public PlayerEntity getPlayer() {
        return player;
    }

    public void setPlayer(PlayerEntity player) {
        this.player = player;
    }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }

    public ExcuseReason getExcuseReason() {
        return excuseReason;
    }

    public void setExcuseReason(ExcuseReason excuseReason) {
        this.excuseReason = excuseReason;
    }

    public String getExcuseNote() {
        return excuseNote;
    }

    public void setExcuseNote(String excuseNote) {
        this.excuseNote = excuseNote;
    }

    public String getAdminNote() {
        return adminNote;
    }

    public void setAdminNote(String adminNote) {
        this.adminNote = adminNote;
    }

    public Team getTeam() {
        return team;
    }

    public void setTeam(Team team) {
        this.team = team;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }
}



--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationHistoryEntity.java
--------------------
package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.persistence.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "match_registration_history")
public class MatchRegistrationHistoryEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // ID z pĹŻvodnĂ­ hlavnĂ­ tabulky
    @Column(name = "match_registration_id", nullable = false)
    private Long matchRegistrationId;

    @Column(name = "match_id", nullable = false)
    private Long matchId;

    @Column(name = "player_id", nullable = false)
    private Long playerId;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerMatchStatus status;

    @Enumerated(EnumType.STRING)
    @Column(name = "excuse_reason")
    private ExcuseReason excuseReason;

    @Column(name = "excuse_note")
    private String excuseNote;

    @Column(name = "admin_note")
    private String adminNote;

    @Enumerated(EnumType.STRING)
    @Column(name = "team")
    private Team team;

    // pĹŻvodnĂ­ timestamp
    @Column(name = "original_timestamp", nullable = false)
    private LocalDateTime originalTimestamp;

    @Column(name = "created_by", nullable = false)
    private String createdBy;

    @Column(nullable = false)
    private String action; // INSERT / UPDATE / DELETE

    @Column(name = "changed_at", nullable = false)
    private LocalDateTime changedAt;

    public MatchRegistrationHistoryEntity() {
    }

    // Gettery a settery


    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getMatchRegistrationId() {
        return matchRegistrationId;
    }

    public void setMatchRegistrationId(Long matchRegistrationId) {
        this.matchRegistrationId = matchRegistrationId;
    }

    public Long getMatchId() {
        return matchId;
    }

    public void setMatchId(Long matchId) {
        this.matchId = matchId;
    }

    public Long getPlayerId() {
        return playerId;
    }

    public void setPlayerId(Long playerId) {
        this.playerId = playerId;
    }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }

    public ExcuseReason getExcuseReason() {
        return excuseReason;
    }

    public void setExcuseReason(ExcuseReason excuseReason) {
        this.excuseReason = excuseReason;
    }

    public String getExcuseNote() {
        return excuseNote;
    }

    public void setExcuseNote(String excuseNote) {
        this.excuseNote = excuseNote;
    }

    public String getAdminNote() {
        return adminNote;
    }

    public void setAdminNote(String adminNote) {
        this.adminNote = adminNote;
    }

    public Team getTeam() {
        return team;
    }

    public void setTeam(Team team) {
        this.team = team;
    }

    public LocalDateTime getOriginalTimestamp() {
        return originalTimestamp;
    }

    public void setOriginalTimestamp(LocalDateTime originalTimestamp) {
        this.originalTimestamp = originalTimestamp;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }

    public String getAction() {
        return action;
    }

    public void setAction(String action) {
        this.action = action;
    }

    public LocalDateTime getChangedAt() {
        return changedAt;
    }

    public void setChangedAt(LocalDateTime changedAt) {
        this.changedAt = changedAt;
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerEntity.java
--------------------
package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerType;
import jakarta.persistence.*;

@Entity
@Table(name = "player_entity")
public class PlayerEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String surname;

    private String nickName;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerType type; // VIP, STANDARD, BASIC

    private String fullName;
    private String phoneNumber;

    @Enumerated(EnumType.STRING)
    private Team team;

    @Enumerated(EnumType.STRING)
    private PlayerStatus status = PlayerStatus.PENDING;


    // Many-to-One: kaĹľdĂ˝ hrĂˇÄŤ patĹ™Ă­ jednomu uĹľivateli
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private AppUserEntity user;

    // ----------------- Konstruktor -----------------
    public PlayerEntity() {
        this.type = PlayerType.BASIC;
    }

    public PlayerEntity(String name, String surname, String nickName, PlayerType type, String phoneNumber, Team team, PlayerStatus status) {
        this.name = name;
        this.surname = surname;
        this.nickName = nickName;
        this.type = type;
        this.fullName = name + " " + surname;
        this.phoneNumber = phoneNumber;
        this.team = team;
        this.status = status;
    }

    // ----------------- Gettery a Settery -----------------
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
        updateFullName();
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
        updateFullName();
    }

    public String getNickname() { return nickName;}
    public void setNickname(String nickName) { this.nickName = nickName; }

    public String getFullName() {
        return fullName;
    }

    public PlayerType getType() {
        return type;
    }
    public void setType(PlayerType type) {
        this.type = type;
    }

    private void updateFullName() {
        this.fullName = name + " " + surname;
    }

    public String getPhoneNumber() {
        return phoneNumber;
    }
    public void setPhoneNumber(String phoneNumber) {
        this.phoneNumber = phoneNumber;
    }

    public Team getTeam() {
        return team;
    }
    public void setTeam(Team team) {
        this.team = team;
    }

    public AppUserEntity getUser() {
        return user;
    }
    public void setUser(AppUserEntity user) {
        this.user = user;
    }

    public PlayerStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerStatus status) {
        this.status = status;
    }

    public String getNickName() {
        return nickName;
    }

    public void setNickName(String nickName) {
        this.nickName = nickName;
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerInactivityPeriodEntity.java
--------------------
package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "player_inactivity_period")
public class PlayerInactivityPeriodEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    // neaktivnĂ­ od
    @Column(name = "inactive_from", nullable = false)
    private LocalDateTime inactiveFrom;

    // neaktivnĂ­ do
    @Column(name = "inactive_to", nullable = false)
    private LocalDateTime inactiveTo;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public PlayerEntity getPlayer() {
        return player;
    }

    public void setPlayer(PlayerEntity player) {
        this.player = player;
    }

    public LocalDateTime getInactiveFrom() {
        return inactiveFrom;
    }

    public void setInactiveFrom(LocalDateTime inactiveFrom) {
        this.inactiveFrom = inactiveFrom;
    }

    public LocalDateTime getInactiveTo() {
        return inactiveTo;
    }

    public void setInactiveTo(LocalDateTime inactiveTo) {
        this.inactiveTo = inactiveTo;
    }

}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\ExcuseReason.java
--------------------
package cz.phsoft.hokej.data.enums;

public enum ExcuseReason {
    NEMOC,
    PRACE,
    NECHE_SE_MI,
    JINE
}

--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\PlayerMatchStatus.java
--------------------
package cz.phsoft.hokej.data.enums;

public enum PlayerMatchStatus {
    REGISTERED, // registrovĂˇn
    UNREGISTERED, // odhlĂˇĹˇen
    EXCUSED,  // omluven
    RESERVED, // nĂˇhradnĂ­k
    NO_RESPONSE, // bez odpovÄ›di
    NO_EXCUSED, // neomluven - byl registrovĂˇn a nepĹ™iĹˇel

}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\PlayerStatus.java
--------------------
package cz.phsoft.hokej.data.enums;

public enum PlayerStatus {
    PENDING, // ÄŤekĂˇ na schvĂˇlenĂ­
    APPROVED, // schvĂˇleno administrĂˇtorem
    REJECTED // zamĂ­tnuto
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\PlayerType.java
--------------------
package cz.phsoft.hokej.data.enums;

public enum PlayerType {
    VIP,
    STANDARD,
    BASIC
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\Role.java
--------------------
package cz.phsoft.hokej.data.enums;

public enum Role {
    ROLE_PLAYER,
    ROLE_MANAGER,
    ROLE_ADMIN
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\Team.java
--------------------
package cz.phsoft.hokej.data.enums;

public enum Team {
    DARK,
    LIGHT

}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\AppUserRepository.java
--------------------
package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface AppUserRepository extends JpaRepository<AppUserEntity, Long> {
    Optional<AppUserEntity> findByEmail(String email);
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\EmailVerificationTokenRepository.java
--------------------
package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.EmailVerificationTokenEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface EmailVerificationTokenRepository extends JpaRepository<EmailVerificationTokenEntity, Long> {
    Optional<EmailVerificationTokenEntity> findByToken(String token);
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRegistrationHistoryRepository.java
--------------------
package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchRegistrationHistoryEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface MatchRegistrationHistoryRepository extends JpaRepository<MatchRegistrationHistoryEntity, Long> {

    // vĹˇechny registrace na zĂˇpas
    List<MatchRegistrationHistoryEntity> findByMatchRegistrationIdOrderByChangedAtDesc(Long matchRegistrationId);

    // Historie pro konkrĂ©tnĂ­ zĂˇpas
    List<MatchRegistrationHistoryEntity> findByMatchIdOrderByChangedAtDesc(Long matchId);

    // Historie zmÄ›n hrĂˇÄŤe
    List<MatchRegistrationHistoryEntity> findByPlayerIdOrderByChangedAtDesc(Long playerId);

}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRegistrationRepository.java
--------------------
package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

    @Repository
    public interface MatchRegistrationRepository extends JpaRepository<MatchRegistrationEntity, Long> {

        // VrĂˇtĂ­ poslednĂ­ status pro danĂ©ho hrĂˇÄŤe a zĂˇpas
        Boolean existsByPlayerIdAndMatchId(Long playerId, Long matchId);

        // VolitelnÄ›: vĹˇechny registrace pro urÄŤitĂ˝ zĂˇpas
        List<MatchRegistrationEntity> findByMatchId(Long matchId);

        // VolitelnÄ›: vĹˇechny registrace pro urÄŤitĂ©ho hrĂˇÄŤe
        List<MatchRegistrationEntity> findByPlayerId(Long playerId);

        // --- NovĂˇ metoda pro hledĂˇnĂ­ konkrĂ©tnĂ­ registrace ---
        Optional<MatchRegistrationEntity> findByPlayerIdAndMatchId(Long playerId, Long matchId);

        long countByMatchIdAndStatus(Long matchId, PlayerMatchStatus status);

        List<MatchRegistrationEntity> findByMatchIdIn(List<Long> matchIds);
    }
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRepository.java
--------------------
package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import java.time.LocalDateTime;
import java.util.List;

public interface MatchRepository extends JpaRepository<MatchEntity, Long> {
    List<MatchEntity> findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime dateTime);
    List<MatchEntity> findByDateTimeBeforeOrderByDateTimeDesc(LocalDateTime dateTime);
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\PlayerInactivityPeriodRepository.java
--------------------

package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface PlayerInactivityPeriodRepository extends JpaRepository<PlayerInactivityPeriodEntity, Long> {

    // zjistĂ­, zda hrĂˇÄŤ je aktuĂˇlnÄ› neaktivnĂ­
    boolean existsByPlayerAndInactiveFromLessThanEqualAndInactiveToGreaterThanEqual(
            PlayerEntity player, LocalDateTime from, LocalDateTime to);

    // zĂ­skĂˇ vĹˇechny neaktivnĂ­ obdobĂ­ hrĂˇÄŤe, kterĂ© spadajĂ­ do intervalu
    List<PlayerInactivityPeriodEntity> findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
            PlayerEntity player, LocalDateTime from, LocalDateTime to);

    List<PlayerInactivityPeriodEntity> findByPlayerOrderByInactiveFromAsc(PlayerEntity player);
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\PlayerRepository.java
--------------------
package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface PlayerRepository extends JpaRepository<PlayerEntity, Long> {
    Optional<PlayerEntity> findById(Long id);

    List<PlayerEntity> findByIdNotIn(List<Long> ids);
    boolean existsByNameAndSurname(String name, String surname);

    Optional<PlayerEntity> findByNameAndSurname(String name, String surname);
    Optional<PlayerEntity> findByUserEmail(String email);
    List<PlayerEntity> findAllByUserEmail(String email);
    List<PlayerEntity> findByUser_EmailOrderByIdAsc(String email);
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\AccountNotActivatedException.java
--------------------
package cz.phsoft.hokej.exceptions;

import org.springframework.http.HttpStatus;

public class AccountNotActivatedException extends BusinessException {

    public AccountNotActivatedException() {
        super("PrvnĂ­ musĂ­te aktivovat ĂşÄŤet pomocĂ­ odkazu v emailu", HttpStatus.FORBIDDEN); // 403
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\ApiError.java
--------------------
package cz.phsoft.hokej.exceptions;

import com.fasterxml.jackson.annotation.JsonFormat;
import java.time.LocalDateTime;
import java.util.Map;

public class ApiError {

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime timestamp;
    private int status;
    private String error;
    private String message;
    private String path;
    private String clientIp; // â† novÄ›

    // VolitelnĂ©: podrobnosti (validace, vĂ­ce chyb, atd.)
    private Map<String, String> details;

    public ApiError(int status, String error, String message, String path,
                    String clientIp) {
        this.timestamp = LocalDateTime.now();
        this.status = status;
        this.error = error;
        this.message = message;
        this.path = path;
        this.clientIp = clientIp;
    }

    public ApiError(int status,
                            String error,
                            String message,
                            String path,
                            String clientIp,
                            Map<String, String> details) {
        this(status, error, message, path, clientIp);
        this.details = details;
    }

    public LocalDateTime getTimestamp() { return timestamp; }
    public int getStatus() { return status; }
    public String getError() { return error; }
    public String getMessage() { return message; }
    public String getPath() { return path; }
    public String getClientIp() { return clientIp; }
    public Map<String, String> getDetails() { return details; }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\BusinessException.java
--------------------
package cz.phsoft.hokej.exceptions;

import org.springframework.http.HttpStatus;

public class BusinessException extends RuntimeException {

    private final HttpStatus status;

    protected BusinessException(String message, HttpStatus status) {
        super(message);
        this.status = status;
    }

    public HttpStatus getStatus() {
        return status;
    }
}

--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\DuplicateNameSurnameException.java
--------------------
package cz.phsoft.hokej.exceptions;

public class DuplicateNameSurnameException extends RuntimeException {
    public DuplicateNameSurnameException(String message) {
        super(message);
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\DuplicateRegistrationException.java
--------------------
package cz.phsoft.hokej.exceptions;

public class DuplicateRegistrationException extends RuntimeException {
    public DuplicateRegistrationException(Long matchId, Long playerId) {
        super("HrĂˇÄŤ " + playerId + " jiĹľ mĂˇ aktivnĂ­ registraci na zĂˇpas " + matchId);
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\InvalidPlayerStatusException.java
--------------------
package cz.phsoft.hokej.exceptions;

public class InvalidPlayerStatusException extends RuntimeException {
    public InvalidPlayerStatusException(String message) {
        super(message);
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\MatchNotFoundException.java
--------------------
package cz.phsoft.hokej.exceptions;

public class MatchNotFoundException extends RuntimeException {
    public MatchNotFoundException(Long matchId) {
        super("ZĂˇpas s ID " + matchId + " nenalezen.");;
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\PlayerNotFoundException.java
--------------------
package cz.phsoft.hokej.exceptions;

import org.springframework.http.HttpStatus;

public class PlayerNotFoundException extends BusinessException {
    public PlayerNotFoundException(Long playerId) {
        super("HrĂˇÄŤ s ID " + playerId + " nenalezen.", HttpStatus.NOT_FOUND);}
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\RegistrationNotFoundException.java
--------------------
package cz.phsoft.hokej.exceptions;

public class RegistrationNotFoundException extends RuntimeException {
    public RegistrationNotFoundException(Long matchId, Long playerId) {
        super("HrĂˇÄŤ " + playerId + " nemĂˇ registraci na zĂˇpas " + matchId);
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\UserAlreadyExistsException.java
--------------------
package cz.phsoft.hokej.exceptions;

import org.springframework.http.HttpStatus;

public class UserAlreadyExistsException extends BusinessException {

    public UserAlreadyExistsException(String message) {
        super(message, HttpStatus.CONFLICT); // 409
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\AppUserMapper.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.PlayerSummaryDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

import java.util.List;

@Mapper(componentModel = "spring")
public interface AppUserMapper {
    @Mapping(target = "players", source = "players")
    AppUserDTO toDTO(AppUserEntity entity);

    List<AppUserDTO> toDtoList(List<AppUserEntity> entities);

    @Mapping(source = "nickname", target = "nickName")
    @Mapping(target = "fullName", ignore = true)
    PlayerDTO toPlayerDTO(PlayerEntity entity);
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\MatchMapper.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchOverviewDTO;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;

@Mapper(componentModel = "spring")
public interface MatchMapper {

    MatchDTO toDTO(MatchEntity entity);

    MatchEntity toEntity(MatchDTO dto);

    void updateEntity(MatchDTO dto, @MappingTarget MatchEntity entity);
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\MatchRegistrationMapper.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

import java.util.List;

@Mapper(componentModel = "spring")
public interface MatchRegistrationMapper {

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "match", source = "match")
    @Mapping(target = "player", source = "player")
    @Mapping(target = "status", source = "status")
    @Mapping(target = "excuseReason", source = "excuseReason")
    @Mapping(target = "excuseNote", source = "note")
    @Mapping(target = "team", source = "team")
    @Mapping(target = "adminNote", source = "adminNote")
    @Mapping(target = "createdBy", source = "createdBy")
    @Mapping(target = "timestamp", expression = "java(java.time.LocalDateTime.now())")
    MatchRegistrationEntity toEntity(
            MatchEntity match,
            PlayerEntity player,
            PlayerMatchStatus status,
            ExcuseReason excuseReason,
            String note,
            Team team,
            String adminNote,
            String createdBy
    );

    // entity â†’ DTO (volitelnĂ©)
    @Mapping(target = "matchId", source = "match.id")
    @Mapping(target = "playerId", source = "player.id")
    MatchRegistrationDTO toDTO(MatchRegistrationEntity entity);

    List<MatchRegistrationDTO> toDTOList(List<MatchRegistrationEntity> entities);
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\PlayerInactivityPeriodMapper.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import org.mapstruct.*;

@Mapper(componentModel = "spring")
public interface PlayerInactivityPeriodMapper {

    // Entity -> DTO (OK)
    @Mapping(target = "playerId", source = "player.id")
    PlayerInactivityPeriodDTO toDTO(PlayerInactivityPeriodEntity entity);

    // DTO -> Entity (player Ĺ™eĹˇĂ­ @ObjectFactory)
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "player", ignore = true)
    PlayerInactivityPeriodEntity toEntity(PlayerInactivityPeriodDTO dto, @Context PlayerEntity player);

    // UPDATE DTO -> existujĂ­cĂ­ entity (bez zmÄ›ny player)
    @Mapping(target = "player", ignore = true)
    void updateEntityFromDto(PlayerInactivityPeriodDTO dto, @MappingTarget PlayerInactivityPeriodEntity entity);

    // FACTORY â€“ jedinĂ˝ sprĂˇvnĂ˝ zpĹŻsob, jak nastavit player z @Context
    @ObjectFactory
    default PlayerInactivityPeriodEntity createEntity(PlayerInactivityPeriodDTO dto, @Context PlayerEntity player) {
        PlayerInactivityPeriodEntity entity = new PlayerInactivityPeriodEntity();
        entity.setPlayer(player);
        return entity;
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\PlayerMapper.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

import java.util.List;

@Mapper(componentModel = "spring")
public interface PlayerMapper {

        // Entity â†’ DTO (heslo se neposĂ­lĂˇ)
        @Mapping(source = "nickname", target = "nickName")
        @Mapping(target = "fullName", ignore = true) // generuje se v DTO
        PlayerDTO toDTO(PlayerEntity entity);

        // DTO â†’ Entity (heslo se mapuje, pokud existuje)
        @Mapping(source = "nickName", target = "nickname")   // KLĂŤÄŚOVĂ‰
        @Mapping(target = "fullName", ignore = true)         // generuje si Entity sama
        @Mapping(target = "user", ignore = true)             // nastavujeĹˇ v service
        @Mapping(
                target = "status",
                expression = "java(dto.getStatus() != null ? dto.getStatus() : cz.phsoft.hokej.data.enums.PlayerStatus.PENDING)"
        )
        PlayerEntity toEntity(PlayerDTO dto);

        // Aktualizace existujĂ­cĂ­ho DTO (ignorujeme fullName)
        @Mapping(target = "fullName", ignore = true)
        @Mapping(target = "id", ignore = true)
        void updatePlayerDTO(PlayerDTO source, @MappingTarget PlayerDTO target);

        // Aktualizace existujĂ­cĂ­ Entity (heslo se mapuje, fullName nenĂ­ pole v Entity)
        @Mapping(source = "nickName", target = "nickname")   // i tady je dĹŻleĹľitĂ©
        @Mapping(target = "fullName", ignore = true)
        @Mapping(target = "user", ignore = true)
        @Mapping(
                target = "status",
                expression = "java(source.getStatus() != null ? source.getStatus() : target.getStatus())"
        )
        void updatePlayerEntity(PlayerDTO source, @MappingTarget PlayerEntity target);

    List<PlayerDTO> toDTOList(List<PlayerEntity> players);


}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\requests\MatchRegistrationRequest.java
--------------------
package cz.phsoft.hokej.models.dto.requests;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.validation.constraints.*;


public class MatchRegistrationRequest {
    @NotNull
    @Positive
    private Long matchId;

    @NotNull
    @Positive
    private Long playerId;

    private Team team;
    private ExcuseReason excuseReason;
    private String excuseNote;
    private String adminNote;
    private boolean unregister;

    public Long getMatchId() { return matchId; }
    public Long getPlayerId() { return playerId; }
    public Team getTeam() { return team; }
    public ExcuseReason getExcuseReason() { return excuseReason; }
    public String getExcuseNote() { return excuseNote; }
    public String getAdminNote() { return adminNote; }
    public boolean isUnregister() { return unregister; }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\AppUserDTO.java
--------------------
package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.util.Set;

public class AppUserDTO {
    private Long id;
    private String name; // not null
    private String surname;
    private String email;
    private Role role;
    private boolean enabled;
    private Set<PlayerDTO> players; // jednostrannĂ©


    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public Role getRole() {
        return role;
    }

    public void setRole(Role role) {
        this.role = role;
    }

    public boolean isEnabled() { return enabled; }

    public void setEnabled(boolean enabled) { this.enabled = enabled;}

    public Set<PlayerDTO> getPlayers() {
        return players;
    }

    public void setPlayers(Set<PlayerDTO> players) {
        this.players = players;
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\ChangePasswordDTO.java
--------------------
package cz.phsoft.hokej.models.dto;

public class ChangePasswordDTO {
    private String oldPassword;
    private String newPassword;
    private String newPasswordConfirm;

    // gettery a settery
    public String getOldPassword() { return oldPassword; }
    public void setOldPassword(String oldPassword) { this.oldPassword = oldPassword; }
    public String getNewPassword() { return newPassword; }
    public void setNewPassword(String newPassword) { this.newPassword = newPassword; }
    public String getNewPasswordConfirm() { return newPasswordConfirm; }
    public void setNewPasswordConfirm(String newPasswordConfirm) { this.newPasswordConfirm = newPasswordConfirm; }
}

--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchDetailDTO.java
--------------------
package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;

import java.time.LocalDateTime;
import java.util.List;

public class MatchDetailDTO {
    private Long id;
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime dateTime;
    private int maxPlayers;
    private int inGamePlayers;
    private int outGamePlayers;
    private int waitingPlayers;
    private int noActionPlayers;
    private double pricePerRegisteredPlayer;
    private int remainingSlots;

    List<PlayerDTO> registeredPlayers;
    List<PlayerDTO> reservedPlayers;
    List<PlayerDTO> unregisteredPlayers;
    List<PlayerDTO> excusedPlayers;
    List<PlayerDTO> noResponsePlayers;

    // Gettery a settery

    public Long getId() {       return id;    }
    public void setId(Long id) {
        this.id = id;
    }
    public LocalDateTime getDateTime() {
        return dateTime;
    }

    public void setDateTime(LocalDateTime dateTime) {
        this.dateTime = dateTime;
    }

    public int getMaxPlayers() {
        return maxPlayers;
    }
    public void setMaxPlayers(int maxPlayers) {
        this.maxPlayers = maxPlayers;
    }

    public int getInGamePlayers() {
        return inGamePlayers;
    }
    public void setInGamePlayers(int inGamePlayers) {
        this.inGamePlayers = inGamePlayers;
    }

    public void setOutGamePlayers(int outGamePlayers) {
        this.outGamePlayers = outGamePlayers;
    }

    public int getWaitingPlayers() {
        return waitingPlayers;
    }
    public void setWaitingPlayers(int waitingPlayers) {
        this.waitingPlayers = waitingPlayers;
    }

    public int getNoActionPlayers() {
        return noActionPlayers;
    }
    public void setNoActionPlayers(int noActionPlayers) {
        this.noActionPlayers = noActionPlayers;
    }

    public double getPricePerRegisteredPlayer() {
        return pricePerRegisteredPlayer;
    }
    public void setPricePerRegisteredPlayer(double pricePerRegisteredPlayer) {
        this.pricePerRegisteredPlayer = pricePerRegisteredPlayer;
    }

    public int getRemainingSlots() {
        return remainingSlots;
    }
    public void setRemainingSlots(int remainingSlots) {
        this.remainingSlots = remainingSlots;
    }

    public List<PlayerDTO> getRegisteredPlayers() {
        return registeredPlayers;
    }
    public void setRegisteredPlayers(List<PlayerDTO> registeredPlayers) {
        this.registeredPlayers = registeredPlayers;
    }

    public List<PlayerDTO> getReservedPlayers() {
        return reservedPlayers;
    }
    public void setReservedPlayers(List<PlayerDTO> reservedPlayers) {
        this.reservedPlayers = reservedPlayers;
    }

    public List<PlayerDTO> getUnregisteredPlayers() {
        return unregisteredPlayers;
    }

    public void setUnregisteredPlayers(List<PlayerDTO> unregisteredPlayers) {
        this.unregisteredPlayers = unregisteredPlayers;
    }
    public List<PlayerDTO> getExcusedPlayers() {
        return excusedPlayers;
    }
    public void setExcusedPlayers(List<PlayerDTO> excusedPlayers) {
        this.excusedPlayers = excusedPlayers;
    }

    public List<PlayerDTO> getNoResponsePlayers() {
        return noResponsePlayers;
    }
    public void setNoResponsePlayers(List<PlayerDTO> noResponsePlayers) {
        this.noResponsePlayers = noResponsePlayers;
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchDTO.java
--------------------
package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import jakarta.validation.constraints.FutureOrPresent;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

import java.time.LocalDateTime;

public class MatchDTO {

    private Long id;
    @NotNull(message = "Datum a ÄŤas zĂˇpasu je povinnĂ©.")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime dateTime;

    @NotBlank(message = "MĂ­sto zĂˇpasu je povinnĂ©.")
    @Size(min = 3, max = 100)
    private String location;

    @Size(max = 255, message = "Popis mĹŻĹľe mĂ­t max 255 znakĹŻ.")
    private String description;

    @NotNull(message = "MaximĂˇlnĂ­ poÄŤet hrĂˇÄŤĹŻ je povinnĂ˝")
    private Integer maxPlayers;

    @NotNull(message = "Cena je povinnĂˇ")
    private Integer price;

    // gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }
    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() {
        return price;
    }

    public void setPrice(Integer price) {
        this.price = price;
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchOverviewDTO.java
--------------------
package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;

import java.time.LocalDateTime;

public class MatchOverviewDTO {

    private Long id;

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime dateTime;

    private String location;
    private String description;
    private Integer price;
    private int maxPlayers;
    private int inGamePlayers;
    private double pricePerRegisteredPlayer;
    private PlayerMatchStatus status;

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getPrice() { return price; }
    public void setPrice(Integer price) { this.price = price; }

    public int getMaxPlayers() { return maxPlayers; }
    public void setMaxPlayers(int maxPlayers) { this.maxPlayers = maxPlayers; }

    public int getInGamePlayers() { return inGamePlayers; }
    public void setInGamePlayers(int inGamePlayers) { this.inGamePlayers = inGamePlayers; }

    public double getPricePerRegisteredPlayer() { return pricePerRegisteredPlayer; }
    public void setPricePerRegisteredPlayer(double pricePerRegisteredPlayer) { this.pricePerRegisteredPlayer = pricePerRegisteredPlayer; }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchRegistrationDTO.java
--------------------
package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;

public class MatchRegistrationDTO {
    private Long id; // volitelnĂ©, pĹ™i GET

    @NotNull(message = "ID zĂˇpasu je povinnĂ©.")
    @Positive(message = "ID zĂˇpasu musĂ­ bĂ˝t kladnĂ©.")
    private Long matchId;

    @NotNull(message = "ID hrĂˇÄŤe je povinnĂ©.")
    @Positive(message = "ID hrĂˇÄŤe musĂ­ bĂ˝t kladnĂ©.")
    private Long playerId;

    private PlayerMatchStatus status;
    private ExcuseReason excuseReason; // pouze pokud status = EXCUSED
    private String excuseNote;
    private String adminNote;
    private Team team;

    @NotNull
    private String createdBy; // "user" nebo "system"

    private PlayerDTO playerDTO;

    public MatchRegistrationDTO() {}

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public Long getMatchId() { return matchId; }
    public void setMatchId(Long matchId) { this.matchId = matchId; }

    public Long getPlayerId() { return playerId; }
    public void setPlayerId(Long playerId) { this.playerId = playerId; }

    public PlayerMatchStatus getStatus() { return status; }
    public void setStatus(PlayerMatchStatus status) { this.status = status; }

    public ExcuseReason getExcuseReason() { return excuseReason; }
    public void setExcuseReason(ExcuseReason excuseReason) { this.excuseReason = excuseReason; }

    public String getExcuseNote() { return excuseNote; }
    public void setExcuseNote(String excuseNote) { this.excuseNote = excuseNote; }

    public String getAdminNote() { return adminNote; }
    public void setAdminNote(String adminNote) { this.adminNote = adminNote; }

    public Team getTeam() { return team; }
    public void setTeam (Team team) { this.team = team; }

    public String getCreatedBy() { return createdBy; }
    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }
}

--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerDTO.java
--------------------
package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerType;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class PlayerDTO {


    private Long id; // autogenerated, nullable pĹ™i create

    @NotBlank(message = "KĹ™estnĂ­ jmĂ©no je povinnĂ©.")
    @Size(min = 2, max = 50)
    private String name; // not null

    @NotBlank(message = "PĹ™Ă­jmenĂ­ je povinnĂ©.")
    @Size(min = 2, max = 50)
    private String surname; // not null
    private String nickName;
    private String fullName; // derived
    private String phoneNumber;
    private PlayerType type; // not null, default BASIC
    private Team team;
    private PlayerStatus status;


    public PlayerDTO() {
        this.type = PlayerType.BASIC;
   }

    public PlayerDTO(Long id, String name, String surname, String nickName, PlayerType type, Team team, PlayerStatus status) {
        this.id = id;
        this.name = name;
        this.surname = surname;
        this.nickName = nickName;
        this.type = type != null ? type : PlayerType.BASIC;
        this.updateFullName();
        this.team = team;
        this.status = status != null ? status : PlayerStatus.PENDING;
    }

    // --- Gettery a Settery ---

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; updateFullName(); }

    public String getSurname() { return surname; }
    public void setSurname(String surname) { this.surname = surname; updateFullName(); }

    public String getNickName() { return nickName; }

    public void setNickName(String nickName) { this.nickName = nickName; }

    public String getFullName() { return fullName; }

    private void updateFullName() { this.fullName = name + " " + surname; }

    public PlayerType getType() { return type; }
    public void setType(PlayerType type) { this.type = type != null ? type : PlayerType.BASIC; }

    public Team getTeam() { return team; }
    public void setTeam(Team team) { this.team = team; }

    public String getPhoneNumber() { return phoneNumber; }
    public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }

    public PlayerStatus getStatus() { return status; }
    public void setStatus(PlayerStatus status) { this.status = status != null ? status : PlayerStatus.PENDING;
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerInactivityPeriodDTO.java
--------------------
package cz.phsoft.hokej.models.dto;

import java.time.LocalDateTime;

public class PlayerInactivityPeriodDTO {

    private Long id;
    private Long playerId;
    private LocalDateTime inactiveFrom;
    private LocalDateTime inactiveTo;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getPlayerId() {
        return playerId;
    }

    public void setPlayerId(Long playerId) {
        this.playerId = playerId;
    }

    public LocalDateTime getInactiveFrom() {
        return inactiveFrom;
    }

    public void setInactiveFrom(LocalDateTime inactiveFrom) {
        this.inactiveFrom = inactiveFrom;
    }

    public LocalDateTime getInactiveTo() {
        return inactiveTo;
    }

    public void setInactiveTo(LocalDateTime inactiveTo) {
        this.inactiveTo = inactiveTo;
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerSummaryDTO.java
--------------------
package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.enums.Team;

public class PlayerSummaryDTO {
    private Long id;
    private String name;
    private String surname;
    private String fullName;
    private String nickName;
    private PlayerType type;
    private Team team;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public String getFullName() {
        return fullName;
    }

    public void setFullName(String fullName) {
        this.fullName = fullName;
    }

    public String getNickName() {
        return nickName;
    }

    public void setNickName(String nickName) {
        this.nickName = nickName;
    }

    public PlayerType getType() {
        return type;
    }

    public void setType(PlayerType type) {
        this.type = type;
    }

    public Team getTeam() {
        return team;
    }

    public void setTeam(Team team) {
        this.team = team;
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\RegisterUserDTO.java
--------------------
package cz.phsoft.hokej.models.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class RegisterUserDTO {

    @NotBlank(message = "KĹ™estnĂ­ jmĂ©no je povinnĂ©.")
    @Size(min = 2, max = 50)
    private String name; // not null

    @NotBlank(message = "PĹ™Ă­jmenĂ­ je povinnĂ©.")
    @Size(min = 2, max = 50)
    private String surname;

    @NotBlank(message = "email je povinnĂ˝.")
    @Email
    private String email;

    @NotBlank
    @Size(min = 8, max = 64)
    private String password;

    @NotBlank
    private String passwordConfirm;


    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getPasswordConfirm() {
        return passwordConfirm;
    }

    public void setPasswordConfirm(String passwordConfirm) {
        this.passwordConfirm = passwordConfirm;
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\SuccessResponseDTO.java
--------------------
package cz.phsoft.hokej.models.dto;

public class SuccessResponseDTO {
    private  String message;
    private Long id;
    private String timestamp;

    public SuccessResponseDTO(String message, Long id, String timestamp) {
        this.message = message;
        this.id = id;
        this.timestamp = timestamp;
    }

    public String getMessage() { return message; }
    public Long getId() { return id; }
    public String getTimestamp() { return timestamp; }

}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\email\EmailService.java
--------------------
package cz.phsoft.hokej.models.services.email;

import jakarta.mail.MessagingException;
import jakarta.mail.internet.MimeMessage;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

@Service
public class EmailService {
    private final JavaMailSender mailSender;

    @Value("${spring.mail.from}")
    private String fromEmail;

    @Value("${email.enabled:true}")   //
    private boolean emailEnabled;

    public EmailService(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    // ===== 1) JEDNODUCHĂť TEXTOVĂť EMAIL =====
    @Async
    public void sendSimpleEmail(String to, String subject, String text) {

        if (!emailEnabled) {
            System.out.println("MAIL JE VYPNUTĂť â€“ email nebyl odeslĂˇn na: " + to);
            return;
        }


        try {
            SimpleMailMessage message = new SimpleMailMessage();
            message.setTo(to);
            message.setSubject(subject);
            message.setText(text);
            message.setFrom(fromEmail);

            mailSender.send(message);
        } catch (Exception e) {
            // DoporuÄŤeno: logovat do souboru
            throw new RuntimeException("Chyba pĹ™i odesĂ­lĂˇnĂ­ emailu: " + e.getMessage(), e);
        }
    }

    // ===== 2) HTML EMAIL (HEZÄŚĂŤ) =====
    @Async
    public void sendHtmlEmail(String to, String subject, String htmlContent) {

        if (!emailEnabled) {
            System.out.println("MAIL JE VYPNUTĂť â€“ email nebyl odeslĂˇn na: " + to);
            return;
        }

        try {
            MimeMessage mimeMessage = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true, "UTF-8");

            helper.setTo(to);
            helper.setSubject(subject);
            helper.setText(htmlContent, true); // true = HTML
            helper.setFrom(fromEmail);

            mailSender.send(mimeMessage);
        } catch (MessagingException e) {
            throw new RuntimeException("Chyba pĹ™i odesĂ­lĂˇnĂ­ HTML emailu: " + e.getMessage(), e);
        }
    }
    public void sendActivationEmail(String to, String activationLink) {
        String subject = "PotvrÄŹte svĹŻj ĂşÄŤet";
        String text = "DobrĂ˝ den,\n\n"
                + "KliknÄ›te na tento odkaz pro aktivaci ĂşÄŤtu:\n"
                + activationLink + "\n\n"
                + "Platnost odkazu: 24 hodin.\n\n"
                + "DÄ›kujeme!";
        sendSimpleEmail(to, subject, text);
    }

    @Async
    public void sendActivationEmailHTML(String to, String activationLink) {
        String subject = "PotvrzenĂ­ registrace - App - Hokej StarĂˇ Garda";
        String html = "<p>DÄ›kujeme za registraci.</p>" +
                "<p>KliknÄ›te na odkaz pro aktivaci ĂşÄŤtu:</p>" +
                "<a href=\"" + activationLink + "\">Aktivovat ĂşÄŤet</a>";

        sendHtmlEmail(to, subject, html);
    }

}

--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsMessageBuilder.java
--------------------
package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import org.springframework.stereotype.Component;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;

import java.time.format.DateTimeFormatter;

@Component
public class SmsMessageBuilder {

    private final MatchRegistrationRepository matchRegistrationRepository;
    private final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");

    public SmsMessageBuilder(MatchRegistrationRepository matchRegistrationRepository) {
        this.matchRegistrationRepository = matchRegistrationRepository;
    }

    // --------------------------
    // zprĂˇva po registraci/odhlĂˇĹˇenĂ­/omluvenĂ­
    // --------------------------
    public String buildMessageRegistration(MatchRegistrationEntity registration) {
        PlayerMatchStatus status = registration.getStatus();
        String statusText = switch (status) {
            case REGISTERED -> "pĹ™ihlĂˇsil se k zĂˇpasu";
            case UNREGISTERED -> "odhlĂˇsil se ze zĂˇpasu";
            case EXCUSED -> "omluven";
            default -> "neznĂˇmĂ˝ stav";
        };

        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(registration.getMatch().getId(), PlayerMatchStatus.REGISTERED);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - datum: ")
                .append(registration.getMatch().getDateTime().toLocalDate());

        if (status != PlayerMatchStatus.EXCUSED) {
            sb.append(", ").append(registeredCount)
                    .append("/").append(registration.getMatch().getMaxPlayers());
        }

        sb.append(", hrĂˇÄŤ: ").append(registration.getPlayer().getFullName())
                .append(", status: ").append(statusText);

        return sb.toString();
    }

    // --------------------------
    // zprĂˇva pro hrĂˇÄŤe, kteĹ™Ă­ jeĹˇtÄ› nereagovali
    // --------------------------
    public String buildMessageNoResponse(PlayerDTO player, MatchEntity match) {
        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - upozornÄ›nĂ­: zĂˇpas ")
                .append(match.getDateTime().format(dateFormatter))
                .append(" - volnĂˇ mĂ­sta: ")
                .append(match.getMaxPlayers() - registeredCount)
                .append(". JeĹˇtÄ› jste nereagoval.");

        return sb.toString();
    }

    // --------------------------
    // finĂˇlnĂ­ pĹ™ipomĂ­nka pro pĹ™ihlĂˇĹˇenĂ© hrĂˇÄŤe v den zĂˇpasu
    // --------------------------
    public String buildMessageFinal(MatchRegistrationEntity registration) {
        MatchEntity match = registration.getMatch();
        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);

        double pricePerPlayer = match.getPrice() / Math.max(registeredCount, 1);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - pĹ™ipomĂ­nka zĂˇpasu ")
                .append(match.getDateTime().format(dateFormatter))
                .append(", pĹ™ihlĂˇĹˇeno: ").append(registeredCount).append("/").append(match.getMaxPlayers())
                .append(", cena na hrĂˇÄŤe: ").append(String.format("%.2f KÄŤ", pricePerPlayer));

        return sb.toString();
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsSchedulerService.java
--------------------
package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import jakarta.transaction.Transactional;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.List;

@Service
public class SmsSchedulerService {

    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository registrationRepository;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;
    private final MatchRegistrationService matchRegistrationService;

    public SmsSchedulerService(
            MatchRepository matchRepository,
            MatchRegistrationRepository registrationRepository,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder,
            MatchRegistrationService matchRegistrationService) {

        this.matchRepository = matchRepository;
        this.registrationRepository = registrationRepository;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
        this.matchRegistrationService = matchRegistrationService;
    }

    // PoslĂˇnĂ­ SMS v den zĂˇpasu
    // SpustĂ­ se kaĹľdĂ˝ den v 12:30
    @Scheduled(cron = "0 30 12 * * *")
    @Transactional
    public void sendFinalSmsForTodayMatches() {

        LocalDate today = LocalDate.now();

        // najdeme vĹˇechny dneĹˇnĂ­ zĂˇpasy
        List<MatchEntity> todaysMatches = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().toLocalDate().isEqual(today))
                .toList();

        for (MatchEntity match : todaysMatches) {

            // naÄŤteme vĹˇechny registrace k danĂ©mu zĂˇpasu (BEZ zmÄ›n entit)
            List<MatchRegistrationEntity> registrations =
                    registrationRepository.findByMatchId(match.getId());

            for (MatchRegistrationEntity reg : registrations) {

                // pouĹľijeĹˇ svĹŻj pĹŻvodnĂ­ builder
                String smsMsg = smsMessageBuilder.buildMessageFinal(reg);

                try {
                    smsService.sendSms(reg.getPlayer().getPhoneNumber(), smsMsg);
                    System.out.println("FinĂˇlnĂ­ SMS poslĂˇna hrĂˇÄŤi "
                            + reg.getPlayer().getFullName() + ": " + smsMsg);

                } catch (Exception e) {
                    System.err.println("Chyba SMS pro hrĂˇÄŤe "
                            + reg.getPlayer().getFullName() + ": " + e.getMessage());
                }
            }
        }
    }

    // poslĂˇnĂ­ SMS 3 dny pĹ™ed zĂˇpasem - noresponse player
    @Scheduled(cron = "0 40 14 * * *") // kaĹľdĂ˝ den ve 12:30
    @Transactional
    public void sendNoResponseSmsForMatchesIn3Days() {

        LocalDate targetDate = LocalDate.now().plusDays(3);

        // vĹˇechny zĂˇpasy, kterĂ© jsou za 3 dny
        List<MatchEntity> matchesInThreeDays = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().toLocalDate().isEqual(targetDate))
                .toList();

        for (MatchEntity match : matchesInThreeDays) {

            // pouĹľijeme tvĹŻj existujĂ­cĂ­ helper
            List<PlayerDTO> noResponsePlayers =
                    matchRegistrationService.getNoResponsePlayers(match.getId());

            for (PlayerDTO player : noResponsePlayers) {

                String smsMsg = smsMessageBuilder.buildMessageNoResponse(player, match);

                try {
                    smsService.sendSms(player.getPhoneNumber(), smsMsg);
                    System.out.println("NORESPONSE SMS poslĂˇna hrĂˇÄŤi "
                            + player.getFullName() + ": " + smsMsg);
                } catch (Exception e) {
                    System.err.println("Chyba NORESPONSE SMS pro hrĂˇÄŤe "
                            + player.getFullName() + ": " + e.getMessage());
                }
            }
        }
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsService.java
--------------------
package cz.phsoft.hokej.models.services.sms;

public interface SmsService {
    void sendSms(String phoneNumber, String message);
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsServiceImpl.java
--------------------
/* package cz.phsoft.hokej.models.services.sms;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;

@Service
public class SmsServiceImpl {

   // private final RestTemplate restTemplate = new RestTemplate();

    @Value("${textbee.api-url}")
    private String apiUrl;

    @Value("${textbee.api-key}")
    private String apiKey;

    // testovacĂ­ ÄŤĂ­slo
    //private final String testNumber = "+420776609956";

    /**
     * OdeĹˇle SMS na testovacĂ­ ÄŤĂ­slo.
     * @param message text zprĂˇvy
     */

/*
    public void sendSms(String phoneNumber, String message) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("x-api-key", apiKey);

        Map<String, Object> body = Map.of(
                "recipients", List.of(phoneNumber),
                "message", message
        );

        HttpEntity<Map<String,Object>> request = new HttpEntity<>(body, headers);

        try {
            ResponseEntity<String> response = restTemplate.postForEntity(apiUrl, request, String.class);
            System.out.println("SMS poslĂˇna na testovacĂ­ ÄŤĂ­slo  xxx   : " + response.getBody());
        } catch (Exception e) {
            System.err.println("Chyba pĹ™i odesĂ­lĂˇnĂ­ SMS: " + e.getMessage());
        }
    }

*/
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsTextBeeService.java
--------------------
package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.models.services.sms.SmsService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;

// textbee - free s omezenĂ­m na 50 sms / den
@Service
public class SmsTextBeeService implements SmsService {

    @Value("${sms.enabled:true}")
    private boolean smsEnabled;

    @Value("${textbee.api-url}")
    private String apiUrl;

    @Value("${textbee.api-key}")
    private String apiKey;

    private final RestTemplate restTemplate = new RestTemplate();

    @Override
    public void sendSms(String phoneNumber, String message) {
        if (!smsEnabled) {
            System.out.println("SMS disabled, message not sent: " + message);
            return;
        }

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("x-api-key", apiKey);

        Map<String, Object> body = Map.of(
                "recipients", List.of(phoneNumber),
                "message", message
        );

        HttpEntity<Map<String,Object>> request = new HttpEntity<>(body, headers);

        try {
            ResponseEntity<String> response = restTemplate.postForEntity(apiUrl, request, String.class);
            System.out.println("SMS odeslĂˇna hrĂˇÄŤi: " + phoneNumber + ", response: " + response.getBody());
        } catch (Exception e) {
            System.err.println("Chyba pĹ™i odesĂ­lĂˇnĂ­ SMS: " + e.getMessage());
        }
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserService.java
--------------------
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;

import java.util.List;

public interface AppUserService {
    /**
     * Registrace novĂ©ho uĹľivatele
     *
     * @param registerUserDTO data pro registraci
     * @throws IllegalArgumentException pokud email existuje nebo hesla se neshodujĂ­
     */
    void register(RegisterUserDTO registerUserDTO);

    AppUserDTO getCurrentUser(String email);

    List<AppUserDTO> getAllUsers();

    void changePassword(String email, String oldPassword, String newPassword, String newPasswordConfirm);

    void resetPassword(Long userId);

    void updateUser(String email, AppUserDTO dto);

    boolean activateUser(String token);
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserServiceImpl.java
--------------------
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.EmailVerificationTokenEntity;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.EmailVerificationTokenRepository;
import cz.phsoft.hokej.exceptions.UserAlreadyExistsException;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;
import cz.phsoft.hokej.models.dto.mappers.AppUserMapper;
import cz.phsoft.hokej.models.services.email.EmailService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class AppUserServiceImpl implements AppUserService {

    @Value("${app.base-url}")
    private String baseUrl;

    private final AppUserRepository userRepository;
    private final BCryptPasswordEncoder passwordEncoder;
    private final AppUserMapper appUserMapper;
    private final EmailService emailService;
    private final EmailVerificationTokenRepository tokenRepository;

    public AppUserServiceImpl(AppUserRepository userRepository,
                              BCryptPasswordEncoder passwordEncoder, AppUserMapper appUserMapper,
                              EmailService emailService, EmailVerificationTokenRepository tokenRepository) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
        this.appUserMapper = appUserMapper;
        this.emailService = emailService;
        this.tokenRepository = tokenRepository;
    }

    @Override
    public void register(RegisterUserDTO dto) {
        if (!dto.getPassword().equals(dto.getPasswordConfirm())) {
            throw new IllegalArgumentException("Hesla se neshodujĂ­");
        }

        if (userRepository.findByEmail(dto.getEmail()).isPresent()) {
            throw new UserAlreadyExistsException("UĹľivatel s tĂ­mto emailem jiĹľ existuje");
        }

        AppUserEntity user = new AppUserEntity();
        user.setName(dto.getName());
        user.setSurname(dto.getSurname());
        user.setEmail(dto.getEmail());
        user.setPassword(passwordEncoder.encode(dto.getPassword()));
        user.setRole(Role.ROLE_PLAYER);
        user.setEnabled(false); // NEaktivnĂ­ pĹ™i registraci

        AppUserEntity savedUser = userRepository.save(user);

        // GenerovĂˇnĂ­ tokenu
        String token = java.util.UUID.randomUUID().toString();
        EmailVerificationTokenEntity verificationToken = new EmailVerificationTokenEntity();
        verificationToken.setToken(token);
        verificationToken.setUser(savedUser);
        verificationToken.setExpiresAt(java.time.LocalDateTime.now().plusHours(24));

        tokenRepository.save(verificationToken);


        // OdeslĂˇnĂ­ aktivaÄŤnĂ­ho emailu
        String activationLink = baseUrl + "/api/auth/verify?token=" + token;
        // Pro test lokĂˇlnÄ›: vypĂ­Ĺˇe odkaz do konzole
        System.out.println("AktivaÄŤnĂ­ odkaz: " + activationLink);

        emailService.sendActivationEmailHTML(savedUser.getEmail(), activationLink);
    }

    @Override
    public boolean activateUser(String token) {
        EmailVerificationTokenEntity verificationToken = tokenRepository.findByToken(token)
                .orElse(null);

        if (verificationToken == null || verificationToken.getExpiresAt().isBefore(java.time.LocalDateTime.now())) {
            return false; // neplatnĂ˝ token nebo vyprĹˇel
        }

        AppUserEntity user = verificationToken.getUser();
        user.setEnabled(true); // aktivujeme uĹľivatele
        userRepository.save(user);

        // Po aktivaci token smaĹľeme (nenĂ­ potĹ™eba jej uchovĂˇvat)
        tokenRepository.delete(verificationToken);

        return true;
    }

    @Override
    public void updateUser(String email, AppUserDTO dto) {

        AppUserEntity user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("UĹľivatel nenalezen"));

        // NastavenĂ­ novĂ©ho hesla
        user.setName(dto.getName());
        user.setSurname(dto.getSurname());
        user.setEmail(dto.getEmail());
        userRepository.save(user);
    }

    @Override
    public AppUserDTO getCurrentUser(String email) {
        AppUserEntity user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("User not found"));

        // â† vyuĹľitĂ­ mapperu
        return appUserMapper.toDTO(user);
    }

    @Override
    public List<AppUserDTO> getAllUsers() {
        return userRepository.findAll().stream()
                .map(appUserMapper::toDTO)
                .toList();
    }

    @Override
    public void changePassword(String email, String oldPassword, String newPassword, String newPasswordConfirm) {
        if (!newPassword.equals(newPasswordConfirm)) {
            throw new IllegalArgumentException("NovĂˇ hesla se neshodujĂ­");
        }

        AppUserEntity user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("UĹľivatel nenalezen"));

        // OvÄ›Ĺ™enĂ­ starĂ©ho hesla
        if (!passwordEncoder.matches(oldPassword, user.getPassword())) {
            throw new IllegalArgumentException("StarĂ© heslo je nesprĂˇvnĂ©");
        }

        // NastavenĂ­ novĂ©ho hesla
        user.setPassword(passwordEncoder.encode(newPassword));
        userRepository.save(user);
    }

    // reset hesla
    @Override
    public void resetPassword(Long userId) {
        AppUserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("UĹľivatel nenalezen"));

        // NastavenĂ­ novĂ©ho hesla na "Player123"
        user.setPassword(passwordEncoder.encode("Player123"));
        userRepository.save(user);
    }


}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationService.java
--------------------
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;

import java.util.List;

public interface MatchRegistrationService {

    // đź”Ą VracĂ­ DTO mĂ­sto entity
    MatchRegistrationDTO upsertRegistration(
            Long matchId,
            Long playerId,
            Team team,
            String adminNote,
            ExcuseReason excuseReason,
            String excuseNote,
            boolean unregister
    );

    List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId);

    List<MatchRegistrationDTO> getRegistrationsForMatches(List<Long> matchIds);

    List<MatchRegistrationDTO> getAllRegistrations();

    List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId);

    List<PlayerDTO> getNoResponsePlayers(Long matchId);

    void recalcStatusesForMatch(Long matchId);
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationServiceImpl.java
--------------------
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.DuplicateRegistrationException;
import cz.phsoft.hokej.exceptions.MatchNotFoundException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.exceptions.RegistrationNotFoundException;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.mappers.MatchRegistrationMapper;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.sms.SmsMessageBuilder;
import cz.phsoft.hokej.models.services.sms.SmsService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
public class MatchRegistrationServiceImpl implements MatchRegistrationService {

    Logger logger = LoggerFactory.getLogger(MatchServiceImpl.class);
    private final MatchRegistrationRepository registrationRepository;
    private final MatchRepository matchRepository;
    private final PlayerRepository playerRepository;
    private final MatchRegistrationMapper matchRegistrationMapper;
    private final PlayerMapper playerMapper;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;

    public MatchRegistrationServiceImpl(
            MatchRegistrationRepository registrationRepository,
            MatchRepository matchRepository,
            PlayerRepository playerRepository,
            MatchRegistrationMapper matchRegistrationMapper,
            PlayerMapper playerMapper,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder) {
        this.registrationRepository = registrationRepository;
        this.matchRepository = matchRepository;
        this.playerRepository = playerRepository;
        this.matchRegistrationMapper = matchRegistrationMapper;
        this.playerMapper = playerMapper;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
    }
    private MatchEntity getMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }
    private PlayerEntity getPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }
    private boolean isSlotAvailable(MatchEntity match) {
        long registeredCount = registrationRepository.countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);
        return registeredCount < match.getMaxPlayers();
    }
    private void sendSms(MatchRegistrationEntity registration, String message) {
        if (registration == null || registration.getPlayer() == null) return;
        try {
            smsService.sendSms(registration.getPlayer().getPhoneNumber(), message);
        } catch (Exception e) {
            System.err.println("Chyba SMS: " + e.getMessage());
        }
    }
    private MatchRegistrationEntity updateRegistrationStatus(
            MatchRegistrationEntity registration, PlayerMatchStatus status, String updatedBy, boolean updateTimestamp) {

        registration.setStatus(PlayerMatchStatus.valueOf(status.name()));
        registration.setCreatedBy(updatedBy);
        if (updateTimestamp) {
            registration.setTimestamp(LocalDateTime.now());
        }
        return registrationRepository.saveAndFlush(registration);
    }
    // -------------------- REGISTRATION --------------------
    @Transactional
    @Override
    public MatchRegistrationDTO upsertRegistration(
            Long matchId,
            Long playerId,
            Team team,
            String adminNote,
            ExcuseReason excuseReason,
            String excuseNote,
            boolean unregister) {

        // TEST: poĹˇli ERROR zprĂˇvu pro otestovĂˇnĂ­ emailu
        logger.error("Test ERROR zprĂˇva pro email");

        MatchEntity match = getMatchOrThrow(matchId);
        PlayerEntity player = getPlayerOrThrow(playerId);

        MatchRegistrationEntity registration = registrationRepository
                .findByPlayerIdAndMatchId(playerId, matchId)
                .orElse(null);

        PlayerMatchStatus newStatus;

        // UNREGISTER: lze pouze kdyĹľ hrĂˇÄŤ mĂˇ aktuĂˇlnÄ› REGISTERED
        if (unregister) {
            if (registration == null || registration.getStatus() != PlayerMatchStatus.REGISTERED) {
                throw new RegistrationNotFoundException(matchId, playerId);
            }
            registration.setExcuseReason(null);
            newStatus = PlayerMatchStatus.UNREGISTERED;

            // EXCUSE: lze vytvoĹ™it pouze pokud hrĂˇÄŤ NEMĂ status REGISTERED
        } else if (excuseReason != null) {
            if (registration != null && registration.getStatus() == PlayerMatchStatus.REGISTERED) {
                throw new DuplicateRegistrationException(matchId, playerId);
            }
            // pokud neexistuje, vytvoĹ™Ă­me pozici; pokud existuje a nenĂ­ REGISTERED, povolĂ­me EXCUSED
            if (registration == null) {
                registration = new MatchRegistrationEntity();
                registration.setMatch(match);
                registration.setPlayer(player);
            }
            registration.setExcuseReason(excuseReason);
            newStatus = PlayerMatchStatus.EXCUSED;

            // REGISTER / RESERVE: lze vytvoĹ™it pokud hrĂˇÄŤ NEMĂ status REGISTERED (tedy i kdyĹľ mĂˇ EXCUSED)
        } else {
            // pokud uĹľ je registrovĂˇn, nepovolĂ­me duplicitu
            if (registration != null && registration.getStatus() == PlayerMatchStatus.REGISTERED) {
                throw new DuplicateRegistrationException(matchId, playerId);
            }

            newStatus = isSlotAvailable(match) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;

            if (registration == null) {
                registration = new MatchRegistrationEntity();
                registration.setMatch(match);
                registration.setPlayer(player);
            } else {
                // pĹ™i pĹ™echodu na register/reserve zruĹˇĂ­me pĹ™Ă­padnou vĂ˝mluvu
                registration.setExcuseReason(null);
            }
        }

        registration.setStatus(newStatus);
        registration.setTimestamp(LocalDateTime.now());
        registration.setCreatedBy("user");

        if (team != null) registration.setTeam(team);
        if (adminNote != null) registration.setAdminNote(adminNote);
        // excuseReason uĹľ jsme nastavili vĂ˝Ĺˇe (pokud to byl EXCUSED pĹ™Ă­pad)
        if (excuseReason != null) registration.setExcuseReason(excuseReason);

        registration = registrationRepository.save(registration);

        if (unregister) recalcStatusesForMatch(matchId);

        sendSms(registration, smsMessageBuilder.buildMessageRegistration(registration));

        return matchRegistrationMapper.toDTO(registration);
    }
    // -------------------- FETCH --------------------
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId) {
        return matchRegistrationMapper.toDTOList(registrationRepository.findByMatchId(matchId));
    }

    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatches(List<Long> matchIds) {
        if (matchIds == null || matchIds.isEmpty()) {
            return List.of();
        }

        return matchRegistrationMapper.toDTOList(
                registrationRepository.findByMatchIdIn(matchIds)
        );
    }

    @Override
    public List<MatchRegistrationDTO> getAllRegistrations() {
        return matchRegistrationMapper.toDTOList(registrationRepository.findAll());
    }

    @Override
    public List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId) {
        return matchRegistrationMapper.toDTOList(registrationRepository.findByPlayerId(playerId));
    }

    @Override
    public List<PlayerDTO> getNoResponsePlayers(Long matchId) {
        List<Long> responded = registrationRepository.findByMatchId(matchId).stream()
                .map(r -> r.getPlayer().getId())
                .toList();

        List<PlayerEntity> noResponsePlayers = playerRepository.findAll().stream()
                .filter(p -> !responded.contains(p.getId()))
                .toList();

        return noResponsePlayers.stream()
                .map(playerMapper::toDTO)
                .toList();
    }
    // -------------------- RECALC --------------------
    @Override
    @Transactional
    public void recalcStatusesForMatch(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);
        int maxPlayers = match.getMaxPlayers();

        List<MatchRegistrationEntity> regs = registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED
                        || r.getStatus() == PlayerMatchStatus.RESERVED)
                .sorted((a, b) -> a.getTimestamp().compareTo(b.getTimestamp()))
                .toList();

        for (int i = 0; i < regs.size(); i++) {
            MatchRegistrationEntity reg = regs.get(i);
            PlayerMatchStatus newStatus = (i < maxPlayers) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;
            if (reg.getStatus() != newStatus) updateRegistrationStatus(reg, newStatus, "system", false);
        }
    }

    // -------------------- SMS --------------------
    @Transactional
    public void sendSmsToRegisteredPlayers(Long matchId) {
        registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .forEach(r -> sendSms(r, smsMessageBuilder.buildMessageFinal(r)));
    }

    public void sendNoResponseSmsForMatch(Long matchId) {
        var match = getMatchOrThrow(matchId);

        getNoResponsePlayers(matchId).forEach(player -> {
            String smsMsg = smsMessageBuilder.buildMessageNoResponse(player, match);

            try {
                smsService.sendSms(player.getPhoneNumber(), smsMsg);
            } catch (Exception e) {
                System.err.println("Chyba SMS pro hrĂˇÄŤe "
                        + player.getFullName() + ": " + e.getMessage());
                logger.error("Chyba pĹ™i odeslĂˇnĂ­ SMS hrĂˇÄŤi {}: {}", player.getFullName(), e.getMessage());
            }
        });
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchService.java
--------------------
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;
import cz.phsoft.hokej.models.dto.MatchOverviewDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;

import java.util.List;

public interface MatchService {
    List<MatchDTO> getAllMatches();
    List<MatchDTO> getUpcomingMatches();
    List<MatchDTO> getPastMatches();
    MatchDTO getNextMatch();
    MatchDTO getMatchById(Long id);
    MatchDTO createMatch(MatchDTO dto);
    MatchDTO updateMatch(Long id, MatchDTO dto);
    SuccessResponseDTO deleteMatch(Long id);
    MatchDetailDTO getMatchDetail(Long id);
    List<MatchDTO> getAvailableMatchesForPlayer(Long playerId);
    List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId);
    Long getPlayerIdByEmail(String email);
    List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId);
    public List<MatchOverviewDTO> getAllPassedMatchesForPlayer(Long playerId);


}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchServiceImpl.java
--------------------
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.MatchNotFoundException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.models.dto.*;
import cz.phsoft.hokej.models.dto.mappers.MatchMapper;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class MatchServiceImpl implements MatchService {

    private final MatchRepository matchRepository;
    private final MatchMapper matchMapper;
    private final MatchRegistrationService registrationService;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodService playerInactivityPeriodService;
    private final PlayerMapper playerMapper;
    private static final String ROLE_ADMIN = "ROLE_ADMIN";
    private static final String ROLE_MANAGER = "ROLE_MANAGER";

    public MatchServiceImpl(MatchRepository matchRepository,
                            MatchMapper matchMapper,
                            MatchRegistrationService registrationService,
                            PlayerRepository playerRepository,
                            PlayerInactivityPeriodService playerInactivityPeriodService,
                            PlayerMapper playerMapper) {
        this.matchRepository = matchRepository;
        this.matchMapper = matchMapper;
        this.registrationService = registrationService;
        this.playerRepository = playerRepository;
        this.playerInactivityPeriodService = playerInactivityPeriodService;
        this.playerMapper = playerMapper;
    }
    // metoda pro zĂ­skĂˇnĂ­ vĹˇech zĂˇpasĹŻ
    @Override
    public List<MatchDTO> getAllMatches() {
        return matchRepository.findAll().stream()
                .map(matchMapper::toDTO)
                .toList();
    }
    // metoda pro zĂ­skĂˇnĂ­ vĹˇech nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ
    @Override
    public List<MatchDTO> getUpcomingMatches() {
        return matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now())
                .stream()
                .map(matchMapper::toDTO)
                .toList();
    }
    // metoda pro zĂ­skĂˇnĂ­ uplynulĂ˝ch zĂˇpasĹŻ
    public List<MatchDTO> getPastMatches() {
        return matchRepository.findByDateTimeBeforeOrderByDateTimeDesc(LocalDateTime.now())
                .stream()
                .map(matchMapper::toDTO)
                .toList();
    }
    // metoda pro zĂ­skĂˇnĂ­ prvnĂ­ho nadchĂˇzejĂ­cĂ­ho zĂˇpasu
    @Override
    public MatchDTO getNextMatch() {
        return matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now())
                .stream()
                .findFirst()
                .map(matchMapper::toDTO)
                .orElse(null);
    }
    // metoda pro zĂˇpas dle ID
    @Override
    public MatchDTO getMatchById(Long id) {
        return matchMapper.toDTO(findMatchOrThrow(id));
    }

    // metoda pro vytvoĹ™enĂ­ zĂˇpasu
    @Override
    public MatchDTO createMatch(MatchDTO dto) {
        MatchEntity entity = matchMapper.toEntity(dto);
        return matchMapper.toDTO(matchRepository.save(entity));
    }

    // metoda pro Ăşpravu zĂˇpasu
    @Override
    public MatchDTO updateMatch(Long id, MatchDTO dto) {
        MatchEntity match = findMatchOrThrow(id);

        int oldMaxPlayers = match.getMaxPlayers();
        matchMapper.updateEntity(dto, match);
        MatchEntity saved = matchRepository.save(match);

        // PĹ™epoÄŤet registracĂ­ pokud doĹˇlo ke zmÄ›nÄ› maxPlayers
        if (saved.getMaxPlayers() != oldMaxPlayers) {
            registrationService.recalcStatusesForMatch(saved.getId());
        }

        return matchMapper.toDTO(saved);
    }

    // metoda pro odstranÄ›nĂ­ zĂˇpasu
    @Override
    public SuccessResponseDTO deleteMatch(Long id) {
        MatchEntity match = findMatchOrThrow(id);

        // 2) Pokud existuje, smaĹľeme ho
        matchRepository.delete(match);

        return new SuccessResponseDTO(
                "ZĂˇpas " + match.getId() + match.getDateTime() + " byl ĂşspÄ›ĹˇnÄ› smazĂˇn",
                id,
                LocalDateTime.now().toString()
        );
    }

    // metoda pro detail zĂˇpasu - omezen vĂ˝pis pro ADMIN, MANAGER, PLAYER
    @Override
    public MatchDetailDTO getMatchDetail(Long id) {
        MatchEntity match = findMatchOrThrow(id);
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();

        boolean isAdminOrManager = auth != null && auth.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals(ROLE_ADMIN) || a.getAuthority().equals(ROLE_MANAGER));

        // oddÄ›lena logika pĹ™Ă­stupu hrĂˇÄŤe do privĂˇtnĂ­ metody
        checkAccessForPlayer(match, auth);

        // sbÄ›r statistik hrĂˇÄŤĹŻ pĹ™es privĂˇtnĂ­ metodu
        return collectPlayerStatus(match, isAdminOrManager);
    }

    // privĂˇtnĂ­ metoda pro kontrolu pĹ™Ă­stupu hrĂˇÄŤe - jen pokud byl registrovĂˇn na zĂˇpas
    private void checkAccessForPlayer(MatchEntity match, Authentication auth) {
        if (auth == null || !auth.isAuthenticated()) return;

        boolean isAdminOrManager = auth.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals(ROLE_ADMIN) || a.getAuthority().equals(ROLE_MANAGER));

        if (isAdminOrManager) return;

        Object principal = auth.getPrincipal();
        if (!(principal instanceof org.springframework.security.core.userdetails.UserDetails userDetails)) return;

        List<PlayerEntity> ownedPlayers = playerRepository.findAll().stream()
                .filter(p -> p.getUser() != null && p.getUser().getEmail().equals(userDetails.getUsername()))
                .toList();

        boolean hasRestrictedPlayer = ownedPlayers.stream()
                .anyMatch(p -> {
                    List<MatchRegistrationDTO> registrations = registrationService.getRegistrationsForMatch(match.getId());

                    boolean noResponse = registrations.stream()
                            .noneMatch(r -> r.getPlayerId().equals(p.getId()));

                    boolean inactiveForMatch = !playerInactivityPeriodService.isActive(p, match.getDateTime());

                    return noResponse || inactiveForMatch;
                });

        if (hasRestrictedPlayer) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "NemĂˇte pĹ™Ă­stup k detailu tohoto zĂˇpasu."
            );
        }
    }

    // privĂˇtnĂ­ metoda pro sbÄ›r statistik hrĂˇÄŤĹŻ
    private MatchDetailDTO collectPlayerStatus(MatchEntity match, boolean isAdminOrManager) {
        List<MatchRegistrationDTO> registrations = registrationService.getRegistrationsForMatch(match.getId());

        // PĹ™evod vĹˇech registracĂ­ na Map<PlayerMatchStatus, List<PlayerDTO>>
        var statusToPlayersMap = registrations.stream()
                .map(r -> playerRepository.findById(r.getPlayerId())
                        .map(playerMapper::toDTO)
                        .map(dto -> new java.util.AbstractMap.SimpleEntry<>(r.getStatus(), dto))
                )
                .filter(java.util.Optional::isPresent) // odstranĂ­me chybÄ›jĂ­cĂ­ hrĂˇÄŤe
                .map(java.util.Optional::get)
                .collect(Collectors.groupingBy(
                        java.util.Map.Entry::getKey,
                        Collectors.mapping(java.util.Map.Entry::getValue, Collectors.toList())
                ));

        List<PlayerEntity> allPlayers = playerRepository.findAll();
        Set<Long> respondedIds = registrations.stream()
                .map(MatchRegistrationDTO::getPlayerId)
                .collect(Collectors.toSet());

        List<PlayerDTO> noResponsePlayers = allPlayers.stream()
                .filter(p -> !respondedIds.contains(p.getId()))
                .map(playerMapper::toDTO)
                .toList();

        // PoÄŤty hrĂˇÄŤĹŻ podle statusu
        int inGamePlayers = statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()).size();
        int outGamePlayers = statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()).size()
                + statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()).size();
        int waitingPlayers = statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()).size();
        int noActionPlayers = noResponsePlayers.size();
        int remainingSlots = match.getMaxPlayers() - inGamePlayers;
        double pricePerRegistered = inGamePlayers > 0 ? match.getPrice() / (double) inGamePlayers : 0;

        MatchDetailDTO dto = new MatchDetailDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setMaxPlayers(match.getMaxPlayers());
        dto.setInGamePlayers(inGamePlayers);
        dto.setOutGamePlayers(outGamePlayers);
        dto.setWaitingPlayers(waitingPlayers);
        dto.setNoActionPlayers(noActionPlayers);
        dto.setPricePerRegisteredPlayer(pricePerRegistered);
        dto.setRemainingSlots(remainingSlots);

        // NastavenĂ­ hrĂˇÄŤĹŻ podle statusu z mapy
        dto.setRegisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()));
        dto.setReservedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()));
        dto.setUnregisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()));
        dto.setExcusedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()));

        // pouze admin/manager uvidĂ­ no-response hrĂˇÄŤe
        dto.setNoResponsePlayers(isAdminOrManager ? noResponsePlayers : null);

        return dto;
    }

    // dostupnĂ© zĂˇpasy pro hrĂˇÄŤe - byl nebo je aktivnĂ­
    @Override
    public List<MatchDTO> getAvailableMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        // Filtrace pĹ™es stream bez mezivĂ˝sledkĹŻ
        return matchRepository.findAll().stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .map(matchMapper::toDTO)
                .toList();
    }

    // zĂ­skĂˇnĂ­ hrĂˇÄŤe dle emailu
    public Long getPlayerIdByEmail(String email) {
        return playerRepository.findByUserEmail(email)
                .map(PlayerEntity::getId)
                .orElseThrow(() -> new RuntimeException("HrĂˇÄŤ s emailem " + email + " nenalezen"));
    }


    // nĂˇhled nadchĂˇzejĂ­cĂ­ch zĂˇpasu pro hrĂˇÄŤe - dle PlayerType
    @Override
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        // 1) NejbliĹľĹˇĂ­ nadchĂˇzejĂ­cĂ­ zĂˇpasy podle data
        List<MatchEntity> upcomingAll = matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now());

        // 2) OmezenĂ­ podle typu hrĂˇÄŤe
        List<MatchEntity> limited = switch (type) {
            case VIP -> upcomingAll;
            case STANDARD -> upcomingAll.stream().limit(2).toList();
            case BASIC -> upcomingAll.isEmpty() ? List.of() : List.of(upcomingAll.get(0));
        };

        // 3) FiltrovĂˇnĂ­ podle aktivity hrĂˇÄŤe a mapovĂˇnĂ­ na MatchOverviewDTO
        return limited.stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .map(match -> toOverviewDTO(match, playerId))
                .toList();
    }

    // nadchĂˇzejĂ­cĂ­ zĂˇpas
    @Override
    public List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        // 1) NejbliĹľĹˇĂ­ nadchĂˇzejĂ­cĂ­ zĂˇpasy podle data
        List<MatchEntity> upcomingAll = matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now());

        List<MatchEntity> limited = switch (type) {
            case VIP -> upcomingAll;
            case STANDARD -> upcomingAll.stream().limit(2).toList();
            case BASIC -> upcomingAll.isEmpty() ? List.of() : List.of(upcomingAll.get(0));
        };

        // 2) FiltrovĂˇnĂ­ podle aktivity hrĂˇÄŤe
        return limited.stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .map(matchMapper::toDTO)
                .toList();
    }

    // pomocnĂ© metody
    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    private MatchEntity findMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }

    private MatchOverviewDTO toOverviewDTO(MatchEntity match) {
        MatchOverviewDTO dto = new MatchOverviewDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setLocation(match.getLocation());
        dto.setDescription(match.getDescription());
        dto.setPrice(match.getPrice());
        dto.setMaxPlayers(match.getMaxPlayers());


        // poÄŤet registrovanĂ˝ch hrĂˇÄŤĹŻ
        int inGamePlayers = registrationService.getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .mapToInt(r -> 1)
                .sum();
        dto.setInGamePlayers(inGamePlayers);

        // cena na registrovanĂ©ho hrĂˇÄŤe
        double pricePerPlayer = inGamePlayers > 0 && match.getPrice() != null
                ? match.getPrice() / (double) inGamePlayers : 0;
        dto.setPricePerRegisteredPlayer(pricePerPlayer);



        return dto;
    }

    private MatchOverviewDTO toOverviewDTO(MatchEntity match, Long playerId) {

        MatchOverviewDTO dto = toOverviewDTO(match); // â† znovupouĹľitĂ­ tvĂ© pĹŻvodnĂ­ metody

        PlayerMatchStatus status = registrationService
                .getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getPlayerId().equals(playerId))
                .map(MatchRegistrationDTO::getStatus)
                .findFirst()
                .filter(s ->
                        s == PlayerMatchStatus.REGISTERED ||
                                s == PlayerMatchStatus.UNREGISTERED ||
                                s == PlayerMatchStatus.EXCUSED ||
                                s == PlayerMatchStatus.RESERVED
                )
                .orElse(PlayerMatchStatus.NO_RESPONSE);

        dto.setStatus(status);
        return dto;
    }

    @Override
    public List<MatchOverviewDTO> getAllPassedMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        // Vezmeme dostupnĂ© zĂˇpasy jako entity (bez DTO)
        List<MatchEntity> availableMatches = matchRepository.findAll().stream()
                .filter(match -> match.getDateTime().isBefore(LocalDateTime.now()) || match.getDateTime().isEqual(LocalDateTime.now()))
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .toList();

        if (availableMatches.isEmpty()) {
            return List.of();
        }

        // VĹˇechny ID zĂˇpasĹŻ
        List<Long> matchIds = availableMatches.stream()
                .map(MatchEntity::getId)
                .toList();

        // Jeden jedinĂ˝ dotaz na vĹˇechny registrace
        List<MatchRegistrationDTO> allRegistrations =
                registrationService.getRegistrationsForMatches(matchIds);

        // Mapa: matchId -> (playerId -> status)
        var statusMap = allRegistrations.stream()
                .collect(Collectors.groupingBy(
                        MatchRegistrationDTO::getMatchId,
                        Collectors.toMap(
                                MatchRegistrationDTO::getPlayerId,
                                MatchRegistrationDTO::getStatus,
                                (a, b) -> a
                        )
                ));

        // MapovĂˇnĂ­ na MatchOverviewDTO + nastavenĂ­ statusu
        return availableMatches.stream()
                .map(match -> {
                    MatchOverviewDTO overview = toOverviewDTO(match);

                    PlayerMatchStatus status = Optional.ofNullable(statusMap.get(match.getId()))
                            .map(m -> m.get(playerId))
                            .filter(s ->
                                    s == PlayerMatchStatus.REGISTERED ||
                                            s == PlayerMatchStatus.UNREGISTERED ||
                                            s == PlayerMatchStatus.EXCUSED ||
                                            s == PlayerMatchStatus.RESERVED
                            )
                            .orElse(PlayerMatchStatus.NO_RESPONSE);

                    overview.setStatus(status);
                    return overview;
                })
                .toList();
    }



}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodService.java
--------------------
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;

import java.time.LocalDateTime;
import java.util.List;

public interface PlayerInactivityPeriodService {

    List<PlayerInactivityPeriodDTO> getAll();

    PlayerInactivityPeriodDTO getById(Long id);

    List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId);

    PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto);

    PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto);

    void delete(Long id);

    public boolean isActive(PlayerEntity player, LocalDateTime dateTime);
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodServiceImpl.java
--------------------
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.data.repositories.PlayerInactivityPeriodRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.dto.mappers.PlayerInactivityPeriodMapper;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import java.util.List;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

@Service
public class PlayerInactivityPeriodServiceImpl implements PlayerInactivityPeriodService {

    private final PlayerInactivityPeriodRepository inactivityRepository;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodMapper mapper;

    public PlayerInactivityPeriodServiceImpl(PlayerInactivityPeriodRepository inactivityRepository,
                                             PlayerRepository playerRepository,
                                             PlayerInactivityPeriodMapper mapper) {
        this.inactivityRepository = inactivityRepository;
        this.playerRepository = playerRepository;
        this.mapper = mapper;
    }

    @Override
    public List<PlayerInactivityPeriodDTO> getAll() {
        return inactivityRepository.findAll().stream()
                .map(mapper::toDTO)
                .toList();
    }

    @Override
    public PlayerInactivityPeriodDTO getById(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException(
                        "ObdobĂ­ neaktivity s ID " + id + " neexistuje."
                ));
        return mapper.toDTO(entity);
    }

    @Override
    public List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId) {
        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new RuntimeException("Player not found"));

        return inactivityRepository.findByPlayerOrderByInactiveFromAsc(player)
                .stream()
                .map(mapper::toDTO)
                .toList();
    }

    // --- TRANSACTIONAL pro zĂˇpis dat ---
    @Override
    @Transactional
    public PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto) {
        PlayerEntity player = playerRepository.findById(dto.getPlayerId())
                .orElseThrow(() -> new IllegalArgumentException("HrĂˇÄŤ s ID " + dto.getPlayerId() + " neexistuje."));

        validateDates(dto);

        // kontrola pĹ™ekryvu existujĂ­cĂ­ch obdobĂ­
        boolean overlaps = !inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        player, dto.getInactiveFrom(), dto.getInactiveTo()
                ).isEmpty();

        if (overlaps) {
            throw new IllegalStateException("NovĂ© obdobĂ­ se pĹ™ekrĂ˝vĂˇ s existujĂ­cĂ­m obdobĂ­m neaktivity hrĂˇÄŤe.");
        }

        PlayerInactivityPeriodEntity entity = mapper.toEntity(dto, player);
        return mapper.toDTO(inactivityRepository.save(entity));
    }

    @Override
    @Transactional
    public PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("ObdobĂ­ neaktivity s ID " + id + " neexistuje."));

        validateDates(dto);

        // kontrola pĹ™ekryvu, ignoruje aktuĂˇlnĂ­ zĂˇznam
        boolean overlaps = inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        entity.getPlayer(), dto.getInactiveFrom(), dto.getInactiveTo()
                ).stream()
                .anyMatch(p -> !p.getId().equals(id));

        if (overlaps) {
            throw new IllegalStateException("UpravenĂ© obdobĂ­ se pĹ™ekrĂ˝vĂˇ s jinĂ˝m obdobĂ­m neaktivity hrĂˇÄŤe.");
        }

        mapper.updateEntityFromDto(dto, entity);
        return mapper.toDTO(inactivityRepository.save(entity));
    }

    @Override
    @Transactional
    public void delete(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("ObdobĂ­ neaktivity s ID " + id + " neexistuje."));
        inactivityRepository.delete(entity);
    }

    // --- true = aktivnĂ­, false = neaktivnĂ­ ---
    public boolean isActive(PlayerEntity player, LocalDateTime dateTime) {
        return !inactivityRepository.existsByPlayerAndInactiveFromLessThanEqualAndInactiveToGreaterThanEqual(
                player, dateTime, dateTime);
    }

    // --- privĂˇtnĂ­ metoda pro validaci dat ---
    private void validateDates(PlayerInactivityPeriodDTO dto) {
        if (dto.getInactiveFrom() == null || dto.getInactiveTo() == null) {
            throw new IllegalArgumentException("Datum od a do nesmĂ­ bĂ˝t null.");
        }
        if (!dto.getInactiveFrom().isBefore(dto.getInactiveTo())) {
            throw new IllegalArgumentException("inactiveFrom musĂ­ bĂ˝t pĹ™ed inactiveTo.");
        }
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerService.java
--------------------
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;

import java.util.List;


public interface PlayerService {
    List<PlayerDTO> getAllPlayers();
    PlayerDTO getPlayerById(Long id);
    PlayerDTO createPlayer(PlayerDTO player);
    PlayerDTO createPlayerForUser(PlayerDTO dto, String userEmail);
    PlayerDTO updatePlayer(Long id, PlayerDTO player);
    SuccessResponseDTO deletePlayer(Long id);
    public List<PlayerDTO> getPlayersByUser(String email);
    SuccessResponseDTO approvePlayer (Long id);
    SuccessResponseDTO rejectPlayer (Long id);
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerServiceImpl.java
--------------------
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.DuplicateNameSurnameException;
import cz.phsoft.hokej.exceptions.InvalidPlayerStatusException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;
import cz.phsoft.hokej.models.dto.PlayerDTO;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class PlayerServiceImpl implements PlayerService {

    private final PlayerRepository playerRepository;
    private final PlayerMapper playerMapper;
    private final AppUserRepository appUserRepository;

    public PlayerServiceImpl(PlayerRepository playerRepository, PlayerMapper playerMapper, AppUserRepository appUserRepository) {
        this.playerRepository = playerRepository;
        this.playerMapper = playerMapper;
        this.appUserRepository = appUserRepository;
    }

    @Override
    public List<PlayerDTO> getAllPlayers() {
        return playerRepository.findAll().stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    @Override
    public PlayerDTO getPlayerById(Long id) {
        PlayerEntity player = playerRepository.findById(id)
                .orElseThrow(() -> new PlayerNotFoundException(id)); // mĂ­sto RuntimeException
        return playerMapper.toDTO(player);
    }


    // --- TRANSACTIONAL pro zĂˇpis dat ---
    @Override
    @Transactional
    public PlayerDTO createPlayer(PlayerDTO dto) {
        checkDuplicateNameSurname(dto.getName(), dto.getSurname(), null);

        PlayerEntity entity = playerMapper.toEntity(dto);
        PlayerEntity saved = playerRepository.save(entity);
        return playerMapper.toDTO(saved);
    }

    @Override
    @Transactional
    public PlayerDTO createPlayerForUser(PlayerDTO dto, String userEmail) {
        AppUserEntity user = appUserRepository.findByEmail(userEmail)
                .orElseThrow(() -> new RuntimeException("User not found"));

        PlayerEntity player = playerMapper.toEntity(dto);
        player.setUser(user); // pĹ™iĹ™azenĂ­ hrĂˇÄŤe k uĹľivateli


        PlayerEntity saved = playerRepository.save(player);
        return playerMapper.toDTO(saved);
    }

    @Override
    public List<PlayerDTO> getPlayersByUser(String email) {
        return playerRepository.findByUser_EmailOrderByIdAsc(email).stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    @Override
    @Transactional
    public PlayerDTO updatePlayer(Long id, PlayerDTO dto) {
        PlayerEntity existing = findPlayerOrThrow(id);

        // pokud se jmĂ©no/pĹ™Ă­jmenĂ­ mÄ›nĂ­, ovÄ›Ĺ™ duplicitu
        if (!existing.getName().equals(dto.getName())
                || !existing.getSurname().equals(dto.getSurname())) {
            checkDuplicateNameSurname(dto.getName(), dto.getSurname(), id);
        }

        existing.setName(dto.getName());
        existing.setSurname(dto.getSurname());
        existing.setNickname(dto.getNickName());
        existing.setPhoneNumber(dto.getPhoneNumber());
        existing.setType(dto.getType());
        existing.setTeam(dto.getTeam());
        existing.setStatus(dto.getStatus());

        PlayerEntity saved = playerRepository.save(existing);
        return playerMapper.toDTO(saved);
    }

    @Override
    @Transactional
    public SuccessResponseDTO deletePlayer(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);
        playerRepository.delete(player);

        return new SuccessResponseDTO(
                "HrĂˇÄŤ " + player.getFullName() + " byl ĂşspÄ›ĹˇnÄ› smazĂˇn",
                id,
                LocalDateTime.now().toString()
        );
    }

    // --- privĂˇtnĂ­ metoda pro kontrolu duplicity jmĂ©na a pĹ™Ă­jmenĂ­ ---
    private void checkDuplicateNameSurname(String name, String surname, Long ignoreId) {
        Optional<PlayerEntity> duplicateOpt = playerRepository.findByNameAndSurname(name, surname);

        if (duplicateOpt.isPresent()) {
            if (ignoreId == null || !duplicateOpt.get().getId().equals(ignoreId)) {
                throw new DuplicateNameSurnameException("HrĂˇÄŤ se jmĂ©nem " + name + " " + surname + " jiĹľ existuje.");
            }
        }
    }

    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    @Override
    @Transactional
    public SuccessResponseDTO approvePlayer(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);

        if (player.getStatus() == PlayerStatus.APPROVED) {
            throw new InvalidPlayerStatusException("HrĂˇÄŤ uĹľ je schvĂˇlen.");
        }
        player.setStatus(PlayerStatus.APPROVED);
        playerRepository.save(player);
        return new SuccessResponseDTO(
                "HrĂˇÄŤ " + player.getFullName() + " byl ĂşspÄ›ĹˇnÄ› aktivovĂˇn",
                id,
                LocalDateTime.now().toString()
        );
    }

    @Override
    @Transactional
    public SuccessResponseDTO rejectPlayer(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);

        if (player.getStatus() == PlayerStatus.REJECTED) {
            throw new InvalidPlayerStatusException("HrĂˇÄŤ uĹľ je zamĂ­tnut.");
        }
        player.setStatus(PlayerStatus.REJECTED);
        playerRepository.save(player);

        return new SuccessResponseDTO(
                "HrĂˇÄŤ " + player.getFullName() + " byl ĂşspÄ›ĹˇnÄ› zamĂ­tnut",
                id,
                LocalDateTime.now().toString()
        );
    }


}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\CurrentPlayerContext.java
--------------------
package cz.phsoft.hokej.security;


import cz.phsoft.hokej.data.entities.PlayerEntity;

// pro vĂ˝bÄ›r hrĂˇÄŤe
public class CurrentPlayerContext {

        private static final ThreadLocal<PlayerEntity> currentPlayer = new ThreadLocal<>();

        public static void set(PlayerEntity player) {
            currentPlayer.set(player);
        }

        public static PlayerEntity get() {
            return currentPlayer.get();
        }

        public static void clear() {
            currentPlayer.remove();
        }
    }
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\CurrentPlayerFilter.java
--------------------
package cz.phsoft.hokej.security;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;

@Component
public class CurrentPlayerFilter extends OncePerRequestFilter {

    private final PlayerRepository playerRepository;
    private final CurrentPlayerService currentPlayerService;

    public CurrentPlayerFilter(PlayerRepository playerRepository,
                               CurrentPlayerService currentPlayerService) {
        this.playerRepository = playerRepository;
        this.currentPlayerService = currentPlayerService;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {

        Long playerId = currentPlayerService.getCurrentPlayerId();

        if (playerId != null) {
            playerRepository.findById(playerId)
                    .ifPresent(CurrentPlayerContext::set);
        }

        try {
            filterChain.doFilter(request, response);
        } finally {
            CurrentPlayerContext.clear();
        }
    }
}

--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\CurrentPlayerService.java
--------------------
package cz.phsoft.hokej.security;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import jakarta.servlet.http.HttpSession;
import org.springframework.stereotype.Service;

@Service
public class CurrentPlayerService {

    private final HttpSession session;
    private final PlayerRepository playerRepository;

    public CurrentPlayerService(HttpSession session, PlayerRepository playerRepository) {
        this.session = session;
        this.playerRepository = playerRepository;
    }

    public Long getCurrentPlayerId() {
        return (Long) session.getAttribute(SessionKeys.CURRENT_PLAYER_ID);
    }

    public void setCurrentPlayerId(Long playerId) {
        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));

        if (player.getStatus() != PlayerStatus.APPROVED) {
            throw new IllegalStateException(
                    "Nelze zvolit hrĂˇÄŤe, kterĂ˝ nenĂ­ schvĂˇlen administrĂˇtorem."
            );
        }

        session.setAttribute(SessionKeys.CURRENT_PLAYER_ID, playerId);
    }

    public void requireCurrentPlayer() {
        if (getCurrentPlayerId() == null) {
            throw new IllegalStateException("NenĂ­ zvolen aktuĂˇlnĂ­ hrĂˇÄŤ");
        }
    }

    public void clear() {
        session.removeAttribute(SessionKeys.CURRENT_PLAYER_ID);
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\PlayerSecurity.java
--------------------
package cz.phsoft.hokej.security;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;
// - ZatĂ­m nepouĹľĂ­vĂˇm - pouĹľĂ­vĂˇm /me
@Component("playerSecurity") // nĂˇzev pro pouĹľitĂ­ v SpEL (@PreAuthorize)
public class PlayerSecurity {

    private static final Logger logger = LoggerFactory.getLogger(PlayerSecurity.class);

    private final PlayerRepository playerRepository;

    public PlayerSecurity(PlayerRepository playerRepository) {
        this.playerRepository = playerRepository;
    }

    /**
     * ZjistĂ­, zda je aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ˝ uĹľivatel vlastnĂ­kem hrĂˇÄŤe
     *
     * @param authentication aktuĂˇlnĂ­ authentication objekt
     * @param playerId       ID hrĂˇÄŤe
     * @return true pokud je vlastnĂ­kem, jinak false
     */
    public boolean isOwner(Authentication authentication, Long playerId) {
        try {
            if (authentication == null || !authentication.isAuthenticated()) {
                logger.warn("NeautorizovanĂ˝ pĹ™Ă­stup: ĹľĂˇdnĂˇ autentizace pro playerId {}", playerId);
                return false;
            }

            Object principal = authentication.getPrincipal();
            if (!(principal instanceof UserDetails userDetails)) {
                logger.warn("NeautorizovanĂ˝ pĹ™Ă­stup: principal nenĂ­ UserDetails pro playerId {}", playerId);
                return false;
            }

            boolean isOwner = playerRepository.findById(playerId)
                    .map(player -> player.getUser() != null &&
                            player.getUser().getEmail().equals(userDetails.getUsername()))
                    .orElse(false);

            if (!isOwner) {
                logger.warn("NeautorizovanĂ˝ pĹ™Ă­stup: uĹľivatel {} nenĂ­ vlastnĂ­kem hrĂˇÄŤe {}", userDetails.getUsername(), playerId);
            }

            return isOwner;

        } catch (Exception e) {
            logger.error("Chyba pĹ™i kontrole vlastnĂ­ka hrĂˇÄŤe {}: {}", playerId, e.getMessage(), e);
            // nikdy nepropustit vĂ˝jimku do SpEL
            return false;
        }
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\SessionKeys.java
--------------------
package cz.phsoft.hokej.security;

public final class SessionKeys {
    private SessionKeys() {}

    public static final String CURRENT_PLAYER_ID = "CURRENT_PLAYER_ID";
}
--------------------
C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\StaraGardaApplication.java
--------------------
package cz.phsoft.hokej;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableJpaRepositories // JPA v naĹˇem Spring Boot projektu
@EnableScheduling
@EnableAsync
public class StaraGardaApplication {
    public static void main(String[] args) {
        SpringApplication.run(StaraGardaApplication.class, args);


        }
    }
--------------------
C:\Projekty Práce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\AppUserMapperImpl.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2026-01-20T13:10:47+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class AppUserMapperImpl implements AppUserMapper {

    @Override
    public AppUserDTO toDTO(AppUserEntity entity) {
        if ( entity == null ) {
            return null;
        }

        AppUserDTO appUserDTO = new AppUserDTO();

        appUserDTO.setPlayers( playerEntitySetToPlayerDTOSet( entity.getPlayers() ) );
        appUserDTO.setId( entity.getId() );
        appUserDTO.setName( entity.getName() );
        appUserDTO.setSurname( entity.getSurname() );
        appUserDTO.setEmail( entity.getEmail() );
        appUserDTO.setRole( entity.getRole() );
        appUserDTO.setEnabled( entity.isEnabled() );

        return appUserDTO;
    }

    @Override
    public List<AppUserDTO> toDtoList(List<AppUserEntity> entities) {
        if ( entities == null ) {
            return null;
        }

        List<AppUserDTO> list = new ArrayList<AppUserDTO>( entities.size() );
        for ( AppUserEntity appUserEntity : entities ) {
            list.add( toDTO( appUserEntity ) );
        }

        return list;
    }

    @Override
    public PlayerDTO toPlayerDTO(PlayerEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerDTO playerDTO = new PlayerDTO();

        playerDTO.setNickName( entity.getNickname() );
        playerDTO.setId( entity.getId() );
        playerDTO.setName( entity.getName() );
        playerDTO.setSurname( entity.getSurname() );
        playerDTO.setType( entity.getType() );
        playerDTO.setTeam( entity.getTeam() );
        playerDTO.setPhoneNumber( entity.getPhoneNumber() );
        playerDTO.setStatus( entity.getStatus() );

        return playerDTO;
    }

    protected Set<PlayerDTO> playerEntitySetToPlayerDTOSet(Set<PlayerEntity> set) {
        if ( set == null ) {
            return null;
        }

        Set<PlayerDTO> set1 = new LinkedHashSet<PlayerDTO>( Math.max( (int) ( set.size() / .75f ) + 1, 16 ) );
        for ( PlayerEntity playerEntity : set ) {
            set1.add( toPlayerDTO( playerEntity ) );
        }

        return set1;
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchMapperImpl.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2026-01-20T13:10:46+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchMapperImpl implements MatchMapper {

    @Override
    public MatchDTO toDTO(MatchEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchDTO matchDTO = new MatchDTO();

        matchDTO.setId( entity.getId() );
        matchDTO.setDateTime( entity.getDateTime() );
        matchDTO.setLocation( entity.getLocation() );
        matchDTO.setDescription( entity.getDescription() );
        matchDTO.setMaxPlayers( entity.getMaxPlayers() );
        matchDTO.setPrice( entity.getPrice() );

        return matchDTO;
    }

    @Override
    public MatchEntity toEntity(MatchDTO dto) {
        if ( dto == null ) {
            return null;
        }

        MatchEntity matchEntity = new MatchEntity();

        matchEntity.setId( dto.getId() );
        matchEntity.setDateTime( dto.getDateTime() );
        matchEntity.setLocation( dto.getLocation() );
        matchEntity.setDescription( dto.getDescription() );
        matchEntity.setMaxPlayers( dto.getMaxPlayers() );
        matchEntity.setPrice( dto.getPrice() );

        return matchEntity;
    }

    @Override
    public void updateEntity(MatchDTO dto, MatchEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setDateTime( dto.getDateTime() );
        entity.setLocation( dto.getLocation() );
        entity.setDescription( dto.getDescription() );
        entity.setMaxPlayers( dto.getMaxPlayers() );
        entity.setPrice( dto.getPrice() );
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchRegistrationMapperImpl.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2026-01-20T13:10:47+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchRegistrationMapperImpl implements MatchRegistrationMapper {

    @Override
    public MatchRegistrationEntity toEntity(MatchEntity match, PlayerEntity player, PlayerMatchStatus status, ExcuseReason excuseReason, String note, Team team, String adminNote, String createdBy) {
        if ( match == null && player == null && status == null && excuseReason == null && note == null && team == null && adminNote == null && createdBy == null ) {
            return null;
        }

        MatchRegistrationEntity matchRegistrationEntity = new MatchRegistrationEntity();

        matchRegistrationEntity.setMatch( match );
        matchRegistrationEntity.setPlayer( player );
        matchRegistrationEntity.setStatus( status );
        matchRegistrationEntity.setExcuseReason( excuseReason );
        matchRegistrationEntity.setExcuseNote( note );
        matchRegistrationEntity.setTeam( team );
        matchRegistrationEntity.setAdminNote( adminNote );
        matchRegistrationEntity.setCreatedBy( createdBy );
        matchRegistrationEntity.setTimestamp( java.time.LocalDateTime.now() );

        return matchRegistrationEntity;
    }

    @Override
    public MatchRegistrationDTO toDTO(MatchRegistrationEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchRegistrationDTO matchRegistrationDTO = new MatchRegistrationDTO();

        matchRegistrationDTO.setMatchId( entityMatchId( entity ) );
        matchRegistrationDTO.setPlayerId( entityPlayerId( entity ) );
        matchRegistrationDTO.setId( entity.getId() );
        matchRegistrationDTO.setStatus( entity.getStatus() );
        matchRegistrationDTO.setExcuseReason( entity.getExcuseReason() );
        matchRegistrationDTO.setExcuseNote( entity.getExcuseNote() );
        matchRegistrationDTO.setAdminNote( entity.getAdminNote() );
        matchRegistrationDTO.setTeam( entity.getTeam() );
        matchRegistrationDTO.setCreatedBy( entity.getCreatedBy() );

        return matchRegistrationDTO;
    }

    @Override
    public List<MatchRegistrationDTO> toDTOList(List<MatchRegistrationEntity> entities) {
        if ( entities == null ) {
            return null;
        }

        List<MatchRegistrationDTO> list = new ArrayList<MatchRegistrationDTO>( entities.size() );
        for ( MatchRegistrationEntity matchRegistrationEntity : entities ) {
            list.add( toDTO( matchRegistrationEntity ) );
        }

        return list;
    }

    private Long entityMatchId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        MatchEntity match = matchRegistrationEntity.getMatch();
        if ( match == null ) {
            return null;
        }
        Long id = match.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }

    private Long entityPlayerId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        PlayerEntity player = matchRegistrationEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerInactivityPeriodMapperImpl.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2026-01-20T13:10:47+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerInactivityPeriodMapperImpl implements PlayerInactivityPeriodMapper {

    @Override
    public PlayerInactivityPeriodDTO toDTO(PlayerInactivityPeriodEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerInactivityPeriodDTO playerInactivityPeriodDTO = new PlayerInactivityPeriodDTO();

        playerInactivityPeriodDTO.setPlayerId( entityPlayerId( entity ) );
        playerInactivityPeriodDTO.setId( entity.getId() );
        playerInactivityPeriodDTO.setInactiveFrom( entity.getInactiveFrom() );
        playerInactivityPeriodDTO.setInactiveTo( entity.getInactiveTo() );

        return playerInactivityPeriodDTO;
    }

    @Override
    public PlayerInactivityPeriodEntity toEntity(PlayerInactivityPeriodDTO dto, PlayerEntity player) {
        if ( dto == null ) {
            return null;
        }

        PlayerInactivityPeriodEntity playerInactivityPeriodEntity = createEntity( dto, player );

        playerInactivityPeriodEntity.setInactiveFrom( dto.getInactiveFrom() );
        playerInactivityPeriodEntity.setInactiveTo( dto.getInactiveTo() );

        return playerInactivityPeriodEntity;
    }

    @Override
    public void updateEntityFromDto(PlayerInactivityPeriodDTO dto, PlayerInactivityPeriodEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setInactiveFrom( dto.getInactiveFrom() );
        entity.setInactiveTo( dto.getInactiveTo() );
    }

    private Long entityPlayerId(PlayerInactivityPeriodEntity playerInactivityPeriodEntity) {
        if ( playerInactivityPeriodEntity == null ) {
            return null;
        }
        PlayerEntity player = playerInactivityPeriodEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}
--------------------
C:\Projekty Práce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerMapperImpl.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2026-01-20T13:10:47+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerMapperImpl implements PlayerMapper {

    @Override
    public PlayerDTO toDTO(PlayerEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerDTO playerDTO = new PlayerDTO();

        playerDTO.setNickName( entity.getNickname() );
        playerDTO.setId( entity.getId() );
        playerDTO.setName( entity.getName() );
        playerDTO.setSurname( entity.getSurname() );
        playerDTO.setType( entity.getType() );
        playerDTO.setTeam( entity.getTeam() );
        playerDTO.setPhoneNumber( entity.getPhoneNumber() );
        playerDTO.setStatus( entity.getStatus() );

        return playerDTO;
    }

    @Override
    public PlayerEntity toEntity(PlayerDTO dto) {
        if ( dto == null ) {
            return null;
        }

        PlayerEntity playerEntity = new PlayerEntity();

        playerEntity.setNickname( dto.getNickName() );
        playerEntity.setId( dto.getId() );
        playerEntity.setName( dto.getName() );
        playerEntity.setSurname( dto.getSurname() );
        playerEntity.setType( dto.getType() );
        playerEntity.setPhoneNumber( dto.getPhoneNumber() );
        playerEntity.setTeam( dto.getTeam() );
        playerEntity.setNickName( dto.getNickName() );

        playerEntity.setStatus( dto.getStatus() != null ? dto.getStatus() : cz.phsoft.hokej.data.enums.PlayerStatus.PENDING );

        return playerEntity;
    }

    @Override
    public void updatePlayerDTO(PlayerDTO source, PlayerDTO target) {
        if ( source == null ) {
            return;
        }

        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setNickName( source.getNickName() );
        target.setType( source.getType() );
        target.setTeam( source.getTeam() );
        target.setPhoneNumber( source.getPhoneNumber() );
        target.setStatus( source.getStatus() );
    }

    @Override
    public void updatePlayerEntity(PlayerDTO source, PlayerEntity target) {
        if ( source == null ) {
            return;
        }

        target.setNickname( source.getNickName() );
        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setType( source.getType() );
        target.setPhoneNumber( source.getPhoneNumber() );
        target.setTeam( source.getTeam() );
        target.setNickName( source.getNickName() );

        target.setStatus( source.getStatus() != null ? source.getStatus() : target.getStatus() );
    }

    @Override
    public List<PlayerDTO> toDTOList(List<PlayerEntity> players) {
        if ( players == null ) {
            return null;
        }

        List<PlayerDTO> list = new ArrayList<PlayerDTO>( players.size() );
        for ( PlayerEntity playerEntity : players ) {
            list.add( toDTO( playerEntity ) );
        }

        return list;
    }
}
--------------------
C:\Projekty Práce\StaraGarda\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchMapperImpl.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-04T13:04:23+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchMapperImpl implements MatchMapper {

    @Override
    public MatchDTO toDTO(MatchEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchDTO matchDTO = new MatchDTO();

        matchDTO.setId( entity.getId() );
        matchDTO.setDateTime( entity.getDateTime() );
        matchDTO.setLocation( entity.getLocation() );
        matchDTO.setDescription( entity.getDescription() );
        matchDTO.setMaxPlayers( entity.getMaxPlayers() );
        matchDTO.setPrice( entity.getPrice() );

        return matchDTO;
    }

    @Override
    public MatchEntity toEntity(MatchDTO dto) {
        if ( dto == null ) {
            return null;
        }

        MatchEntity matchEntity = new MatchEntity();

        matchEntity.setId( dto.getId() );
        matchEntity.setDateTime( dto.getDateTime() );
        matchEntity.setLocation( dto.getLocation() );
        matchEntity.setDescription( dto.getDescription() );
        matchEntity.setMaxPlayers( dto.getMaxPlayers() );
        matchEntity.setPrice( dto.getPrice() );

        return matchEntity;
    }

    @Override
    public void updateEntity(MatchDTO dto, MatchEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setDateTime( dto.getDateTime() );
        entity.setLocation( dto.getLocation() );
        entity.setDescription( dto.getDescription() );
        entity.setMaxPlayers( dto.getMaxPlayers() );
        entity.setPrice( dto.getPrice() );
    }
}
--------------------
C:\Projekty Práce\StaraGarda\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchRegistrationMapperImpl.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.JerseyColor;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-04T13:04:22+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchRegistrationMapperImpl implements MatchRegistrationMapper {

    @Override
    public MatchRegistrationEntity toEntity(MatchEntity match, PlayerEntity player, PlayerMatchStatus status, ExcuseReason excuseReason, String note, JerseyColor jerseyColor, String adminNote, String createdBy) {
        if ( match == null && player == null && status == null && excuseReason == null && note == null && jerseyColor == null && adminNote == null && createdBy == null ) {
            return null;
        }

        MatchRegistrationEntity matchRegistrationEntity = new MatchRegistrationEntity();

        matchRegistrationEntity.setMatch( match );
        matchRegistrationEntity.setPlayer( player );
        matchRegistrationEntity.setStatus( status );
        matchRegistrationEntity.setExcuseReason( excuseReason );
        matchRegistrationEntity.setExcuseNote( note );
        matchRegistrationEntity.setJerseyColor( jerseyColor );
        matchRegistrationEntity.setAdminNote( adminNote );
        matchRegistrationEntity.setCreatedBy( createdBy );
        matchRegistrationEntity.setTimestamp( java.time.LocalDateTime.now() );

        return matchRegistrationEntity;
    }

    @Override
    public MatchRegistrationDTO toDTO(MatchRegistrationEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchRegistrationDTO matchRegistrationDTO = new MatchRegistrationDTO();

        matchRegistrationDTO.setMatchId( entityMatchId( entity ) );
        matchRegistrationDTO.setPlayerId( entityPlayerId( entity ) );
        matchRegistrationDTO.setId( entity.getId() );
        matchRegistrationDTO.setStatus( entity.getStatus() );
        matchRegistrationDTO.setExcuseReason( entity.getExcuseReason() );
        matchRegistrationDTO.setExcuseNote( entity.getExcuseNote() );
        matchRegistrationDTO.setAdminNote( entity.getAdminNote() );
        matchRegistrationDTO.setJerseyColor( entity.getJerseyColor() );
        matchRegistrationDTO.setCreatedBy( entity.getCreatedBy() );

        return matchRegistrationDTO;
    }

    private Long entityMatchId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        MatchEntity match = matchRegistrationEntity.getMatch();
        if ( match == null ) {
            return null;
        }
        Long id = match.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }

    private Long entityPlayerId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        PlayerEntity player = matchRegistrationEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}
--------------------
C:\Projekty Práce\StaraGarda\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerInactivityPeriodMapperImpl.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-04T13:04:23+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerInactivityPeriodMapperImpl implements PlayerInactivityPeriodMapper {

    @Override
    public PlayerInactivityPeriodDTO toDTO(PlayerInactivityPeriodEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerInactivityPeriodDTO playerInactivityPeriodDTO = new PlayerInactivityPeriodDTO();

        playerInactivityPeriodDTO.setPlayerId( entityPlayerId( entity ) );
        playerInactivityPeriodDTO.setId( entity.getId() );
        playerInactivityPeriodDTO.setInactiveFrom( entity.getInactiveFrom() );
        playerInactivityPeriodDTO.setInactiveTo( entity.getInactiveTo() );

        return playerInactivityPeriodDTO;
    }

    @Override
    public PlayerInactivityPeriodEntity toEntity(PlayerInactivityPeriodDTO dto, PlayerEntity player) {
        if ( dto == null ) {
            return null;
        }

        PlayerInactivityPeriodEntity playerInactivityPeriodEntity = createEntity( dto, player );

        playerInactivityPeriodEntity.setInactiveFrom( dto.getInactiveFrom() );
        playerInactivityPeriodEntity.setInactiveTo( dto.getInactiveTo() );

        return playerInactivityPeriodEntity;
    }

    @Override
    public void updateEntityFromDto(PlayerInactivityPeriodDTO dto, PlayerInactivityPeriodEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setInactiveFrom( dto.getInactiveFrom() );
        entity.setInactiveTo( dto.getInactiveTo() );
    }

    private Long entityPlayerId(PlayerInactivityPeriodEntity playerInactivityPeriodEntity) {
        if ( playerInactivityPeriodEntity == null ) {
            return null;
        }
        PlayerEntity player = playerInactivityPeriodEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}
--------------------
C:\Projekty Práce\StaraGarda\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerMapperImpl.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-04T13:04:23+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerMapperImpl implements PlayerMapper {

    @Override
    public PlayerDTO toDTO(PlayerEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerDTO playerDTO = new PlayerDTO();

        playerDTO.setId( entity.getId() );
        playerDTO.setName( entity.getName() );
        playerDTO.setSurname( entity.getSurname() );
        playerDTO.setType( entity.getType() );
        playerDTO.setJerseyColor( entity.getJerseyColor() );

        return playerDTO;
    }

    @Override
    public PlayerEntity toEntity(PlayerDTO dto) {
        if ( dto == null ) {
            return null;
        }

        PlayerEntity playerEntity = new PlayerEntity();

        playerEntity.setId( dto.getId() );
        playerEntity.setName( dto.getName() );
        playerEntity.setSurname( dto.getSurname() );
        playerEntity.setType( dto.getType() );
        playerEntity.setJerseyColor( dto.getJerseyColor() );

        return playerEntity;
    }

    @Override
    public void updatePlayerDTO(PlayerDTO source, PlayerDTO target) {
        if ( source == null ) {
            return;
        }

        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setType( source.getType() );
        target.setJerseyColor( source.getJerseyColor() );
    }

    @Override
    public void updatePlayerEntity(PlayerDTO source, PlayerEntity target) {
        if ( source == null ) {
            return;
        }

        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setType( source.getType() );
        target.setJerseyColor( source.getJerseyColor() );
    }
}
