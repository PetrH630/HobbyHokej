Balíček (složka): services
Cesta: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services

Seznam souborů:
AppUserService.java
AppUserServiceImpl.java
AppUserSettingsService.java
AppUserSettingsServiceImpl.java
CurrentPlayerService.java
CurrentPlayerServiceImpl.java
CurrentSeasonService.java
CurrentSeasonServiceImpl.java
MatchRegistrationHistoryService.java
MatchRegistrationHistoryServiceImpl.java
MatchRegistrationService.java
MatchRegistrationServiceImpl.java
MatchService.java
MatchServiceImpl.java
NotificationDecision.java
PlayerInactivityPeriodService.java
PlayerInactivityPeriodServiceImpl.java
PlayerService.java
PlayerServiceImpl.java
PlayerSettingsService.java
PlayerSettingsServiceImpl.java
SeasonService.java
SeasonServiceImpl.java



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.ForgottenPasswordResetDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;
import org.springframework.http.ResponseEntity;

import java.util.List;

/**
 * Rozhraní pro správu uživatelských účtů v aplikaci.
 * <p>
 * Definuje kontrakt pro práci s uživateli z pohledu business logiky.
 * Implementace tohoto rozhraní zajišťuje registraci, správu účtů,
 * změnu hesla a aktivaci uživatelů.
 * </p>
 *
 * Účel:
 * <ul>
 *     <li>oddělit business logiku práce s uživateli od technické implementace,</li>
 *     <li>poskytnout jednotný vstupní bod pro správu uživatelů,</li>
 *     <li>umožnit bezpečnou a konzistentní správu uživatelských účtů.</li>
 * </ul>
 *
 * Použití:
 * <ul>
 *     <li>využívá se v controllerech a dalších business službách,</li>
 *     <li>pracuje výhradně s DTO objekty, nikoliv s entitami.</li>
 * </ul>
 *
 * Implementační poznámky:
 * <ul>
 *     <li>implementace by měla řešit validace vstupních dat,</li>
 *     <li>bezpečnostní kontroly (hesla, tokeny, role),</li>
 *     <li>správu životního cyklu uživatelského účtu.</li>
 * </ul>
 */
public interface AppUserService {

    /**
     * Zaregistruje nového uživatele do systému.
     * <p>
     * Metoda vytvoří nový uživatelský účet na základě
     * registračních dat poskytnutých uživatelem.
     * </p>
     *
     * Validace:
     * <ul>
     *     <li>email musí být jedinečný,</li>
     *     <li>heslo a potvrzení hesla se musí shodovat,</li>
     *     <li>registrační data musí splňovat validační pravidla.</li>
     * </ul>
     *
     * @param registerUserDTO data potřebná pro registraci uživatele
     * @throws IllegalArgumentException pokud email již existuje
     *                                  nebo hesla nejsou shodná
     */
    void register(RegisterUserDTO registerUserDTO);
    /**
     * Aktualizuje údaje uživatele.
     * <p>
     * Metoda umožňuje změnu uživatelských údajů,
     * které nevyžadují změnu hesla (např. jméno, role, stav).
     * </p>
     *
     * @param email email uživatele, který má být aktualizován
     * @param dto   nové hodnoty uživatelských údajů
     */
    void updateUser(String email, AppUserDTO dto);
    /**
     * Vrátí aktuálně přihlášeného uživatele podle emailu.
     * <p>
     * Typicky se používá v kontextu přihlášeného uživatele
     * (např. endpointy typu {@code /me}).
     * </p>
     *
     * @param email email přihlášeného uživatele
     * @return DTO reprezentace aktuálního uživatele
     */
    AppUserDTO getCurrentUser(String email);

    /**
     * Vrátí seznam všech uživatelů v systému.
     * <p>
     * Typicky dostupné pouze pro administrátorské role.
     * </p>
     *
     * @return seznam uživatelů ve formě DTO
     */
    List<AppUserDTO> getAllUsers();

    /**
     * Vrátí uživatele v systému dle ID.
     * <p>
     * Typicky dostupné pouze pro administrátorské role.
     * </p>
     * @param userId ID uživatele
     * @return uživatel ve formě DTO
     */
    AppUserDTO getUserById(Long userId);

    /**
     * Změní heslo uživatele.
     * <p>
     * Metoda slouží pro standardní změnu hesla,
     * kdy uživatel zná své aktuální heslo.
     * </p>
     *
     * Validace:
     * <ul>
     *     <li>aktuální heslo musí odpovídat uloženému heslu,</li>
     *     <li>nové heslo a jeho potvrzení se musí shodovat,</li>
     *     <li>nové heslo musí splňovat bezpečnostní požadavky.</li>
     * </ul>
     *
     * @param email               email uživatele
     * @param oldPassword         aktuální heslo
     * @param newPassword         nové heslo
     * @param newPasswordConfirm  potvrzení nového hesla
     */
    void changePassword(
            String email,
            String oldPassword,
            String newPassword,
            String newPasswordConfirm
    );

    /**
     * Resetuje heslo uživatele.
     * <p>
     * Používá se typicky v administrátorském kontextu
     * nebo při řešení zapomenutého hesla.
     * </p>
     *
     * @param userId ID uživatele, jehož heslo má být resetováno
     */
    void resetPassword(Long userId);



    /**
     * Aktivuje uživatelský účet pomocí aktivačního tokenu.
     * <p>
     * Typicky se používá po registraci uživatele
     * (aktivace přes emailový odkaz).
     * </p>
     *
     * @param token aktivační token
     * @return {@code true}, pokud byla aktivace úspěšná,
     *         jinak {@code false}
     */
    boolean activateUser(String token);

    /**
     * Aktivuje uživatelský účet
     * <p>
     * Používá se po registraci uživatele
     * v administrátorském prostředí (uživatel má problémy s tokenem)
     * </p>
     */
   void activateUserByAdmin(Long id);
    /**
     * Deaktivuje uživatelský účet
     * <p>
     * Používá se v administrátorském prostředí
     * pro deaktivaci účtu,nechci uživatele mazat, ale nechci
     * aby měl dočasně přístup do aplikace.
     * </p>
     */
    void deactivateUserByAdmin(Long id);

    void requestForgottenPasswordReset(String email);

    String getForgottenPasswordResetEmail(String token);

    void forgottenPasswordReset(ForgottenPasswordResetDTO dto);
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.EmailVerificationTokenEntity;
import cz.phsoft.hokej.data.entities.ForgottenPasswordResetTokenEntity;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.EmailVerificationTokenRepository;
import cz.phsoft.hokej.data.repositories.ForgottenPasswordResetTokenRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.ForgottenPasswordResetDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;
import cz.phsoft.hokej.models.mappers.AppUserMapper;
import cz.phsoft.hokej.models.services.email.EmailService;
import cz.phsoft.hokej.models.services.notification.ForgottenPasswordResetContext;
import cz.phsoft.hokej.models.services.notification.NotificationService;
import cz.phsoft.hokej.models.services.notification.UserActivationContext;
import jakarta.transaction.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;


/**
 * Service pro správu aplikačních uživatelských účtů.
 * <p>
 * Odpovědnosti:
 * <ul>
 *     <li>registrace nových uživatelů,</li>
 *     <li>aktivace účtů pomocí emailového ověřovacího tokenu,</li>
 *     <li>změna a reset hesla,</li>
 *     <li>správa základních údajů uživatelského účtu.</li>
 * </ul>
 * <p>
 * Bezpečnost:
 * <ul>
 *     <li>hesla jsou vždy ukládána hashovaná pomocí BCrypt,</li>
 *     <li>nově registrovaný účet je neaktivní, dokud není ověřen email.</li>
 * </ul>
 * <p>
 * Tato service neřeší:
 * <ul>
 *     <li>autentizaci (řeší Spring Security),</li>
 *     <li>správu hráčů (řeší {@link PlayerService}).</li>
 * </ul>
 */
@Service
public class AppUserServiceImpl implements AppUserService {

    private static final Logger log = LoggerFactory.getLogger(AppUserServiceImpl.class);

    /**
     * Výchozí heslo při resetu účtu administrátorem
     */
    private static final String DEFAULT_RESET_PASSWORD = "Player123";

    /**
     * Base URL aplikace – používá se pro generování aktivačních odkazů
     */
    @Value("${app.base-url}")
    private String baseUrl;

    private String buildActivationLink(EmailVerificationTokenEntity token) {
        return baseUrl + "/api/auth/verify?token=" + token.getToken();
    }

    private String buildResetPasswordlink(ForgottenPasswordResetTokenEntity token) {
        return baseUrl + "/api/auth/reset-password?token=" + token.getToken();
    }

    private final AppUserRepository userRepository;
    private final BCryptPasswordEncoder passwordEncoder;
    private final AppUserMapper appUserMapper;
    private final EmailService emailService;
    private final EmailVerificationTokenRepository tokenRepository;
    private final AppUserSettingsService appUserSettingsService;
    private final NotificationService notificationService;
    private final ForgottenPasswordResetTokenRepository forgottenPasswordResetTokenRepository;

    public AppUserServiceImpl(AppUserRepository userRepository,
                              BCryptPasswordEncoder passwordEncoder,
                              AppUserMapper appUserMapper,
                              EmailService emailService,
                              EmailVerificationTokenRepository tokenRepository,
                              AppUserSettingsService appUserSettingsService,
                              NotificationService notificationService,
                              ForgottenPasswordResetTokenRepository forgottenPasswordResetTokenRepository) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
        this.appUserMapper = appUserMapper;
        this.emailService = emailService;
        this.tokenRepository = tokenRepository;
        this.appUserSettingsService = appUserSettingsService;
        this.notificationService = notificationService;
        this.forgottenPasswordResetTokenRepository = forgottenPasswordResetTokenRepository;
    }

    /**
     * Zaregistruje nového uživatele.
     * <p>
     * Průběh registrace:
     * <ol>
     *     <li>ověření shody hesel,</li>
     *     <li>kontrola duplicity emailu,</li>
     *     <li>vytvoření neaktivního uživatele,</li>
     *     <li>vytvoření ověřovacího tokenu,</li>
     *     <li>odeslání aktivačního emailu.</li>
     * </ol>
     *
     * @param dto registrační údaje uživatele
     */
    @Override
    @Transactional
    public void register(RegisterUserDTO dto) {

        ensurePasswordsMatch(dto.getPassword(), dto.getPasswordConfirm(), null);
        ensureEmailNotUsed(dto.getEmail(), null);

        AppUserEntity user = createUserFromRegisterDto(dto);
        AppUserEntity savedUser = userRepository.save(user);

        EmailVerificationTokenEntity verificationToken =
                createVerificationToken(savedUser);

        // ⬅ TADY ZÍSKÁŠ activationLink
        String activationLink = buildActivationLink(verificationToken);
        log.info("Aktivační odkaz pro {}: {}", user.getEmail(), activationLink);
        // 1) Pošleme aktivační email přes EmailService (stávající logika)
//        emailService.sendActivationEmail(
//                savedUser.getEmail(),
//                savedUser.getName(),         // nebo full name, jak to máš
//                activationLink
//        );

        // 2) Pošleme notifikaci přes NotificationService (user + manažeři)
        notificationService.notifyUser(
                savedUser,
                NotificationType.USER_CREATED,
                new UserActivationContext(savedUser, activationLink)
        );
    }

    /**
     * Aktivuje uživatelský účet na základě ověřovacího tokenu.
     *
     * @param token aktivační token z emailu
     * @return {@code true} pokud byl účet úspěšně aktivován,
     * {@code false} pokud je token neplatný nebo expirovaný
     */
    @Override
    @Transactional
    public boolean activateUser(String token) {

        EmailVerificationTokenEntity verificationToken =
                tokenRepository.findByToken(token).orElse(null);

        if (verificationToken == null ||
                verificationToken.getExpiresAt().isBefore(LocalDateTime.now())) {
            return false;
        }

        AppUserEntity user = verificationToken.getUser();
        boolean newlyActivated = false;

        if (!user.isEnabled()) {
            user.setEnabled(true);
            newlyActivated = true;

            // pokud user ještě nemá settings → vytvoř default
            if (user.getSettings() == null) {
                appUserSettingsService.createDefaultSettingsForUser(user);
            }
            userRepository.save(user);
        }
        // token vždy smažeme, pokud byl platný
        tokenRepository.delete(verificationToken);
        // pokud se opravdu podaří nově aktivoval, pošleme notifikaci USER_ACTIVATED
        if (newlyActivated) {
            notifyUser(user, NotificationType.USER_ACTIVATED);
        }
        return true;
    }

    /**
     * Aktivuje uživatelský účet na základě aktivace Administrátorem.
     */
    @Override
    public void activateUserByAdmin(Long id) {
        AppUserEntity user = findUserByIdOrThrow(id);
        if (user.isEnabled()) {
            throw new InvalidUserActivationException(
                    "BE - Aktivace účtu již byla provedena"
            );
        }
        boolean newlyActivated = false;

        // aktivace účtu
        if (!user.isEnabled()) {
            user.setEnabled(true);
            newlyActivated = true;

            // pokud user ještě nemá settings → vytvoř default
            if (user.getSettings() == null) {
                appUserSettingsService.createDefaultSettingsForUser(user);
            }

            userRepository.save(user);
        }

        // smazání všech tokenu uživatele
        tokenRepository.deleteByUser(user);
        // případně: tokenRepository.deleteByUserId(user.getId());

        // pokud se opravdu nově aktivoval, pošleme notifikaci USER_ACTIVATED
        // pokud se opravdu nově aktivoval, pošleme notifikaci USER_ACTIVATED
        if (newlyActivated) {
            notifyUser(user, NotificationType.USER_ACTIVATED);
        }

    }

    /**
     * Aktualizuje základní údaje přihlášeného uživatele.
     *
     * @param email email aktuálního uživatele
     * @param dto   aktualizovaná data účtu
     */
    @Override
    @Transactional
    public void updateUser(String email, AppUserDTO dto) {

        AppUserEntity user = findUserByEmailOrThrow(email);

        if (!user.getEmail().equals(dto.getEmail())) {
            ensureEmailNotUsed(dto.getEmail(), user.getId());
        }

        user.setName(dto.getName());
        user.setSurname(dto.getSurname());
        user.setEmail(dto.getEmail());

        userRepository.save(user);
        notifyUser(user, NotificationType.USER_UPDATED);
    }

    /**
     * Vrátí detail aktuálně přihlášeného uživatele.
     *
     * @param email email uživatele
     * @return DTO uživatele
     */
    @Override
    public AppUserDTO getCurrentUser(String email) {
        AppUserEntity user = findUserByEmailOrThrow(email);
        return appUserMapper.toDTO(user);
    }

    /**
     * Vrátí seznam všech uživatelů v systému.
     * <p>
     * Určeno pouze pro administrátora.
     *
     * @return seznam uživatelů
     */
    @Override
    public List<AppUserDTO> getAllUsers() {
        return userRepository.findAll().stream()
                .map(appUserMapper::toDTO)
                .toList();
    }

    /**
     * Změní heslo přihlášeného uživatele.
     *
     * @param email              email uživatele
     * @param oldPassword        původní heslo
     * @param newPassword        nové heslo
     * @param newPasswordConfirm potvrzení nového hesla
     */
    @Override
    @Transactional
    public void changePassword(String email,
                               String oldPassword,
                               String newPassword,
                               String newPasswordConfirm) {

        ensurePasswordsMatch(
                newPassword,
                newPasswordConfirm,
                "BE - Nové heslo a potvrzení nového hesla se neshodují"
        );

        AppUserEntity user = findUserByEmailOrThrow(email);

        if (!passwordEncoder.matches(oldPassword, user.getPassword())) {
            throw new InvalidOldPasswordException();
        }

        user.setPassword(passwordEncoder.encode(newPassword));
        userRepository.save(user);

        notifyUser(user, NotificationType.USER_CHANGE_PASSWORD);
    }

    /**
     * Resetuje heslo uživatele na výchozí hodnotu.
     * <p>
     * Operace dostupná pouze administrátorovi.
     *
     * @param userId ID uživatele
     */
    @Override
    @Transactional
    public void resetPassword(Long userId) {
        AppUserEntity user = findUserByIdOrThrow(userId);
        user.setPassword(passwordEncoder.encode(DEFAULT_RESET_PASSWORD));
        userRepository.save(user);

        notifyUser(user, NotificationType.PASSWORD_RESET);
    }

    /**
     * Deaktivuj uživatelský účet na základě deaktivace Administrátorem.
     */
    @Override
    public void deactivateUserByAdmin(Long id) {
        AppUserEntity user = findUserByIdOrThrow(id);

        if (!user.isEnabled()) {
            throw new InvalidUserActivationException(
                    "BE - Deaktivace účtu již byla provedena"
            );
        }
        user.setEnabled(false);
        userRepository.save(user);
        notifyUser(user, NotificationType.USER_DEACTIVATED);

    }

    public AppUserDTO getUserById(Long id) {
        AppUserEntity user = findUserByIdOrThrow(id);
        return appUserMapper.toDTO(user);
    }

    @Override
    @Transactional
    public void requestForgottenPasswordReset(String email) {

        AppUserEntity user = userRepository.findByEmail(email)
                .orElse(null);

        // Bezpečnost: i když user neexistuje, neřekneme to klientovi.
        if (user == null) {
            log.info("Požadavek na forgotten password reset pro neexistující email: {}", email);
            return;
        }

        // Smažeme staré reset tokeny
        forgottenPasswordResetTokenRepository.deleteByUser(user);

        // Vytvoříme nový reset token
        ForgottenPasswordResetTokenEntity forgottenPasswordToken = createResetPasswordToken(user);

//        ForgottenPasswordResetTokenEntity token = new ForgottenPasswordResetTokenEntity();
//        token.setToken(UUID.randomUUID().toString());
//        token.setUser(user);
//        token.setExpiresAt(LocalDateTime.now().plusHours(1));
//
//        ForgottenPasswordResetTokenEntity savedToken =
//                forgottenPasswordResetTokenRepository.save(token);

        // ⬅ TADY ZÍSKÁŠ activationLink
        String resetPasswordlink = buildResetPasswordlink(forgottenPasswordToken);

        log.info("Odkaz pro reset hesla {}: {}", user.getEmail(), resetPasswordlink);


        notifyUser(
                user,
                NotificationType.FORGOTTEN_PASSWORD_RESET_REQUEST,
                new ForgottenPasswordResetContext(user, resetPasswordlink)
        );
    }

    @Override
    @Transactional
    public String getForgottenPasswordResetEmail(String token) {

        ForgottenPasswordResetTokenEntity resetToken =
                forgottenPasswordResetTokenRepository.findByToken(token)
                        .orElseThrow(() -> new InvalidResetTokenException());

        if (resetToken.getExpiresAt().isBefore(LocalDateTime.now())) {
            throw new InvalidResetTokenException("BE - Reset token expiroval.");
        }

        return resetToken.getUser().getEmail();
    }

    @Override
    @Transactional
    public void forgottenPasswordReset(ForgottenPasswordResetDTO dto) {

        ensurePasswordsMatch(
                dto.getNewPassword(),
                dto.getNewPasswordConfirm(),
                "BE - Nové heslo a potvrzení nového hesla se neshodují"
        );

        ForgottenPasswordResetTokenEntity resetToken =
                forgottenPasswordResetTokenRepository.findByToken(dto.getToken())
                        .orElseThrow(() -> new InvalidResetTokenException());

        if (resetToken.getExpiresAt().isBefore(LocalDateTime.now())) {
            throw new InvalidResetTokenException("BE - Reset token expiroval.");
        }

        AppUserEntity user = resetToken.getUser();

        user.setPassword(passwordEncoder.encode(dto.getNewPassword()));
        userRepository.save(user);

        // token zneplatníme – smažeme
        forgottenPasswordResetTokenRepository.delete(resetToken);

        // Notifikace – heslo změněno (můžeš použít buď USER_CHANGE_PASSWORD, nebo speciální FORGOTTEN_PASSWORD_RESET_COMPLETED)
        //notifyUser(user, NotificationType.USER_CHANGE_PASSWORD);
        // nebo:
        notifyUser(user, NotificationType.FORGOTTEN_PASSWORD_RESET_COMPLETED);
    }

    // ==================================================
    // HELPER METODY
    // ==================================================

    private AppUserEntity findUserByEmailOrThrow(String email) {
        return userRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException(email));
    }

    private AppUserEntity findUserByIdOrThrow(Long id) {
        return userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException(id));
    }


    /**
     * Ověří shodu hesla a potvrzení hesla.
     */
    private void ensurePasswordsMatch(String password,
                                      String confirm,
                                      String customMessage) {

        if (password == null || confirm == null || !password.equals(confirm)) {
            if (customMessage == null) {
                throw new PasswordsDoNotMatchException();
            }
            throw new PasswordsDoNotMatchException(customMessage);
        }
    }

    /**
     * Ověří, že email není používán jiným uživatelem.
     *
     * @param email         nový email
     * @param currentUserId ID uživatele, který je ignorován (při update),
     *                      při registraci {@code null}
     */
    private void ensureEmailNotUsed(String email, Long currentUserId) {
        userRepository.findByEmail(email).ifPresent(existing -> {
            if (currentUserId == null || !existing.getId().equals(currentUserId)) {
                throw new UserAlreadyExistsException(
                        "BE - Uživatel s tímto emailem již existuje"
                );
            }
        });
    }

    /**
     * Vytvoří nového uživatele z registračního DTO.
     */
    private AppUserEntity createUserFromRegisterDto(RegisterUserDTO dto) {
        AppUserEntity user = appUserMapper.fromRegisterDto(dto);
        user.setPassword(passwordEncoder.encode(dto.getPassword()));
        user.setRole(Role.ROLE_PLAYER);
        user.setEnabled(false);
        return user;
    }

    /**
     * Vytvoří a uloží emailový ověřovací token.
     */
    private EmailVerificationTokenEntity createVerificationToken(AppUserEntity user) {
        EmailVerificationTokenEntity token = new EmailVerificationTokenEntity();
        token.setToken(UUID.randomUUID().toString());
        token.setUser(user);
        token.setExpiresAt(LocalDateTime.now().plusHours(24));
        return tokenRepository.save(token);
    }

    /**
     * Vytvoří a uloží emailový reset password token.
     */
    private ForgottenPasswordResetTokenEntity createResetPasswordToken(AppUserEntity user) {
        ForgottenPasswordResetTokenEntity token = new ForgottenPasswordResetTokenEntity();
        token.setToken(UUID.randomUUID().toString());
        token.setUser(user);
        token.setExpiresAt(LocalDateTime.now().plusHours(1));
        return forgottenPasswordResetTokenRepository.save(token);
    }


    // metody pro notifikaci
    private void notifyUser(AppUserEntity user, NotificationType type) {
        notificationService.notifyUser(user, type, null);
    }

    private void notifyUser(AppUserEntity user, NotificationType type, Object context) {
        notificationService.notifyUser(user, type, context);
    }
}




-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserSettingsService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.AppUserSettingsEntity;
import cz.phsoft.hokej.models.dto.AppUserSettingsDTO;

/**
 * Service pro práci s nastavením uživatele (AppUserSettingsEntity).
 *
 * Pracuje v kontextu účtu (user), nikoliv currentPlayer.
 */
public interface AppUserSettingsService {

    /**
     * Vrátí nastavení pro uživatele identifikovaného emailem.
     * Pokud nastavení ještě neexistuje, vytvoří se s default hodnotami.
     *
     * @param userEmail email uživatele (unikátní login)
     * @return nastavení uživatele ve formě DTO
     */
    AppUserSettingsDTO getSettingsForUser(String userEmail);

    /**
     * Aktualizuje nastavení pro uživatele identifikovaného emailem.
     *
     * @param userEmail email uživatele
     * @param dto       nové nastavení
     * @return aktualizované nastavení
     */
    AppUserSettingsDTO updateSettingsForUser(String userEmail, AppUserSettingsDTO dto);

    AppUserSettingsEntity createDefaultSettingsForUser(AppUserEntity user);

}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserSettingsServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.AppUserSettingsEntity;
import cz.phsoft.hokej.data.enums.GlobalNotificationLevel;
import cz.phsoft.hokej.data.enums.PlayerSelectionMode;
import cz.phsoft.hokej.data.repositories.AppUserSettingsRepository;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.exceptions.UserNotFoundException;
import cz.phsoft.hokej.models.dto.AppUserSettingsDTO;
import cz.phsoft.hokej.models.mappers.AppUserSettingsMapper;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

/**
 * Implementace service pro práci s nastavením uživatele.
 */
@Service
@Transactional
public class AppUserSettingsServiceImpl implements AppUserSettingsService {

    private final AppUserRepository appUserRepository;
    private final AppUserSettingsRepository appUserSettingsRepository;
    private final AppUserSettingsMapper mapper;

    public AppUserSettingsServiceImpl(AppUserRepository appUserRepository,
                                      AppUserSettingsRepository appUserSettingsRepository,
                                      AppUserSettingsMapper mapper) {
        this.appUserRepository = appUserRepository;
        this.appUserSettingsRepository = appUserSettingsRepository;
        this.mapper = mapper;
    }

    @Override
    public AppUserSettingsDTO getSettingsForUser(String userEmail) {
        AppUserEntity user = findUserByEmailOrThrow(userEmail);

        // zkusíme najít existující settings
        Optional<AppUserSettingsEntity> existingOpt = appUserSettingsRepository.findByUser(user);

        AppUserSettingsEntity settings = existingOpt.orElseGet(() -> {
            // vytvoření default nastavení pro uživatele, pokud ještě neexistuje
            AppUserSettingsEntity created = createDefaultSettingsForUser(user);
            return appUserSettingsRepository.save(created);
        });

        return mapper.toDTO(settings);
    }

    @Override
    public AppUserSettingsDTO updateSettingsForUser(String userEmail, AppUserSettingsDTO dto) {
        AppUserEntity user = findUserByEmailOrThrow(userEmail);

        AppUserSettingsEntity settings = appUserSettingsRepository.findByUser(user)
                .orElseGet(() -> createDefaultSettingsForUser(user));

        // aplikovat hodnoty z DTO
        mapper.updateEntityFromDTO(dto, settings);

        // zajistit napojení na usera (pro případ nového objektu)
        settings.setUser(user);

        AppUserSettingsEntity saved = appUserSettingsRepository.save(settings);

        return mapper.toDTO(saved);
    }

    // =========================================
    // HELPER METODY
    // =========================================

    private AppUserEntity findUserByEmailOrThrow(String email) {
        return appUserRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException(email));
    }

    @Override
    public AppUserSettingsEntity createDefaultSettingsForUser(AppUserEntity user) {
        AppUserSettingsEntity settings = new AppUserSettingsEntity();
        settings.setUser(user);

        // výchozí hodnoty – stejné jako v entitě, ale explicitně
        settings.setPlayerSelectionMode(PlayerSelectionMode.FIRST_PLAYER);
        settings.setGlobalNotificationLevel(GlobalNotificationLevel.ALL);
        settings.setCopyAllPlayerNotificationsToUserEmail(false);
        settings.setReceiveNotificationsForPlayersWithOwnEmail(false);
        settings.setEmailDigestEnabled(false);
        settings.setEmailDigestTime(null);
        settings.setUiLanguage("cs");
        settings.setTimezone("Europe/Prague");
        settings.setDefaultLandingPage("DASHBOARD");

        appUserSettingsRepository.save(settings);

        return settings;

    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\CurrentPlayerService.java
-----

package cz.phsoft.hokej.models.services;

/**
 * Rozhraní pro správu „aktuálně zvoleného hráče“ přihlášeného uživatele.
 * <p>
 * Uživatel může mít v systému více hráčů, ale většina operací
 * (registrace na zápasy, přehledy, statistiky) pracuje vždy
 * s jedním jednoznačně zvoleným hráčem.
 * </p>
 *
 * Účel:
 * <ul>
 *     <li>poskytnout jednotný kontrakt pro práci s aktuálním hráčem,</li>
 *     <li>oddělit práci se session / kontextem od business logiky,</li>
 *     <li>zajistit konzistentní chování napříč aplikací.</li>
 * </ul>
 *
 * Použití:
 * <ul>
 *     <li>využívá se zejména v controllerech a business službách,</li>
 *     <li>typicky v kontextu endpointů pracujících s „/me“.</li>
 * </ul>
 *
 * Implementační poznámky:
 * <ul>
 *     <li>implementace typicky ukládá identifikátor hráče do uživatelského kontextu
 *     (např. HTTP session),</li>
 *     <li>ověření existence a stavu hráče je zodpovědností implementace.</li>
 * </ul>
 */
public interface CurrentPlayerService {

    /**
     * Vrátí ID aktuálně zvoleného hráče.
     *
     * @return ID hráče nebo {@code null}, pokud aktuální hráč není nastaven
     */
    Long getCurrentPlayerId();

    /**
     * Nastaví aktuálního hráče.
     * <p>
     * Metoda slouží ke změně uživatelského kontextu na konkrétního hráče.
     * Implementace je zodpovědná za validaci, že hráč může být zvolen
     * (např. že existuje a je ve správném stavu).
     * </p>
     *
     * @param playerId ID hráče, který má být nastaven jako aktuální
     */
    void setCurrentPlayerId(Long playerId);

    /**
     * Ověří, že je aktuální hráč nastaven.
     * <p>
     * Používá se zejména před operacemi, které vyžadují kontext
     * aktuálního hráče.
     * </p>
     *
     * @throws RuntimeException pokud aktuální hráč není nastaven
     */
    void requireCurrentPlayer();

    /**
     * Odstraní informaci o aktuálním hráči z uživatelského kontextu.
     * <p>
     * Typicky se používá při odhlášení uživatele
     * nebo při resetu uživatelského kontextu.
     * </p>
     */
    void clear();
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\CurrentPlayerServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.CurrentPlayerNotSelectedException;
import cz.phsoft.hokej.exceptions.InvalidPlayerStatusException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.security.SessionKeys;
import jakarta.servlet.http.HttpSession;
import org.springframework.stereotype.Service;

/**
 * Service pro správu „aktuálně zvoleného hráče“ přihlášeného uživatele.
 * <p>
 * význam:
 * <ul>
 *     <li>jeden uživatel může mít více hráčů,</li>
 *     <li>pro většinu operací (registrace na zápasy, přehledy, statistiky)
 *     musí být jednoznačně určen aktuální hráč.</li>
 * </ul>
 *
 * Technické řešení:
 * <ul>
 *     <li>aktuální hráč je uložen v HTTP session,</li>
 *     <li>do session se ukládá pouze ID hráče, nikoliv celá entita.</li>
 * </ul>
 *
 * Tato service:
 * <ul>
 *     <li>ukládá a čte ID aktuálního hráče ze session,</li>
 *     <li>ověřuje existenci hráče,</li>
 *     <li>hlídá, že hráč je ve správném stavu (APPROVED).</li>
 * </ul>
 *
 * Tato service neřeší:
 * <ul>
 *     <li>oprávnění uživatele k hráči (řeší {@link PlayerService}),</li>
 *     <li>business logiku zápasů.</li>
 * </ul>
 */
@Service
public class CurrentPlayerServiceImpl implements CurrentPlayerService {

    /**
     * HTTP session vázaná na přihlášeného uživatele.
     */
    private final HttpSession session;

    /**
     * Repozitář hráčů – slouží k ověření existence a stavu hráče.
     */
    private final PlayerRepository playerRepository;

    public CurrentPlayerServiceImpl(HttpSession session,
                                    PlayerRepository playerRepository) {
        this.session = session;
        this.playerRepository = playerRepository;
    }

    /**
     * Vrátí ID aktuálně zvoleného hráče ze session.
     *
     * @return ID hráče nebo {@code null}, pokud ještě nebyl vybrán
     */
    @Override
    public Long getCurrentPlayerId() {
        return (Long) session.getAttribute(SessionKeys.CURRENT_PLAYER_ID);
    }

    /**
     * Nastaví aktuálního hráče do session.
     * <p>
     * Validace:
     * <ul>
     *     <li>hráč musí existovat,</li>
     *     <li>hráč musí být ve stavu {@link PlayerStatus#APPROVED}.</li>
     * </ul>
     *
     * @param playerId ID hráče, který má být nastaven jako aktuální
     */
    @Override
    public void setCurrentPlayerId(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        validatePlayerSelectable(player);

        session.setAttribute(SessionKeys.CURRENT_PLAYER_ID, playerId);
    }

    /**
     * Ověří, že je aktuální hráč nastaven.
     * <p>
     * Používá se zejména:
     * <ul>
     *     <li>před registrací na zápas,</li>
     *     <li>u endpointů pracujících s kontextem „/me“.</li>
     * </ul>
     *
     * @throws CurrentPlayerNotSelectedException pokud aktuální hráč není nastaven
     */
    @Override
    public void requireCurrentPlayer() {
        Long currentPlayerId = getCurrentPlayerId();
        if (currentPlayerId == null) {
            throw new CurrentPlayerNotSelectedException();
        }
    }

    /**
     * Odstraní aktuálního hráče ze session.
     * <p>
     * Typicky se používá při:
     * <ul>
     *     <li>odhlášení uživatele,</li>
     *     <li>resetu uživatelského kontextu.</li>
     * </ul>
     */
    @Override
    public void clear() {
        session.removeAttribute(SessionKeys.CURRENT_PLAYER_ID);
    }

    // ==================================================
    // HELPER METODY
    // ==================================================

    /**
     * Najde hráče podle ID nebo vyhodí výjimku.
     */
    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    /**
     * Ověří, zda hráč může být zvolen jako „aktuální“.
     * <p>
     * Aktuálně je povolen pouze stav {@link PlayerStatus#APPROVED}.
     *
     * Možná budoucí rozšíření:
     * <ul>
     *     <li>hráč nesmí být smazaný,</li>
     *     <li>hráč musí mít vyplněné kontaktní údaje,</li>
     *     <li>hráč nesmí být dlouhodobě neaktivní.</li>
     * </ul>
     */
    private void validatePlayerSelectable(PlayerEntity player) {
        if (player.getPlayerStatus() != PlayerStatus.APPROVED) {
            throw new InvalidPlayerStatusException(
                    "BE - Nelze zvolit hráče, který není schválen administrátorem."
            );
        }
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\CurrentSeasonService.java
-----

package cz.phsoft.hokej.models.services;

public interface CurrentSeasonService {

    /**
     * Vrátí ID sezóny uložené v session, nebo:
     * - pokud není nic nastaveno, vezme globálně aktivní sezónu,
     *   uloží ji do session a vrátí její ID.
     */
    Long getCurrentSeasonIdOrDefault();

    /**
     * Nastaví sezónu pro aktuálního uživatele (session).
     */
    void setCurrentSeasonId(Long seasonId);

    /**
     * Volitelně – vymaže sezónu ze session (např. při logoutu).
     */
    void clearCurrentSeason();
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\CurrentSeasonServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.SeasonDTO;
import jakarta.servlet.http.HttpSession;
import org.springframework.stereotype.Service;

@Service
public class CurrentSeasonServiceImpl implements CurrentSeasonService {

    private static final String CURRENT_SEASON_SESSION_ATTR = "CURRENT_SEASON_ID";
    private static final String CURRENT_SEASON_CUSTOM_ATTR  = "CURRENT_SEASON_CUSTOM";

    private final HttpSession session;
    private final SeasonService seasonService;

    public CurrentSeasonServiceImpl(HttpSession session,
                                    SeasonService seasonService) {
        this.session = session;
        this.seasonService = seasonService;
    }

    @Override
    public Long getCurrentSeasonIdOrDefault() {
        Object value = session.getAttribute(CURRENT_SEASON_SESSION_ATTR);
        Boolean custom = (Boolean) session.getAttribute(CURRENT_SEASON_CUSTOM_ATTR);
        // Pokud si uživatel sezónu VĚDOMĚ zvolil, respektujeme ji
        if (Boolean.TRUE.equals(custom) && value != null) {
            return toLong(value);
        }

        // Jinak vždy bereme AKTUÁLNÍ aktivní sezónu z DB (adminem nastavenou)
        SeasonDTO active = seasonService.getActiveSeasonOrNull();
        if (active != null) {
            Long id = active.getId();
            session.setAttribute(CURRENT_SEASON_SESSION_ATTR, id);
            session.setAttribute(CURRENT_SEASON_CUSTOM_ATTR, Boolean.FALSE);
            return id;
        }

        // fallback - žádná aktivní sezóna
        return null;
    }

    @Override
    public void setCurrentSeasonId(Long seasonId) {
        // Uživatel si sezónu explicitně vybral
        session.setAttribute(CURRENT_SEASON_SESSION_ATTR, seasonId);
        session.setAttribute(CURRENT_SEASON_CUSTOM_ATTR, Boolean.TRUE);
    }

    @Override
    public void clearCurrentSeason() {
        session.removeAttribute(CURRENT_SEASON_SESSION_ATTR);
        session.removeAttribute(CURRENT_SEASON_CUSTOM_ATTR);
    }

    // malá pojistka pro případ, že container vrátí Integer/String místo Long
    private Long toLong(Object value) {
        if (value instanceof Long l) return l;
        if (value instanceof Integer i) return i.longValue();
        return Long.valueOf(value.toString());
    }
}




-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationHistoryService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.MatchRegistrationHistoryDTO;

import java.util.List;

/**
 * Service pro práci s historickými (auditními) záznamy
 * registrací hráčů k zápasům.
 *
 * <p>
 * Tato service:
 * <ul>
 *     <li>slouží výhradně pro čtení dat (read-only),</li>
 *     <li>pracuje nad tabulkou {@code match_registration_history},</li>
 *     <li>neobsahuje žádnou byznys logiku ani zápis do databáze,</li>
 *     <li>odděluje auditní dotazy od hlavní logiky registrací.</li>
 * </ul>
 * </p>
 *
 * <p>
 * Typické použití:
 * <ul>
 *     <li>zobrazení historie změn registrace přihlášeného hráče,</li>
 *     <li>administrativní audit registrací konkrétního hráče k zápasu.</li>
 * </ul>
 * </p>
 */
public interface MatchRegistrationHistoryService {

    /**
     * Vrátí historii všech změn registrace přihlášeného hráče
     * pro konkrétní zápas.
     *
     * <p>
     * Metoda:
     * <ul>
     *     <li>automaticky určí aktuálně přihlášeného hráče (currentPlayer),</li>
     *     <li>vrací pouze záznamy, které se vztahují k tomuto hráči,</li>
     *     <li>výsledky jsou seřazeny sestupně podle času změny
     *         (nejnovější změna jako první).</li>
     * </ul>
     * </p>
     *
     * @param matchId ID zápasu, ke kterému se historie načítá
     * @return seznam historických záznamů registrace hráče k zápasu
     */
    List<MatchRegistrationHistoryDTO> getHistoryForCurrentPlayerAndMatch(Long matchId);

    /**
     * Vrátí historii všech změn registrace konkrétního hráče
     * k danému zápasu.
     *
     * <p>
     * Metoda je určena zejména pro:
     * <ul>
     *     <li>administrativní a auditní účely,</li>
     *     <li>kontrolu zásahů do registrací hráčů,</li>
     *     <li>řešení sporů a reklamací.</li>
     * </ul>
     * </p>
     *
     * <p>
     * Výsledky jsou seřazeny sestupně podle času změny
     * (nejnovější změna jako první).
     * </p>
     *
     * @param matchId  ID zápasu
     * @param playerId ID hráče
     * @return seznam historických záznamů registrace hráče k zápasu
     */
    List<MatchRegistrationHistoryDTO> getHistoryForPlayerAndMatch(Long matchId, Long playerId);
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationHistoryServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.repositories.MatchRegistrationHistoryRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.exceptions.MatchNotFoundException;
import cz.phsoft.hokej.models.dto.MatchRegistrationHistoryDTO;
import cz.phsoft.hokej.models.mappers.MatchRegistrationHistoryMapper;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class MatchRegistrationHistoryServiceImpl implements MatchRegistrationHistoryService{

    private final MatchRegistrationHistoryRepository historyRepository;
    private final MatchRegistrationHistoryMapper historyMapper;
    private final CurrentPlayerService currentPlayerService;
    private final MatchRepository matchRepository;

    public MatchRegistrationHistoryServiceImpl(
            MatchRegistrationHistoryRepository historyRepository,
            MatchRegistrationHistoryMapper historyMapper,
            CurrentPlayerService currentPlayerService,
            MatchRepository matchRepository
    ) {
        this.historyRepository = historyRepository;
        this.historyMapper = historyMapper;
        this.currentPlayerService = currentPlayerService;
        this.matchRepository = matchRepository;
    }

    /**
     * Vrátí historii registrací přihlášeného hráče pro daný zápas.
     */
    public List<MatchRegistrationHistoryDTO> getHistoryForCurrentPlayerAndMatch(Long matchId) {
        // ověření, že zápas existuje
        MatchEntity match = matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));

        // zjištění currentPlayer (předpokládám, že službu už máš)
        //PlayerEntity currentPlayer = currentPlayerService.getCurrentPlayerOrThrow();
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();


        // dotaz do historie
        var history = historyRepository
                .findByMatchIdAndPlayerIdOrderByChangedAtDesc(match.getId(), currentPlayerId);

        return historyMapper.toDTOList(history);
    }

    /**
     * Použitelná i pro admin účely – např. v jiném endpointu.
     */
    public List<MatchRegistrationHistoryDTO> getHistoryForPlayerAndMatch(Long matchId, Long playerId) {
        MatchEntity match = matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));

        var history = historyRepository
                .findByMatchIdAndPlayerIdOrderByChangedAtDesc(match.getId(), playerId);

        return historyMapper.toDTOList(history);
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;

import java.util.List;

/**
 * Rozhraní pro správu registrací hráčů na zápasy.
 * <p>
 * Definuje kontrakt pro práci s účastí hráčů na zápasech
 * z pohledu business logiky aplikace.
 * </p>
 *
 * Význam v aplikaci:
 * <ul>
 *     <li>umožňuje hráčům reagovat na zápasy (přihlášení, odhlášení, omluva),</li>
 *     <li>poskytuje přehled registrací pro zápasy i jednotlivé hráče,</li>
 *     <li>zajišťuje konzistenci stavů registrací.</li>
 * </ul>
 *
 * Architektonické zásady:
 * <ul>
 *     <li>pracuje výhradně s DTO objekty, nikoliv s entitami,</li>
 *     <li>odděluje business logiku registrací od persistence vrstvy,</li>
 *     <li>implementace je zodpovědná za validace a přechody stavů.</li>
 * </ul>
 *
 * Použití:
 * <ul>
 *     <li>využívá se v controllerech a dalších business službách,</li>
 *     <li>je klíčovou součástí workflow práce se zápasy.</li>
 * </ul>
 */
public interface MatchRegistrationService {

    /**
     * Vytvoří nebo aktualizuje registraci hráče na zápas.
     * <p>
     * Metoda slouží jako jednotný vstupní bod pro reakci hráče
     * na zápas (tzv. upsert – insert nebo update).
     * </p>
     *
     * Typické scénáře:
     * <ul>
     *     <li>přihlášení hráče k zápasu,</li>
     *     <li>odhlášení hráče ze zápasu,</li>
     *     <li>omluva hráče.</li>
     * </ul>
     *
     * Implementace zajišťuje:
     * <ul>
     *     <li>validaci vstupních dat,</li>
     *     <li>kontrolu povolených přechodů stavů,</li>
     *     <li>vytvoření nebo úpravu registrace.</li>
     * </ul>
     *
     * @param playerId ID hráče, který reaguje na zápas
     * @param request  požadavek obsahující data o registraci
     * @return DTO reprezentace výsledného stavu registrace
     */
    MatchRegistrationDTO upsertRegistration(
            Long playerId,
            MatchRegistrationRequest request
    );

    /**
     * Vrátí seznam registrací pro konkrétní zápas.
     *
     * @param matchId ID zápasu
     * @return seznam registrací hráčů k danému zápasu
     */
    List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId);

    /**
     * Vrátí seznam registrací pro více zápasů.
     * <p>
     * Typicky se používá pro hromadné přehledy nebo statistiky.
     * </p>
     *
     * @param matchIds seznam ID zápasů
     * @return seznam registrací pro zadané zápasy
     */
    List<MatchRegistrationDTO> getRegistrationsForMatches(List<Long> matchIds);

    /**
     * Vrátí všechny registrace v systému.
     * <p>
     * Typicky určeno pro administrátorské přehledy.
     * </p>
     *
     * @return seznam všech registrací
     */
    List<MatchRegistrationDTO> getAllRegistrations();

    /**
     * Vrátí seznam registrací konkrétního hráče.
     *
     * @param playerId ID hráče
     * @return seznam registrací daného hráče
     */
    List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId);

    /**
     * Vrátí seznam hráčů, kteří dosud nereagovali na daný zápas.
     * <p>
     * Používá se zejména:
     * </p>
     * <ul>
     *     <li>pro připomínkové notifikace,</li>
     *     <li>pro přehledy nevyřešené účasti.</li>
     * </ul>
     *
     * @param matchId ID zápasu
     * @return seznam hráčů bez reakce
     */
    List<PlayerDTO> getNoResponsePlayers(Long matchId);

    /**
     * Přepočítá stavy registrací pro daný zápas.
     * <p>
     * Metoda slouží k zajištění konzistence stavů
     * (např. po administrátorském zásahu).
     * </p>
     *
     * @param matchId ID zápasu
     */
    void recalcStatusesForMatch(Long matchId);

    /**
     * Změní stav registrace hráče na zápas.
     * <p>
     * Typicky se používá v administrátorském kontextu,
     * kde je nutné ručně upravit stav registrace.
     * </p>
     *
     * @param matchId  ID zápasu
     * @param playerId ID hráče
     * @param status   nový stav registrace
     * @return DTO reprezentace aktualizované registrace
     */
    MatchRegistrationDTO updateStatus(
            Long matchId,
            Long playerId,
            PlayerMatchStatus status
    );

    /**
     * Označí hráče jako „neomluveného“ pro konkrétní zápas.
     * <p>
     * Používá se zejména v administrátorském kontextu
     * po vyhodnocení účasti na zápase.
     * </p>
     *
     * @param matchId   ID zápasu
     * @param playerId  ID hráče
     * @param adminNote poznámka administrátora
     * @return DTO reprezentace aktualizované registrace
     */
    MatchRegistrationDTO markNoExcused(
            Long matchId,
            Long playerId,
            String adminNote
    );
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.mappers.MatchRegistrationMapper;
import cz.phsoft.hokej.models.mappers.PlayerMapper;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;
import cz.phsoft.hokej.models.services.notification.NotificationService;
import cz.phsoft.hokej.models.services.sms.SmsMessageBuilder;
import cz.phsoft.hokej.models.services.sms.SmsService;
import jakarta.transaction.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Service pro správu registrací hráčů na zápasy.
 * <p>
 * Odpovědnosti:
 * <ul>
 *     <li>vytváření a změna registrací (REGISTER, RESERVED, UNREGISTERED, EXCUSED, NO_EXCUSED),</li>
 *     <li>přepočet pořadí REGISTERED/RESERVED podle kapacity zápasu,</li>
 *     <li>získávání přehledů o registracích (pro zápas, hráče, NO_RESPONSE hráče),</li>
 *     <li>spouštění notifikací (email/SMS) podle změny statusu.</li>
 * </ul>
 * <p>
 * Tato service:
 * <ul>
 *     <li>řeší byznys logiku registrací a stavových přechodů,</li>
 *     <li>neřeší UI, security ani výběr aktuálního hráče (to řeší jiné vrstvy).</li>
 * </ul>
 */
@Service
public class MatchRegistrationServiceImpl implements MatchRegistrationService {

    private static final Logger log = LoggerFactory.getLogger(MatchRegistrationServiceImpl.class);

    private final MatchRegistrationRepository registrationRepository;
    private final MatchRepository matchRepository;
    private final PlayerRepository playerRepository;
    private final MatchRegistrationMapper matchRegistrationMapper;
    private final PlayerMapper playerMapper;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;
    private final NotificationService notificationService;
    private final SeasonService seasonService;
    private final CurrentSeasonService currentSeasonService;

    public MatchRegistrationServiceImpl(
            MatchRegistrationRepository registrationRepository,
            MatchRepository matchRepository,
            PlayerRepository playerRepository,
            MatchRegistrationMapper matchRegistrationMapper,
            PlayerMapper playerMapper,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder,
            NotificationService notificationService,
            SeasonService seasonService,
            CurrentSeasonService currentSeasonService
    ) {
        this.registrationRepository = registrationRepository;
        this.matchRepository = matchRepository;
        this.playerRepository = playerRepository;
        this.matchRegistrationMapper = matchRegistrationMapper;
        this.playerMapper = playerMapper;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
        this.notificationService = notificationService;
        this.seasonService = seasonService;
        this.currentSeasonService = currentSeasonService;
    }

    // ==========================================
    // HLAVNÍ METODA – UPSERT REGISTRACE HRÁČE
    // ==========================================

    /**
     * Vytvoří nebo aktualizuje registraci hráče na zápas.
     * <p>
     * Postup:
     * <ol>
     *     <li>načte zápas a hráče,</li>
     *     <li>najde existující registraci (pokud existuje),</li>
     *     <li>podle obsahu {@link MatchRegistrationRequest} větví na:
     *         <ul>
     *             <li>UNREGISTER → {@link #handleUnregister},</li>
     *             <li>EXCUSE → {@link #handleExcuse},</li>
     *             <li>REGISTER/RESERVE → {@link #handleRegisterOrReserveOrSubstitute},</li>
     *         </ul>
     *     </li>
     *     <li>aplikuje společné detaily z requestu ({@link #applyRequestDetails}),</li>
     *     <li>uloží registraci,</li>
     *     <li>po UNREGISTER přepočítá pořadí REGISTERED/RESERVED,</li>
     *     <li>podle výsledného statusu spustí notifikace.</li>
     * </ol>
     *
     * @param playerId ID hráče
     * @param request  požadavek na změnu registrace
     * @return DTO výsledné registrace
     */
    @Transactional
    @Override
    public MatchRegistrationDTO upsertRegistration(Long playerId, MatchRegistrationRequest request) {

        MatchEntity match = getMatchOrThrow(request.getMatchId());
        PlayerEntity player = getPlayerOrThrow(playerId);

        /**
         * Ověření, že zápas patří do aktuálně aktivní sezóny.
         * Zápisy do neaktivní sezóny nejsou povoleny.
         */
        assertMatchInActiveSeason(match);

        /**
         * Ověření, zda aktuální uživatel smí měnit registraci
         *  s ohledem na svou roli a čas zápasu.
         */
        assertPlayerCanModifyMatch(match);

        MatchRegistrationEntity registration =
                getRegistrationOrNull(playerId, request.getMatchId());

        if (registration == null && !request.isUnregister()) {
            registration = new MatchRegistrationEntity();
            registration.setMatch(match);
            registration.setPlayer(player);
        }

        PlayerMatchStatus newStatus;

        if (request.isUnregister()) {
            // UNREGISTER – pouze z REGISTERED/RESERVED
            newStatus = handleUnregister(request, playerId, registration);
        } else if (request.getExcuseReason() != null) {
            // EXCUSE – pouze pokud ještě nemá žádnou registraci
            newStatus = handleExcuse(request, match, player, registration);
        } else {
            // REGISTER / RESERVE / SUBSTITUTE
            newStatus = handleRegisterOrReserveOrSubstitute(request, match, player, registration);
        }

        // společné nastavení detailů z requestu (team, admin poznámka, excuse...)
        applyRequestDetails(registration, request);

        // finální nastavení – status, timestamp, kdo vytvořil
        registration.setStatus(newStatus);
        registration.setTimestamp(now());
        registration.setCreatedBy("user");

        registration = registrationRepository.save(registration);

        // po UNREGISTER přepočítáme REGISTERED/RESERVED (náhradníky)
        if (request.isUnregister()) {
            recalcStatusesForMatch(request.getMatchId());
        }

        // notifikace (email/SMS) podle typu změny
        NotificationType notificationType = resolveNotificationType(newStatus);
        if (notificationType != null) {
            notifyPlayer(player, notificationType, registration);
        }

        return matchRegistrationMapper.toDTO(registration);
    }

    /**
     * Větev pro REGISTER / RESERVE / SUBSTITUTE (náhradník „možná“):
     * <ul>
     *     <li>pokud je hráč už REGISTERED, další registrace není povolena,</li>
     *     <li>pokud je volné místo → REGISTERED, jinak RESERVED,</li>
     *     <li>při přechodu z EXCUSED smaže excuseReason / excuseNote,</li>
     *     <li>SUBSTITUTE se chová jako NO_RESPONSE:
     *         hráč může kdykoliv přejít na REGISTER/RESERVE nebo EXCUSED.</li>
     * </ul>
     */
    private PlayerMatchStatus handleRegisterOrReserveOrSubstitute(
            MatchRegistrationRequest request,
            MatchEntity match,
            PlayerEntity player,
            MatchRegistrationEntity registration
    ) {
        PlayerMatchStatus currentStatus =
                (registration != null) ? registration.getStatus() : null;

        boolean isAlreadyRegistered = currentStatus == PlayerMatchStatus.REGISTERED;

        if (isAlreadyRegistered) {
            throw new DuplicateRegistrationException(request.getMatchId(), player.getId());
        }

        // explicitní registrace jako „možná“ (SUBSTITUTE) Hráč se označí jako náhradník / možná, neblokuje kapacitu,
        // neúčastní se auto-přepočtů a může později- přejít na REGISTER/RESERVED/EXCUSED
        if (request.isSubstitute()) {
            if (currentStatus == PlayerMatchStatus.SUBSTITUTE) {
                throw new DuplicateRegistrationException(request.getMatchId(), player.getId(), "Hráč již má zaregistrováno - možná");
            }

            clearExcuseIfNeeded(registration);
            return PlayerMatchStatus.SUBSTITUTE;
        }

        PlayerMatchStatus newStatus =
                isSlotAvailable(match) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;

        clearExcuseIfNeeded(registration);
        return newStatus;
    }

    /**
     * Větev pro UNREGISTER:
     * <ul>
     *     <li>povoleno pouze, pokud registrace/rezervace existuje a je REGISTERED/RESERVED,</li>
     *     <li>nastaví excuseReason a excuseNote,</li>
     *     <li>vrací nový status UNREGISTERED.</li>
     * </ul>
     */
    private PlayerMatchStatus handleUnregister(
            MatchRegistrationRequest request,
            Long playerId,
            MatchRegistrationEntity registration
    ) {
        boolean isAllowedUnregisterStatus =
                registration != null &&
                        (registration.getStatus() == PlayerMatchStatus.REGISTERED
                                || registration.getStatus() == PlayerMatchStatus.RESERVED);

        if (!isAllowedUnregisterStatus) {
            throw new RegistrationNotFoundException(request.getMatchId(), playerId);
        }

        registration.setExcuseReason(request.getExcuseReason());
        registration.setExcuseNote(request.getExcuseNote());

        return PlayerMatchStatus.UNREGISTERED;
    }

    /**
     * Větev pro EXCUSE (omluva z účasti):
     * <ul>
     *     <li>nelze, pokud má hráč aktuálně REGISTERED,</li>
     *     <li>pokud registrace neexistuje, vytvoří novou,</li>
     *     <li>nastaví excuseReason a excuseNote,</li>
     *     <li>vrací status EXCUSED.</li>
     * </ul>
     */
    private PlayerMatchStatus handleExcuse(
            MatchRegistrationRequest request,
            MatchEntity match,
            PlayerEntity player,
            MatchRegistrationEntity registration
    ) {
        // NO_RESPONSE = registrace bez statusu
        boolean isNoResponseOrSubstitute =
                (registration == null
                        || registration.getStatus() == null
                        || registration.getStatus() == PlayerMatchStatus.SUBSTITUTE);


        if (!isNoResponseOrSubstitute) {
            throw new DuplicateRegistrationException(
                    request.getMatchId(),
                    player.getId(),
                    "BE - Omluva je možná pouze pokud hráč dosud nereagoval na zápas, nebo byl náhradník."
            );
        }
        registration.setExcuseReason(request.getExcuseReason());
        registration.setExcuseNote(request.getExcuseNote());

        return PlayerMatchStatus.EXCUSED;
    }

    /**
     * Speciální admin logika pro nastavení statusu NO_EXCUSED:
     * <ul>
     *     <li>zápas musí být v minulosti,</li>
     *     <li>původní status musí být REGISTERED,</li>
     *     <li>smaže se excuseReason a excuseNote,</li>
     *     <li>nastaví se adminNote (z parametru nebo defaultní).</li>
     * </ul>
     */
    @Override
    @Transactional
    public MatchRegistrationDTO markNoExcused(Long matchId,
                                              Long playerId,
                                              String adminNote) {

        MatchEntity match = getMatchOrThrow(matchId);
        PlayerEntity player = getPlayerOrThrow(playerId);

        if (match.getDateTime().isAfter(now())) {
            throw new InvalidPlayerStatusException(
                    "BE - Status NO_EXCUSED lze nastavit pouze u již proběhlého zápasu."
            );
        }

        MatchRegistrationEntity registration = getRegistrationOrThrow(playerId, matchId);

        if (registration.getStatus() != PlayerMatchStatus.REGISTERED) {
            throw new InvalidPlayerStatusException(
                    "BE - Status NO_EXCUSED lze nastavit pouze z registrace REGISTERED."
            );
        }

        registration.setExcuseReason(null);
        registration.setExcuseNote(null);

        if (adminNote == null || adminNote.isBlank()) {
            registration.setAdminNote("Nedostavil se bez omluvy");
        } else {
            registration.setAdminNote(adminNote);
        }

        MatchRegistrationEntity updated =
                updateRegistrationStatus(
                        registration,
                        PlayerMatchStatus.NO_EXCUSED,
                        "admin",
                        true
                );

        PlayerMatchStatus newStatus = PlayerMatchStatus.NO_EXCUSED;

        NotificationType notificationType = resolveNotificationType(newStatus);
        if (notificationType != null) {
            notifyPlayer(player, notificationType, updated);
        }

        return matchRegistrationMapper.toDTO(updated);
    }
    /**
     * Společné nastavení detailů registrace podle requestu:
     * <ul>
     *     <li>team (světlý/tmavý),</li>
     *     <li>adminNote,</li>
     *     <li>případná aktualizace excuseReason.</li>
     *     <li>případná aktualizace excuseReason.</li>
     * </ul>
     */
    private void applyRequestDetails(MatchRegistrationEntity registration,
                                     MatchRegistrationRequest request) {

        if (request.getTeam() != null) {
            registration.setTeam(request.getTeam());
        }

        if (request.getAdminNote() != null) {
            registration.setAdminNote(request.getAdminNote());
        }

        if (request.getExcuseReason() != null) {
            registration.setExcuseReason(request.getExcuseReason());
        }

        if (request.getExcuseNote() != null) {
            registration.setExcuseNote(request.getExcuseNote());
        }
    }

    /*
     společný pro všechny přechody, kde nechceme zachovat omluvu
     */
    private void clearExcuseIfNeeded(MatchRegistrationEntity registration) {
        if (registration == null) {
            return;
        }
        if (registration.getExcuseReason() != null || registration.getExcuseNote() != null) {
            registration.setExcuseReason(null);
            registration.setExcuseNote(null);
        }
    }

    /**
     * Vrátí všechny registrace pro daný zápas.
     * <p>
     * Pokud zápas nepatří do aktuálně vybrané sezóny (currentSeason/active),
     * vrací prázdný seznam.
     * </p>
     */
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);

        if (!isMatchInCurrentSeason(match)) {
            // Zápas je mimo currentSeason – pro účely přehledů vracíme prázdný seznam
            return List.of();
        }

        return matchRegistrationMapper.toDTOList(
                registrationRepository.findByMatchId(matchId)
        );
    }

    /**
     * Vrátí všechny registrace pro zadané zápasy,
     * omezené na aktuálně vybranou sezónu.
     *
     * <p>
     * Pokud je seznam ID prázdný nebo {@code null}, vrací prázdný seznam.
     * </p>
     */
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatches(List<Long> matchIds) {
        if (matchIds == null || matchIds.isEmpty()) {
            return List.of();
        }

        List<MatchRegistrationEntity> regsInSeason = registrationRepository
                .findByMatchIdIn(matchIds).stream()
                .filter(this::isRegistrationInCurrentSeason)
                .toList();

        return matchRegistrationMapper.toDTOList(regsInSeason);
    }

    /**
     * Vrátí všechny registrace v systému
     * omezené na aktuálně vybranou sezónu.
     */
    @Override
    public List<MatchRegistrationDTO> getAllRegistrations() {
        List<MatchRegistrationEntity> regsInSeason = registrationRepository
                .findAll().stream()
                .filter(this::isRegistrationInCurrentSeason)
                .toList();

        return matchRegistrationMapper.toDTOList(regsInSeason);
    }

    /**
     * Vrátí všechny registrace konkrétního hráče
     * omezené na aktuálně vybranou sezónu.
     */
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId) {
        List<MatchRegistrationEntity> regsInSeason = registrationRepository
                .findByPlayerId(playerId).stream()
                .filter(this::isRegistrationInCurrentSeason)
                .toList();

        return matchRegistrationMapper.toDTOList(regsInSeason);
    }

    /**
     * Vrátí hráče, kteří na daný zápas nijak nereagovali
     * (nemají žádnou registraci bez ohledu na status).
     *
     * <p>
     * Pokud zápas nepatří do aktuálně vybrané sezóny,
     * vrací prázdný seznam.
     * </p>
     */
    @Override
    public List<PlayerDTO> getNoResponsePlayers(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);

        if (!isMatchInCurrentSeason(match)) {
            return List.of();
        }

        Set<Long> respondedIds = getRespondedPlayerIds(matchId);

        List<PlayerEntity> noResponsePlayers = playerRepository.findAll().stream()
                .filter(p -> !respondedIds.contains(p.getId()))
                .toList();

        return noResponsePlayers.stream()
                .map(playerMapper::toDTO)
                .toList();
    }
    /**
     * Přepočítá statusy REGISTERED/RESERVED pro daný zápas.
     * <p>
     * Postup:
     * <ul>
     *     <li>vybere registrace se statusem REGISTERED/RESERVED,</li>
     *     <li>seřadí je podle timestampu,</li>
     *     <li>prvních maxPlayers nastaví na REGISTERED, ostatní na RESERVED.</li>
     * </ul>
     * <p>
     * Příklad:
     * <pre>
     * maxPlayers = 10
     * 15 hráčů má status REGISTERED/RESERVED
     * → prvních 10 = REGISTERED, zbylých 5 = RESERVED
     * </pre>
     */
    @Override
    @Transactional
    public void recalcStatusesForMatch(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);
        int maxPlayers = match.getMaxPlayers();

        List<MatchRegistrationEntity> regs = registrationRepository.findByMatchId(matchId).stream()
                // do auto-přepočtu jdou pouze REGISTERED/RESERVED,
                // SUBSTITUTE (možná) se ignoruje – neblokuje místo ani frontu
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED
                        || r.getStatus() == PlayerMatchStatus.RESERVED)
                .sorted((a, b) -> a.getTimestamp().compareTo(b.getTimestamp()))
                .toList();

        for (int i = 0; i < regs.size(); i++) {
            MatchRegistrationEntity reg = regs.get(i);
            PlayerMatchStatus newStatus =
                    (i < maxPlayers) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;

            if (reg.getStatus() != newStatus) {
                updateRegistrationStatus(reg, newStatus, "system", false);
            }
        }
    }

    // =========================
    // SMS – HROMADNÉ ODESÍLÁNÍ
    // =========================

    /**
     * Odešle SMS všem hráčům, kteří jsou REGISTERED na daný zápas
     * a mají povolené SMS notifikace.
     */
    @Transactional
    public void sendSmsToRegisteredPlayers(Long matchId) {
        registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .forEach(r -> {
                    PlayerEntity player = r.getPlayer();
                    if (player == null) {
                        return;
                    }

                    var settings = player.getSettings();
                    // pokud nemá settings nebo má SMS vypnuté → nic neposíláme
                    if (settings == null || !settings.isSmsEnabled()) {
                        return;
                    }

                    // samotné odeslání (pomocí helperu níž)
                    sendSms(r, smsMessageBuilder.buildMessageFinal(r));
                });
    }

    /**
     * Odešle připomínkovou SMS všem hráčům, kteří na zápas nijak nereagovali
     * (NO_RESPONSE) a mají povolené SMS notifikace.
     */
    /**
     * public void sendNoResponseSmsForMatch(Long matchId) {
     * var match = getMatchOrThrow(matchId);
     * <p>
     * getNoResponsePlayers(matchId).forEach(player -> {
     * String smsMsg = smsMessageBuilder.buildMessageNoResponse(player, match);
     * <p>
     * try {
     * if (player.isNotifyBySms()) {
     * smsService.sendSms(player.getPhoneNumber(), smsMsg);
     * }
     * } catch (Exception e) {
     * log.error(
     * "Chyba při odesílání SMS hráči {} ({}) pro zápas {}: {}",
     * player.getFullName(),
     * player.getPhoneNumber(),
     * matchId,
     * e.getMessage(),
     * e
     * );
     * }
     * });
     * }
     * /*


     * <p>
     * // ================================================
     * // ADMIN – RUČNÍ ZMĚNA STATUSU / NO_EXCUSED LOGIKA
     * // ================================================
     * <p>
     * /**
     * Obecná admin operace pro změnu statusu registrace hráče na zápas.
     * <p>
     * Nepovoluje nastavení statusu NO_EXCUSED – ten má vlastní logiku.
     *
     * @param matchId  ID zápasu
     * @param playerId ID hráče
     * @param status   cílový status (mimo NO_EXCUSED)
     * @return DTO aktualizované registrace
     */
    @Override
    @Transactional
    public MatchRegistrationDTO updateStatus(Long matchId, Long playerId, PlayerMatchStatus status) {

        getMatchOrThrow(matchId);
        getPlayerOrThrow(playerId);

        if (status == PlayerMatchStatus.NO_EXCUSED) {
            throw new InvalidPlayerStatusException(
                    "BE - Status NO_EXCUSED musí být nastaven přes speciální endpoint / logiku."
            );
        }

        MatchRegistrationEntity registration = getRegistrationOrThrow(playerId, matchId);

        MatchRegistrationEntity updated =
                updateRegistrationStatus(registration, status, "admin", true);

        return matchRegistrationMapper.toDTO(updated);
    }


    // ====================================================
    // PRIVÁTNÍ HELPERY – NAČÍTÁNÍ ENTIT A ZÁKLADNÍ LOGIKA
    // ====================================================
    //TODO - možná změnit Object context na MatchRegistrationEntity entity
    private void notifyPlayer(PlayerEntity player, NotificationType type, Object context) {
        notificationService.notifyPlayer(player, type, context);
    }

    /**
     * Vrátí množinu ID hráčů, kteří mají k zápasu nějakou registraci.
     */
    private Set<Long> getRespondedPlayerIds(Long matchId) {
        return registrationRepository.findByMatchId(matchId).stream()
                .map(r -> r.getPlayer().getId())
                .collect(Collectors.toSet());
    }

    /**
     * Najde zápas podle ID nebo vyhodí {@link MatchNotFoundException}.
     */
    private MatchEntity getMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }

    /**
     * Najde hráče podle ID nebo vyhodí {@link PlayerNotFoundException}.
     */
    private PlayerEntity getPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    /**
     * Vrátí registraci hráče na zápas, pokud existuje, jinak {@code null}.
     */
    private MatchRegistrationEntity getRegistrationOrNull(Long playerId, Long matchId) {
        return registrationRepository
                .findByPlayerIdAndMatchId(playerId, matchId)
                .orElse(null);
    }

    /**
     * Vrátí registraci hráče na zápas, pokud existuje,
     * jinak vyhodí {@link RegistrationNotFoundException}.
     */
    private MatchRegistrationEntity getRegistrationOrThrow(Long playerId, Long matchId) {
        return registrationRepository
                .findByPlayerIdAndMatchId(playerId, matchId)
                .orElseThrow(() -> new RegistrationNotFoundException(matchId, playerId));
    }

    /**
     * Zjistí, zda je ve zápase ještě volné místo pro status REGISTERED.
     */
    private boolean isSlotAvailable(MatchEntity match) {
        long registeredCount = registrationRepository
                .countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);
        return registeredCount < match.getMaxPlayers();
    }

    // TODO - ŘEŠENO NOTIFIKACEMI - ASI SMAZAT
    /**
     * Bezpečně odešle SMS hráči z registrace.
     * <p>
     * Pokud je registrace nebo hráč null, nic neudělá.
     * Chyby při odesílání pouze zaloguje.
     */
    private void sendSms(MatchRegistrationEntity registration, String message) {
        if (registration == null || registration.getPlayer() == null) {
            return;
        }

        PlayerEntity player = registration.getPlayer();
        var settings = player.getSettings();

        // 1) upřednostni contactPhone z PlayerSettings
        String phone = null;
        if (settings != null && settings.getContactPhone() != null && !settings.getContactPhone().isBlank()) {
            phone = settings.getContactPhone();
        } else if (player.getPhoneNumber() != null && !player.getPhoneNumber().isBlank()) {
            // 2) fallback – telefon přímo na hráči
            phone = player.getPhoneNumber();
        }

        if (phone == null || phone.isBlank()) {
            log.debug("sendSms: hráč {} nemá žádné telefonní číslo – SMS se nepošle", player.getId());
            return;
        }

        try {
            smsService.sendSms(phone, message);
        } catch (Exception e) {
            log.error(
                    "Chyba při odesílání SMS pro registraci {}: {}",
                    registration.getId(),
                    e.getMessage(),
                    e
            );
        }
    }


    /**
     * Společná metoda pro změnu statusu registrace.
     *
     * @param registration    registrace ke změně
     * @param status          nový status
     * @param updatedBy       kdo změnu provedl (user/admin/system)
     * @param updateTimestamp zda přepsat timestamp na aktuální čas
     */
    private MatchRegistrationEntity updateRegistrationStatus(
            MatchRegistrationEntity registration,
            PlayerMatchStatus status,
            String updatedBy,
            boolean updateTimestamp
    ) {
        registration.setStatus(status);
        registration.setCreatedBy(updatedBy);
        if (updateTimestamp) {
            registration.setTimestamp(LocalDateTime.now());
        }
        return registrationRepository.saveAndFlush(registration);
    }

    /**
     * Převede výsledný {@link PlayerMatchStatus} na typ notifikace.
     *
     * @return odpovídající {@link NotificationType}, nebo {@code null},
     * pokud se pro daný status notifikace neposílá
     */
    private NotificationType resolveNotificationType(PlayerMatchStatus newStatus) {
        return switch (newStatus) {
            case REGISTERED -> NotificationType.MATCH_REGISTRATION_CREATED;
            case UNREGISTERED -> NotificationType.MATCH_REGISTRATION_CANCELED;
            case EXCUSED -> NotificationType.PLAYER_EXCUSED;
            case RESERVED -> NotificationType.MATCH_REGISTRATION_RESERVED;
            case NO_RESPONSE -> NotificationType.MATCH_REGISTRATION_NO_RESPONSE;
            case SUBSTITUTE -> NotificationType.MATCH_REGISTRATION_SUBSTITUTE;
            case NO_EXCUSED -> NotificationType.PLAYER_NO_EXCUSED;
            default -> null;
        };
    }

    /**
     * Pomocná metoda pro získání aktuálního času.
     * <p>
     * Odděleno kvůli lepší testovatelnosti.
     */
    private LocalDateTime now() {
        return LocalDateTime.now();
    }

    /**
     * Ověří, že zápas patří do aktivní sezóny.
     * <p>
     * Používá se před zápisem (upsert registrace), aby hráči nemohli
     * měnit registrace v neaktivních sezónách.
     */
    private void assertMatchInActiveSeason(MatchEntity match) {
        if (match.getSeason() == null || !match.getSeason().isActive()) {
            // InvalidSeasonStateException už v projektu máš (používáš ji v SeasonService),
            // případně si sem můžeš doplnit vlastní zprávu/typ výjimky.
            throw new InvalidSeasonStateException(
                    "BE - Registrace lze měnit pouze u zápasů v aktivní sezóně."
            );
        }
    }

    /**
     * Ověří, zda aktuálně přihlášený uživatel může měnit
     * registraci na daný zápas.
     *
     * <p>
     * Pravidla:
     * <ul>
     *     <li>uživatel s rolí ADMIN / MANAGER není časově omezen,</li>
     *     <li>uživatel s rolí PLAYER může měnit registraci pouze
     *         do 30 minut po začátku zápasu.</li>
     * </ul>
     * </p>
     *
     * @param match zápas, pro který se registrace mění
     * @throws InvalidPlayerStatusException pokud hráč překročil
     *                                      povolené časové okno pro změnu registrace
     */
    private void assertPlayerCanModifyMatch(MatchEntity match) {
        if (!isCurrentUserPlayer()) {
            // Admin / manager – žádné časové omezení
            return;
        }

        if (!isMatchEditableForPlayer(match)) {
            throw new InvalidPlayerStatusException(
                    "BE - Jako hráč můžeš měnit registraci pouze do 30 minut po začátku zápasu."
            );
        }
    }

    /**
     * Zjistí, zda je zápas ještě v časovém okně,
     * ve kterém může hráč (ROLE_PLAYER) upravovat svou registraci.
     *
     * <p>
     * Logika:
     * <pre>
     * now() &lt; match.dateTime + 30 minut
     * </pre>
     * <p>
     * Tzn.:
     * <ul>
     *     <li>před zápasem → povoleno,</li>
     *     <li>během zápasu → povoleno do 30. minuty,</li>
     *     <li>30+ minut po začátku zápasu → zakázáno.</li>
     * </ul>
     * </p>
     *
     * @param match zápas, ke kterému se vztahuje registrace
     * @return {@code true}, pokud je změna registrace ještě povolena
     */
    private boolean isMatchEditableForPlayer(MatchEntity match) {
        LocalDateTime editLimit = match.getDateTime().plusMinutes(30);
        return now().isBefore(editLimit);
    }

    /**
     * Zjistí, zda má aktuálně přihlášený uživatel roli {@code ROLE_PLAYER}.
     *
     * <p>
     * Používá se pro rozlišení chování:
     * <ul>
     *     <li>ROLE_PLAYER – omezené časem zápasu,</li>
     *     <li>ostatní role (ADMIN, MANAGER) – bez časového omezení.</li>
     * </ul>
     * </p>
     *
     * @return {@code true}, pokud má uživatel roli PLAYER,
     * jinak {@code false}
     */
    private boolean isCurrentUserPlayer() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth == null) {
            return false;
        }

        return auth.getAuthorities().stream()
                .anyMatch(a -> "ROLE_PLAYER".equals(a.getAuthority()));
    }

    // ======================================
    // SEASON – POMOCNÉ METODY PRO CURRENT SEASON
    // ======================================

    /**
     * Zjistí, zda daný zápas patří do aktuálně vybrané sezóny
     * (currentSeason z {@link CurrentSeasonService} nebo aktivní sezóny).
     *
     * @param match zápas, který se kontroluje
     * @return {@code true}, pokud má zápas sezónu shodnou
     * s hodnotou {@link #getCurrentSeasonIdOrActive()},
     * jinak {@code false}
     */
    private boolean isMatchInCurrentSeason(MatchEntity match) {
        if (match == null || match.getSeason() == null) {
            return false;
        }
        Long seasonId = getCurrentSeasonIdOrActive();
        return seasonId.equals(match.getSeason().getId());
    }

    /**
     * Zjistí, zda daná registrace patří k zápasu v aktuálně vybrané sezóně.
     *
     * @param registration registrace, která se kontroluje
     * @return {@code true}, pokud je registrace navázaná na zápas,
     * jehož sezóna odpovídá {@link #getCurrentSeasonIdOrActive()},
     * jinak {@code false}
     */
    private boolean isRegistrationInCurrentSeason(MatchRegistrationEntity registration) {
        if (registration == null) {
            return false;
        }
        return isMatchInCurrentSeason(registration.getMatch());
    }

    /**
     * Vrátí ID sezóny, která se má použít pro filtrování registrací.
     *
     * <p>
     * Postup:
     * <ul>
     *     <li>nejprve se pokusí použít uživatelem zvolenou currentSeason
     *         (uloženou v {@link CurrentSeasonService}),</li>
     *     <li>pokud není k dispozici, spadne na globálně aktivní sezónu
     *         {@link SeasonService#getActiveSeason()}.</li>
     * </ul>
     * </p>
     *
     * @return ID aktuální (uživatelské) nebo aktivní sezóny
     */
    private Long getCurrentSeasonIdOrActive() {
        Long id = currentSeasonService.getCurrentSeasonIdOrDefault();
        if (id != null) {
            return id;
        }
        return seasonService.getActiveSeason().getId();
    }

}


-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.enums.MatchCancelReason;
import cz.phsoft.hokej.models.dto.*;

import java.util.List;

/**
 * Rozhraní pro správu zápasů v aplikaci.
 * <p>
 * Definuje kontrakt pro práci se zápasy z pohledu business logiky –
 * vytváření, úpravu, mazání, získávání přehledů a práci s dostupností
 * pro konkrétního hráče.
 * </p>
 *
 * Účel:
 * <ul>
 *     <li>poskytnout jednotný vstupní bod pro práci se zápasy,</li>
 *     <li>oddělit business logiku zápasů od persistence vrstvy,</li>
 *     <li>nabídnout specializované přehledy pro hráče i administraci.</li>
 * </ul>
 *
 * Použití:
 * <ul>
 *     <li>využívá se v controllerech a plánovačích (scheduler),</li>
 *     <li>pracuje výhradně s DTO objekty pro přenos dat.</li>
 * </ul>
 */
public interface MatchService {

    /**
     * Vrátí seznam všech zápasů v systému.
     * <p>
     * Metoda typicky slouží pro administrátorské přehledy
     * nebo globální seznam zápasů.
     * </p>
     *
     * @return seznam všech zápasů ve formě {@link MatchDTO}
     */
    List<MatchDTO> getAllMatches();

    /**
     * Vrátí seznam všech nadcházejících zápasů.
     * <p>
     * Nadcházející zápasy jsou ty, které mají datum v budoucnosti
     * (podle interně zvolené definice – např. datum/čas &gt;= nyní).
     * </p>
     *
     * @return seznam nadcházejících zápasů
     */
    List<MatchDTO> getUpcomingMatches();

    /**
     * Vrátí seznam všech již odehraných zápasů.
     *
     * @return seznam minulých zápasů
     */
    List<MatchDTO> getPastMatches();

    /**
     * Vrátí nejbližší nadcházející zápas.
     * <p>
     * Typicky se používá pro rychlé zobrazení „dalšího zápasu“
     * na dashboardu nebo v notifikacích.
     * </p>
     *
     * @return nejbližší nadcházející zápas nebo {@code null},
     *         pokud žádný neexistuje
     */
    MatchDTO getNextMatch();

    /**
     * Vrátí detail zápasu podle jeho ID.
     *
     * @param id ID zápasu
     * @return zápas ve formě {@link MatchDTO}
     */
    MatchDTO getMatchById(Long id);

    /**
     * Vytvoří nový zápas.
     * <p>
     * Metoda typicky dostupná pouze pro administrátory / manažery.
     * </p>
     *
     * @param dto data nového zápasu
     * @return vytvořený zápas
     */
    MatchDTO createMatch(MatchDTO dto);

    /**
     * Aktualizuje existující zápas.
     *
     * @param id  ID zápasu, který má být upraven
     * @param dto nové hodnoty pro zápas
     * @return aktualizovaný zápas
     */
    MatchDTO updateMatch(Long id, MatchDTO dto);

    /**
     * Smaže zápas podle ID.
     * <p>
     * Typicky vrací informaci o úspěchu operace
     * ve formě {@link SuccessResponseDTO}.
     * </p>
     *
     * @param id ID zápasu, který má být smazán
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO deleteMatch(Long id);

    /**
     * Vrátí detailní informace o zápasu.
     * <p>
     * Na rozdíl od {@link #getMatchById(Long)} může obsahovat
     * rozšířené informace (např. registrace, statistiky, atd.).
     * </p>
     *
     * @param id ID zápasu
     * @return detail zápasu
     */
    MatchDetailDTO getMatchDetail(Long id);

    /**
     * Vrátí seznam zápasů, na které se daný hráč může registrovat.
     * <p>
     * Typicky filtruje:
     * </p>
     * <ul>
     *     <li>pouze nadcházející zápasy,</li>
     *     <li>zápasy, kde ještě není plná kapacita,</li>
     *     <li>zápasy v rámci povolené sezóny / pravidel.</li>
     * </ul>
     *
     * @param playerId ID hráče
     * @return seznam dostupných zápasů pro hráče
     */
    List<MatchDTO> getAvailableMatchesForPlayer(Long playerId);

    /**
     * Vrátí nadcházející zápasy pro konkrétního hráče.
     * <p>
     * Může zahrnovat:
     * </p>
     * <ul>
     *     <li>zápasy, na které je hráč přihlášen,</li>
     *     <li>případně další omezené podle business pravidel.</li>
     * </ul>
     *
     * @param playerId ID hráče
     * @return seznam nadcházejících zápasů pro daného hráče
     */
    List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId);

    /**
     * Najde ID hráče podle emailu uživatele.
     * <p>
     * Pomocná metoda pro případy, kdy je k dispozici email
     * přihlášeného uživatele a je potřeba zjistit navázaného hráče.
     * </p>
     *
     * @param email email uživatele
     * @return ID hráče nebo {@code null}, pokud neexistuje
     */
    Long getPlayerIdByEmail(String email);

    /**
     * Vrátí přehled nadcházejících zápasů pro hráče.
     * <p>
     * Na rozdíl od {@link #getUpcomingMatchesForPlayer(Long)} může
     * poskytovat zjednodušený nebo agregovaný pohled (overview)
     * vhodný pro seznamy a dashboardy.
     * </p>
     *
     * @param playerId ID hráče
     * @return přehled nadcházejících zápasů pro daného hráče
     */
    List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId);

    /**
     * Vrátí přehled všech odehraných zápasů pro hráče.
     * <p>
     * Využívá se pro statistiky, historii účasti a přehled
     * minulých zápasů daného hráče.
     * </p>
     *
     * @param playerId ID hráče
     * @return přehled všech odehraných zápasů pro daného hráče
     */
    List<MatchOverviewDTO> getAllPassedMatchesForPlayer(Long playerId);

    /**
     * Zruší zápas a nastaví důvod zrušení.
     * <p>
     * Zápas je označen jako zrušený s uvedeným důvodem.
     * Implementace může navazovat další logiku
     * (např. notifikace hráčů).
     * </p>
     *
     * @param matchId ID zápasu
     * @param reason  důvod zrušení
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO cancelMatch(Long matchId, MatchCancelReason reason);

    /**
     * Obnoví dříve zrušený zápas.
     * <p>
     * Zápas se vrátí do stavu, kdy je opět platný a může se konat,
     * pokud to dovolují ostatní podmínky (např. datum, kapacita).
     * </p>
     *
     * @param matchId ID zápasu
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO unCancelMatch(Long matchId);

}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchServiceImpl.java
-----

package cz.phsoft.hokej.models.services;


import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.*;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.models.dto.*;
import cz.phsoft.hokej.models.mappers.MatchMapper;
import cz.phsoft.hokej.models.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.notification.NotificationService;
import cz.phsoft.hokej.models.services.notification.MatchTimeChangeContext;

import jakarta.transaction.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;


import java.time.LocalDateTime;
import java.util.*;

import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Service vrstva pro práci se zápasy.
 * <p>
 * Odpovědnosti:
 * <ul>
 *     <li>CRUD nad zápasy v rámci aktivní sezóny,</li>
 *     <li>filtrování zápasů podle data a typu hráče (VIP/STANDARD/BASIC),</li>
 *     <li>výpočet detailních statistik k zápasu (MatchDetailDTO),</li>
 *     <li>přístupová logika k detailu zápasu (hráč vs admin/manager),</li>
 *     <li>přehledy zápasů pro konkrétního hráče (overview),</li>
 *     <li>rušení a obnovení zápasů (CANCELLED / uncancel).</li>
 * </ul>
 * <p>
 * Tato service:
 * <ul>
 *     <li>neřeší registrace (detailní stav hráče) – to řeší {@link MatchRegistrationService},</li>
 *     <li>neřeší výběr aktuálního hráče – to řeší {@link CurrentPlayerService} a controller.</li>
 * </ul>
 */
@Service
public class MatchServiceImpl implements MatchService {

    private static final Logger logger = LoggerFactory.getLogger(MatchServiceImpl.class);

    private static final String ROLE_ADMIN = "ROLE_ADMIN";
    private static final String ROLE_MANAGER = "ROLE_MANAGER";

    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository matchRegistrationRepository;
    private final MatchMapper matchMapper;
    private final MatchRegistrationService registrationService;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodService playerInactivityPeriodService;
    private final PlayerMapper playerMapper;
    private final CurrentPlayerService currentPlayerService;
    private final SeasonService seasonService;
    private final CurrentSeasonService currentSeasonService;
    private final NotificationService notificationService;


    public MatchServiceImpl(MatchRepository matchRepository,
                            MatchRegistrationRepository matchRegistrationRepository,
                            MatchMapper matchMapper,
                            MatchRegistrationService registrationService,
                            PlayerRepository playerRepository,
                            PlayerInactivityPeriodService playerInactivityPeriodService,
                            PlayerMapper playerMapper,
                            CurrentPlayerService currentPlayerService,
                            SeasonService seasonService,
                            CurrentSeasonService currentSeasonService,
                            NotificationService notificationService) {
        this.matchRepository = matchRepository;
        this.matchRegistrationRepository = matchRegistrationRepository;
        this.matchMapper = matchMapper;
        this.registrationService = registrationService;
        this.playerRepository = playerRepository;
        this.playerInactivityPeriodService = playerInactivityPeriodService;
        this.playerMapper = playerMapper;
        this.currentPlayerService = currentPlayerService;
        this.seasonService = seasonService;
        this.currentSeasonService = currentSeasonService;
        this.notificationService = notificationService;
    }

    // ======================
    // ZÁKLADNÍ SEZNAMY ZÁPASŮ
    // ======================

    /**
     * Vrátí všechny zápasy v rámci aktivní sezóny
     * seřazené podle data vzestupně.
     */
    @Override
    public List<MatchDTO> getAllMatches() {
        Long seasonId = getCurrentSeasonIdOrActive();
        List<MatchEntity> matches =
                matchRepository.findAllBySeasonIdOrderByDateTimeAsc(seasonId);

        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);
        return assignMatchNumbers(matches, matchMapper::toDTO, matchNumberMap);
    }

    /**
     * Vrátí všechny nadcházející zápasy v aktivní sezóně
     * (datum > aktuální čas), seřazené podle data vzestupně.
     */
    @Override
    public List<MatchDTO> getUpcomingMatches() {
        Long seasonId = getCurrentSeasonIdOrActive();
        List<MatchEntity> upcomingMatches = findUpcomingMatchesForCurrentSeason();

        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);
        return assignMatchNumbers(upcomingMatches, matchMapper::toDTO, matchNumberMap);
    }

    /**
     * Vrátí všechny již proběhlé zápasy v aktivní sezóně
     * (datum < aktuální čas), seřazené podle data sestupně
     * (nejnovější první).
     */
    @Override
    public List<MatchDTO> getPastMatches() {
        Long seasonId = getCurrentSeasonIdOrActive();
        List<MatchEntity> pastMatches = findPastMatchesForCurrentSeason();

        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);
        return assignMatchNumbers(pastMatches, matchMapper::toDTO, matchNumberMap);
    }

    /**
     * Vrátí nejbližší nadcházející zápas v aktivní sezóně
     * nebo {@code null}, pokud žádný neexistuje.
     */
    @Override
    public MatchDTO getNextMatch() {
        return findUpcomingMatchesForCurrentSeason()
                .stream()
                .findFirst()
                .map(matchMapper::toDTO)
                .orElse(null);
    }

    /**
     * Vrátí konkrétní zápas podle ID.
     *
     * @throws MatchNotFoundException pokud zápas neexistuje
     */
    @Override
    public MatchDTO getMatchById(Long id) {
        return matchMapper.toDTO(findMatchOrThrow(id));
    }

    /**
     * Vytvoří nový zápas.
     * <ul>
     *     <li>namapuje DTO na entitu,</li>
     *     <li>ověří, že datum zápasu spadá do aktivní sezóny,</li>
     *     <li>přiřadí aktivní sezónu,</li>
     *     <li>uloží zápas a vrátí DTO.</li>
     * </ul>
     */
    @Override
    public MatchDTO createMatch(MatchDTO dto) {
        MatchEntity entity = matchMapper.toEntity(dto);
        validateMatchDateInActiveSeason(entity.getDateTime());

        entity.setSeason(seasonService.getActiveSeason());

        return matchMapper.toDTO(matchRepository.save(entity));
    }

    /**
     * Aktualizuje existující zápas.
     * <ul>
     *     <li>ověří, že zápas patří do aktivní sezóny,</li>
     *     <li>přenese změny z DTO do entity,</li>
     *     <li>znovu zvaliduje datum v rámci aktivní sezóny,</li>
     *     <li>uloží změny,</li>
     *     <li>pokud se změnil maxPlayers, přepočítá REGISTERED/RESERVED.</li>
     * </ul>
     *
     * @throws InvalidMatchStatusException pokud zápas nepatří do aktivní sezóny
     */
    @Override
    public MatchDTO updateMatch(Long id, MatchDTO dto) {
        MatchEntity entity = findMatchOrThrow(id);

        // zjistíme roli uživatele
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        boolean isAdminOrManager = hasAdminOrManagerRole(auth);

        // Kontrola sezóny jen pro "běžné" uživatele (kdyby se tahle metoda někdy použila i pro ně)
        if (!isAdminOrManager) {
            Long activeSeasonId = seasonService.getActiveSeason().getId();
            if (!entity.getSeason().getId().equals(activeSeasonId)) {
                throw new InvalidMatchStatusException(
                        id, " - Zápas nepatří do aktuální sezóny, nelze ho upravit."
                );
            }
        }

        int oldMaxPlayers = entity.getMaxPlayers();
        LocalDateTime oldDateTime = entity.getDateTime();

        matchMapper.updateEntity(dto, entity);

        // validace data v aktivní sezóně jen pro ne-adminy
        if (!isAdminOrManager) {
            validateMatchDateInActiveSeason(entity.getDateTime());
        }

        MatchEntity saved = matchRepository.save(entity);
        //pokud se změnil maxPlayers, přepočet REGISTERED/RESERVED
        if (saved.getMaxPlayers() != oldMaxPlayers) {
            registrationService.recalcStatusesForMatch(saved.getId());
        }
        // pokud se změnilo datum nebo čas - MATCH_TIME_CHANGED
        if (saved.getDateTime().isBefore(LocalDateTime.now())) {
            throw new InvalidMatchDateTimeException("Zápas by již byl minulostí");
        }
        MatchStatus matchStatus = saved.getMatchStatus();
        boolean dateTimeChanged = !saved.getDateTime().isEqual(oldDateTime);

        if (dateTimeChanged) {
            // vytvoří context se starým datem/časem
            MatchTimeChangeContext ctx = new MatchTimeChangeContext(saved, oldDateTime);
            notifyPlayersAboutMatchChanges(ctx, MatchStatus.UPDATED);
        }

        return matchMapper.toDTO(saved);
    }

    /**
     * Smaže zápas podle ID.
     * <p>
     * Pokud zápas neexistuje, vyhodí {@link MatchNotFoundException}.
     *
     * @return {@link SuccessResponseDTO} s potvrzením smazání
     */
    @Override
    public SuccessResponseDTO deleteMatch(Long id) {
        MatchEntity match = findMatchOrThrow(id);
        matchRepository.delete(match);

        return new SuccessResponseDTO(
                "BE - Zápas " + match.getId() + match.getDateTime() + " byl úspěšně smazán",
                id,
                LocalDateTime.now().toString()
        );
    }

    /**
     * Zruší zápas s uvedeným důvodem.
     * <ul>
     *     <li>nastaví MatchStatus.CANCELLED,</li>
     *     <li>uloží důvod zrušení,</li>
     *     <li>pokud je již zrušen, vyhodí InvalidMatchStatusException.</li>
     * </ul>
     */
    @Override
    @Transactional
    public SuccessResponseDTO cancelMatch(Long matchId, MatchCancelReason reason) {
        MatchEntity match = findMatchOrThrow(matchId);
        String message = " je již zrušen";

        if (match.getMatchStatus() == MatchStatus.CANCELLED) {
            throw new InvalidMatchStatusException(matchId, message);
        }


        match.setMatchStatus(MatchStatus.CANCELLED);
        match.setCancelReason(reason);

        MatchEntity saved = matchRepository.save(match);
        notifyPlayersAboutMatchChanges(saved, MatchStatus.CANCELLED);

        return new SuccessResponseDTO(
                "BE - Zápas " + match.getId() + match.getDateTime() + " byl úspěšně zrušen",
                match.getId(),
                LocalDateTime.now().toString()
        );
    }

    /**
     * Obnoví dříve zrušený zápas.
     * <ul>
     *     <li>MatchStatus nastaví na null,</li>
     *     <li>cancelReason nastaví na null,</li>
     *     <li>pokud zápas nebyl zrušen, vyhodí InvalidMatchStatusException.</li>
     * </ul>
     */
    @Override
    @Transactional
    public SuccessResponseDTO unCancelMatch(Long matchId) {
        MatchEntity match = findMatchOrThrow(matchId);
        String message = " ještě nebyl zrušen";

        if (match.getMatchStatus() != MatchStatus.CANCELLED) {
            throw new InvalidMatchStatusException(matchId, message);
        }

        match.setMatchStatus(null);
        match.setCancelReason(null);

        return new SuccessResponseDTO(
                "BE - Zápas " + match.getId() + match.getDateTime() + " byl úspěšně obnoven",
                match.getId(),
                LocalDateTime.now().toString()
        );
    }

    // ======================
    // POMOCNÉ METODY – ENTITY
    // ======================


    // ======================
    // DETAIL ZÁPASU
    // ======================

    /**
     * Vrátí detail zápasu (MatchDetailDTO) včetně:
     * <ul>
     *     <li>seskupení hráčů podle statusu (REGISTERED/RESERVED/EXCUSED/...),</li>
     *     <li>počtů hráčů v zápase, mimo zápas, náhradníků, NO_EXCUSED, NO_RESPONSE,</li>
     *     <li>ceny na registrovaného hráče,</li>
     *     <li>stavu zápasu (MatchStatus + důvod zrušení),</li>
     *     <li>stavu aktuálního hráče (PlayerMatchStatus) a jeho omluvy.</li>
     * </ul>
     * <p>
     * Obsahuje i přístupovou logiku:
     * <ul>
     *     <li>ADMIN/MANAGER vidí vždy,</li>
     *     <li>běžný uživatel:
     *          <ul>
     *              <li>nadcházející zápas → musí mít aktivního hráče k datu zápasu,</li>
     *              <li>proběhlý zápas → některý jeho hráč musel být REGISTERED.</li>
     *          </ul>
     *     </li>
     * </ul>
     */
    @Override
    public MatchDetailDTO getMatchDetail(Long id) {
        MatchEntity match = findMatchOrThrow(id);

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        boolean isAdminOrManager = hasAdminOrManagerRole(auth);

        // 1) přístupová logika
        checkAccessForPlayer(match, auth);

        // 2) sběr statistik a stavů hráčů
        MatchDetailDTO dto = collectPlayerStatus(match, isAdminOrManager);

        // 3) stav aktuálního hráče (pokud je zvolen)
        Long currentPlayerId = null;
        try {
            currentPlayerId = currentPlayerService.getCurrentPlayerId();
        } catch (Exception e) {
            logger.debug("Nebyl nalezen currentPlayerId pro match detail {}", id);
        }

        PlayerMatchStatus playerMatchStatus = resolveStatusForPlayer(dto, currentPlayerId);
        dto.setPlayerMatchStatus(playerMatchStatus);

        // 4) omluva aktuálního hráče (pokud existuje registrace)
        if (currentPlayerId != null) {
            matchRegistrationRepository.findByPlayerIdAndMatchId(currentPlayerId, match.getId())
                    .ifPresent(reg -> {
                        dto.setExcuseReason(reg.getExcuseReason());
                        dto.setExcuseNote(reg.getExcuseNote());
                    });
        } else {
            dto.setExcuseReason(null);
            dto.setExcuseNote(null);
        }

        // 5) stav zápasu
        dto.setMatchStatus(match.getMatchStatus());
        dto.setCancelReason(match.getCancelReason());

        // 6) číslo zápasu v sezóně podle globálního pořadí v sezóně   
        if (match.getSeason() != null && match.getSeason().getId() != null) {
            Long seasonId = match.getSeason().getId();
            Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);
            Integer number = matchNumberMap.get(match.getId());
            dto.setMatchNumber(number);
        }

        return dto;
    }

    // --------------------------------------------------
    // Přístupová logika – kdo smí vidět detail zápasu
    // --------------------------------------------------

    /**
     * Ověří, zda má aktuální uživatel přístup k detailu zápasu.
     * <ul>
     *     <li>nepřihlášený → AccessDenied,</li>
     *     <li>ADMIN/MANAGER → vždy povoleno,</li>
     *     <li>běžný uživatel:
     *         <ul>
     *             <li>získá své hráče (ownedPlayers) podle emailu,</li>
     *             <li>bez hráčů → AccessDenied,</li>
     *             <li>nadcházející zápas → musí mít aktivního hráče k datu zápasu,</li>
     *             <li>uplynulý zápas → jeho hráč musel být REGISTERED.</li>
     *         </ul>
     *     </li>
     * </ul>
     *
     * @throws org.springframework.security.access.AccessDeniedException pokud uživatel nesplňuje podmínky
     */
    private void checkAccessForPlayer(MatchEntity match, Authentication auth) {
        if (auth == null || !auth.isAuthenticated()) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - Musíte být přihlášen."
            );
        }

        boolean isAdminOrManager = hasAdminOrManagerRole(auth);
        if (isAdminOrManager) {
            return;
        }

        Long currentSeasonId = getCurrentSeasonIdOrActive();
        if (match.getSeason() == null || !match.getSeason().getId().equals(currentSeasonId)) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - K detailu zápasu z jiné sezóny nemáte přístup."
            );
        }

        Object principal = auth.getPrincipal();
        if (!(principal instanceof org.springframework.security.core.userdetails.UserDetails userDetails)) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - Nemáte přístup k detailu tohoto zápasu."
            );
        }

        List<PlayerEntity> ownedPlayers =
                playerRepository.findByUser_EmailOrderByIdAsc(userDetails.getUsername());

        if (ownedPlayers.isEmpty()) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - Nemáte přiřazeného žádného hráče."
            );
        }

        LocalDateTime now = now();
        boolean isPastOrNow = !match.getDateTime().isAfter(now);
        List<Long> ownedPlayerIds = ownedPlayers.stream()
                .map(PlayerEntity::getId)
                .toList();

        List<MatchRegistrationDTO> registrations =
                registrationService.getRegistrationsForMatch(match.getId());

        if (!isPastOrNow) {
            // nadcházející zápas – hráč musí být aktivní pro datum zápasu
            boolean hasActivePlayerForMatch = ownedPlayers.stream()
                    .anyMatch(p -> isPlayerActiveForMatch(p, match.getDateTime()));

            if (!hasActivePlayerForMatch) {
                throw new org.springframework.security.access.AccessDeniedException(
                        "BE - Nemáte aktivního hráče pro tento zápas."
                );
            }
            return;
        }

        // uplynulý zápas – hráč musí být mezi REGISTERED
        boolean wasRegistered = registrations.stream()
                .anyMatch(r ->
                        r.getStatus() == PlayerMatchStatus.REGISTERED
                                && ownedPlayerIds.contains(r.getPlayerId())
                );

        if (!wasRegistered) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - K tomuto uplynulému zápasu nemáte oprávnění (nejste mezi registrovanými hráči)."
            );
        }
    }

    // --------------------------------------------------
    // Sběr statistik hráčů pro MatchDetailDTO
    // --------------------------------------------------

    /**
     * Sestaví {@link MatchDetailDTO} pro daný zápas:
     * <ul>
     *     <li>seskupí hráče podle statusu (REGISTERED/RESERVED/EXCUSED/...)</li>
     *     <li>spočítá počty hráčů v jednotlivých kategoriích,</li>
     *     <li>vypočítá cenu na registrovaného hráče,</li>
     *     <li>naplní seznamy hráčů k jednotlivým statusům,</li>
     *     <li>pole noResponsePlayers vyplní jen pro admin/manager.</li>
     * </ul>
     */
    private MatchDetailDTO collectPlayerStatus(MatchEntity match, boolean isAdminOrManager) {
        List<MatchRegistrationDTO> registrations =
                registrationService.getRegistrationsForMatch(match.getId());


        var statusToPlayersMap = registrations.stream()
                .map(r -> playerRepository.findById(r.getPlayerId())
                        .map(playerMapper::toDTO)
                        .map(dto -> new AbstractMap.SimpleEntry<>(r.getStatus(), dto))
                )
                .filter(Optional::isPresent)
                .map(Optional::get)
                .collect(Collectors.groupingBy(
                        java.util.Map.Entry::getKey,
                        Collectors.mapping(java.util.Map.Entry::getValue, Collectors.toList())
                ));

        List<PlayerDTO> noResponsePlayers =
                registrationService.getNoResponsePlayers(match.getId());

        int inGamePlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()).size();


        registrations.forEach(r -> {
            System.out.println("Reg: status=" + r.getStatus()
                    + ", team=" + r.getTeam());
        });


        int inGamePlayersDark =
                (int) registrations.stream()
                        .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                        .filter(r -> r.getTeam() == Team.DARK)
                        .count();

        int inGamePlayersLight =
                (int) registrations.stream()
                        .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                        .filter(r -> r.getTeam() == Team.LIGHT)
                        .count();

        int substitutePlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.SUBSTITUTE, List.of()).size();

        int outGamePlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()).size()
                        + statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()).size()
                        + statusToPlayersMap.getOrDefault(PlayerMatchStatus.NO_EXCUSED, List.of()).size();

        int waitingPlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()).size();

        int noExcusedPlayersSum =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.NO_EXCUSED, List.of()).size();

        int noActionPlayers = noResponsePlayers.size();

        int remainingSlots = match.getMaxPlayers() - inGamePlayers;
        double pricePerRegistered = inGamePlayers > 0
                ? match.getPrice() / (double) inGamePlayers
                : match.getPrice();

        MatchDetailDTO dto = new MatchDetailDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setLocation(match.getLocation());
        dto.setDescription(match.getDescription());
        dto.setPrice(match.getPrice());
        dto.setMaxPlayers(match.getMaxPlayers());
        dto.setInGamePlayers(inGamePlayers);
        dto.setInGamePlayersDark(inGamePlayersDark);
        dto.setInGamePlayersLight(inGamePlayersLight);
        dto.setSubstitutePlayers(substitutePlayers);
        dto.setOutGamePlayers(outGamePlayers);
        dto.setWaitingPlayers(waitingPlayers);
        dto.setNoExcusedPlayersSum(noExcusedPlayersSum);
        dto.setNoActionPlayers(noActionPlayers);
        dto.setPricePerRegisteredPlayer(pricePerRegistered);
        dto.setRemainingSlots(remainingSlots);

        dto.setRegisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()));
        dto.setReservedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()));
        dto.setUnregisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()));
        dto.setExcusedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()));
        dto.setSubstitutedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.SUBSTITUTE, List.of()));
        dto.setNoExcusedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.NO_EXCUSED, List.of()));

        dto.setNoResponsePlayers(isAdminOrManager ? noResponsePlayers : null);

        return dto;
    }

    /**
     * Z MatchDetailDTO odvodí status konkrétního hráče
     * na základě jeho členství v seznamu hráčů dle statusu.
     * Pokud není v žádném seznamu, vrací NO_RESPONSE.
     */
    private PlayerMatchStatus resolveStatusForPlayer(MatchDetailDTO dto, Long playerId) {
        if (dto == null || playerId == null) {
            return PlayerMatchStatus.NO_RESPONSE;
        }

        if (isIn(dto.getRegisteredPlayers(), playerId)) {
            return PlayerMatchStatus.REGISTERED;
        }
        if (isIn(dto.getReservedPlayers(), playerId)) {
            return PlayerMatchStatus.RESERVED;
        }
        if (isIn(dto.getExcusedPlayers(), playerId)) {
            return PlayerMatchStatus.EXCUSED;
        }
        if (isIn(dto.getSubstitutedPlayers(), playerId)) {
            return PlayerMatchStatus.SUBSTITUTE;
        }

        if (isIn(dto.getUnregisteredPlayers(), playerId)) {
            return PlayerMatchStatus.UNREGISTERED;
        }
        if (isIn(dto.getNoExcusedPlayers(), playerId)) {
            return PlayerMatchStatus.NO_EXCUSED;
        }

        return PlayerMatchStatus.NO_RESPONSE;
    }

    /**
     * Pomocná metoda – zjistí, zda je hráč s daným ID v seznamu PlayerDTO.
     */
    private boolean isIn(List<PlayerDTO> players, Long playerId) {
        return players != null
                && players.stream().anyMatch(p -> p.getId().equals(playerId));
    }


    // ======================
    // DALŠÍ PUBLIC METODY
    // ======================

    /**
     * Vrátí všechny zápasy, ve kterých může daný hráč potenciálně hrát.
     * <ul>
     *     <li>vezme všechny zápasy (všechny sezóny),</li>
     *     <li>filtruje je podle aktivity hráče v daném datu
     *         (PlayerInactivityPeriodService.isActive).</li>
     * </ul>
     * <p>
     * POZOR: tady se zápasy tahají přes všechny sezóny, takže globální
     * "číslo v sezóně" nedává smysl – DTO se nečíslují.
     */
    @Override
    public List<MatchDTO> getAvailableMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        return matchRepository.findAll().stream()
                .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                .map(matchMapper::toDTO)
                .toList();
    }

    /**
     * Najde ID hráče podle emailu uživatele (User.email).
     *
     * @throws PlayerNotFoundException pokud uživatel nemá hráče
     */
    @Override
    public Long getPlayerIdByEmail(String email) {
        return playerRepository.findByUserEmail(email)
                .map(PlayerEntity::getId)
                .orElseThrow(() -> new PlayerNotFoundException(email));
    }

    /**
     * Vrátí přehled nadcházejících zápasů pro konkrétního hráče.
     * <ul>
     *     <li>zjistí PlayerType hráče,</li>
     *     <li>vezme všechny nadcházející zápasy v aktivní sezóně,</li>
     *     <li>omezí jejich počet podle PlayerType (VIP/STANDARD/BASIC),</li>
     *     <li>filtruje jen zápasy, kde je hráč aktivní,</li>
     *     <li>namapuje na MatchOverviewDTO včetně PlayerMatchStatus.</li>
     * </ul>
     */
    @Override
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        List<MatchEntity> upcomingAll = findUpcomingMatchesForCurrentSeason();
        List<MatchEntity> limited = limitMatchesByPlayerType(upcomingAll, type);

        List<MatchEntity> activeMatches = limited.stream()
                .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                .toList();

        Long seasonId = getCurrentSeasonIdOrActive();
        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);

        return assignMatchNumbers(
                activeMatches,
                match -> toOverviewDTO(match, playerId),
                matchNumberMap
        );
    }

    /**
     * Vrátí seznam nadcházejících zápasů pro konkrétního hráče
     * v plném MatchDTO formátu, s omezením podle PlayerType.
     */
    @Override
    public List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        List<MatchEntity> upcomingAll = findUpcomingMatchesForCurrentSeason();
        List<MatchEntity> limited = limitMatchesByPlayerType(upcomingAll, type);

        List<MatchEntity> activeMatches = limited.stream()
                .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                .toList();

        Long seasonId = getCurrentSeasonIdOrActive();
        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);

        return assignMatchNumbers(activeMatches, matchMapper::toDTO, matchNumberMap);
    }

    /**
     * Vrátí overview všech proběhlých zápasů aktivní sezóny,
     * kterých se hráč mohl účastnit.
     * <ul>
     *     <li>bere jen proběhlé zápasy v aktivní sezóně,</li>
     *     <li>filtruje podle aktivity hráče v datu zápasu,</li>
     *     <li>najednou načte všechny registrace k těmto zápasům,</li>
     *     <li>z nich sestaví mapu matchId → playerId → status,</li>
     *     <li>pro každý zápas sestaví MatchOverviewDTO a nastaví PlayerMatchStatus.</li>
     * </ul>
     */
    @Override
    public List<MatchOverviewDTO> getAllPassedMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        List<MatchEntity> availableMatches =
                findPastMatchesForCurrentSeason().stream()
                        .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                        .toList();

        if (availableMatches.isEmpty()) {
            return List.of();
        }

        List<Long> matchIds = availableMatches.stream()
                .map(MatchEntity::getId)
                .toList();

        List<MatchRegistrationDTO> allRegistrations =
                registrationService.getRegistrationsForMatches(matchIds);

        var statusMap = allRegistrations.stream()
                .collect(Collectors.groupingBy(
                        MatchRegistrationDTO::getMatchId,
                        Collectors.toMap(
                                MatchRegistrationDTO::getPlayerId,
                                MatchRegistrationDTO::getStatus,
                                (a, b) -> a
                        )
                ));

        // původní logika + globální číslo zápasu v sezóně
        List<MatchOverviewDTO> overviews = availableMatches.stream()
                .map(match -> {
                    MatchOverviewDTO overview = toOverviewDTO(match);
                    PlayerMatchStatus playerMatchStatus = Optional.ofNullable(statusMap.get(match.getId()))
                            .map(m -> normalizePlayerStatus(m.get(playerId)))
                            .orElse(PlayerMatchStatus.NO_RESPONSE);
                    overview.setPlayerMatchStatus(playerMatchStatus);
                    return overview;
                })
                .toList();

        Long seasonId = getCurrentSeasonIdOrActive();
        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);

        overviews.forEach(o -> o.setMatchNumber(matchNumberMap.get(o.getId())));

        return overviews;
    }



    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    private MatchEntity findMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }

    private MatchRegistrationEntity findMatchRegistrationOrThrow(Long playerId, Long matchId) {
        return matchRegistrationRepository.findByPlayerIdAndMatchId(playerId, matchId)
                .orElseThrow(() -> new MatchRegistrationNotFoundException(playerId, matchId));
    }

    private LocalDateTime now() {
        return LocalDateTime.now();
    }

    // ======================
    // POMOCNÉ METODY – DTO MAPOVÁNÍ
    // ======================

    /**
     * Sestaví základní {@link MatchOverviewDTO} pro daný zápas
     * (bez ohledu na konkrétního hráče).
     * <ul>
     *     <li>vypočítá počet REGISTERED hráčů,</li>
     *     <li>vypočítá cenu na registrovaného hráče.</li>
     * </ul>
     */
    private MatchOverviewDTO toOverviewDTO(MatchEntity match) {
        MatchOverviewDTO dto = new MatchOverviewDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setLocation(match.getLocation());
        dto.setDescription(match.getDescription());
        dto.setPrice(match.getPrice());
        dto.setMaxPlayers(match.getMaxPlayers());

        int inGamePlayers = registrationService.getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .mapToInt(r -> 1)
                .sum();
        dto.setInGamePlayers(inGamePlayers);

        double pricePerPlayer = inGamePlayers > 0 && match.getPrice() != null
                ? match.getPrice() / (double) inGamePlayers
                : match.getPrice();
        dto.setPricePerRegisteredPlayer(pricePerPlayer);

        return dto;
    }

    /**
     * Rozšířená verze overview o stav konkrétního hráče v zápase.
     */
    private MatchOverviewDTO toOverviewDTO(MatchEntity match, Long playerId) {
        MatchOverviewDTO dto = toOverviewDTO(match);

        PlayerMatchStatus playerMatchStatus = registrationService
                .getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getPlayerId().equals(playerId))
                .map(MatchRegistrationDTO::getStatus)
                .findFirst()
                .map(this::normalizePlayerStatus)
                .orElse(PlayerMatchStatus.NO_RESPONSE);

        dto.setPlayerMatchStatus(playerMatchStatus);
        return dto;
    }

    // ======================
    // DALŠÍ POMOCNÉ METODY
    // ======================

    /**
     * Zjistí, zda má uživatel roli ADMIN nebo MANAGER.
     */
    private boolean hasAdminOrManagerRole(Authentication auth) {
        if (auth == null) {
            return false;
        }
        return auth.getAuthorities().stream()
                .anyMatch(a ->
                        ROLE_ADMIN.equals(a.getAuthority()) ||
                                ROLE_MANAGER.equals(a.getAuthority())
                );
    }

    /**
     * Všechny nadcházející zápasy v aktivní sezóně (datum > teď),
     * seřazené podle data vzestupně.
     */
    private List<MatchEntity> findUpcomingMatchesForCurrentSeason() {
        return matchRepository.findBySeasonIdAndDateTimeAfterOrderByDateTimeAsc(
                getCurrentSeasonIdOrActive(),
                now()
        );
    }

    /**
     * Všechny proběhlé zápasy v aktivní sezóně (datum < teď),
     * seřazené podle data sestupně.
     */
    private List<MatchEntity> findPastMatchesForCurrentSeason() {
        return matchRepository.findBySeasonIdAndDateTimeBeforeOrderByDateTimeDesc(
                getCurrentSeasonIdOrActive(),
                now()
        );
    }

    /**
     * Omezení seznamu nadcházejících zápasů podle typu hráče.
     * <ul>
     *     <li>VIP → max 3 zápasy,</li>
     *     <li>STANDARD → max 2 zápasy,</li>
     *     <li>BASIC → pouze nejbližší zápas.</li>
     * </ul>
     */
    private List<MatchEntity> limitMatchesByPlayerType(List<MatchEntity> upcomingAll, PlayerType type) {
        if (upcomingAll == null || upcomingAll.isEmpty()) {
            return List.of();
        }

        return switch (type) {
            case VIP -> upcomingAll.stream().limit(3).toList();
            case STANDARD -> upcomingAll.stream().limit(2).toList();
            case BASIC -> List.of(upcomingAll.get(0));
        };
    }

    /**
     * Ověří, zda je hráč aktivní pro dané datum zápasu,
     * pomocí {@link PlayerInactivityPeriodService}.
     */
    private boolean isPlayerActiveForMatch(PlayerEntity player, LocalDateTime dateTime) {
        return playerInactivityPeriodService.isActive(player, dateTime);
    }

    /**
     * Normalizuje status hráče.
     * <ul>
     *     <li>null → NO_RESPONSE,</li>
     *     <li>jinak vrací status, pokud je z podporovaného seznamu.</li>
     * </ul>
     */
    private PlayerMatchStatus normalizePlayerStatus(PlayerMatchStatus status) {
        if (status == null) {
            return PlayerMatchStatus.NO_RESPONSE;
        }

        return switch (status) {
            case REGISTERED,
                 UNREGISTERED,
                 EXCUSED,
                 SUBSTITUTE,
                 RESERVED,
                 NO_EXCUSED -> status;
            default -> PlayerMatchStatus.NO_RESPONSE;
        };
    }

    /**
     * Ověří, že datum zápasu spadá do intervalu aktivní sezóny,
     * jinak vyhodí {@link InvalidSeasonPeriodDateException}.
     */
    private void validateMatchDateInActiveSeason(LocalDateTime dateTime) {
        var activeSeason = seasonService.getActiveSeason();
        var date = dateTime.toLocalDate();

        if (date.isBefore(activeSeason.getStartDate()) ||
                date.isAfter(activeSeason.getEndDate())) {

            throw new InvalidSeasonPeriodDateException(
                    "BE - Datum zápasu musí být v rozmezí aktivní sezóny (" +
                            activeSeason.getStartDate() + " - " + activeSeason.getEndDate() + ")."
            );
        }
    }

    /**
     * Sezona pro uživatele
     */
    private Long getCurrentSeasonIdOrActive() {
        Long id = currentSeasonService.getCurrentSeasonIdOrDefault();
        if (id != null) {
            return id;
        }
        // fallback – kdyby náhodou nebyla v session ani globálně aktivní
        return seasonService.getActiveSeason().getId();
    }

    /**
     * Generická metoda pro číslování zápasů:
     * číslo se bere z mapy matchId -> pořadí v sezóně.
     */
    private <D extends NumberedMatchDTO> List<D> assignMatchNumbers(
            List<MatchEntity> matches,
            Function<MatchEntity, D> mapper,
            Map<Long, Integer> matchNumberMap
    ) {
        return matches.stream()
                .map(entity -> {
                    D dto = mapper.apply(entity);
                    Integer number = matchNumberMap.get(entity.getId());
                    dto.setMatchNumber(number);
                    return dto;
                })
                .toList();
    }

    /**
     * Pro danou sezónu vrátí mapu:
     * matchId -> pořadové číslo zápasu v sezóně (1..N)
     * Pořadí je podle dateTime ASC.
     */
    private Map<Long, Integer> buildMatchNumberMapForSeason(Long seasonId) {
        List<MatchEntity> allMatchesInSeason =
                matchRepository.findAllBySeasonIdOrderByDateTimeAsc(seasonId);

        Map<Long, Integer> map = new HashMap<>();
        int counter = 1;
        for (MatchEntity m : allMatchesInSeason) {
            map.put(m.getId(), counter++);
        }
        return map;
    }


    private void notifyPlayersAboutMatchChanges(Object context, MatchStatus matchStatus) {
        // z contextu vytáhneme MatchEntity
        MatchEntity match;
        if (context instanceof MatchTimeChangeContext mtc) {
            match = mtc.match();
        } else if (context instanceof MatchEntity m) {
            match = m;
        } else {
            throw new IllegalArgumentException("Nepodporovaný typ contextu: " + context);
        }

        var registrations = matchRegistrationRepository.findByMatchId(match.getId());

        registrations.stream()
                .filter(reg -> reg.getStatus() == PlayerMatchStatus.REGISTERED
                        || reg.getStatus() == PlayerMatchStatus.RESERVED)
                .forEach(reg -> {
                    PlayerEntity player = reg.getPlayer();

                    if (matchStatus == MatchStatus.UPDATED) {
                        // tady chceme vidět i staré datum -> musíme poslat celý context
                        notificationService.notifyPlayer(
                                player,
                                NotificationType.MATCH_TIME_CHANGED,
                                context // MatchTimeChangeContext
                        );
                    }

                    if (matchStatus == MatchStatus.CANCELLED) {
                        notificationService.notifyPlayer(
                                player,
                                NotificationType.MATCH_CANCELED,
                                match // stačí MatchEntity
                        );
                    }

                    if (matchStatus == MatchStatus.UNCANCELED) {
                        notificationService.notifyPlayer(
                                player,
                                NotificationType.MATCH_UNCANCELED,
                                match
                        );
                    }
                });
    }


}


-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\NotificationDecision.java
-----

package cz.phsoft.hokej.models.services;

/**
 * Výsledek vyhodnocení notifikačních preferencí.
 *
 * Třída říká:
 * - zda poslat email uživateli (AppUser),
 * - zda poslat email hráči (pokud má vlastní email),
 * - zda poslat SMS hráči,
 * - jaké konkrétní kontakty použít.
 */
public class NotificationDecision {

    // ===== EMAIL =====


     /**
     * Poslat email uživateli (AppUser)?
     */
    private boolean sendEmailToUser;

    /**
     * Email uživatele (AppUser.email).
     */
    private String userEmail;

    /**
     * fullname uživatele (AppUser.email).
     */
    private String fullname;
    /**
     * Poslat email hráči na jeho kontakt (PlayerSettings.contactEmail)?
     */
    private boolean sendEmailToPlayer;

    /**
     * Email hráče (PlayerSettings.contactEmail nebo fallback).
     */
    private String playerEmail;

    // ===== SMS =====

    /**
     * Poslat SMS hráči?
     */
    private boolean sendSmsToPlayer;

    /**
     * Telefon hráče (PlayerSettings.contactPhone nebo fallback).
     */
    private String playerPhone;

    // ===== GETTERY / SETTERY =====


    public boolean isSendEmailToUser() {
        return sendEmailToUser;
    }

    public void setSendEmailToUser(boolean sendEmailToUser) {
        this.sendEmailToUser = sendEmailToUser;
    }

    public String getUserEmail() {
        return userEmail;
    }

    public void setUserEmail(String userEmail) {
        this.userEmail = userEmail;
    }

    public boolean isSendEmailToPlayer() {
        return sendEmailToPlayer;
    }

    public void setSendEmailToPlayer(boolean sendEmailToPlayer) {
        this.sendEmailToPlayer = sendEmailToPlayer;
    }

    public String getPlayerEmail() {
        return playerEmail;
    }

    public void setPlayerEmail(String playerEmail) {
        this.playerEmail = playerEmail;
    }

    public boolean isSendSmsToPlayer() {
        return sendSmsToPlayer;
    }

    public void setSendSmsToPlayer(boolean sendSmsToPlayer) {
        this.sendSmsToPlayer = sendSmsToPlayer;
    }

    public String getPlayerPhone() {
        return playerPhone;
    }

    public void setPlayerPhone(String playerPhone) {
        this.playerPhone = playerPhone;
    }


}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;

import java.time.LocalDateTime;
import java.util.List;

/**
 * Rozhraní pro správu období neaktivity hráčů.
 * <p>
 * Definuje kontrakt pro práci s časovými úseky, ve kterých
 * je hráč považován za neaktivního (např. zranění, dovolená,
 * dlouhodobá absence).
 * </p>
 *
 * Účel:
 * <ul>
 *     <li>evidence období, kdy se hráč nemůže účastnit zápasů,</li>
 *     <li>poskytnutí přehledů neaktivity pro hráče i administraci,</li>
 *     <li>umožnění kontroly, zda je hráč v daný okamžik aktivní.</li>
 * </ul>
 *
 * Použití:
 * <ul>
 *     <li>využívá se při registraci hráčů na zápasy,</li>
 *     <li>slouží pro validaci účasti hráče v konkrétním čase,</li>
 *     <li>je součástí business pravidel plánování zápasů.</li>
 * </ul>
 *
 * Architektonické zásady:
 * <ul>
 *     <li>pracuje výhradně s DTO objekty, nikoliv přímo s entitami,</li>
 *     <li>odděluje business logiku neaktivity od persistence vrstvy.</li>
 * </ul>
 */
public interface PlayerInactivityPeriodService {

    /**
     * Vrátí seznam všech období neaktivity v systému.
     * <p>
     * Typicky dostupné pouze pro administrátorské přehledy.
     * </p>
     *
     * @return seznam všech období neaktivity
     */
    List<PlayerInactivityPeriodDTO> getAll();

    /**
     * Vrátí období neaktivity podle jeho ID.
     *
     * @param id ID období neaktivity
     * @return období neaktivity ve formě DTO
     */
    PlayerInactivityPeriodDTO getById(Long id);

    /**
     * Vrátí seznam období neaktivity pro konkrétního hráče.
     *
     * @param playerId ID hráče
     * @return seznam období neaktivity daného hráče
     */
    List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId);

    /**
     * Vytvoří nové období neaktivity hráče.
     * <p>
     * Implementace je zodpovědná za validaci časového rozsahu
     * (např. začátek &lt; konec, nepřekrývání s jinými obdobími).
     * </p>
     *
     * @param dto data nového období neaktivity
     * @return vytvořené období neaktivity
     */
    PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto);

    /**
     * Aktualizuje existující období neaktivity.
     *
     * @param id  ID období neaktivity, které má být upraveno
     * @param dto nové hodnoty období neaktivity
     * @return aktualizované období neaktivity
     */
    PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto);

    /**
     * Odstraní období neaktivity podle ID.
     *
     * @param id ID období neaktivity, které má být smazáno
     */
    void delete(Long id);

    /**
     * Ověří, zda je hráč v daném okamžiku aktivní.
     * <p>
     * Metoda vrací informaci, zda se zadaný čas
     * nenachází v žádném z evidovaných období neaktivity hráče.
     * </p>
     *
     * Typické použití:
     * <ul>
     *     <li>při registraci hráče na zápas,</li>
     *     <li>při validaci účasti hráče v konkrétním čase.</li>
     * </ul>
     *
     * @param player   hráč, jehož aktivita se ověřuje
     * @param dateTime časový okamžik, pro který se aktivita kontroluje
     * @return {@code true}, pokud je hráč v daném čase aktivní,
     *         jinak {@code false}
     */
    boolean isActive(PlayerEntity player, LocalDateTime dateTime);
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.data.repositories.PlayerInactivityPeriodRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.InactivityPeriodNotFoundException;
import cz.phsoft.hokej.exceptions.InactivityPeriodOverlapException;
import cz.phsoft.hokej.exceptions.InvalidInactivityPeriodDateException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import cz.phsoft.hokej.models.mappers.PlayerInactivityPeriodMapper;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

/**
 * Služba pro správu období neaktivity hráčů.
 *
 * OBCHODNÍ VÝZNAM:
 * <ul>
 *     <li>určuje, zda je hráč v daném čase aktivní/neaktivní,</li>
 *     <li>využívá se při:
 *         <ul>
 *             <li>zobrazování dostupných zápasů,</li>
 *             <li>kontrole přístupu k detailu zápasu,</li>
 *             <li>registracích na zápasy.</li>
 *         </ul>
 *     </li>
 * </ul>
 *
 * KLÍČOVÉ PRAVIDLO:
 * <ul>
 *     <li>hráč NESMÍ mít překrývající se období neaktivity.</li>
 * </ul>
 *
 * Tato služba je čistě doménová:
 * <ul>
 *     <li>neřeší bezpečnost ani role,</li>
 *     <li>neposílá notifikace,</li>
 *     <li>řeší pouze data a pravidla kolem neaktivity.</li>
 * </ul>
 */
@Service
public class PlayerInactivityPeriodServiceImpl implements PlayerInactivityPeriodService {

    private final PlayerInactivityPeriodRepository inactivityRepository;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodMapper mapper;

    public PlayerInactivityPeriodServiceImpl(
            PlayerInactivityPeriodRepository inactivityRepository,
            PlayerRepository playerRepository,
            PlayerInactivityPeriodMapper mapper
    ) {
        this.inactivityRepository = inactivityRepository;
        this.playerRepository = playerRepository;
        this.mapper = mapper;
    }

    // ======================
    // READ OPERACE
    // ======================

    /**
     * Vrátí všechna období neaktivity všech hráčů.
     *
     * Použití:
     * <ul>
     *     <li>administrace,</li>
     *     <li>interní přehledy.</li>
     * </ul>
     */
    @Override
    public List<PlayerInactivityPeriodDTO> getAll() {
        return inactivityRepository.findAll().stream()
                .map(mapper::toDTO)
                .toList();
    }

    /**
     * Vrátí konkrétní období neaktivity dle ID.
     *
     * @throws InactivityPeriodNotFoundException pokud záznam neexistuje
     */
    @Override
    public PlayerInactivityPeriodDTO getById(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new InactivityPeriodNotFoundException(id));

        return mapper.toDTO(entity);
    }

    /**
     * Vrátí všechna období neaktivity konkrétního hráče,
     * seřazená podle začátku neaktivity (od nejstaršího).
     *
     * @throws PlayerNotFoundException pokud hráč neexistuje
     */
    @Override
    public List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId) {
        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));

        return inactivityRepository.findByPlayerOrderByInactiveFromAsc(player).stream()
                .map(mapper::toDTO)
                .toList();
    }

    // ======================
    // CREATE
    // ======================

    /**
     * Vytvoří nové období neaktivity hráče.
     *
     * Validace:
     * <ul>
     *     <li>hráč musí existovat,</li>
     *     <li>datum {@code inactiveFrom} &lt; {@code inactiveTo},</li>
     *     <li>nové období se NESMÍ překrývat s jiným obdobím neaktivity hráče.</li>
     * </ul>
     *
     * @throws PlayerNotFoundException               pokud hráč neexistuje
     * @throws InvalidInactivityPeriodDateException  pokud jsou špatná data od/do
     * @throws InactivityPeriodOverlapException      pokud se období překrývá s existujícím
     */
    @Override
    @Transactional
    public PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto) {

        PlayerEntity player = playerRepository.findById(dto.getPlayerId())
                .orElseThrow(() -> new PlayerNotFoundException(dto.getPlayerId()));

        validateDates(dto);

        // kontrola překryvu existujících období:
        // pokud existuje JAKÝKOLI záznam, který se časově protíná, je to chyba
        boolean overlaps = !inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        player,
                        dto.getInactiveFrom(),
                        dto.getInactiveTo()
                ).isEmpty();

        if (overlaps) {
            throw new InactivityPeriodOverlapException();
        }

        PlayerInactivityPeriodEntity entity = mapper.toEntity(dto, player);
        PlayerInactivityPeriodEntity saved = inactivityRepository.save(entity);

        return mapper.toDTO(saved);
    }

    // ======================
    // UPDATE
    // ======================

    /**
     * Aktualizuje existující období neaktivity.
     * <p>
     * Oproti {@link #create(PlayerInactivityPeriodDTO)}:
     * <ul>
     *     <li>při kontrole překryvu ignoruje sám sebe (aktuální záznam).</li>
     * </ul>
     *
     * @throws InactivityPeriodNotFoundException     pokud záznam neexistuje
     * @throws InvalidInactivityPeriodDateException  pokud jsou špatná data od/do
     * @throws InactivityPeriodOverlapException      pokud se upravené období překrývá s jiným
     */
    @Override
    @Transactional
    public PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto) {

        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new InactivityPeriodNotFoundException(id));

        validateDates(dto);

        // kontrola překryvu – ignorujeme aktuální záznam (id)
        boolean overlaps = inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        entity.getPlayer(),
                        dto.getInactiveFrom(),
                        dto.getInactiveTo()
                ).stream()
                .anyMatch(p -> !p.getId().equals(id));

        if (overlaps) {
            throw new InactivityPeriodOverlapException(
                    "BE - Upravené období se překrývá s jiným obdobím neaktivity hráče."
            );
        }

        mapper.updateEntityFromDto(dto, entity);
        PlayerInactivityPeriodEntity saved = inactivityRepository.save(entity);

        return mapper.toDTO(saved);
    }

    // ======================
    // DELETE
    // ======================

    /**
     * Smaže období neaktivity dle ID.
     *
     * @throws InactivityPeriodNotFoundException pokud záznam neexistuje
     */
    @Override
    @Transactional
    public void delete(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new InactivityPeriodNotFoundException(id));

        inactivityRepository.delete(entity);
    }

    // ======================
    // AKTIVITA HRÁČE
    // ======================

    /**
     * Zjistí, zda je hráč v daném čase AKTIVNÍ.
     *
     * @param player   hráč
     * @param dateTime čas, pro který ověřujeme aktivitu
     *
     * @return {@code true}  pokud hráč NENÍ v žádném období neaktivity<br>
     *         {@code false} pokud je v daném čase v období neaktivity
     *
     * Použití:
     * <ul>
     *     <li>v {@link MatchServiceImpl} (filtrace zápasů podle dostupnosti hráče),</li>
     *     <li>v přístupové logice (zda má hráč „nárok“ na daný zápas).</li>
     * </ul>
     */
    @Override
    public boolean isActive(PlayerEntity player, LocalDateTime dateTime) {
        // pokud existuje záznam, který obaluje daný čas → hráč je NEaktivní
        return !inactivityRepository
                .existsByPlayerAndInactiveFromLessThanEqualAndInactiveToGreaterThanEqual(
                        player,
                        dateTime,
                        dateTime
                );
    }

    // ======================
    // PRIVÁTNÍ VALIDACE
    // ======================

    /**
     * Validace časového rozsahu neaktivity.
     * <ul>
     *     <li>datum od/do nesmí být {@code null},</li>
     *     <li>{@code inactiveFrom} musí být přísně před {@code inactiveTo}.</li>
     * </ul>
     *
     * @throws InvalidInactivityPeriodDateException při neplatných datech
     */
    private void validateDates(PlayerInactivityPeriodDTO dto) {
        if (dto.getInactiveFrom() == null || dto.getInactiveTo() == null) {
            throw new InvalidInactivityPeriodDateException(
                    "BE - Datum od a do nesmí být null."
            );
        }

        if (!dto.getInactiveFrom().isBefore(dto.getInactiveTo())) {
            throw new InvalidInactivityPeriodDateException(
                    "BE - Datum 'od' musí být před 'do'."
            );
        }
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;

import java.util.List;

/**
 * Rozhraní pro správu hráčů v aplikaci.
 * <p>
 * Definuje kontrakt pro práci s hráči z pohledu business logiky,
 * včetně jejich vytváření, úprav, schvalování a vazby na uživatele.
 * </p>
 *
 * Účel:
 * <ul>
 *     <li>správa životního cyklu hráčů (vytvoření, úprava, smazání),</li>
 *     <li>vazba hráčů na uživatelské účty,</li>
 *     <li>řízení stavu hráče (čekající, schválený, zamítnutý).</li>
 * </ul>
 *
 * Použití:
 * <ul>
 *     <li>využívá se v controllerech a dalších business službách,</li>
 *     <li>pracuje výhradně s DTO objekty.</li>
 * </ul>
 */
public interface PlayerService {

    /**
     * Vrátí seznam všech hráčů v systému.
     * <p>
     * Typicky určeno pro administrátorské přehledy.
     * </p>
     *
     * @return seznam všech hráčů
     */
    List<PlayerDTO> getAllPlayers();

    /**
     * Vrátí hráče podle jeho ID.
     *
     * @param id ID hráče
     * @return hráč ve formě DTO
     */
    PlayerDTO getPlayerById(Long id);

    /**
     * Vytvoří nového hráče.
     * <p>
     * Hráč je po vytvoření obvykle ve stavu čekajícím
     * na schválení administrátorem.
     * </p>
     *
     * @param player data nového hráče
     * @return vytvořený hráč
     */
    PlayerDTO createPlayer(PlayerDTO player);

    /**
     * Vytvoří nového hráče a přiřadí jej ke konkrétnímu uživateli.
     * <p>
     * Používá se v případech, kdy je hráč vytvářen
     * v kontextu již existujícího uživatelského účtu.
     * </p>
     *
     * @param dto       data nového hráče
     * @param userEmail email uživatele, ke kterému má být hráč přiřazen
     * @return vytvořený hráč
     */
    PlayerDTO createPlayerForUser(PlayerDTO dto, String userEmail);

    /**
     * Aktualizuje údaje existujícího hráče.
     *
     * @param id     ID hráče, který má být aktualizován
     * @param player nové hodnoty hráče
     * @return aktualizovaný hráč
     */
    PlayerDTO updatePlayer(Long id, PlayerDTO player);

    /**
     * Odstraní hráče ze systému.
     * <p>
     * Typicky vrací informaci o úspěchu operace
     * ve formě {@link SuccessResponseDTO}.
     * </p>
     *
     * @param id ID hráče, který má být odstraněn
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO deletePlayer(Long id);

    /**
     * Vrátí seznam hráčů přiřazených ke konkrétnímu uživateli.
     *
     * @param email email uživatele
     * @return seznam hráčů daného uživatele
     */
    List<PlayerDTO> getPlayersByUser(String email);

    /**
     * Schválí hráče.
     * <p>
     * Po schválení je hráč považován za aktivního
     * a může se účastnit zápasů.
     * </p>
     *
     * @param id ID hráče
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO approvePlayer(Long id);

    /**
     * Zamítne hráče.
     * <p>
     * Zamítnutý hráč se nemůže účastnit zápasů
     * a není považován za aktivního.
     * </p>
     *
     * @param id ID hráče
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO rejectPlayer(Long id);

    /**
     * Nastaví aktuálního hráče pro konkrétního uživatele.
     * <p>
     * Slouží k explicitnímu výběru hráče v případě,
     * že má uživatel přiřazeno více hráčů.
     * </p>
     *
     * @param userEmail email uživatele
     * @param playerId  ID hráče, který má být nastaven jako aktuální
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO setCurrentPlayerForUser(String userEmail, Long playerId);

    /**
     * Automaticky zvolí aktuálního hráče pro daného uživatele
     * podle jeho nastavení (AppUserSettings.playerSelectionMode).
     *
     * Používá se typicky:
     * - po přihlášení uživatele,
     * - při explicitním volání z FE (např. tlačítko "Vybrat výchozího hráče").
     *
     * @param userEmail email přihlášeného uživatele (auth.getName())
     * @return jednoduchá zpráva o výsledku
     */
    SuccessResponseDTO autoSelectCurrentPlayerForUser(String userEmail);

    /**
     * Změní přiřazeného uživatele k existujícímu hráči.
     * <p>
     * Slouží k administrátorské úpravě vazby mezi hráčem a
     * uživatelským účtem, zejména v případech:
     * <ul>
     *     <li>opravy chybného přiřazení hráče k uživateli,</li>
     *     <li>převodu hráče pod jiný uživatelský účet,</li>
     *     <li>řešení duplicit nebo technických korekcí dat.</li>
     * </ul>
     *
     * Metoda:
     * <ul>
     *     <li>mění pouze vazbu hráč → uživatel,</li>
     *     <li>neprovádí žádné notifikace,</li>
     *     <li>neřeší nastavení aktuálního hráče (řeší volající).</li>
     * </ul>
     *
     * @param id        ID hráče, kterému se má změnit přiřazený uživatel
     * @param newUserId ID nového uživatele, ke kterému má být hráč přiřazen
     */
    void changePlayerUser(Long id, Long newUserId);

}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerSettingsEntity;
import cz.phsoft.hokej.data.enums.PlayerSelectionMode;
import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.notification.NotificationService;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import static cz.phsoft.hokej.data.enums.PlayerStatus.APPROVED;
import static cz.phsoft.hokej.data.enums.PlayerStatus.REJECTED;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Service vrstva pro práci s hráči ({@link PlayerEntity}).
 * <p>
 * Zodpovídá za:
 * <ul>
 *     <li>CRUD operace nad hráči (create/update/delete),</li>
 *     <li>kontrolu duplicity (jméno + příjmení),</li>
 *     <li>vazbu hráče na uživatele ({@link AppUserEntity}),</li>
 *     <li>změnu statusu hráče (APPROVED / REJECTED) včetně notifikací,</li>
 *     <li>nastavení „aktuálního hráče“ v {@link CurrentPlayerService} pro přihlášeného uživatele.</li>
 * </ul>
 * <p>
 * Co tato service NEřeší:
 * <ul>
 *     <li>HTTP/session vrstvu – to obstarávají controllery + CurrentPlayerService,</li>
 *     <li>autentizaci/autorizaci – řeší Spring Security a controller vrstva,</li>
 *     <li>detailní logiku zápasů – řeší {@link MatchServiceImpl}.</li>
 * </ul>
 */
@Service
public class PlayerServiceImpl implements PlayerService {

    private final PlayerRepository playerRepository;
    private final PlayerMapper playerMapper;
    private final AppUserRepository appUserRepository;
    private final NotificationService notificationService;
    private final CurrentPlayerService currentPlayerService;
    private final AppUserSettingsService appUserSettingsService;
    private final PlayerSettingsService playerSettingsService;

    public PlayerServiceImpl(
            PlayerRepository playerRepository,
            PlayerMapper playerMapper,
            AppUserRepository appUserRepository,
            NotificationService notificationService,
            CurrentPlayerService currentPlayerService,
            AppUserSettingsService appUserSettingsService,
            PlayerSettingsService playerSettingsService
    ) {
        this.playerRepository = playerRepository;
        this.playerMapper = playerMapper;
        this.appUserRepository = appUserRepository;
        this.notificationService = notificationService;
        this.currentPlayerService = currentPlayerService;
        this.appUserSettingsService = appUserSettingsService;
        this.playerSettingsService = playerSettingsService;
    }

    // ======================
    // READ
    // ======================

    /**
     * Vytvoří nového hráče bez vazby na uživatele.
     * <p>
     * Kroky:
     * <ol>
     *     <li>zkontroluje duplicitu jména + příjmení,</li>
     *     <li>namapuje {@link PlayerDTO} → {@link PlayerEntity},</li>
     *     <li>uloží hráče,</li>
     *     <li>notifikace se aktuálně NEposílají (zachování původního chování).</li>
     * </ol>
     */
    @Override
    @Transactional
    public PlayerDTO createPlayer(PlayerDTO dto) {
        // kontrola, že neexistuje jiný hráč se stejným jménem + příjmením
        ensureUniqueNameSurname(dto.getName(), dto.getSurname(), null);

        PlayerEntity entity = playerMapper.toEntity(dto);
        PlayerEntity saved = playerRepository.save(entity);

        // Původně zde byla notifikace:
        // notificationService.notifyPlayer(saved, NotificationType.PLAYER_CREATED, null);
        // → zachováváme původní chování = bez notifikace.

        return playerMapper.toDTO(saved);
    }

    /**
     * Vytvoří nového hráče a rovnou ho přiřadí k uživateli (dle emailu).
     * <p>
     * Kroky:
     * <ol>
     *     <li>najde {@link AppUserEntity} podle emailu,</li>
     *     <li>zkontroluje duplicitu jméno + příjmení,</li>
     *     <li>namapuje DTO → entity, přiřadí uživatele,</li>
     *     <li>uloží hráče a odešle notifikaci typu {@link NotificationType#PLAYER_CREATED}.</li>
     * </ol>
     *
     * @param dto       data hráče
     * @param userEmail email uživatele, kterému má hráč patřit
     * @throws UserNotFoundException         pokud uživatel neexistuje
     * @throws DuplicateNameSurnameException pokud existuje hráč se stejným jménem a příjmením
     */
    @Override
    @Transactional
    public PlayerDTO createPlayerForUser(PlayerDTO dto, String userEmail) {
        AppUserEntity user = appUserRepository.findByEmail(userEmail)
                .orElseThrow(() -> new UserNotFoundException(userEmail));

        ensureUniqueNameSurname(dto.getName(), dto.getSurname(), null);

        PlayerEntity player = playerMapper.toEntity(dto);
        player.setUser(user);
        PlayerEntity saved = playerRepository.save(player);

        notifyPlayer(saved, NotificationType.PLAYER_CREATED, saved);

        return playerMapper.toDTO(saved);
    }

    /**
     * Aktualizuje existujícího hráče.
     * <p>
     * Kroky:
     * <ol>
     *     <li>najde hráče podle ID,</li>
     *     <li>pokud se mění jméno/příjmení → zkontroluje duplicitu,</li>
     *     <li>přepíše základní údaje (jméno, příjmení, přezdívka, telefon, typ, tým, status),</li>
     *     <li>uloží hráče a odešle notifikaci {@link NotificationType#PLAYER_UPDATED}.</li>
     * </ol>
     *
     * @throws PlayerNotFoundException       pokud hráč neexistuje
     * @throws DuplicateNameSurnameException pokud nová kombinace jméno+příjmení koliduje s jiným hráčem
     */
    @Override
    @Transactional
    public PlayerDTO updatePlayer(Long id, PlayerDTO dto) {
        PlayerEntity existing = findPlayerOrThrow(id);

        boolean nameChanged =
                !existing.getName().equals(dto.getName()) ||
                        !existing.getSurname().equals(dto.getSurname());

        // kontrola duplicity jen pokud se jméno/příjmení mění
        if (nameChanged) {
            ensureUniqueNameSurname(dto.getName(), dto.getSurname(), id);
        }

        existing.setName(dto.getName());
        existing.setSurname(dto.getSurname());
        existing.setNickname(dto.getNickname());
        existing.setPhoneNumber(dto.getPhoneNumber());
        existing.setType(dto.getType());
        existing.setTeam(dto.getTeam());
        if (dto.getPlayerStatus() != null) {
            existing.setPlayerStatus(dto.getPlayerStatus());
        }

        PlayerEntity saved =  playerRepository.save(existing);
        notifyPlayer(saved, NotificationType.PLAYER_UPDATED, saved);

        return playerMapper.toDTO(saved);
    }

    /**
     * Smaže hráče podle ID.
     *
     * @param id ID hráče
     * @return {@link SuccessResponseDTO} s potvrzující zprávou
     * @throws PlayerNotFoundException pokud hráč neexistuje
     */
    @Override
    @Transactional
    public SuccessResponseDTO deletePlayer(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);
        playerRepository.delete(player);

        String message = "Hráč " + player.getFullName() + " byl úspěšně smazán";
        notifyPlayer(player, NotificationType.PLAYER_DELETED, player);

        return buildSuccessResponse(message, id);
    }

    // ======================
    // STATUS – APPROVE / REJECT
    // ======================

    /**
     * Schválí hráče (nastaví {@link PlayerStatus#APPROVED}).
     * <ul>
     *     <li>pokud už je APPROVED → vyhodí {@link InvalidPlayerStatusException},</li>
     *     <li>po uložení odešle notifikaci {@link NotificationType#PLAYER_APPROVED}.</li>
     * </ul>
     */
    @Override
    @Transactional
    public SuccessResponseDTO approvePlayer(Long id) {
        return changePlayerStatus(
                id,
                PlayerStatus.APPROVED,          // cílový status
                PlayerStatus.APPROVED,          // status, při kterém hlásíme "už je schválen"
                NotificationType.PLAYER_APPROVED,
                "BE - Hráč už je schválen.",
                "Hráč %s byl úspěšně aktivován"


        );
    }

    /**
     * Zamítne hráče (nastaví {@link PlayerStatus#REJECTED}).
     * <ul>
     *     <li>pokud už je REJECTED → vyhodí {@link InvalidPlayerStatusException},</li>
     *     <li>po uložení odešle notifikaci {@link NotificationType#PLAYER_REJECTED}.</li>
     * </ul>
     */
    @Override
    @Transactional
    public SuccessResponseDTO rejectPlayer(Long id) {
        return changePlayerStatus(
                id,
                REJECTED,           // cílový status
                REJECTED,           // status, při kterém hlásíme "už je zamítnut"
                NotificationType.PLAYER_REJECTED,
                "BE - Hráč už je zamítnut.",
                "Hráč %s byl úspěšně zamítnut"
        );
    }
    // TODO - msg builder - dvě zprávy
    @Transactional
    public void changePlayerUser(Long id, Long newUserId) {
        PlayerEntity player = findPlayerOrThrow(id);
        AppUserEntity newUser = findUserOrThrow(newUserId);
        AppUserEntity oldUser = player.getUser();

        if (oldUser != null && oldUser.getId().equals(newUserId)) {
            throw new InvalidChangePlayerUserException();
        }
        player.setUser(newUser);
        PlayerEntity saved = playerRepository.save(player);

        notifyPlayer(saved, NotificationType.PLAYER_CHANGE_USER, newUser);
        notifyUser(newUser, NotificationType.PLAYER_CHANGE_USER, player);
    }

    /**
     * Vrátí všechny hráče v systému namapované na {@link PlayerDTO}.
     */
    @Override
    public List<PlayerDTO> getAllPlayers() {
        return playerRepository.findAll().stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    /**
     * Vrátí jednoho hráče podle ID.
     *
     * @param id ID hráče
     * @return {@link PlayerDTO} odpovídající hráči
     * @throws PlayerNotFoundException pokud hráč s daným ID neexistuje
     */
    @Override
    public PlayerDTO getPlayerById(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);
        return playerMapper.toDTO(player);
    }

    /**
     * Vrátí všechny hráče, kteří patří uživateli s daným emailem
     * ({@link AppUserEntity#getEmail()}), seřazené podle ID vzestupně.
     *
     * @param email email uživatele
     */
    @Override
    public List<PlayerDTO> getPlayersByUser(String email) {
        return playerRepository.findByUser_EmailOrderByIdAsc(email).stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    // ======================
    // CURRENT PLAYER – SESSION
    // ======================

    /**
     * Nastaví aktuálního hráče pro daného uživatele.
     * <p>
     * Kroky:
     * <ol>
     *     <li>najde hráče podle ID,</li>
     *     <li>ověří, že hráč patří danému uživateli (podle emailu),</li>
     *     <li>předá ID hráče do {@link CurrentPlayerService#setCurrentPlayerId(Long)}.</li>
     * </ol>
     *
     * @param userEmail email přihlášeného uživatele
     * @param playerId  ID hráče, který má být nastaven jako aktuální
     * @throws PlayerNotFoundException        pokud hráč neexistuje
     * @throws ForbiddenPlayerAccessException pokud hráč nepatří uživateli
     */
    @Override
    public SuccessResponseDTO setCurrentPlayerForUser(String userEmail, Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        assertPlayerBelongsToUser(player, userEmail);

        currentPlayerService.setCurrentPlayerId(playerId);

        String message = "BE - Aktuální hráč nastaven na ID: " + playerId;
        return buildSuccessResponse(message, playerId);
    }

    // NOVÁ LOGIKA AUTO-SELECTU HRÁČE PODLE AppUserSettings.playerSelectionMode
    @Override
    public SuccessResponseDTO autoSelectCurrentPlayerForUser(String userEmail) {

        // zjistit nastavení uživatele (včetně playerSelectionMode)
        var userSettingsDto = appUserSettingsService.getSettingsForUser(userEmail);

        PlayerSelectionMode mode = PlayerSelectionMode.FIRST_PLAYER; // bezpečný default
        if (userSettingsDto.getPlayerSelectionMode() != null) {
            mode = PlayerSelectionMode.valueOf(userSettingsDto.getPlayerSelectionMode());

        }

        // podle režimu nastavení se rozhodnout, co udělat
        switch (mode) {
            case FIRST_PLAYER:
                return autoSelectFirstPlayer(userEmail);
            case ALWAYS_CHOOSE:
                // - pokud má uživatel přesně 1 hráče -> vybere se automaticky
                // - pokud má 0 nebo více než 1 hráče -> nevybere se nikdo a FE má nabídnout ruční výběr
                return autoSelectIfSinglePlayer(userEmail);
            default:
                // bezpečnostní fallback – chová se jako FIRST_PLAYER
                return autoSelectFirstPlayer(userEmail);
        }
    }

    /**
     * Pomocná metoda: najde prvního hráče uživatele (podle ID)
     * a nastaví ho jako aktuálního hráče v CurrentPlayerService.
     */
    private SuccessResponseDTO autoSelectFirstPlayer(String userEmail) {
        // najdeme všechny hráče uživatele seřazené podle ID vzestupně
        List<PlayerEntity> players = playerRepository.findByUser_EmailOrderByIdAsc(userEmail);

        if (players.isEmpty()) {
            // nemá žádného hráče – currentPlayer vyčistíme
            currentPlayerService.clear();
            throw new PlayerNotFoundException("BE - Uživatel nemá přiřazeného žádného hráče. Nelze automaticky vybrat.", userEmail);
        }

        // vezmeme prvního hráče (nejstarší ID)
        PlayerEntity firstPlayer = players.get(0);
        if (firstPlayer.getPlayerStatus() != APPROVED) {
            throw new InvalidPlayerStatusException(
                    "BE - Nelze zvolit hráče, který není schválen administrátorem."
            );
        }

        currentPlayerService.setCurrentPlayerId(firstPlayer.getId());
        String message = "BE - Automaticky byl vybrán první hráč: " + firstPlayer.getFullName();
        return buildSuccessResponse(message, firstPlayer.getId());
    }

    /**
     * Pokud má uživatel přesně jednoho hráče, automaticky ho vybere
     * jako currentPlayer.
     * <p>
     * Používá se v režimu ALWAYS_CHOOSE:
     * - 0 hráčů  -> nevybere se nikdo, FE má nabídnout vytvoření hráče
     * - 1 hráč   -> hráč se automaticky vybere
     * - 2+ hráčů -> nevybere se nikdo, FE má nabídnout ruční výběr
     */
    private SuccessResponseDTO autoSelectIfSinglePlayer(String userEmail) {
        List<PlayerEntity> players = playerRepository
                .findByUser_EmailOrderByIdAsc(userEmail).stream()
                .filter(p -> p.getPlayerStatus() == APPROVED)
                .toList();

        if (players.isEmpty()) {
            // žádný hráč -> nemáme co vybrat
            currentPlayerService.clear();

            throw new PlayerNotFoundException(
                    "BE - Uživatel nemá přiřazeného žádného hráče schváleného Administrátorem. Nelze automaticky vybrat.",
                    userEmail
            );
        }
        if (players.size() == 1) {
            // přesně jeden hráč -> vybereme ho i v režimu ALWAYS_CHOOSE
            PlayerEntity onlyPlayer = players.get(0);

            currentPlayerService.setCurrentPlayerId(onlyPlayer.getId());

            String message = "BE - Byl vybrán jediný schválený hráč: " + onlyPlayer.getFullName();
            return buildSuccessResponse(message, onlyPlayer.getId());
        }

        // TODO PRO FRONTEND
        // více hráčů -> nevybíráme, FE musí nabídnout výběr hráče
        currentPlayerService.clear();

        StringBuilder sb = new StringBuilder();
        for (PlayerEntity player : players) {
            sb.append(players.indexOf(player) + 1);
            sb.append(". - ");
            sb.append(player.getFullName());
            sb.append(" / ");
        }
        String message = "BE - uživatel má více hráču a musí je vybrat manuálně dle nastavení: " + sb;
        return buildSuccessResponse(message, 0L);
    }

    /**
     * Změní přiřazeného uživatele k hráči.
     * <p>
     * Typické použití:
     * <ul>
     *     <li>oprava chybně spárovaného hráče a uživatele,</li>
     *     <li>převod hráče pod jiný účet (např. rodič → jiný rodič),</li>
     *     <li>úklid dat po sloučení / změně uživatelských účtů.</li>
     * </ul>
     * <p>
     * Kroky:
     * <ol>
     *     <li>najde hráče podle ID ({@link #findPlayerOrThrow(Long)}),</li>
     *     <li>najde nového uživatele podle ID ({@link #findUserOrThrow(Long)}),</li>
     *     <li>ověří, zda už není hráč přiřazen tomuto uživateli,</li>
     *     <li>pokud ano → vyhodí {@link InvalidChangePlayerUserException},</li>
     *     <li>pokud ne → přepíše vazbu {@code player.user} na nového uživatele.</li>
     * </ol>
     * <p>
     * Metoda:
     * <ul>
     *     <li>neposílá žádné notifikace,</li>
     *     <li>nezasahuje do nastavení „current player“ – to případně řeší volající.</li>
     * </ul>
     *
     * @param id        ID hráče, kterému se mění vazba na uživatele
     * @param newUserId ID nového {@link AppUserEntity}, ke kterému má být hráč přiřazen
     * @throws PlayerNotFoundException          pokud hráč s daným ID neexistuje
     * @throws UserNotFoundException            pokud uživatel s daným ID neexistuje
     * @throws InvalidChangePlayerUserException pokud je hráč již přiřazen tomuto uživateli
     */


// ======================
// PRIVATE HELPERY – ENTITY / DUPLICITY
// ======================

    /**
     * Najde hráče podle ID, nebo vyhodí {@link PlayerNotFoundException}.
     */
    private PlayerEntity findPlayerOrThrow(Long Id) {
        return playerRepository.findById(Id)
                .orElseThrow(() -> new PlayerNotFoundException(Id));
    }

    /**
     * Najde uživatele podle ID, nebo vyhodí {@link UserNotFoundException}.
     */
    private AppUserEntity findUserOrThrow(Long Id) {
        return appUserRepository.findById(Id)
                .orElseThrow(() -> new UserNotFoundException(Id));
    }

    /**
     * Kontrola duplicity kombinace jméno + příjmení.
     *
     * @param name     jméno hráče
     * @param surname  příjmení hráče
     * @param ignoreId ID hráče, kterého chceme ignorovat (typicky hráč,
     *                 kterého zrovna upravujeme), nebo {@code null} u create
     */
    private void ensureUniqueNameSurname(String name, String surname, Long ignoreId) {
        Optional<PlayerEntity> duplicateOpt = playerRepository.findByNameAndSurname(name, surname);

        if (duplicateOpt.isPresent()) {
            PlayerEntity duplicate = duplicateOpt.get();

            // pokud máme ignoreId, dovolíme "duplicitu sám se sebou"
            if (ignoreId == null || !duplicate.getId().equals(ignoreId)) {
                throw new DuplicateNameSurnameException(name, surname);
            }
        }
    }

    /**
     * Ověří, že hráč skutečně patří danému uživateli (porovnává email v uživateli).
     *
     * @throws ForbiddenPlayerAccessException pokud hráč nepatří danému uživateli
     */
    private void assertPlayerBelongsToUser(PlayerEntity player, String userEmail) {
        if (player.getUser() == null ||
                player.getUser().getEmail() == null ||
                !player.getUser().getEmail().equals(userEmail)) {

            throw new ForbiddenPlayerAccessException(player.getId());
        }
    }

    /**
     * Pomocná metoda pro jednotné vytváření {@link SuccessResponseDTO}
     * (delete / approve / reject / nastavení current player).
     */
    private SuccessResponseDTO buildSuccessResponse(String message, Long id) {
        return new SuccessResponseDTO(
                message,
                id,
                LocalDateTime.now().toString()
        );
    }

    /**
     * Obecná pomocná metoda pro změnu statusu hráče (approve/reject).
     *
     * @param id                     ID hráče
     * @param targetStatus           cílový status, na který se má hráč nastavit
     * @param alreadyStatus          status, který znamená „už je v tomto stavu“
     * @param notificationType       typ notifikace, která se má odeslat
     * @param alreadyMessage         text chyby, pokud je hráč už v {@code alreadyStatus}
     * @param successMessageTemplate šablona textu pro SuccessResponseDTO
     */
    private SuccessResponseDTO changePlayerStatus(Long id,
                                                  PlayerStatus targetStatus,
                                                  PlayerStatus alreadyStatus,
                                                  NotificationType notificationType,
                                                  String alreadyMessage,
                                                  String successMessageTemplate) {

        PlayerEntity player = findPlayerOrThrow(id);

        // ochrana proti dvojímu schválení / zamítnutí
        if (player.getPlayerStatus() == alreadyStatus) {
            throw new InvalidPlayerStatusException(alreadyMessage);
        }

        player.setPlayerStatus(targetStatus);

        if (targetStatus == APPROVED && player.getSettings() == null) {
            PlayerSettingsEntity settings =
                    playerSettingsService.createDefaultSettingsForPlayer(player);
            player.setSettings(settings); // obousměrný vztah, cascade se postará o persist
        }

        PlayerEntity saved = playerRepository.save(player);

        notificationType = resolveNotificationType(targetStatus);
        if (notificationType != null) {
            notifyPlayer(saved, notificationType, saved);
        }


        String message = String.format(successMessageTemplate, saved.getFullName());
        return buildSuccessResponse(message, id);
    }

    // ====================================================
    // PRIVÁTNÍ HELPERY – NAČÍTÁNÍ ENTIT A ZÁKLADNÍ LOGIKA
    // ====================================================
    //TODO - možná změnit Object context
    private void notifyPlayer(PlayerEntity player, NotificationType type, Object context) {
        notificationService.notifyPlayer(player, type, context);
    }

    private void notifyUser(AppUserEntity user, NotificationType type, Object context) {
        notificationService.notifyUser(user, type, context);
    }

    /**
     * Převede výsledný {@link PlayerStatus} na typ notifikace.
     *
     * @return odpovídající {@link NotificationType}, nebo {@code null},
     * pokud se pro daný status notifikace neposílá
     * PENDING - nevyužíváme - zasláno při vytvoření hráče
     */
    private NotificationType resolveNotificationType(PlayerStatus newStatus) {
        return switch (newStatus) {
            case APPROVED -> NotificationType.PLAYER_APPROVED;
            case REJECTED -> NotificationType.MATCH_REGISTRATION_CANCELED;
            default -> null;
        };
    }

}





-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerSettingsService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerSettingsEntity;
import cz.phsoft.hokej.models.dto.PlayerSettingsDTO;

/**
 * Service pro práci s nastavením hráče (PlayerSettingsEntity).
 *
 * Řeší:
 * - načtení nastavení konkrétního hráče,
 * - aktualizaci nastavení konkrétního hráče,
 * - případně nastavení pro aktuálního hráče (currentPlayer).
 */
public interface PlayerSettingsService {

    /**
     * Vrátí nastavení pro hráče podle jeho ID.
     * Pokud nastavení ještě neexistuje, vytvoří se s default hodnotami.
     *
     * Autorizace (vlastnictví hráče / role admin) se řeší
     * na úrovni controlleru nebo vyšší servisní vrstvy.
     */
    PlayerSettingsDTO getSettingsForPlayer(Long playerId);

    /**
     * Aktualizuje nastavení pro hráče podle jeho ID.
     *
     * @param playerId ID hráče
     * @param dto      nové nastavení
     * @return aktualizované nastavení
     */
    PlayerSettingsDTO updateSettingsForPlayer(Long playerId, PlayerSettingsDTO dto);

    PlayerSettingsEntity createDefaultSettingsForPlayer(PlayerEntity player);
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerSettingsServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerSettingsEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.data.repositories.PlayerSettingsRepository;
import cz.phsoft.hokej.models.dto.PlayerSettingsDTO;
import cz.phsoft.hokej.models.mappers.PlayerSettingsMapper;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

/**
 * Implementace service pro práci s nastavením hráče.
 */
@Service
@Transactional
public class PlayerSettingsServiceImpl implements PlayerSettingsService {

    private final PlayerRepository playerRepository;
    private final PlayerSettingsRepository playerSettingsRepository;
    private final PlayerSettingsMapper mapper;

    public PlayerSettingsServiceImpl(PlayerRepository playerRepository,
                                     PlayerSettingsRepository playerSettingsRepository,
                                     PlayerSettingsMapper mapper) {
        this.playerRepository = playerRepository;
        this.playerSettingsRepository = playerSettingsRepository;
        this.mapper = mapper;
    }

    @Override
    public PlayerSettingsDTO getSettingsForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        Optional<PlayerSettingsEntity> existingOpt =
                playerSettingsRepository.findByPlayer(player);

        PlayerSettingsEntity settings = existingOpt.orElseGet(() -> {
            PlayerSettingsEntity created = createDefaultSettingsForPlayer(player);
            return playerSettingsRepository.save(created);
        });

        return mapper.toDTO(settings);
    }

    @Override
    public PlayerSettingsDTO updateSettingsForPlayer(Long playerId, PlayerSettingsDTO dto) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        PlayerSettingsEntity settings = playerSettingsRepository.findByPlayer(player)
                .orElseGet(() -> createDefaultSettingsForPlayer(player));

        mapper.updateEntityFromDTO(dto, settings);

        // pro jistotu napojení
        settings.setPlayer(player);

        PlayerSettingsEntity saved = playerSettingsRepository.save(settings);

        return mapper.toDTO(saved);
    }

    // =========================
    // HELPER METODY
    // =========================

    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }
    @Override
    public PlayerSettingsEntity createDefaultSettingsForPlayer(PlayerEntity player) {
        PlayerSettingsEntity settings = new PlayerSettingsEntity();
        settings.setPlayer(player);

        // defaulty – stejné jako v entitě, ale explicitně

        settings.setContactEmail(null);
        settings.setContactPhone(null);

        // POZOR: tady je přesun staré logiky z PlayerEntity.emailEnabled / smsEnabled
        // Původně jsi měl tyto příznaky v PlayerEntity – teď žijí tady:
        settings.setNotifyOnRegistration(true);
        settings.setNotifyOnExcuse(true);
        settings.setNotifyOnMatchChange(true);
        settings.setNotifyOnMatchCancel(true);
        settings.setNotifyOnPayment(false);

        settings.setNotifyReminders(true);
        settings.setReminderHoursBefore(24);

        return settings;
    }


}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\SeasonService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.SeasonEntity;
import cz.phsoft.hokej.models.dto.SeasonDTO;

import java.util.List;

/**
 * Rozhraní pro správu sezón v aplikaci.
 * <p>
 * Definuje kontrakt pro práci se sezónami, které slouží
 * jako časový rámec pro organizaci zápasů, statistik
 * a dalších herních dat.
 * </p>
 *
 * Účel:
 * <ul>
 *     <li>správa životního cyklu sezón (vytvoření, úprava, aktivace),</li>
 *     <li>určení aktuálně aktivní sezóny,</li>
 *     <li>poskytnutí přehledu všech sezón v systému.</li>
 * </ul>
 *
 * Použití:
 * <ul>
 *     <li>využívá se v controllerech a business službách,</li>
 *     <li>slouží jako centrální zdroj informace o aktivní sezóně.</li>
 * </ul>
 *
 * Architektonické zásady:
 * <ul>
 *     <li>většina operací pracuje s DTO objekty,</li>
 *     <li>získání aktivní sezóny může vracet entitu
 *     (např. pro interní business logiku).</li>
 * </ul>
 */
public interface SeasonService {

    /**
     * Vytvoří novou sezónu.
     * <p>
     * Implementace je zodpovědná za validaci období sezóny
     * (např. že začátek je před koncem a že se sezóny nepřekrývají).
     * </p>
     *
     * @param season data nové sezóny
     * @return vytvořená sezóna
     */
    SeasonDTO createSeason(SeasonDTO season);

    /**
     * Aktualizuje existující sezónu.
     *
     * @param id     ID sezóny, která má být aktualizována
     * @param season nové hodnoty sezóny
     * @return aktualizovaná sezóna
     */
    SeasonDTO updateSeason(Long id, SeasonDTO season);

    /**
     * Vrátí aktuálně aktivní sezónu.
     * <p>
     * Aktivní sezóna představuje časový rámec,
     * ve kterém jsou zápasy považovány za platné.
     * </p>
     *
     * @return aktivní sezóna jako entita
     */
    SeasonEntity getActiveSeason();

    /**
     * Vrátí seznam všech sezón v systému.
     * <p>
     * Typicky slouží pro administrátorské přehledy.
     * </p>
     *
     * @return seznam všech sezón
     */
    List<SeasonDTO> getAllSeasons();

    /**
     * Nastaví zadanou sezónu jako aktivní.
     * <p>
     * Implementace zajistí, že v systému existuje
     * vždy maximálně jedna aktivní sezóna.
     * </p>
     *
     * @param seasonId ID sezóny, která má být nastavena jako aktivní
     */
    void setActiveSeason(Long seasonId);

    SeasonDTO getActiveSeasonOrNull();

    SeasonDTO getSeasonById(Long id);
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\SeasonServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.SeasonEntity;
import cz.phsoft.hokej.data.repositories.SeasonRepository;
import cz.phsoft.hokej.exceptions.InvalidSeasonPeriodDateException;
import cz.phsoft.hokej.exceptions.InvalidSeasonStateException;
import cz.phsoft.hokej.exceptions.SeasonNotFoundException;
import cz.phsoft.hokej.exceptions.SeasonPeriodOverlapException;
import cz.phsoft.hokej.models.dto.SeasonDTO;
import cz.phsoft.hokej.models.mappers.SeasonMapper;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;

/**
 * Service vrstva pro správu sezón ({@link SeasonEntity}).
 *
 * Zodpovídá za:
 * <ul>
 *     <li>vytvoření nové sezóny (včetně validace dat a překryvů),</li>
 *     <li>úpravu existující sezóny (včetně pravidel pro aktivní sezónu),</li>
 *     <li>získání aktuálně aktivní sezóny,</li>
 *     <li>návrat všech sezón v logickém pořadí,</li>
 *     <li>nastavení konkrétní sezóny jako aktivní (a deaktivaci ostatních).</li>
 * </ul>
 *
 * DŮLEŽITÉ INVARIANTY:
 * <ul>
 *     <li>datum začátku musí být před datem konce,</li>
 *     <li>nesmí existovat dvě sezóny, které se časově překrývají,</li>
 *     <li>systém by neměl zůstat bez aktivní sezóny,</li>
 *     <li>v jeden okamžik smí být aktivní právě jedna sezóna.</li>
 * </ul>
 *
 * Třída je čistě doménová:
 * <ul>
 *     <li>neřeší autentizaci/autorizaci (řeší controller + Security),</li>
 *     <li>neposílá notifikace,</li>
 *     <li>zajišťuje konzistentní stav kalendáře sezón pro zbytek aplikace.</li>
 * </ul>
 */
@Service
public class SeasonServiceImpl implements SeasonService {

    private final SeasonRepository seasonRepository;
    private final SeasonMapper mapper;

    public SeasonServiceImpl(SeasonRepository seasonRepository, SeasonMapper mapper) {
        this.seasonRepository = seasonRepository;
        this.mapper = mapper;
    }

    // ======================
    // CREATE
    // ======================

    /**
     * Vytvoří novou sezónu.
     * <p>
     * Kroky:
     * <ol>
     *     <li>zvaliduje datumové rozmezí a překryvy s jinými sezónami,</li>
     *     <li>uloží novou sezónu,</li>
     *     <li>zajistí, že v systému vždy existuje nějaká aktivní sezóna:
     *         <ul>
     *             <li>pokud {@code seasonDTO.isActive() == true} → nastaví ji jako jedinou aktivní,</li>
     *             <li>pokud je to úplně první sezóna v systému (activeCount == 0),
     *                 nastaví tuto novou sezónu jako aktivní i když DTO říká {@code active = false}.</li>
     *         </ul>
     *     </li>
     * </ol>
     *
     * @param seasonDTO vstupní data sezóny
     * @return vytvořená sezóna v podobě {@link SeasonDTO}
     *
     * @throws InvalidSeasonPeriodDateException pokud jsou neplatná data od/do
     * @throws SeasonPeriodOverlapException     pokud se sezóna překrývá s existující
     */
    @Override
    @Transactional
    public SeasonDTO createSeason(SeasonDTO seasonDTO) {
        // u create nemáme ID → předáváme null, validace bere v potaz všechny existující sezóny
        validateDates(seasonDTO, null);

        SeasonEntity entity = mapper.toEntity(seasonDTO);
        SeasonEntity saved = seasonRepository.save(entity);

        long activeCount = seasonRepository.countByActiveTrue();

        if (seasonDTO.isActive()) {
            // nová sezóna má být aktivní → uděláme z ní jedinou aktivní
            setOnlyActiveSeason(saved.getId());
        } else if (activeCount == 0) {
            // v systému není žádná aktivní sezóna → nesmíme zůstat bez aktivní
            // → automaticky tuto novou sezónu nastavíme jako jedinou aktivní
            setOnlyActiveSeason(saved.getId());
        }

        return mapper.toDTO(saved);
    }

    // ======================
    // UPDATE
    // ======================

    /**
     * Aktualizuje existující sezónu.
     * <p>
     * Kroky:
     * <ol>
     *     <li>ověří, že sezóna s daným ID existuje,</li>
     *     <li>zvaliduje datumy s ignorováním této jedné sezóny
     *         (aby se "nepřekrývala sama se sebou"),</li>
     *     <li>zkontroluje, že nelze deaktivovat „poslední“ aktivní sezónu v systému,</li>
     *     <li>promítne změny z DTO do entity a uloží je,</li>
     *     <li>pokud se sezóna z neaktivní stala aktivní, nastaví ji jako JEDINOU aktivní.</li>
     * </ol>
     *
     * @param id        ID upravované sezóny
     * @param seasonDTO nové hodnoty sezóny
     *
     * @throws SeasonNotFoundException      pokud sezóna s daným ID neexistuje
     * @throws InvalidSeasonPeriodDateException pokud jsou neplatná data od/do
     * @throws SeasonPeriodOverlapException pokud se sezóna překrývá s jinou
     * @throws InvalidSeasonStateException  pokud se pokoušíš deaktivovat jedinou aktivní sezónu
     */
    @Override
    @Transactional
    public SeasonDTO updateSeason(Long id, SeasonDTO seasonDTO) {
        // 1) najít existující sezónu
        SeasonEntity existing = seasonRepository.findById(id)
                .orElseThrow(() -> new SeasonNotFoundException(id));

        // 2) validace dat s ignorováním této sezóny (aby se nepočítala jako překryv sama se sebou)
        validateDates(seasonDTO, id);

        boolean wasActive = existing.isActive();
        boolean willBeActive = seasonDTO.isActive();

        // *** STRIKTNÍ REŽIM: nelze deaktivovat jedinou aktivní sezónu
        if (wasActive && !willBeActive) {
            long activeCount = seasonRepository.countByActiveTrue();
            if (activeCount <= 1) {
                throw new InvalidSeasonStateException(
                        "BE - Nelze deaktivovat jedinou aktivní sezónu. " +
                        "Nejprve nastavte jinou sezónu jako aktivní."
                );
            }
        }

        // 3) promítnout změny z DTO do entity a uložit
        mapper.updateEntityFromDTO(seasonDTO, existing);
        SeasonEntity saved = seasonRepository.save(existing);

        // pokud se sezóna z neaktivní stala aktivní → uděláme z ní jedinou aktivní
        if (!wasActive && saved.isActive()) {
            setOnlyActiveSeason(saved.getId());
        }

        return mapper.toDTO(saved);
    }

    // ======================
    // AKTIVNÍ SEZÓNA
    // ======================

    /**
     * Vrátí aktuálně aktivní sezónu ({@link SeasonEntity}).
     *
     * @return aktivní sezóna
     * @throws SeasonNotFoundException pokud není nastavena žádná aktivní sezóna
     */
    @Override
    public SeasonEntity getActiveSeason() {
        return seasonRepository.findByActiveTrue()
                .orElseThrow(() -> new SeasonNotFoundException(
                        "BE - Není nastavena žádná aktivní sezóna."
                ));
    }

    @Override
    public SeasonDTO getActiveSeasonOrNull() {
        return seasonRepository.findByActiveTrue()
                .map(mapper::toDTO)
                .orElse(null);
    }

    @Override
    public SeasonDTO getSeasonById(Long id) {
        SeasonEntity entity = seasonRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Season not found: " + id));
        return mapper.toDTO(entity);
    }

    // ======================
    // SEZNAM VŠECH SEZÓN
    // ======================

    /**
     * Vrátí všechny sezóny seřazené podle začátku ({@code startDate ASC}),
     * namapované na {@link SeasonDTO}.
     * <p>
     * Typické použití:
     * <ul>
     *     <li>administrace sezón,</li>
     *     <li>přehled v UI (tabulka sezón).</li>
     * </ul>
     */
    @Override
    public List<SeasonDTO> getAllSeasons() {
        return seasonRepository.findAllByOrderByStartDateAsc()
                .stream()
                .map(mapper::toDTO)
                .toList();
    }



    // ======================
    // NASTAVENÍ AKTIVNÍ SEZÓNY
    // ======================

    /**
     * Nastaví konkrétní sezónu jako aktivní.
     * <p>
     * Kroky:
     * <ol>
     *     <li>ověří, že sezóna s daným ID existuje,</li>
     *     <li>pomocí {@link #setOnlyActiveSeason(Long)} ji nastaví jako jedinou aktivní
     *         (všechny ostatní sezóny deaktivuje).</li>
     * </ol>
     *
     * @param seasonId ID sezóny, která má být aktivní
     *
     * @throws SeasonNotFoundException pokud sezóna s daným ID neexistuje
     */
    @Override
    @Transactional
    public void setActiveSeason(Long seasonId) {
        // 1) ověř, že existuje
        SeasonEntity toActivate = seasonRepository.findById(seasonId)
                .orElseThrow(() -> new SeasonNotFoundException(seasonId
                ));

        // 2) nastavíme ji jako jedinou aktivní
        setOnlyActiveSeason(toActivate.getId());
    }



    // ======================
    // PRIVÁTNÍ VALIDACE DAT
    // ======================

    /**
     * Validuje datumy sezóny a kontroluje překryvy s ostatními sezónami.
     *
     * @param seasonDTO       DTO s daty sezóny
     * @param currentSeasonId ID aktuální sezóny (u UPDATE), nebo {@code null} u CREATE
     *
     * Kontroluje:
     * <ul>
     *     <li>{@code startDate} != null a {@code endDate} != null,</li>
     *     <li>{@code startDate} &lt; {@code endDate},</li>
     *     <li>žádná jiná sezóna se nepřekrývá s intervalem &lt;=end, &gt;=start
     *         (při UPDATE ignoruje sezónu s id = currentSeasonId).</li>
     * </ul>
     *
     * @throws InvalidSeasonPeriodDateException pokud jsou neplatná data
     * @throws SeasonPeriodOverlapException     pokud dochází k překryvu s jinou sezónou
     */
    private void validateDates(SeasonDTO seasonDTO, Long currentSeasonId) {
        LocalDate start = seasonDTO.getStartDate();
        LocalDate end = seasonDTO.getEndDate();

        // základní null-check
        if (start == null || end == null) {
            throw new InvalidSeasonPeriodDateException("BE - Datum od a do nesmí být null.");
        }

        // logická kontrola pořadí
        if (!start.isBefore(end)) {
            throw new InvalidSeasonPeriodDateException("BE - Datum 'od' musí být před 'do'.");
        }

        boolean overlaps;

        if (currentSeasonId == null) {
            // CREATE – překryv s jakoukoli existující sezónou
            overlaps = seasonRepository
                    .existsByStartDateLessThanEqualAndEndDateGreaterThanEqual(end, start);
        } else {
            // UPDATE – překryv s jinou sezónou (id != currentSeasonId)
            overlaps = seasonRepository
                    .existsByStartDateLessThanEqualAndEndDateGreaterThanEqualAndIdNot(
                            end,
                            start,
                            currentSeasonId
                    );
        }

        if (overlaps) {
            throw new SeasonPeriodOverlapException("BE - Sezóna se překrývá s existující sezónou.");
        }
    }

    // ======================
    // PRIVÁTNÍ POMOCNÁ METODA
    // ======================

    /**
     * Nastaví danou sezónu jako JEDINOU aktivní.
     * <p>
     * Implementace:
     * <ul>
     *     <li>načte všechny sezóny z DB,</li>
     *     <li>té s {@code id == activeSeasonId} nastaví {@code active = true},</li>
     *     <li>všem ostatním nastaví {@code active = false},</li>
     *     <li>uloží změny pomocí {@link SeasonRepository#saveAll(Iterable)}.</li>
     * </ul>
     *
     * Tím garantujeme invariant:
     * <ul>
     *     <li>v aplikaci existuje v každém okamžiku právě jedna aktivní sezóna.</li>
     * </ul>
     */
    private void setOnlyActiveSeason(Long activeSeasonId) {
        List<SeasonEntity> all = seasonRepository.findAll();
        for (SeasonEntity season : all) {
            season.setActive(season.getId().equals(activeSeasonId));
        }
        seasonRepository.saveAll(all);
    }
}


