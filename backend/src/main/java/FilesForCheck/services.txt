Balíček (složka): services
Cesta: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services

Seznam souborů:
AppUserHistoryService.java
AppUserHistoryServiceImpl.java
AppUserService.java
AppUserServiceImpl.java
AppUserSettingsService.java
AppUserSettingsServiceImpl.java
CurrentPlayerService.java
CurrentPlayerServiceImpl.java
CurrentSeasonService.java
CurrentSeasonServiceImpl.java
MatchHistoryService.java
MatchHistoryServiceImpl.java
MatchRegistrationHistoryService.java
MatchRegistrationHistoryServiceImpl.java
MatchRegistrationService.java
MatchRegistrationServiceImpl.java
MatchService.java
MatchServiceImpl.java
NotificationDecision.java
package-info.java
PlayerHistoryService.java
PlayerHistoryServiceImpl.java
PlayerInactivityPeriodService.java
PlayerInactivityPeriodServiceImpl.java
PlayerService.java
PlayerServiceImpl.java
PlayerSettingsService.java
PlayerSettingsServiceImpl.java
PlayerStatsService.java
PlayerStatsServiceImpl.java
SeasonHistoryService.java
SeasonHistoryServiceImpl.java
SeasonService.java
SeasonServiceImpl.java



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserHistoryService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.AppUserHistoryDTO;

import java.util.List;

/**
 * Servisní rozhraní pro práci s historií uživatelských účtů.
 *
 * Slouží k načítání historických záznamů uživatele
 * pro auditní a přehledové účely. Historické záznamy
 * jsou typicky vytvářeny databázovými triggery a
 * následně převáděny na DTO objekty pomocí mapperu.
 *
 * Rozhraní je implementováno servisní třídou,
 * která zajišťuje komunikaci s repozitářem
 * a převod entit na DTO.
 */
public interface AppUserHistoryService {

    /**
     * Vrátí historii změn uživatele podle jeho e-mailové adresy.
     *
     * @param email e-mailová adresa uživatele
     * @return seznam historických záznamů uživatele
     */
    List<AppUserHistoryDTO> getHistoryForUser(String email);

    /**
     * Vrátí historii změn uživatele podle jeho identifikátoru.
     *
     * @param id identifikátor uživatele
     * @return seznam historických záznamů uživatele
     */
    List<AppUserHistoryDTO> getHistoryForUser(Long id);
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserHistoryServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.repositories.AppUserHistoryRepository;
import cz.phsoft.hokej.models.dto.AppUserHistoryDTO;
import cz.phsoft.hokej.models.mappers.AppUserHistoryMapper;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * Implementace servisní vrstvy pro práci s historií uživatelských účtů.
 *
 * Zajišťuje načítání historických záznamů uživatele z databáze
 * prostřednictvím repozitáře a jejich převod na DTO objekty
 * pomocí mapperu.
 *
 * Třída neprovádí žádné zápisy do databáze. Historické záznamy
 * jsou vytvářeny databázovými triggery a tato služba slouží
 * výhradně pro čtecí a auditní účely.
 */
@Service
public class AppUserHistoryServiceImpl implements AppUserHistoryService {

    private final AppUserHistoryRepository repository;
    private final AppUserHistoryMapper mapper;

    /**
     * Vytvoří instanci servisní třídy.
     *
     * @param repository repozitář pro přístup k historickým záznamům uživatelů
     * @param mapper mapper pro převod entit na DTO objekty
     */
    public AppUserHistoryServiceImpl(
            AppUserHistoryRepository repository,
            AppUserHistoryMapper mapper
    ) {
        this.repository = repository;
        this.mapper = mapper;
    }

    /**
     * Vrátí historii změn uživatele podle jeho e-mailové adresy.
     *
     * Záznamy jsou načteny z databáze v sestupném pořadí
     * podle času změny a následně převedeny na DTO objekty.
     *
     * @param email e-mailová adresa uživatele
     * @return seznam historických záznamů uživatele
     */
    @Override
    public List<AppUserHistoryDTO> getHistoryForUser(String email) {
        return mapper.toDTOList(
                repository.findByEmailOrderByChangedAtDesc(email)
        );
    }

    /**
     * Vrátí historii změn uživatele podle jeho identifikátoru.
     *
     * Záznamy jsou načteny z databáze v sestupném pořadí
     * podle času změny a následně převedeny na DTO objekty.
     *
     * @param id identifikátor uživatele
     * @return seznam historických záznamů uživatele
     */
    @Override
    public List<AppUserHistoryDTO> getHistoryForUser(Long id) {
        return mapper.toDTOList(
                repository.findByUserIdOrderByChangedAtDesc(id)
        );
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.ForgottenPasswordResetDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;

import java.util.List;

/**
 * Rozhraní pro správu uživatelských účtů aplikace.
 *
 * Definuje se smlouva pro registraci uživatelů, změnu a reset hesla,
 * aktivaci nebo deaktivaci účtů a čtení seznamů uživatelů. Rozhraní
 * se používá v controller vrstvách a v dalších service třídách.
 *
 * Implementace pracuje s DTO objekty a zajišťuje napojení
 * na perzistenční vrstvu (repozitáře) a notifikační mechanismy.
 */
public interface AppUserService {

    /**
     * Zaregistruje nového uživatele do systému.
     *
     * Provádí se kontrola jedinečnosti emailu, shody hesla a jeho potvrzení
     * a další validační pravidla. Nový účet se typicky zakládá jako neaktivní
     * a jeho aktivace se dokončuje přes aktivační odkaz.
     *
     * @param registerUserDTO registrační data nového uživatele
     */
    void register(RegisterUserDTO registerUserDTO);

    /**
     * Aktualizuje údaje uživatele podle emailu.
     *
     * Používá se pro změny běžných údajů (jméno, příjmení, email).
     * Bezpečnost a oprávnění se kontrolují v controller vrstvě.
     *
     * @param email email uživatele, který má být aktualizován
     * @param dto   nové hodnoty uživatelských údajů
     */
    void updateUser(String email, AppUserDTO dto);

    /**
     * Vrací aktuálně přihlášeného uživatele podle emailu.
     *
     * Metoda se používá zejména v kontextu endpointů typu "/me".
     *
     * @param email email přihlášeného uživatele
     * @return DTO reprezentace aktuálního uživatele
     */
    AppUserDTO getCurrentUser(String email);

    /**
     * Vrací seznam všech uživatelů v systému.
     *
     * Typicky se používá v administrátorském rozhraní
     * pro správu uživatelů.
     *
     * @return seznam uživatelů ve formě DTO
     */
    List<AppUserDTO> getAllUsers();

    /**
     * Vrací uživatele podle ID.
     *
     * Používá se v administraci, kde je potřeba pracovat
     * s konkrétním účtem podle jeho identifikátoru.
     *
     * @param userId ID uživatele
     * @return uživatel ve formě DTO
     */
    AppUserDTO getUserById(Long userId);

    /**
     * Změní heslo uživatele.
     *
     * Ověřuje se správnost původního hesla, shoda nového hesla
     * a jeho potvrzení a případné bezpečnostní požadavky.
     *
     * @param email              email uživatele
     * @param oldPassword        původní heslo
     * @param newPassword        nové heslo
     * @param newPasswordConfirm potvrzení nového hesla
     */
    void changePassword(
            String email,
            String oldPassword,
            String newPassword,
            String newPasswordConfirm
    );

    /**
     * Resetuje heslo uživatele na výchozí hodnotu.
     *
     * Operace se typicky používá v administraci, kde se řeší
     * problémy s přihlášením. Konkrétní politika bezpečného
     * zacházení s takovým heslem se řeší v aplikační logice.
     *
     * @param userId ID uživatele, jehož heslo má být resetováno
     */
    void resetPassword(Long userId);

    /**
     * Aktivuje uživatelský účet na základě aktivačního tokenu.
     *
     * Metoda se používá po registraci uživatele, kdy je odkaz
     * zaslán v aktivačním emailu. Při úspěchu se účet označí
     * jako povolený k přihlášení.
     *
     * @param token aktivační token
     * @return true, pokud byla aktivace úspěšná, jinak false
     */
    boolean activateUser(String token);

    /**
     * Aktivuje uživatelský účet v administraci.
     *
     * Aktivace se provádí bez použití aktivačního tokenu,
     * typicky v situaci, kdy má uživatel technický problém
     * s aktivačním emailem.
     *
     * @param id ID uživatele
     */
    void activateUserByAdmin(Long id);

    /**
     * Deaktivuje uživatelský účet v administraci.
     *
     * Účet se ponechá v databázi, ale uživatel se nemůže
     * dočasně přihlásit do aplikace.
     *
     * @param id ID uživatele
     */
    void deactivateUserByAdmin(Long id);

    /**
     * Vytvoří požadavek na reset zapomenutého hesla.
     *
     * Pro daný email se vygeneruje resetovací token a odešle
     * se odpovídající notifikace (například email s odkazem
     * na formulář pro nastavení nového hesla).
     *
     * @param email email uživatele
     */
    void requestForgottenPasswordReset(String email);

    /**
     * Vrací email uživatele pro zadaný resetovací token.
     *
     * Metoda se používá při načítání formuláře pro nastavení
     * nového hesla, aby se ověřilo, ke kterému účtu token patří.
     *
     * @param token resetovací token
     * @return email uživatele
     */
    String getForgottenPasswordResetEmail(String token);

    /**
     * Nastaví nové heslo na základě tokenu pro zapomenuté heslo.
     *
     * Token se ověří, zkontroluje se shoda hesla a jeho potvrzení
     * a poté se heslo uloží v zahashované podobě.
     *
     * @param dto data pro reset zapomenutého hesla
     */
    void forgottenPasswordReset(ForgottenPasswordResetDTO dto);
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.EmailVerificationTokenEntity;
import cz.phsoft.hokej.data.entities.ForgottenPasswordResetTokenEntity;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.EmailVerificationTokenRepository;
import cz.phsoft.hokej.data.repositories.ForgottenPasswordResetTokenRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.ForgottenPasswordResetDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;
import cz.phsoft.hokej.models.mappers.AppUserMapper;
import cz.phsoft.hokej.models.services.email.EmailService;
import cz.phsoft.hokej.models.services.notification.ForgottenPasswordResetContext;
import cz.phsoft.hokej.models.services.notification.NotificationService;
import cz.phsoft.hokej.models.services.notification.UserActivationContext;
import cz.phsoft.hokej.models.services.demo.DemoModeGuard;
import jakarta.transaction.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

/**
 * Implementace servisní vrstvy pro správu aplikačních uživatelských účtů.
 *
 * Zajišťuje registraci uživatele, aktivaci a deaktivaci účtu,
 * změnu a reset hesla a aktualizaci základních údajů.
 * Součástí odpovědnosti je bezpečné uložení hesel pomocí BCrypt
 * a správa ověřovacích a resetovacích tokenů.
 *
 * Notifikace o událostech jsou odesílány prostřednictvím NotificationService.
 * Autentizace a autorizace jsou řešeny v rámci Spring Security
 * a nejsou součástí odpovědnosti této třídy.
 */
@Service
public class AppUserServiceImpl implements AppUserService {

    @Value("${app.frontend-base-url}")
    private String frontendBasUrl;
    @Value("${app.demo-mode:false}")
    private boolean isDemoMode;

    private static final Logger log = LoggerFactory.getLogger(AppUserServiceImpl.class);

    /**
     * Výchozí heslo používané při resetu účtu administrátorem.
     */
    private static final String DEFAULT_RESET_PASSWORD = "Player123";

    /**
     * Základní URL aplikace používaná pro sestavení odkazů
     * v aktivačních a resetovacích notifikacích.
     */
    @Value("${app.base-url}")
    private String baseUrl;

    private final AppUserRepository userRepository;
    private final BCryptPasswordEncoder passwordEncoder;
    private final AppUserMapper appUserMapper;
    private final EmailService emailService;
    private final EmailVerificationTokenRepository tokenRepository;
    private final AppUserSettingsService appUserSettingsService;
    private final NotificationService notificationService;
    private final ForgottenPasswordResetTokenRepository forgottenPasswordResetTokenRepository;
    private final DemoModeGuard demoModeGuard;
    /**
     * Vytvoří instanci servisní třídy.
     *
     * Závislosti jsou předány pomocí konstruktoru a jsou používány
     * pro práci s databází, mapování dat a odesílání notifikací.
     *
     * @param userRepository repozitář pro práci s uživatelskými účty
     * @param passwordEncoder encoder pro hashování a ověření hesel
     * @param appUserMapper mapper pro převod mezi entitami a DTO
     * @param emailService servis pro odesílání e-mailů
     * @param tokenRepository repozitář pro ověřovací tokeny
     * @param appUserSettingsService servis pro správu uživatelských nastavení
     * @param notificationService servis pro odesílání notifikací
     * @param forgottenPasswordResetTokenRepository repozitář pro resetovací tokeny
     */
    public AppUserServiceImpl(AppUserRepository userRepository,
                              BCryptPasswordEncoder passwordEncoder,
                              AppUserMapper appUserMapper,
                              EmailService emailService,
                              EmailVerificationTokenRepository tokenRepository,
                              AppUserSettingsService appUserSettingsService,
                              NotificationService notificationService,
                              ForgottenPasswordResetTokenRepository forgottenPasswordResetTokenRepository,
                              DemoModeGuard demoModeGuard) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
        this.appUserMapper = appUserMapper;
        this.emailService = emailService;
        this.tokenRepository = tokenRepository;
        this.appUserSettingsService = appUserSettingsService;
        this.notificationService = notificationService;
        this.forgottenPasswordResetTokenRepository = forgottenPasswordResetTokenRepository;
        this.demoModeGuard = demoModeGuard;
    }

    /**
     * Zaregistruje nového uživatele.
     *
     * Před vytvořením účtu se ověřuje shoda zadaných hesel
     * a jedinečnost e-mailové adresy. Účet je vytvořen jako neaktivní,
     * je vygenerován ověřovací token a je odeslána notifikace
     * obsahující aktivační odkaz.
     *
     * @param dto registrační údaje uživatele
     */
    @Override
    @Transactional
    public void register(RegisterUserDTO dto) {
        ensurePasswordsMatch(dto.getPassword(), dto.getPasswordConfirm(), null);
        ensureEmailNotUsed(dto.getEmail(), null);

        AppUserEntity user = createUserFromRegisterDto(dto);
        AppUserEntity savedUser = userRepository.save(user);

        EmailVerificationTokenEntity verificationToken =
                createVerificationToken(savedUser);

        String activationLink = buildActivationLink(verificationToken);
        log.info("Aktivační odkaz pro {}: {}", user.getEmail(), activationLink);

        notificationService.notifyUser(
                savedUser,
                NotificationType.USER_CREATED,
                new UserActivationContext(savedUser, activationLink)
        );
    }

    /**
     * Aktivuje uživatelský účet na základě ověřovacího tokenu.
     *
     * Token je vyhledán a je ověřena jeho platnost. Pokud je token neplatný
     * nebo expirovaný, je vrácena hodnota false. Při úspěšné aktivaci
     * je účet povolen a v případě chybějící konfigurace jsou vytvořena
     * výchozí uživatelská nastavení. Použitý token je odstraněn.
     *
     * Po úspěšné aktivaci je odeslána notifikace o aktivaci účtu.
     *
     * @param token aktivační token
     * @return true, pokud byla aktivace provedena, jinak false
     */
    @Override
    @Transactional
    public boolean activateUser(String token) {
        EmailVerificationTokenEntity verificationToken =
                tokenRepository.findByToken(token).orElse(null);

        if (verificationToken == null ||
                verificationToken.getExpiresAt().isBefore(LocalDateTime.now())) {
            return false;
        }

        AppUserEntity user = verificationToken.getUser();
        boolean newlyActivated = false;

        if (!user.isEnabled()) {
            user.setEnabled(true);
            newlyActivated = true;

            if (user.getSettings() == null) {
                appUserSettingsService.createDefaultSettingsForUser(user);
            }
            userRepository.save(user);
        }

        tokenRepository.delete(verificationToken);

        if (newlyActivated) {
            notifyUser(user, NotificationType.USER_ACTIVATED);
        }
        return true;
    }

    /**
     * Aktivuje uživatelský účet v administraci.
     *
     * Ověřuje se, zda se nejedná o administrátorský účet a zda účet již není aktivní.
     * Při úspěšné aktivaci jsou případná chybějící uživatelská nastavení vytvořena
     * a všechny ověřovací tokeny uživatele jsou odstraněny.
     *
     * Po úspěšné aktivaci je odeslána notifikace o aktivaci účtu.
     *
     * @param id identifikátor uživatele
     */
    @Override
    public void activateUserByAdmin(Long id) {
        AppUserEntity user = findUserByIdOrThrow(id);

        if (user.getRole() == Role.ROLE_ADMIN) {
            throw new InvalidAdminActivateDeactivateException(
                    "BE - Administrátorský účet nelze deaktivovat"
            );
        }

        if (user.isEnabled()) {
            throw new InvalidUserActivationException(
                    "BE - Aktivace účtu již byla provedena"
            );
        }
        boolean newlyActivated = false;

        if (!user.isEnabled()) {
            user.setEnabled(true);
            newlyActivated = true;

            if (user.getSettings() == null) {
                appUserSettingsService.createDefaultSettingsForUser(user);
            }

            userRepository.save(user);
        }

        tokenRepository.deleteByUser(user);

        if (newlyActivated) {
            notifyUser(user, NotificationType.USER_ACTIVATED);
        }
    }

    /**
     * Aktualizuje základní údaje uživatele podle e-mailové adresy.
     *
     * Při změně e-mailu se ověřuje, že nová e-mailová adresa není používána
     * jiným účtem. V demo režimu je operace před zápisem do databáze zakázána.
     * Po úspěšné aktualizaci je odeslána notifikace o změně údajů.
     *
     * @param email e-mailová adresa aktuálně přihlášeného uživatele
     * @param dto aktualizovaná data účtu
     */
    @Override
    @Transactional
    public void updateUser(String email, AppUserDTO dto) {
        AppUserEntity user = findUserByEmailOrThrow(email);

        if (!user.getEmail().equals(dto.getEmail())) {
            ensureEmailNotUsed(dto.getEmail(), user.getId());
        }

        demoModeGuard.write(
                user.getId(),
                "Uživatel, který byl vytvořen aplikací, nebude změněn. " +
                        "Aplikace běží v DEMO režimu. Změny budou skutečně provedeny " +
                        "pouze u vámi vytvořených uživatelů."
        );

        user.setName(dto.getName());
        user.setSurname(dto.getSurname());
        user.setEmail(dto.getEmail());

        userRepository.save(user);
        notifyUser(user, NotificationType.USER_UPDATED);
    }

    /**
     * Vrátí detail aktuálně přihlášeného uživatele.
     *
     * Uživatel je vyhledán podle e-mailové adresy a je převeden na DTO.
     *
     * @param email e-mailová adresa uživatele
     * @return DTO reprezentace uživatele
     */
    @Override
    public AppUserDTO getCurrentUser(String email) {
        AppUserEntity user = findUserByEmailOrThrow(email);
        return appUserMapper.toDTO(user);
    }

    /**
     * Vrátí seznam všech uživatelů systému.
     *
     * Záznamy jsou načteny z databáze a jsou mapovány na DTO.
     * Metoda se používá v administraci pro přehled a správu účtů.
     *
     * @return seznam uživatelů ve formě DTO
     */
    @Override
    public List<AppUserDTO> getAllUsers() {
        return userRepository.findAll().stream()
                .map(appUserMapper::toDTO)
                .toList();
    }

    /**
     * Změní heslo aktuálního uživatele.
     *
     * Ověřuje se shoda nového hesla a jeho potvrzení a následně se ověřuje
     * původní heslo. V demo režimu je operace před zápisem do databáze zakázána.
     * Po úspěšné změně hesla je odeslána notifikace.
     *
     * @param email e-mailová adresa uživatele
     * @param oldPassword původní heslo
     * @param newPassword nové heslo
     * @param newPasswordConfirm potvrzení nového hesla
     */
    @Override
    @Transactional
    public void changePassword(String email,
                               String oldPassword,
                               String newPassword,
                               String newPasswordConfirm) {

        ensurePasswordsMatch(
                newPassword,
                newPasswordConfirm,
                "BE - Nové heslo a potvrzení nového hesla se neshodují"
        );

        AppUserEntity user = findUserByEmailOrThrow(email);

        if (!passwordEncoder.matches(oldPassword, user.getPassword())) {
            throw new InvalidOldPasswordException();
        }

        demoModeGuard.write(
                user.getId(),
                "Heslo u uživatele, který byl vytvořen aplikací, nebude změněno. " +
                        "Aplikace běží v DEMO režimu. Změna hesla bude skutečně provedena " +
                        "pouze u vámi vytvořených uživatelů."
        );

        user.setPassword(passwordEncoder.encode(newPassword));
        userRepository.save(user);

        notifyUser(user, NotificationType.USER_CHANGE_PASSWORD);
    }

    /**
     * Resetuje heslo uživatele na výchozí hodnotu.
     *
     * Metoda se používá v administraci při ručním resetu hesla.
     * V demo režimu je operace před zápisem do databáze zakázána.
     * Po úspěšném resetu je odeslána notifikace.
     *
     * @param userId identifikátor uživatele
     */
    @Override
    @Transactional
    public void resetPassword(Long userId) {
        AppUserEntity user = findUserByIdOrThrow(userId);

        if (isDemoMode) {
            throw new DemoModeOperationNotAllowedException(
                    "Heslo nebude resetováno. Aplikace běží v DEMO režimu."
            );
        }

        user.setPassword(passwordEncoder.encode(DEFAULT_RESET_PASSWORD));
        userRepository.save(user);

        notifyUser(user, NotificationType.PASSWORD_RESET);
    }

    /**
     * Deaktivuje uživatelský účet v administraci.
     *
     * Ověřuje se, zda se nejedná o administrátorský účet a zda účet již není deaktivovaný.
     * Po úspěšné deaktivaci je odeslána notifikace o deaktivaci účtu.
     *
     * @param id identifikátor uživatele
     */
    @Override
    public void deactivateUserByAdmin(Long id) {
        AppUserEntity user = findUserByIdOrThrow(id);

        if (user.getRole() == Role.ROLE_ADMIN) {
            throw new InvalidAdminActivateDeactivateException(
                    "BE - Administrátorský účet nelze deaktivovat"
            );
        }

        if (!user.isEnabled()) {
            throw new InvalidUserActivationException(
                    "BE - Deaktivace účtu již byla provedena"
            );
        }

        demoModeGuard.write(
                user.getId(),
                "Uživatel, který byl vytvořen aplikací, nebude deaktivován. " +
                        "Aplikace běží v DEMO režimu. Deaktivace bude skutečně provedena " +
                        "pouze u vámi vytvořených uživatelů."
        );

        user.setEnabled(false);
        userRepository.save(user);

        notifyUser(user, NotificationType.USER_DEACTIVATED);
    }


    /**
     * Vrátí uživatele podle identifikátoru ve formě DTO.
     *
     * Metoda se používá v administraci při zobrazení detailu účtu.
     *
     * @param id identifikátor uživatele
     * @return DTO reprezentace uživatele
     */
    public AppUserDTO getUserById(Long id) {
        AppUserEntity user = findUserByIdOrThrow(id);
        return appUserMapper.toDTO(user);
    }

    /**
     * Vytvoří požadavek na reset zapomenutého hesla.
     *
     * Pokud uživatel pro daný e-mail neexistuje, není vyhozena chyba
     * a metoda se ukončí, aby nebylo možné odvodit existenci účtu.
     * Před vygenerováním nového tokenu jsou odstraněny případné staré tokeny.
     * Následně je odeslána notifikace obsahující odkaz pro nastavení nového hesla.
     *
     * @param email e-mailová adresa uživatele
     */
    @Override
    @Transactional
    public void requestForgottenPasswordReset(String email) {
        AppUserEntity user = userRepository.findByEmail(email)
                .orElse(null);

        if (user == null) {
            log.info("Požadavek na forgotten password reset pro neexistující email: {}", email);
            return;
        }

        forgottenPasswordResetTokenRepository.deleteByUser(user);

        ForgottenPasswordResetTokenEntity forgottenPasswordToken = createResetPasswordToken(user);
        String resetPasswordlink = buildResetPasswordlink(forgottenPasswordToken);

        log.info("Odkaz pro reset hesla {}: {}", user.getEmail(), resetPasswordlink);

        notifyUser(
                user,
                NotificationType.FORGOTTEN_PASSWORD_RESET_REQUEST,
                new ForgottenPasswordResetContext(user, resetPasswordlink)
        );
    }

    /**
     * Vrátí e-mailovou adresu uživatele svázanou se zadaným resetovacím tokenem.
     *
     * Token je vyhledán a je ověřena jeho platnost. Metoda se používá
     * při načítání formuláře pro zadání nového hesla.
     *
     * @param token resetovací token
     * @return e-mailová adresa uživatele
     */
    @Override
    @Transactional
    public String getForgottenPasswordResetEmail(String token) {
        ForgottenPasswordResetTokenEntity resetToken =
                forgottenPasswordResetTokenRepository.findByToken(token)
                        .orElseThrow(InvalidResetTokenException::new);

        if (resetToken.getExpiresAt().isBefore(LocalDateTime.now())) {
            throw new InvalidResetTokenException("BE - Reset token expiroval.");
        }

        return resetToken.getUser().getEmail();
    }

    /**
     * Nastaví nové heslo na základě resetovacího tokenu.
     *
     * Ověřuje se shoda nového hesla a jeho potvrzení a platnost tokenu.
     * Nové heslo je uloženo v zahashované podobě a použitý token je odstraněn.
     * Po úspěšném dokončení je odeslána notifikace o dokončeném resetu hesla.
     *
     * @param dto data pro reset zapomenutého hesla
     */
    @Override
    @Transactional
    public void forgottenPasswordReset(ForgottenPasswordResetDTO dto) {
        ensurePasswordsMatch(
                dto.getNewPassword(),
                dto.getNewPasswordConfirm(),
                "BE - Nové heslo a potvrzení nového hesla se neshodují"
        );

        ForgottenPasswordResetTokenEntity resetToken =
                forgottenPasswordResetTokenRepository.findByToken(dto.getToken())
                        .orElseThrow(InvalidResetTokenException::new);

        if (resetToken.getExpiresAt().isBefore(LocalDateTime.now())) {
            throw new InvalidResetTokenException("BE - Reset token expiroval.");
        }

        AppUserEntity user = resetToken.getUser();


        demoModeGuard.writeWithFinalize(
                user.getId(),
                "Heslo u uživatele, který byl vytvořen aplikací, nebude ve skutečnosti resetováno. " +
                        "Aplikace běží v DEMO režimu. Reset a změna zapomenutého hesla bude skutečně provedena " +
                        "pouze u vámi vytvořených uživatelů.",
                () -> {
                    user.setPassword(passwordEncoder.encode(dto.getNewPassword()));
                    userRepository.save(user);
                    forgottenPasswordResetTokenRepository.delete(resetToken);
                    notifyUser(user, NotificationType.FORGOTTEN_PASSWORD_RESET_COMPLETED);
                },
                () -> {
                    forgottenPasswordResetTokenRepository.delete(resetToken);
                    notifyUser(user, NotificationType.FORGOTTEN_PASSWORD_RESET_COMPLETED);
                }
        );
    }

    // ==================================================
    // HELPER METODY
    // ==================================================

    private String buildActivationLink(EmailVerificationTokenEntity token) {
        return frontendBasUrl + "/verify?token=" + token.getToken();
    }

    private String buildResetPasswordlink(ForgottenPasswordResetTokenEntity token) {
        return baseUrl + "/api/auth/reset-password?token=" + token.getToken();
    }

    private AppUserEntity findUserByEmailOrThrow(String email) {
        return userRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException(email));
    }

    private AppUserEntity findUserByIdOrThrow(Long id) {
        return userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException(id));
    }

    /**
     * Ověří shodu hesla a jeho potvrzení.
     *
     * Pokud se hodnoty neshodují, je vyhozena výjimka PasswordsDoNotMatchException.
     * Pokud je předán vlastní text, je použit jako chybová zpráva výjimky.
     *
     * @param password heslo
     * @param confirm potvrzení hesla
     * @param customMessage volitelná vlastní chybová zpráva
     */
    private void ensurePasswordsMatch(String password,
                                      String confirm,
                                      String customMessage) {
        if (password == null || confirm == null || !password.equals(confirm)) {
            if (customMessage == null) {
                throw new PasswordsDoNotMatchException();
            }
            throw new PasswordsDoNotMatchException(customMessage);
        }
    }

    /**
     * Ověří, že e-mailová adresa není používána jiným uživatelem.
     *
     * Při registraci je currentUserId null. Při aktualizaci účtu se kontroluje,
     * zda případně nalezený uživatel není totožný s aktualizovaným účtem.
     *
     * @param email e-mailová adresa určená ke kontrole
     * @param currentUserId identifikátor aktuálního uživatele nebo null při registraci
     */
    private void ensureEmailNotUsed(String email, Long currentUserId) {
        userRepository.findByEmail(email).ifPresent(existing -> {
            if (currentUserId == null || !existing.getId().equals(currentUserId)) {
                throw new UserAlreadyExistsException(
                        "BE - Uživatel s tímto emailem již existuje"
                );
            }
        });
    }

    /**
     * Vytvoří nového uživatele na základě registračního DTO.
     *
     * Heslo je uloženo v zahashované podobě. Účet je vytvořen jako neaktivní
     * a je mu nastavena výchozí role ROLE_PLAYER.
     *
     * @param dto registrační data
     * @return nová entita uživatele připravená k uložení
     */
    private AppUserEntity createUserFromRegisterDto(RegisterUserDTO dto) {
        AppUserEntity user = appUserMapper.fromRegisterDto(dto);
        user.setPassword(passwordEncoder.encode(dto.getPassword()));
        user.setRole(Role.ROLE_PLAYER);
        user.setEnabled(false);
        return user;
    }

    /**
     * Vytvoří a uloží ověřovací token pro aktivaci účtu.
     *
     * Token má omezenou platnost a je používán při aktivaci účtu přes odkaz.
     *
     * @param user uživatel, pro kterého se token vytváří
     * @return uložený ověřovací token
     */
    private EmailVerificationTokenEntity createVerificationToken(AppUserEntity user) {
        EmailVerificationTokenEntity token = new EmailVerificationTokenEntity();
        token.setToken(UUID.randomUUID().toString());
        token.setUser(user);
        token.setExpiresAt(LocalDateTime.now().plusHours(24));
        return tokenRepository.save(token);
    }

    /**
     * Vytvoří a uloží resetovací token pro proces resetu zapomenutého hesla.
     *
     * Token má omezenou platnost a je používán pro autorizaci nastavení nového hesla.
     *
     * @param user uživatel, pro kterého se token vytváří
     * @return uložený resetovací token
     */
    private ForgottenPasswordResetTokenEntity createResetPasswordToken(AppUserEntity user) {
        ForgottenPasswordResetTokenEntity token = new ForgottenPasswordResetTokenEntity();
        token.setToken(UUID.randomUUID().toString());
        token.setUser(user);
        token.setExpiresAt(LocalDateTime.now().plusHours(1));
        return forgottenPasswordResetTokenRepository.save(token);
    }

    /**
     * Odešle notifikaci uživateli bez kontextu.
     *
     * Volání je delegováno do NotificationService.
     *
     * @param user uživatel, kterému se notifikace odesílá
     * @param type typ notifikace
     */
    private void notifyUser(AppUserEntity user, NotificationType type) {
        notificationService.notifyUser(user, type, null);
    }

    /**
     * Odešle notifikaci uživateli s volitelným kontextem.
     *
     * Volání je delegováno do NotificationService.
     *
     * @param user uživatel, kterému se notifikace odesílá
     * @param type typ notifikace
     * @param context kontextová data pro šablonu notifikace
     */
    private void notifyUser(AppUserEntity user, NotificationType type, Object context) {
        notificationService.notifyUser(user, type, context);
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserSettingsService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.AppUserSettingsEntity;
import cz.phsoft.hokej.models.dto.AppUserSettingsDTO;

/**
 * Service se používá pro práci s uživatelským nastavením.
 *
 * Odpovědností je získávání, vytváření a aktualizace nastavení
 * v kontextu uživatelského účtu, nikoli v kontextu hráče.
 * V této vrstvě se používá typ AppUserSettingsDTO, aby byla
 * oddělena prezentační vrstva od perzistentních entit.
 */
public interface AppUserSettingsService {

    /**
     * Vrátí nastavení pro uživatele identifikovaného e-mailem.
     * Pokud nastavení neexistuje, vytvoří se nový záznam
     * s výchozími hodnotami a uloží se k danému uživateli.
     *
     * Metoda se typicky používá v controlleru pro načtení
     * dat do formuláře na frontendu.
     *
     * @param userEmail e-mail uživatele, který slouží jako unikátní login
     * @return nastavení uživatele převedené do AppUserSettingsDTO
     */
    AppUserSettingsDTO getSettingsForUser(String userEmail);

    /**
     * Aktualizuje nastavení pro uživatele identifikovaného e-mailem.
     * Pokud uživatel nemá dosud žádné nastavení, vytvoří se nejprve
     * výchozí záznam a poté se na něj aplikují hodnoty z DTO.
     *
     * Metoda se obvykle volá z controlleru po odeslání formuláře
     * s uživatelskými preferencemi.
     *
     * @param userEmail e-mail uživatele, pro kterého se nastavení aktualizuje
     * @param dto nové hodnoty nastavení z frontendu
     * @return aktuální stav nastavení po uložení v podobě AppUserSettingsDTO
     */
    AppUserSettingsDTO updateSettingsForUser(String userEmail, AppUserSettingsDTO dto);

    /**
     * Vytvoří výchozí nastavení pro daného uživatele.
     *
     * Metoda se používá interně při prvním přístupu k nastavení,
     * kdy neexistuje žádný záznam v tabulce s nastavením.
     * Výchozí hodnoty se nastaví tak, aby byla aplikace použitelná
     * i bez ručního nastavení.
     *
     * @param user entita uživatele, ke které se nastavení naváže
     * @return nově vytvořená entita AppUserSettingsEntity s výchozími hodnotami
     */
    AppUserSettingsEntity createDefaultSettingsForUser(AppUserEntity user);

}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserSettingsServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.AppUserSettingsEntity;
import cz.phsoft.hokej.data.enums.GlobalNotificationLevel;
import cz.phsoft.hokej.data.enums.PlayerSelectionMode;
import cz.phsoft.hokej.data.repositories.AppUserSettingsRepository;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.exceptions.UserNotFoundException;
import cz.phsoft.hokej.models.dto.AppUserSettingsDTO;
import cz.phsoft.hokej.models.mappers.AppUserSettingsMapper;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

/**
 * Implementace service pro práci s uživatelským nastavením.
 *
 * Odpovědností je vyhledávání uživatele podle e-mailu,
 * získávání nebo vytváření odpovídajícího AppUserSettingsEntity
 * a mapování na AppUserSettingsDTO. V rámci této třídy se udržuje
 * vazba mezi nastavením a uživatelským účtem.
 *
 * Třída představuje transakční hranici pro operace s uživatelským
 * nastavením. Validace vstupů z HTTP vrstvy a autorizace se řeší
 * v controllerech a bezpečnostní vrstvě.
 */
@Service
@Transactional
public class AppUserSettingsServiceImpl implements AppUserSettingsService {

    private final AppUserRepository appUserRepository;
    private final AppUserSettingsRepository appUserSettingsRepository;
    private final AppUserSettingsMapper mapper;

    /**
     * Vytvoří instanci service s repository a mapperem.
     *
     * Repository se používají pro práci s entitami AppUserEntity
     * a AppUserSettingsEntity. Mapper zajišťuje převod mezi entitou
     * a AppUserSettingsDTO pro komunikaci s frontendem.
     *
     * @param appUserRepository repository pro uživatelské účty
     * @param appUserSettingsRepository repository pro uživatelská nastavení
     * @param mapper mapper pro převod mezi entitou a DTO
     */
    public AppUserSettingsServiceImpl(AppUserRepository appUserRepository,
                                      AppUserSettingsRepository appUserSettingsRepository,
                                      AppUserSettingsMapper mapper) {
        this.appUserRepository = appUserRepository;
        this.appUserSettingsRepository = appUserSettingsRepository;
        this.mapper = mapper;
    }

    /**
     * Načte nastavení pro uživatele identifikovaného e-mailem.
     *
     * Pokud nastavení neexistuje, vytvoří se nová entita s výchozími
     * hodnotami pomocí metody createDefaultSettingsForUser a uloží se.
     * Volající část aplikace tak vždy obdrží validní nastavení.
     *
     * @param userEmail e-mail uživatele, pro kterého se nastavení načítá
     * @return AppUserSettingsDTO s aktuálním nastavením uživatele
     * @throws UserNotFoundException pokud uživatel s daným e-mailem neexistuje
     */
    @Override
    public AppUserSettingsDTO getSettingsForUser(String userEmail) {
        AppUserEntity user = findUserByEmailOrThrow(userEmail);

        Optional<AppUserSettingsEntity> existingOpt = appUserSettingsRepository.findByUser(user);

        AppUserSettingsEntity settings = existingOpt.orElseGet(() -> {
            AppUserSettingsEntity created = createDefaultSettingsForUser(user);
            return appUserSettingsRepository.save(created);
        });

        return mapper.toDTO(settings);
    }

    /**
     * Aktualizuje nastavení pro uživatele identifikovaného e-mailem.
     *
     * Pokud uživatel žádné nastavení nemá, vytvoří se nová entita
     * s výchozími hodnotami a následně se do ní aplikují hodnoty
     * z předaného DTO. Je zajištěno, že nastavení je navázáno
     * na správného uživatele.
     *
     * @param userEmail e-mail uživatele, pro kterého se nastavení aktualizuje
     * @param dto nové hodnoty nastavení z frontendu
     * @return AppUserSettingsDTO reprezentující uložené nastavení
     * @throws UserNotFoundException pokud uživatel s daným e-mailem neexistuje
     */
    @Override
    public AppUserSettingsDTO updateSettingsForUser(String userEmail, AppUserSettingsDTO dto) {
        AppUserEntity user = findUserByEmailOrThrow(userEmail);

        AppUserSettingsEntity settings = appUserSettingsRepository.findByUser(user)
                .orElseGet(() -> createDefaultSettingsForUser(user));

        mapper.updateEntityFromDTO(dto, settings);

        settings.setUser(user);

        AppUserSettingsEntity saved = appUserSettingsRepository.save(settings);

        return mapper.toDTO(saved);
    }

    // =========================================
    // Helper metody
    // =========================================

    /**
     * Najde uživatele podle e-mailu nebo vyhodí výjimku.
     *
     * Metoda centralizuje logiku pro vyhledávání uživatele v databázi.
     *
     * @param email e-mail hledaného uživatele
     * @return entita AppUserEntity, pokud byla nalezena
     * @throws UserNotFoundException pokud uživatel s daným e-mailem neexistuje
     */
    private AppUserEntity findUserByEmailOrThrow(String email) {
        return appUserRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException(email));
    }

    /**
     * Vytvoří výchozí nastavení pro daného uživatele.
     *
     * Výchozí hodnoty jsou nastaveny explicitně, aby byly
     * snadno dohledatelné na jednom místě. Metoda se používá
     * při prvním načtení nastavení nebo při zakládání nového účtu.
     *
     * @param user entita uživatele, ke které se nastavení naváže
     * @return entita AppUserSettingsEntity s výchozími hodnotami
     */
    @Override
    public AppUserSettingsEntity createDefaultSettingsForUser(AppUserEntity user) {
        AppUserSettingsEntity settings = new AppUserSettingsEntity();
        settings.setUser(user);

        settings.setPlayerSelectionMode(PlayerSelectionMode.FIRST_PLAYER);
        settings.setGlobalNotificationLevel(GlobalNotificationLevel.ALL);
        settings.setManagerNotificationLevel(GlobalNotificationLevel.ALL);
        settings.setCopyAllPlayerNotificationsToUserEmail(false);
        settings.setReceiveNotificationsForPlayersWithOwnEmail(false);
        settings.setEmailDigestEnabled(false);
        settings.setEmailDigestTime(null);
        settings.setUiLanguage("cs");
        settings.setTimezone("Europe/Prague");
        settings.setDefaultLandingPage("DASHBOARD");

        appUserSettingsRepository.save(settings);

        return settings;
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\CurrentPlayerService.java
-----

package cz.phsoft.hokej.models.services;

/**
 * Rozhraní se používá pro správu aktuálně zvoleného hráče přihlášeného uživatele.
 *
 * Uživatel může mít v systému více hráčů, ale většina aplikačních operací
 * (registrace na zápasy, přehledy, statistiky) pracuje vždy s jedním
 * jednoznačně určeným hráčem. Rozhraní definuje jednotný kontrakt
 * pro práci s tímto kontextem napříč aplikací.
 *
 * Rozhraní odděluje práci s uživatelským kontextem od business logiky.
 * Konkrétní implementace obvykle ukládá identifikátor hráče do uživatelské
 * session. Ověření existence a stavu hráče je odpovědností implementace.
 */
public interface CurrentPlayerService {

    /**
     * Vrátí identifikátor aktuálně zvoleného hráče.
     *
     * @return ID hráče nebo null, pokud aktuální hráč není nastaven
     */
    Long getCurrentPlayerId();

    /**
     * Nastaví aktuálního hráče v uživatelském kontextu.
     *
     * Metoda slouží ke změně kontextu přihlášeného uživatele
     * na konkrétního hráče. Implementace je odpovědná za to,
     * aby byl zvolen pouze platný hráč v odpovídajícím stavu.
     *
     * @param playerId ID hráče, který má být nastaven jako aktuální
     */
    void setCurrentPlayerId(Long playerId);

    /**
     * Ověří, že je aktuální hráč nastaven.
     *
     * Metoda se používá před operacemi, které vyžadují kontext
     * aktuálně zvoleného hráče. Pokud hráč není zvolen, je vyhozena výjimka.
     *
     * @throws RuntimeException pokud aktuální hráč není nastaven
     */
    void requireCurrentPlayer();

    /**
     * Odstraní informaci o aktuálním hráči z uživatelského kontextu.
     *
     * Metoda se používá zejména při odhlášení uživatele nebo při
     * explicitním resetu uživatelského kontextu.
     */
    void clear();
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\CurrentPlayerServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.CurrentPlayerNotSelectedException;
import cz.phsoft.hokej.exceptions.InvalidPlayerStatusException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.security.SessionKeys;
import cz.phsoft.hokej.security.impersonation.ImpersonationContext;
import jakarta.servlet.http.HttpSession;
import org.springframework.stereotype.Service;

/**
 * Implementace rozhraní CurrentPlayerService.
 *
 * Třída spravuje identifikátor aktuálně zvoleného hráče v HTTP session
 * přihlášeného uživatele. V session se ukládá pouze ID hráče, nikoli
 * celá entita.
 *
 * Pokud je aktivní režim zastoupení administrátorem, je jako aktuální hráč
 * vracen hráč určený v impersonačním kontextu. V takovém případě se hodnota
 * v session nepoužívá a zůstává beze změny.
 *
 * Pomocí PlayerRepository se ověřuje, zda hráč existuje a zda je ve stavu
 * vhodném pro použití v aplikaci.
 *
 * Třída neřeší oprávnění uživatele k danému hráči ani business logiku
 * zápasů a registrací. Tyto oblasti jsou pokryty jinými service třídami.
 */
@Service
public class CurrentPlayerServiceImpl implements CurrentPlayerService {

    /**
     * HTTP session vázaná na přihlášeného uživatele.
     * Slouží k uchování identifikátoru aktuálního hráče.
     */
    private final HttpSession session;

    /**
     * Repository pro práci s entitami hráčů.
     * Používá se k ověření existence hráče a jeho aktuálního stavu.
     */
    private final PlayerRepository playerRepository;

    public CurrentPlayerServiceImpl(HttpSession session,
                                    PlayerRepository playerRepository) {
        this.session = session;
        this.playerRepository = playerRepository;
    }

    /**
     * Vrátí identifikátor aktuálního hráče.
     *
     * Pokud je aktivní režim zastoupení, je vrácen identifikátor impersonovaného
     * hráče. V opačném případě je vrácen identifikátor uložený v HTTP session.
     *
     * @return ID hráče nebo null, pokud aktuální hráč ještě nebyl zvolen
     */
    @Override
    public Long getCurrentPlayerId() {
        Long impersonatedPlayerId = ImpersonationContext.getImpersonatedPlayerId();
        if (impersonatedPlayerId != null) {
            return impersonatedPlayerId;
        }
        return (Long) session.getAttribute(SessionKeys.CURRENT_PLAYER_ID);
    }

    /**
     * Nastaví aktuálního hráče do HTTP session.
     *
     * Před uložením do session se ověří, že hráč existuje
     * a že je ve stavu PlayerStatus.APPROVED. Pokud některá
     * z podmínek není splněna, je vyhozena výjimka.
     *
     * Režim zastoupení tuto operaci nemění. Zvolený hráč se ukládá
     * do session a používá se při běžném režimu bez impersonace.
     *
     * @param playerId ID hráče, který má být nastaven jako aktuální
     * @throws PlayerNotFoundException pokud hráč s daným ID neexistuje
     * @throws InvalidPlayerStatusException pokud hráč není ve schváleném stavu
     */
    @Override
    public void setCurrentPlayerId(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        validatePlayerSelectable(player);

        session.setAttribute(SessionKeys.CURRENT_PLAYER_ID, playerId);
    }

    /**
     * Ověří, že je aktuální hráč nastaven.
     *
     * Metoda se používá před operacemi, které vyžadují kontext
     * aktuálního hráče, například před registrací na zápas
     * nebo při volání endpointů pracujících s „/me“.
     *
     * Pokud je aktivní režim zastoupení, je podmínka považována
     * za splněnou, protože aktuální hráč je určen impersonačním kontextem.
     *
     * @throws CurrentPlayerNotSelectedException pokud aktuální hráč není nastaven
     */
    @Override
    public void requireCurrentPlayer() {
        Long currentPlayerId = getCurrentPlayerId();
        if (currentPlayerId == null) {
            throw new CurrentPlayerNotSelectedException();
        }
    }

    /**
     * Odstraní informaci o aktuálním hráči z HTTP session.
     *
     * Metoda se používá při odhlášení uživatele nebo při resetu
     * uživatelského kontextu, kdy již nemá být vazba na konkrétního hráče.
     *
     * Režim zastoupení se neukládá do session a jeho vyčištění se řeší
     * na úrovni request filtru.
     */
    @Override
    public void clear() {
        session.removeAttribute(SessionKeys.CURRENT_PLAYER_ID);
    }

    // ==================================================
    // Helper metody
    // ==================================================

    /**
     * Najde hráče podle ID nebo vyhodí výjimku.
     *
     * @param playerId ID hledaného hráče
     * @return entita PlayerEntity odpovídající zadanému ID
     * @throws PlayerNotFoundException pokud hráč s daným ID neexistuje
     */
    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    /**
     * Ověří, zda může být hráč zvolen jako aktuální.
     *
     * V současné době je povolen pouze stav PlayerStatus.APPROVED.
     * Ostatní stavy jsou považovány za neplatné pro použití
     * v kontextu přihlášeného uživatele.
     *
     * @param player entita hráče, která má být ověřena
     * @throws InvalidPlayerStatusException pokud hráč není ve schváleném stavu
     */
    private void validatePlayerSelectable(PlayerEntity player) {
        if (player.getPlayerStatus() != PlayerStatus.APPROVED) {
            throw new InvalidPlayerStatusException(
                    "BE - Nelze zvolit hráče, který není schválen administrátorem."
            );
        }
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\CurrentSeasonService.java
-----

package cz.phsoft.hokej.models.services;

/**
 * Rozhraní se používá pro správu aktuálně zvolené sezóny
 * v kontextu přihlášeného uživatele.
 *
 * Sezóna slouží jako globální kontextový filtr pro většinu
 * aplikačních operací, jako jsou zápasy, statistiky a přehledy.
 * Uživatel může pracovat buď s automaticky zvolenou aktivní sezónou,
 * nebo si může sezónu explicitně vybrat.
 *
 * Rozhraní definuje jednotný kontrakt pro práci s aktuální sezónou
 * a odděluje práci se session od business logiky správy sezón.
 */
public interface CurrentSeasonService {

    /**
     * Vrátí identifikátor aktuálně používané sezóny.
     *
     * Pokud je v session uložena sezóna, kterou si uživatel
     * explicitně zvolil, vrátí se tato hodnota.
     * Pokud sezóna nastavena není nebo nebyla zvolena vědomě,
     * použije se globálně aktivní sezóna definovaná v systému.
     *
     * Při použití globálně aktivní sezóny se její identifikátor
     * uloží do session jako automaticky zvolený.
     *
     * @return ID aktuální sezóny nebo null, pokud neexistuje žádná aktivní sezóna
     */
    Long getCurrentSeasonIdOrDefault();

    /**
     * Nastaví sezónu jako aktuální pro přihlášeného uživatele.
     *
     * Metoda se používá v okamžiku, kdy si uživatel sezónu
     * explicitně vybere. Zvolená sezóna je uložena do session
     * jako uživatelská volba.
     *
     * @param seasonId ID sezóny, která má být nastavena jako aktuální
     */
    void setCurrentSeasonId(Long seasonId);

    /**
     * Odstraní informaci o aktuální sezóně z uživatelského kontextu.
     *
     * Metoda se používá zejména při odhlášení uživatele
     * nebo při resetu session.
     */
    void clearCurrentSeason();
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\CurrentSeasonServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.SeasonDTO;
import jakarta.servlet.http.HttpSession;
import org.springframework.stereotype.Service;

/**
 * Implementace rozhraní CurrentSeasonService.
 *
 * Třída spravuje identifikátor aktuálně zvolené sezóny
 * v HTTP session přihlášeného uživatele.
 * Rozlišuje se, zda byla sezóna zvolena explicitně uživatelem,
 * nebo byla nastavena automaticky na základě globálně aktivní sezóny.
 *
 * Správa samotných sezón a jejich životního cyklu není
 * odpovědností této třídy a je řešena v SeasonService.
 */
@Service
public class CurrentSeasonServiceImpl implements CurrentSeasonService {

    /**
     * Název session atributu pro uložení ID aktuální sezóny.
     */
    private static final String CURRENT_SEASON_SESSION_ATTR = "CURRENT_SEASON_ID";

    /**
     * Session atribut určující, zda byla sezóna zvolena uživatelem.
     *
     * Hodnota true značí explicitní uživatelskou volbu.
     * Hodnota false nebo null značí automatické nastavení.
     */
    private static final String CURRENT_SEASON_CUSTOM_ATTR = "CURRENT_SEASON_CUSTOM";

    /**
     * HTTP session přihlášeného uživatele.
     */
    private final HttpSession session;

    /**
     * Service poskytující informace o sezónách.
     *
     * Používá se k získání globálně aktivní sezóny.
     */
    private final SeasonService seasonService;

    public CurrentSeasonServiceImpl(HttpSession session,
                                    SeasonService seasonService) {
        this.session = session;
        this.seasonService = seasonService;
    }

    /**
     * Vrátí identifikátor aktuální sezóny podle stanovené priority.
     *
     * Nejprve se zohlední sezóna explicitně zvolená uživatelem.
     * Pokud taková volba neexistuje, použije se globálně aktivní sezóna.
     * Při automatickém nastavení se identifikátor sezóny uloží do session.
     *
     * @return ID aktuální sezóny nebo null, pokud není k dispozici žádná aktivní sezóna
     */
    @Override
    public Long getCurrentSeasonIdOrDefault() {
        Object value = session.getAttribute(CURRENT_SEASON_SESSION_ATTR);
        Boolean custom = (Boolean) session.getAttribute(CURRENT_SEASON_CUSTOM_ATTR);

        if (Boolean.TRUE.equals(custom) && value != null) {
            return toLong(value);
        }

        SeasonDTO active = seasonService.getActiveSeasonOrNull();
        if (active != null) {
            Long id = active.getId();
            session.setAttribute(CURRENT_SEASON_SESSION_ATTR, id);
            session.setAttribute(CURRENT_SEASON_CUSTOM_ATTR, Boolean.FALSE);
            return id;
        }

        return null;
    }

    /**
     * Nastaví sezónu jako aktuální pro přihlášeného uživatele.
     *
     * Sezóna je uložena do session a označena jako
     * explicitní uživatelská volba.
     *
     * @param seasonId ID sezóny, která má být nastavena
     */
    @Override
    public void setCurrentSeasonId(Long seasonId) {
        session.setAttribute(CURRENT_SEASON_SESSION_ATTR, seasonId);
        session.setAttribute(CURRENT_SEASON_CUSTOM_ATTR, Boolean.TRUE);
    }

    /**
     * Odstraní informaci o aktuální sezóně z HTTP session.
     *
     * Metoda se používá při odhlášení uživatele
     * nebo při resetu uživatelského kontextu.
     */
    @Override
    public void clearCurrentSeason() {
        session.removeAttribute(CURRENT_SEASON_SESSION_ATTR);
        session.removeAttribute(CURRENT_SEASON_CUSTOM_ATTR);
    }

    /**
     * Zajistí bezpečný převod hodnoty ze session na typ Long.
     *
     * Metoda slouží jako ochrana proti rozdílným typům hodnot,
     * které může servlet container vrátit.
     *
     * @param value hodnota načtená ze session
     * @return hodnota převedená na Long
     */
    private Long toLong(Object value) {
        if (value instanceof Long l) return l;
        if (value instanceof Integer i) return i.longValue();
        return Long.valueOf(value.toString());
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchHistoryService.java
-----

package cz.phsoft.hokej.models.services;


import cz.phsoft.hokej.models.dto.MatchHistoryDTO;

import java.util.List;

/**
     * Servisní rozhraní pro práci s historií zápasů.
     *
     * Slouží pouze pro čtení auditních záznamů,
     * zápis se provádí přes databázové triggery.
     */
    public interface MatchHistoryService {

        /**
         * Vrátí historii daného zápasu podle jeho ID.
         *
         * @param matchId ID zápasu z hlavní tabulky matches
         * @return seznam historických záznamů od nejnovějšího po nejstarší
         */
        List<MatchHistoryDTO> getHistoryForMatch(Long matchId);
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchHistoryServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.repositories.MatchHistoryRepository;
import cz.phsoft.hokej.models.dto.MatchHistoryDTO;
import cz.phsoft.hokej.models.mappers.MatchHistoryMapper;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * Implementace servisní vrstvy pro práci s historií zápasů.
 *
 * Zajišťuje převod entit na DTO a volání repozitáře.
 * Nemění ani nevytváří historické záznamy – o to se starají
 * databázové triggery.
 */
@Service
public class MatchHistoryServiceImpl implements MatchHistoryService {

    private final MatchHistoryRepository repository;
    private final MatchHistoryMapper mapper;

    public MatchHistoryServiceImpl(
            MatchHistoryRepository repository,
            MatchHistoryMapper mapper
    ) {
        this.repository = repository;
        this.mapper = mapper;
    }

    @Override
    public List<MatchHistoryDTO> getHistoryForMatch(Long matchId) {
        return mapper.toDTOList(
                repository.findByMatchIdOrderByChangedAtDesc(matchId)
        );
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationHistoryService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.MatchRegistrationHistoryDTO;

import java.util.List;

/**
 * Service se používá pro práci s historickými (auditními) záznamy
 * registrací hráčů k zápasům.
 *
 * Tato service je čistě pro čtení. Pracuje s historickými daty,
 * neprovádí žádné změny v databázi a neobsahuje vlastní business logiku.
 * Slouží k oddělení auditních dotazů od hlavní logiky registrací.
 *
 * Typickým použitím je zobrazení historie změn registrace
 * aktuálně přihlášeného hráče nebo provádění administrativního auditu
 * registrací konkrétního hráče k danému zápasu.
 */
public interface MatchRegistrationHistoryService {

    /**
     * Vrátí historii všech změn registrace aktuálně přihlášeného hráče
     * pro zadaný zápas.
     *
     * Metoda pracuje s kontextem aktuálního hráče
     * a vrací pouze záznamy, které se k tomuto hráči vztahují.
     * Historie je seřazena sestupně podle času změny, takže
     * nejnovější změna je na prvním místě.
     *
     * @param matchId ID zápasu, ke kterému se historie načítá
     * @return seznam historických záznamů registrace hráče k zápasu
     */
    List<MatchRegistrationHistoryDTO> getHistoryForCurrentPlayerAndMatch(Long matchId);

    /**
     * Vrátí historii všech změn registrace zadaného hráče
     * k danému zápasu.
     *
     * Metoda se používá zejména pro administrativní a auditní účely,
     * například při kontrole zásahů do registrací hráčů
     * nebo při řešení sporů a reklamací.
     * Historie je seřazena sestupně podle času změny.
     *
     * @param matchId  ID zápasu
     * @param playerId ID hráče
     * @return seznam historických záznamů registrace hráče k zápasu
     */
    List<MatchRegistrationHistoryDTO> getHistoryForPlayerAndMatch(Long matchId, Long playerId);
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationHistoryServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.repositories.MatchRegistrationHistoryRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.exceptions.MatchNotFoundException;
import cz.phsoft.hokej.models.dto.MatchRegistrationHistoryDTO;
import cz.phsoft.hokej.models.mappers.MatchRegistrationHistoryMapper;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * Implementace rozhraní MatchRegistrationHistoryService.
 *
 * Třída zajišťuje načítání historických záznamů registrací hráčů
 * k zápasům z databáze a jejich převod do DTO. Odpovědností je
 * ověření existence zápasu, provedení dotazu do historie a mapování
 * výsledků do podoby vhodné pro controller a frontend.
 *
 * Třída neprovádí žádné změny stavu systému. Slouží jako read-only
 * vrstva nad auditními daty a nenahrazuje hlavní logiku registrací.
 */
@Service
public class MatchRegistrationHistoryServiceImpl implements MatchRegistrationHistoryService {

    /**
     * Repository pro čtení historických záznamů registrací.
     */
    private final MatchRegistrationHistoryRepository historyRepository;

    /**
     * Mapper pro převod historických entit do DTO.
     */
    private final MatchRegistrationHistoryMapper historyMapper;

    /**
     * Service pro práci s aktuálně zvoleným hráčem.
     *
     * Používá se při načítání historie pro přihlášeného hráče.
     */
    private final CurrentPlayerService currentPlayerService;

    /**
     * Repository pro práci se zápasy.
     *
     * Používá se k ověření, že požadovaný zápas existuje.
     */
    private final MatchRepository matchRepository;

    public MatchRegistrationHistoryServiceImpl(
            MatchRegistrationHistoryRepository historyRepository,
            MatchRegistrationHistoryMapper historyMapper,
            CurrentPlayerService currentPlayerService,
            MatchRepository matchRepository
    ) {
        this.historyRepository = historyRepository;
        this.historyMapper = historyMapper;
        this.currentPlayerService = currentPlayerService;
        this.matchRepository = matchRepository;
    }

    /**
     * Načte historii registrací aktuálně přihlášeného hráče pro daný zápas.
     *
     * Nejprve se ověří, že zápas existuje. Poté se ověří,
     * že je nastaven aktuální hráč, a získá se jeho identifikátor.
     * Následně se načtou auditní záznamy pro kombinaci daného zápasu
     * a aktuálního hráče. Výsledky jsou mapovány do DTO.
     *
     * @param matchId ID zápasu
     * @return seznam historických záznamů registrace aktuálního hráče k zápasu
     * @throws MatchNotFoundException pokud zápas s daným ID neexistuje
     */
    @Override
    public List<MatchRegistrationHistoryDTO> getHistoryForCurrentPlayerAndMatch(Long matchId) {
        MatchEntity match = matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));

        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        var history = historyRepository
                .findByMatchIdAndPlayerIdOrderByChangedAtDesc(match.getId(), currentPlayerId);

        return historyMapper.toDTOList(history);
    }

    /**
     * Načte historii registrací zadaného hráče pro daný zápas.
     *
     * Metoda je vhodná pro administrativní a auditní endpointy,
     * kde se nepracuje s kontextem aktuálního hráče, ale s konkrétním
     * hráčem určeným parametrem. Nejprve se ověří existence zápasu,
     * poté se načtou odpovídající historické záznamy a převedou se do DTO.
     *
     * @param matchId  ID zápasu
     * @param playerId ID hráče
     * @return seznam historických záznamů registrace hráče k zápasu
     * @throws MatchNotFoundException pokud zápas s daným ID neexistuje
     */
    @Override
    public List<MatchRegistrationHistoryDTO> getHistoryForPlayerAndMatch(Long matchId, Long playerId) {
        MatchEntity match = matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));

        var history = historyRepository
                .findByMatchIdAndPlayerIdOrderByChangedAtDesc(match.getId(), playerId);

        return historyMapper.toDTOList(history);
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;

import java.util.List;

/**
 * Rozhraní se používá pro správu registrací hráčů na zápasy.
 *
 * Definuje kontrakt pro práci s účastí hráčů na zápasech
 * z pohledu business logiky aplikace. Poskytuje operace pro
 * vytvoření nebo změnu registrace, získávání přehledů a
 * administrativní zásahy do stavů registrací.
 *
 * Rozhraní pracuje s DTO objekty a odděluje business logiku
 * od persistence vrstvy. Implementace je odpovědná za validace
 * a přechody stavů registrací.
 */
public interface MatchRegistrationService {

    /**
     * Vytvoří nebo aktualizuje registraci hráče na zápas.
     *
     * Metoda slouží jako jednotný vstupní bod pro reakci hráče
     * na zápas. Registrace se podle potřeby vytvoří nebo upraví.
     * Implementace zajišťuje validaci vstupních dat, kontrolu
     * povolených přechodů stavů a uložení výsledné registrace.
     *
     * Typickým scénářem je přihlášení hráče k zápasu, odhlášení
     * nebo omluva z účasti.
     *
     * @param playerId ID hráče, který reaguje na zápas
     * @param request  požadavek obsahující data o registraci
     * @return DTO reprezentace výsledného stavu registrace
     */
    MatchRegistrationDTO upsertRegistration(
            Long playerId,
            MatchRegistrationRequest request
    );

    /**
     * Vrátí seznam registrací pro konkrétní zápas.
     *
     * @param matchId ID zápasu
     * @return seznam registrací hráčů k danému zápasu
     */
    List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId);

    /**
     * Vrátí seznam registrací pro více zápasů.
     *
     * Metoda se typicky používá pro hromadné přehledy
     * nebo statistiky přes více zápasů.
     *
     * @param matchIds seznam ID zápasů
     * @return seznam registrací pro zadané zápasy
     */
    List<MatchRegistrationDTO> getRegistrationsForMatches(List<Long> matchIds);

    /**
     * Vrátí všechny registrace v systému omezené
     * na relevantní sezónu podle implementace.
     *
     * Metoda se používá zejména pro administrátorské přehledy.
     *
     * @return seznam všech registrací
     */
    List<MatchRegistrationDTO> getAllRegistrations();

    /**
     * Vrátí seznam registrací konkrétního hráče.
     *
     * @param playerId ID hráče
     * @return seznam registrací daného hráče
     */
    List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId);

    /**
     * Vrátí seznam hráčů, kteří dosud nereagovali na daný zápas.
     *
     * Metoda se používá například pro připomínkové notifikace
     * nebo pro přehledy nevyřešené účasti.
     *
     * @param matchId ID zápasu
     * @return seznam hráčů bez reakce na zápas
     */
    List<PlayerDTO> getNoResponsePlayers(Long matchId);

    /**
     * Přepočítá stavy registrací pro daný zápas.
     *
     * Metoda slouží k zajištění konzistence stavů registrovaných
     * a rezervních hráčů podle kapacity zápasu, typicky po změnách
     * provedených administrátorem.
     *
     * @param matchId ID zápasu
     */
    void recalcStatusesForMatch(Long matchId);

    /**
     * Změní stav registrace hráče na zápas.
     *
     * Metoda se používá převážně v administrátorském kontextu,
     * kde je nutné ručně upravit stav registrace. Nastavení
     * stavu NO_EXCUSED má vlastní logiku a řeší se samostatně.
     *
     * @param matchId  ID zápasu
     * @param playerId ID hráče
     * @param status   nový stav registrace
     * @return DTO reprezentace aktualizované registrace
     */
    MatchRegistrationDTO updateStatus(
            Long matchId,
            Long playerId,
            PlayerMatchStatus status
    );

    /**
     * Označí hráče jako neomluveného pro konkrétní zápas.
     *
     * Metoda se používá v administrátorském kontextu po vyhodnocení
     * účasti na zápase. Původní omluva se odstraní a registrace
     * se nastaví do stavu NO_EXCUSED včetně poznámky administrátora.
     *
     * @param matchId   ID zápasu
     * @param playerId  ID hráče
     * @param adminNote poznámka administrátora
     * @return DTO reprezentace aktualizované registrace
     */
    MatchRegistrationDTO markNoExcused(
            Long matchId,
            Long playerId,
            String adminNote
    );
    // TODO
    MatchRegistrationDTO cancelNoExcused(Long matchId,
                                         Long playerId,
                                         ExcuseReason excuseReason,
                                         String excuseNote);
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.mappers.MatchRegistrationMapper;
import cz.phsoft.hokej.models.mappers.PlayerMapper;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;
import cz.phsoft.hokej.models.services.notification.NotificationService;
import cz.phsoft.hokej.models.services.sms.SmsMessageBuilder;
import cz.phsoft.hokej.models.services.sms.SmsService;
import jakarta.transaction.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Implementace service vrstvy, která se používá pro správu registrací hráčů na zápasy.
 *
 * V této třídě se zajišťuje vytváření a aktualizace registrací, vyhodnocování stavových přechodů
 * podle kapacity zápasu a poskytování přehledů registrací pro zápas, hráče nebo sadu zápasů.
 *
 * Součástí odpovědnosti je také spouštění notifikací hráčům podle typu změny registrace a v případě potřeby
 * také odesílání SMS zpráv registrovaným hráčům.
 *
 * Třída obsahuje business logiku registrací a souvisejících pravidel. Neřeší prezentaci, UI logiku ani výběr
 * aktuálního hráče, které náleží jiným vrstvám aplikace.
 */
@Service
public class MatchRegistrationServiceImpl implements MatchRegistrationService {

    private static final Logger log = LoggerFactory.getLogger(MatchRegistrationServiceImpl.class);

    private final MatchRegistrationRepository registrationRepository;
    private final MatchRepository matchRepository;
    private final PlayerRepository playerRepository;
    private final MatchRegistrationMapper matchRegistrationMapper;
    private final PlayerMapper playerMapper;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;
    private final NotificationService notificationService;
    private final SeasonService seasonService;
    private final CurrentSeasonService currentSeasonService;

    public MatchRegistrationServiceImpl(
            MatchRegistrationRepository registrationRepository,
            MatchRepository matchRepository,
            PlayerRepository playerRepository,
            MatchRegistrationMapper matchRegistrationMapper,
            PlayerMapper playerMapper,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder,
            NotificationService notificationService,
            SeasonService seasonService,
            CurrentSeasonService currentSeasonService
    ) {
        this.registrationRepository = registrationRepository;
        this.matchRepository = matchRepository;
        this.playerRepository = playerRepository;
        this.matchRegistrationMapper = matchRegistrationMapper;
        this.playerMapper = playerMapper;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
        this.notificationService = notificationService;
        this.seasonService = seasonService;
        this.currentSeasonService = currentSeasonService;
    }

    // ==========================================
    // HLAVNÍ METODA – UPSERT REGISTRACE HRÁČE
    // ==========================================

    /**
     * Vytváří nebo aktualizuje registraci hráče na zápas.
     *
     * Nejprve se načte zápas a hráč a ověří se, že zápas patří do aktivní sezóny.
     * Následně se vyhodnotí, zda aktuálně přihlášený uživatel může registraci upravovat s ohledem na roli
     * a čas zápasu.
     *
     * Podle obsahu požadavku se zvolí větev pro odhlášení, omluvu nebo registraci a určí se cílový stav registrace.
     * Společné údaje se převezmou z požadavku, registrace se uloží a při odhlášení se přepočítají stavy registrací
     * pro daný zápas. Po uložení se podle výsledného stavu odešlou notifikace.
     *
     * @param playerId Identifikátor hráče, jehož registrace se upravuje.
     * @param request Požadavek obsahující parametry změny registrace.
     * @return DTO uložené registrace se stavem odpovídajícím vyhodnoceným pravidlům.
     */
    @Transactional
    @Override
    public MatchRegistrationDTO upsertRegistration(Long playerId, MatchRegistrationRequest request) {

        MatchEntity match = getMatchOrThrow(request.getMatchId());
        PlayerEntity player = getPlayerOrThrow(playerId);

        // Ověření, že zápas patří do aktuálně aktivní sezóny.
        // Zápisy do neaktivní sezóny nejsou povoleny.
        assertMatchInActiveSeason(match);

        // Ověření, zda aktuální uživatel smí měnit registraci
        // s ohledem na svou roli a čas zápasu.
        assertPlayerCanModifyMatch(match);

        MatchRegistrationEntity registration =
                getRegistrationOrNull(playerId, request.getMatchId());

        if (registration == null && !request.isUnregister()) {
            registration = new MatchRegistrationEntity();
            registration.setMatch(match);
            registration.setPlayer(player);
        }

        PlayerMatchStatus newStatus;

        if (request.isUnregister()) {
            newStatus = handleUnregister(request, playerId, registration);
        } else if (request.getExcuseReason() != null) {
            newStatus = handleExcuse(request, match, player, registration);
        } else {
            newStatus = handleRegisterOrReserveOrSubstitute(request, match, player, registration);
        }

        applyRequestDetails(registration, request);

        registration.setStatus(newStatus);
        registration.setTimestamp(now());
        registration.setCreatedBy("user");

        registration = registrationRepository.save(registration);

        if (request.isUnregister()) {
            recalcStatusesForMatch(request.getMatchId());
        }

        NotificationType notificationType = resolveNotificationType(newStatus);
        if (notificationType != null) {
            notifyPlayer(player, notificationType, registration);
        }

        return matchRegistrationMapper.toDTO(registration);
    }

    /**
     * Vyhodnocuje registraci typu REGISTERED, RESERVED nebo SUBSTITUTE a vrací cílový stav registrace.
     *
     * Opakovaná registrace hráče, který je již ve stavu REGISTERED, se neumožňuje.
     * Při volbě SUBSTITUTE se nastaví stav náhradníka, který neblokuje kapacitu zápasu.
     * Při standardní registraci se podle kapacity zápasu určí stav REGISTERED nebo RESERVED.
     *
     * Případná omluva uložená na registraci se před nastavením cílového stavu odstraní.
     *
     * @param request Požadavek obsahující parametry změny registrace.
     * @param match Zápas, ke kterému se registrace vztahuje.
     * @param player Hráč, jehož registrace se upravuje.
     * @param registration Existující registrace, nebo null v případě prvního zápisu.
     * @return Cílový stav registrace odpovídající vyhodnoceným pravidlům.
     */
    private PlayerMatchStatus handleRegisterOrReserveOrSubstitute(
            MatchRegistrationRequest request,
            MatchEntity match,
            PlayerEntity player,
            MatchRegistrationEntity registration
    ) {
        PlayerMatchStatus currentStatus =
                (registration != null) ? registration.getStatus() : null;

        boolean isAlreadyRegistered = currentStatus == PlayerMatchStatus.REGISTERED;

        if (isAlreadyRegistered) {
            throw new DuplicateRegistrationException(request.getMatchId(), player.getId());
        }

        // Registrace jako náhradník (SUBSTITUTE) – hráč je označen jako „možná“
        // a neblokuje kapacitu ani pořadí.
        if (request.isSubstitute()) {
            if (currentStatus == PlayerMatchStatus.SUBSTITUTE) {
                throw new DuplicateRegistrationException(
                        request.getMatchId(),
                        player.getId(),
                        "Hráč již má zaregistrováno - možná"
                );
            }

            clearExcuseIfNeeded(registration);
            return PlayerMatchStatus.SUBSTITUTE;
        }

        PlayerMatchStatus newStatus =
                isSlotAvailable(match) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;

        clearExcuseIfNeeded(registration);
        return newStatus;
    }

    /**
     * Zpracovává odhlášení hráče ze zápasu a vrací cílový stav UNREGISTERED.
     *
     * Odhlášení se umožňuje pouze v případě, že registrace existuje a nachází se ve stavu REGISTERED nebo RESERVED.
     * V opačném případě se vyhodí výjimka signalizující neexistující nebo nepovolenou registraci pro odhlášení.
     *
     * Při úspěšném odhlášení se uloží informace o omluvě z požadavku.
     *
     * @param request Požadavek obsahující parametry odhlášení.
     * @param playerId Identifikátor hráče, jehož registrace se odhlašuje.
     * @param registration Existující registrace hráče na zápas.
     * @return Stav UNREGISTERED, který se má na registraci uložit.
     */
    private PlayerMatchStatus handleUnregister(
            MatchRegistrationRequest request,
            Long playerId,
            MatchRegistrationEntity registration
    ) {
        boolean isAllowedUnregisterStatus =
                registration != null &&
                        (registration.getStatus() == PlayerMatchStatus.REGISTERED
                                || registration.getStatus() == PlayerMatchStatus.RESERVED);

        if (!isAllowedUnregisterStatus) {
            throw new RegistrationNotFoundException(request.getMatchId(), playerId);
        }

        registration.setExcuseReason(request.getExcuseReason());
        registration.setExcuseNote(request.getExcuseNote());

        return PlayerMatchStatus.UNREGISTERED;
    }

    /**
     * Zpracovává omluvu hráče z účasti na zápase a vrací cílový stav EXCUSED.
     *
     * Omluva se umožňuje pouze v případě, že hráč dosud nereagoval na zápas, je veden jako náhradník,
     * nebo je ve stavu NO_EXCUSED. Při porušení pravidel se vyhodí výjimka signalizující nepovolený přechod.
     *
     * Při úspěšné omluvě se uloží důvod a poznámka omluvy z požadavku.
     *
     * @param request Požadavek obsahující parametry omluvy.
     * @param match Zápas, ke kterému se omluva vztahuje.
     * @param player Hráč, jehož omluva se zpracovává.
     * @param registration Existující registrace, nebo null v případě prvního zápisu.
     * @return Stav EXCUSED, který se má na registraci uložit.
     */
    private PlayerMatchStatus handleExcuse(
            MatchRegistrationRequest request,
            MatchEntity match,
            PlayerEntity player,
            MatchRegistrationEntity registration
    ) {
        boolean isNoResponseOrSubstitute =
                (registration == null
                        || registration.getStatus() == null
                        || registration.getStatus() == PlayerMatchStatus.SUBSTITUTE
                        || registration.getStatus() == PlayerMatchStatus.NO_EXCUSED);

        if (!isNoResponseOrSubstitute) {
            throw new DuplicateRegistrationException(
                    request.getMatchId(),
                    player.getId(),
                    "BE - Omluva je možná pouze pokud hráč dosud nereagoval na zápas, nebo byl náhradník."
            );
        }

        registration.setExcuseReason(request.getExcuseReason());
        registration.setExcuseNote(request.getExcuseNote());

        return PlayerMatchStatus.EXCUSED;
    }

    /**
     * Nastavuje registraci do stavu NO_EXCUSED na základě rozhodnutí administrátora.
     *
     * Zápas musí být již odehraný a předchozí stav registrace musí být REGISTERED.
     * Případná omluva se odstraní a uloží se poznámka administrátora. Po změně se odešle notifikace
     * odpovídající výslednému stavu.
     *
     * @param matchId Identifikátor zápasu, pro který se stav upravuje.
     * @param playerId Identifikátor hráče, jehož registrace se upravuje.
     * @param adminNote Poznámka administrátora, která se uloží k registraci.
     * @return DTO aktualizované registrace po změně stavu.
     */
    @Override
    @Transactional
    public MatchRegistrationDTO markNoExcused(Long matchId,
                                              Long playerId,
                                              String adminNote) {

        MatchEntity match = getMatchOrThrow(matchId);
        PlayerEntity player = getPlayerOrThrow(playerId);

        if (match.getDateTime().isAfter(now())) {
            throw new InvalidPlayerStatusException(
                    "BE - Status NO_EXCUSED lze nastavit pouze u již proběhlého zápasu."
            );
        }

        MatchRegistrationEntity registration = getRegistrationOrThrow(playerId, matchId);

        if (registration.getStatus() != PlayerMatchStatus.REGISTERED) {
            throw new InvalidPlayerStatusException(
                    "BE - Status NO_EXCUSED lze nastavit pouze z registrace REGISTERED."
            );
        }

        registration.setExcuseReason(null);
        registration.setExcuseNote(null);

        if (adminNote == null || adminNote.isBlank()) {
            registration.setAdminNote("Nedostavil se bez omluvy");
        } else {
            registration.setAdminNote(adminNote);
        }

        MatchRegistrationEntity updated =
                updateRegistrationStatus(
                        registration,
                        PlayerMatchStatus.NO_EXCUSED,
                        "admin",
                        true
                );

        PlayerMatchStatus newStatus = PlayerMatchStatus.NO_EXCUSED;

        NotificationType notificationType = resolveNotificationType(newStatus);
        if (notificationType != null) {
            notifyPlayer(player, notificationType, updated);
        }

        return matchRegistrationMapper.toDTO(updated);
    }

    // TODO
    /**
     * Nastavuje registraci do stavu EXCUSED na základě rozhodnutí administrátora nebo manažera po předchozím NO_EXCUSED.
     *
     * Zápas musí být již odehraný a předchozí stav registrace musí být NO_EXCUSED.
     * Administrátorská poznámka se odstraní a uloží se důvod a poznámka omluvy.
     * V této operaci se notifikace neodesílají.
     *
     * @param matchId Identifikátor zápasu, pro který se stav upravuje.
     * @param playerId Identifikátor hráče, jehož registrace se upravuje.
     * @param excuseReason Důvod omluvy, který se uloží k registraci.
     * @param excuseNote Poznámka omluvy, která se uloží k registraci.
     * @return DTO aktualizované registrace po změně stavu.
     */
    @Override
    @Transactional
    public MatchRegistrationDTO cancelNoExcused(Long matchId,
                                                Long playerId,
                                                ExcuseReason excuseReason,
                                                String excuseNote) {

        MatchEntity match = getMatchOrThrow(matchId);
        PlayerEntity player = getPlayerOrThrow(playerId);

        if (match.getDateTime().isAfter(now())) {
            throw new InvalidPlayerStatusException(
                    "BE - Status EXCUSED po NO-EXCUSED lze nastavit pouze u již proběhlého zápasu."
            );
        }

        MatchRegistrationEntity registration = getRegistrationOrThrow(playerId, matchId);

        if (registration.getStatus() != PlayerMatchStatus.NO_EXCUSED) {
            throw new InvalidPlayerStatusException(
                    "BE - Status EXCUSED (zrušení neomluvení) lze nastavit pouze u hráče se statutem NO_EXCUSED."
            );
        }

        registration.setExcuseReason(ExcuseReason.JINE);
        registration.setAdminNote(null);
        if (excuseNote == null || excuseNote.isBlank()) {
            registration.setExcuseNote("Opravdu nemohl");
        } else {
            registration.setExcuseNote(excuseNote);
        }

        MatchRegistrationEntity updated =
                updateRegistrationStatus(
                        registration,
                        PlayerMatchStatus.EXCUSED,
                        "manager",
                        true
                );

        return matchRegistrationMapper.toDTO(updated);
    }
    // KONEC TODO

    /**
     * Nastavuje do registrace společné údaje převzaté z požadavku.
     *
     * V rámci zápisu se upravuje tým, administrátorská poznámka a informace o omluvě,
     * pokud jsou v požadavku uvedeny.
     *
     * @param registration Registrace, která se má aktualizovat.
     * @param request Požadavek obsahující hodnoty, které se mají zapsat do registrace.
     */
    private void applyRequestDetails(MatchRegistrationEntity registration,
                                     MatchRegistrationRequest request) {

        if (request.getTeam() != null) {
            registration.setTeam(request.getTeam());
        }

        if (request.getAdminNote() != null) {
            registration.setAdminNote(request.getAdminNote());
        }

        if (request.getExcuseReason() != null) {
            registration.setExcuseReason(request.getExcuseReason());
        }

        if (request.getExcuseNote() != null) {
            registration.setExcuseNote(request.getExcuseNote());
        }
    }

    /*
     Společný helper pro přechody, kde se nemá zachovat omluva.
     */
    private void clearExcuseIfNeeded(MatchRegistrationEntity registration) {
        if (registration == null) {
            return;
        }
        if (registration.getExcuseReason() != null || registration.getExcuseNote() != null) {
            registration.setExcuseReason(null);
            registration.setExcuseNote(null);
        }
    }

    /**
     * Vrací registrace pro daný zápas omezené na aktuálně vybranou sezónu.
     *
     * Pokud zápas nepatří do aktuálně vybrané sezóny, vrací se prázdný seznam.
     *
     * @param matchId Identifikátor zápasu, pro který se registrace načítají.
     * @return Seznam registrací převedených do DTO pro daný zápas v rámci aktuální sezóny.
     */
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);

        if (!isMatchInCurrentSeason(match)) {
            return List.of();
        }

        return matchRegistrationMapper.toDTOList(
                registrationRepository.findByMatchId(matchId)
        );
    }

    /**
     * Vrací registrace pro zadanou sadu zápasů omezené na aktuálně vybranou sezónu.
     *
     * Pokud je seznam identifikátorů zápasů null nebo prázdný, vrací se prázdný seznam.
     *
     * @param matchIds Seznam identifikátorů zápasů, pro které se registrace načítají.
     * @return Seznam registrací převedených do DTO pro zadané zápasy v rámci aktuální sezóny.
     */
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatches(List<Long> matchIds) {
        if (matchIds == null || matchIds.isEmpty()) {
            return List.of();
        }

        List<MatchRegistrationEntity> regsInSeason = registrationRepository
                .findByMatchIdIn(matchIds).stream()
                .filter(this::isRegistrationInCurrentSeason)
                .toList();

        return matchRegistrationMapper.toDTOList(regsInSeason);
    }

    /**
     * Vrací všechny registrace v systému omezené na aktuálně vybranou sezónu.
     *
     * @return Seznam všech registrací převedených do DTO v rámci aktuální sezóny.
     */
    @Override
    public List<MatchRegistrationDTO> getAllRegistrations() {
        List<MatchRegistrationEntity> regsInSeason = registrationRepository
                .findAll().stream()
                .filter(this::isRegistrationInCurrentSeason)
                .toList();

        return matchRegistrationMapper.toDTOList(regsInSeason);
    }

    /**
     * Vrací registrace zadaného hráče omezené na aktuálně vybranou sezónu.
     *
     * @param playerId Identifikátor hráče, jehož registrace se načítají.
     * @return Seznam registrací hráče převedených do DTO v rámci aktuální sezóny.
     */
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId) {
        List<MatchRegistrationEntity> regsInSeason = registrationRepository
                .findByPlayerId(playerId).stream()
                .filter(this::isRegistrationInCurrentSeason)
                .toList();

        return matchRegistrationMapper.toDTOList(regsInSeason);
    }

    /**
     * Vrací hráče, kteří na daný zápas nijak nereagovali.
     *
     * Pokud zápas nepatří do aktuálně vybrané sezóny, vrací se prázdný seznam.
     * Při vyhodnocování se používá množina hráčů, kteří mají k zápasu uloženou registraci v jakémkoliv stavu.
     *
     * @param matchId Identifikátor zápasu, pro který se hráči bez reakce vyhodnocují.
     * @return Seznam hráčů bez reakce převedených do DTO v rámci aktuální sezóny.
     */
    @Override
    public List<PlayerDTO> getNoResponsePlayers(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);

        if (!isMatchInCurrentSeason(match)) {
            return List.of();
        }

        Set<Long> respondedIds = getRespondedPlayerIds(matchId);

        List<PlayerEntity> noResponsePlayers = playerRepository.findAll().stream()
                .filter(p -> !respondedIds.contains(p.getId()))
                .toList();

        return noResponsePlayers.stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    /**
     * Přepočítává stavy REGISTERED a RESERVED pro daný zápas podle kapacity zápasu.
     *
     * Registrace se seřadí podle času vytvoření a prvním hráčům do výše kapacity zápasu se nastaví stav REGISTERED.
     * Ostatním hráčům se nastaví stav RESERVED. Registrace ve stavu SUBSTITUTE se do přepočtu nezahrnují.
     *
     * @param matchId Identifikátor zápasu, pro který se stavy přepočítávají.
     */
    @Override
    @Transactional
    public void recalcStatusesForMatch(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);
        int maxPlayers = match.getMaxPlayers();

        List<MatchRegistrationEntity> regs = registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED
                        || r.getStatus() == PlayerMatchStatus.RESERVED)
                .sorted((a, b) -> a.getTimestamp().compareTo(b.getTimestamp()))
                .toList();

        for (int i = 0; i < regs.size(); i++) {
            MatchRegistrationEntity reg = regs.get(i);
            PlayerMatchStatus newStatus =
                    (i < maxPlayers) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;

            if (reg.getStatus() != newStatus) {
                updateRegistrationStatus(reg, newStatus, "system", false);
            }
        }
    }

    // =========================
    // SMS – HROMADNÉ ODESÍLÁNÍ
    // =========================

    /**
     * Odesílá SMS všem hráčům registrovaným na daný zápas ve stavu REGISTERED, kteří mají povolené SMS notifikace.
     *
     * Z registrací se načtou hráči a vyhodnotí se jejich nastavení notifikací. Pokud je SMS notifikace povolena,
     * sestaví se text zprávy a provede se odeslání přes SmsService.
     *
     * @param matchId Identifikátor zápasu, pro který se SMS zprávy odesílají.
     */
    @Transactional
    public void sendSmsToRegisteredPlayers(Long matchId) {
        registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .forEach(r -> {
                    PlayerEntity player = r.getPlayer();
                    if (player == null) {
                        return;
                    }

                    var settings = player.getSettings();
                    if (settings == null || !settings.isSmsEnabled()) {
                        return;
                    }

                    sendSms(r, smsMessageBuilder.buildMessageFinal(r));
                });
    }

    /**
     * Provádí administrátorskou změnu stavu registrace.
     *
     * Před změnou se ověří existence zápasu, hráče i registrace. Stav NO_EXCUSED se touto metodou nenastavuje,
     * protože pro tento stav se používá samostatná operace s vlastní business logikou.
     *
     * @param matchId Identifikátor zápasu, pro který se stav upravuje.
     * @param playerId Identifikátor hráče, jehož registrace se upravuje.
     * @param status Cílový stav registrace, který se má nastavit.
     * @return DTO aktualizované registrace po změně stavu.
     */
    @Override
    @Transactional
    public MatchRegistrationDTO updateStatus(Long matchId, Long playerId, PlayerMatchStatus status) {

        getMatchOrThrow(matchId);
        getPlayerOrThrow(playerId);

        if (status == PlayerMatchStatus.NO_EXCUSED) {
            throw new InvalidPlayerStatusException(
                    "BE - Status NO_EXCUSED musí být nastaven přes speciální endpoint / logiku."
            );
        }

        MatchRegistrationEntity registration = getRegistrationOrThrow(playerId, matchId);

        MatchRegistrationEntity updated =
                updateRegistrationStatus(registration, status, "admin", true);

        return matchRegistrationMapper.toDTO(updated);
    }

    // ====================================================
    // PRIVÁTNÍ HELPERY – NAČÍTÁNÍ ENTIT A ZÁKLADNÍ LOGIKA
    // ====================================================

    // TODO - možná změnit Object context na MatchRegistrationEntity entity
    /**
     * Deleguje odeslání notifikace hráči do NotificationService.
     *
     * Metoda se používá pro centralizaci volání notifikační služby a předání kontextu,
     * který se použije při sestavení obsahu notifikace.
     *
     * @param player Hráč, kterému se notifikace odesílá.
     * @param type Typ notifikace určující šablonu a význam zprávy.
     * @param context Kontext notifikace, který se předává do notifikační vrstvy.
     */
    private void notifyPlayer(PlayerEntity player, NotificationType type, Object context) {
        notificationService.notifyPlayer(player, type, context);
    }

    /**
     * Vrací množinu identifikátorů hráčů, kteří mají k zápasu uloženou registraci v jakémkoliv stavu.
     *
     * @param matchId Identifikátor zápasu, pro který se ID hráčů načítají.
     * @return Množina identifikátorů hráčů, kteří na zápas reagovali vytvořením registrace.
     */
    private Set<Long> getRespondedPlayerIds(Long matchId) {
        return registrationRepository.findByMatchId(matchId).stream()
                .map(r -> r.getPlayer().getId())
                .collect(Collectors.toSet());
    }

    /**
     * Načítá zápas podle identifikátoru nebo vyhazuje výjimku při neexistenci.
     *
     * @param matchId Identifikátor zápasu.
     * @return Načtená entita zápasu.
     */
    private MatchEntity getMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }

    /**
     * Načítá hráče podle identifikátoru nebo vyhazuje výjimku při neexistenci.
     *
     * @param playerId Identifikátor hráče.
     * @return Načtená entita hráče.
     */
    private PlayerEntity getPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    /**
     * Načítá registraci hráče na zápas, pokud existuje.
     *
     * @param playerId Identifikátor hráče.
     * @param matchId Identifikátor zápasu.
     * @return Entita registrace, nebo null pokud registrace neexistuje.
     */
    private MatchRegistrationEntity getRegistrationOrNull(Long playerId, Long matchId) {
        return registrationRepository
                .findByPlayerIdAndMatchId(playerId, matchId)
                .orElse(null);
    }

    /**
     * Načítá registraci hráče na zápas nebo vyhazuje výjimku při neexistenci.
     *
     * @param playerId Identifikátor hráče.
     * @param matchId Identifikátor zápasu.
     * @return Načtená entita registrace.
     */
    private MatchRegistrationEntity getRegistrationOrThrow(Long playerId, Long matchId) {
        return registrationRepository
                .findByPlayerIdAndMatchId(playerId, matchId)
                .orElseThrow(() -> new RegistrationNotFoundException(matchId, playerId));
    }

    /**
     * Vyhodnocuje, zda je v zápase dostupné místo pro registraci ve stavu REGISTERED.
     *
     * @param match Zápas, pro který se dostupnost místa vyhodnocuje.
     * @return True, pokud počet registrovaných hráčů nedosahuje kapacity zápasu, jinak false.
     */
    private boolean isSlotAvailable(MatchEntity match) {
        long registeredCount = registrationRepository
                .countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);
        return registeredCount < match.getMaxPlayers();
    }

    // TODO - ŘEŠENO NOTIFIKACEMI - ASI SMAZAT

    /**
     * Odesílá SMS zprávu hráči navázanému na registraci, pokud je k dispozici telefonní číslo.
     *
     * Pokud registrace nebo hráč neexistují, metoda se ukončí bez provedení. Telefonní číslo se vyhodnocuje
     * primárně z nastavení hráče a sekundárně z hodnoty uložené na hráči. Případné chyby při odesílání se pouze zalogují.
     *
     * @param registration Registrace, pro kterou se zpráva odesílá.
     * @param message Text SMS zprávy.
     */
    private void sendSms(MatchRegistrationEntity registration, String message) {
        if (registration == null || registration.getPlayer() == null) {
            return;
        }

        PlayerEntity player = registration.getPlayer();
        var settings = player.getSettings();

        String phone = null;
        if (settings != null && settings.getContactPhone() != null && !settings.getContactPhone().isBlank()) {
            phone = settings.getContactPhone();
        } else if (player.getPhoneNumber() != null && !player.getPhoneNumber().isBlank()) {
            phone = player.getPhoneNumber();
        }

        if (phone == null || phone.isBlank()) {
            log.debug("sendSms: hráč {} nemá žádné telefonní číslo – SMS se nepošle", player.getId());
            return;
        }

        try {
            smsService.sendSms(phone, message);
        } catch (Exception e) {
            log.error(
                    "Chyba při odesílání SMS pro registraci {}: {}",
                    registration.getId(),
                    e.getMessage(),
                    e
            );
        }
    }

    /**
     * Aktualizuje stav registrace a ukládá změnu do databáze.
     *
     * V rámci změny se nastaví nový stav, identifikace původce změny a volitelně se aktualizuje čas změny.
     * Zápis se provádí přes repository vrstvu s okamžitým flush pro zajištění konzistence následných operací.
     *
     * @param registration Registrace, která se má aktualizovat.
     * @param status Cílový stav registrace.
     * @param updatedBy Identifikace původce změny.
     * @param updateTimestamp Příznak určující, zda se má nastavit aktuální čas změny.
     * @return Uložená entita registrace po změně stavu.
     */
    private MatchRegistrationEntity updateRegistrationStatus(
            MatchRegistrationEntity registration,
            PlayerMatchStatus status,
            String updatedBy,
            boolean updateTimestamp
    ) {
        registration.setStatus(status);
        registration.setCreatedBy(updatedBy);
        if (updateTimestamp) {
            registration.setTimestamp(LocalDateTime.now());
        }
        return registrationRepository.saveAndFlush(registration);
    }

    /**
     * Mapuje stav registrace na typ notifikace.
     *
     * Pokud se pro daný stav notifikace neodesílá, vrací se null.
     *
     * @param newStatus Stav registrace, pro který se typ notifikace vyhodnocuje.
     * @return Typ notifikace odpovídající stavu, nebo null pokud se notifikace neposílá.
     */
    private NotificationType resolveNotificationType(PlayerMatchStatus newStatus) {
        return switch (newStatus) {
            case REGISTERED -> NotificationType.MATCH_REGISTRATION_CREATED;
            case UNREGISTERED -> NotificationType.MATCH_REGISTRATION_CANCELED;
            case EXCUSED -> NotificationType.PLAYER_EXCUSED;
            case RESERVED -> NotificationType.MATCH_REGISTRATION_RESERVED;
            case NO_RESPONSE -> NotificationType.MATCH_REGISTRATION_NO_RESPONSE;
            case SUBSTITUTE -> NotificationType.MATCH_REGISTRATION_SUBSTITUTE;
            case NO_EXCUSED -> NotificationType.PLAYER_NO_EXCUSED;
            default -> null;
        };
    }

    /**
     * Vrací aktuální čas.
     *
     * Metoda se používá pro sjednocení přístupu k času a pro usnadnění testování.
     *
     * @return Aktuální čas jako LocalDateTime.
     */
    private LocalDateTime now() {
        return LocalDateTime.now();
    }

    /**
     * Ověřuje, že zápas patří do aktivní sezóny.
     *
     * Kontrola se používá před zápisem registrace, aby se zabránilo změnám v neaktivních sezónách.
     *
     * @param match Zápas, který se má ověřit.
     */
    private void assertMatchInActiveSeason(MatchEntity match) {
        if (match.getSeason() == null || !match.getSeason().isActive()) {
            throw new InvalidSeasonStateException(
                    "BE - Registrace lze měnit pouze u zápasů v aktivní sezóně."
            );
        }
    }

    /**
     * Ověřuje, zda aktuálně přihlášený uživatel může měnit registraci na daný zápas.
     *
     * Uživatel s rolí ADMIN nebo MANAGER není časově omezen. Uživatel s rolí PLAYER může registraci měnit pouze
     * v definovaném časovém okně po začátku zápasu. Při porušení pravidel se vyhazuje výjimka signalizující
     * nepovolenou změnu.
     *
     * @param match Zápas, pro který se oprávnění vyhodnocuje.
     */
    private void assertPlayerCanModifyMatch(MatchEntity match) {
        if (!isCurrentUserPlayer()) {
            return;
        }

        if (!isMatchEditableForPlayer(match)) {
            throw new InvalidPlayerStatusException(
                    "BE - Jako hráč můžeš měnit registraci pouze do 30 minut po začátku zápasu."
            );
        }
    }

    /**
     * Vyhodnocuje, zda je zápas v časovém okně, ve kterém může hráč měnit registraci.
     *
     * Zápas se považuje za editovatelný pro hráče do třiceti minut po začátku zápasu.
     *
     * @param match Zápas, ke kterému se editovatelnost vyhodnocuje.
     * @return True, pokud je změna registrace ještě povolena, jinak false.
     */
    private boolean isMatchEditableForPlayer(MatchEntity match) {
        LocalDateTime editLimit = match.getDateTime().plusMinutes(30);
        return now().isBefore(editLimit);
    }

    /**
     * Vyhodnocuje, zda má aktuálně přihlášený uživatel roli ROLE_PLAYER.
     *
     * Metoda se používá pro aplikaci časového omezení, které se vztahuje pouze na hráče.
     *
     * @return True, pokud má uživatel roli ROLE_PLAYER, jinak false.
     */
    private boolean isCurrentUserPlayer() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth == null) {
            return false;
        }

        return auth.getAuthorities().stream()
                .anyMatch(a -> "ROLE_PLAYER".equals(a.getAuthority()));
    }

    // ======================================
    // SEASON – POMOCNÉ METODY PRO CURRENT SEASON
    // ======================================

    /**
     * Vyhodnocuje, zda zápas patří do aktuálně vybrané sezóny.
     *
     * Porovnává se identifikátor sezóny zápasu s identifikátorem sezóny vráceným metodou getCurrentSeasonIdOrActive.
     *
     * @param match Zápas, který se má vyhodnotit.
     * @return True, pokud zápas patří do aktuální sezóny, jinak false.
     */
    private boolean isMatchInCurrentSeason(MatchEntity match) {
        if (match == null || match.getSeason() == null) {
            return false;
        }
        Long seasonId = getCurrentSeasonIdOrActive();
        return seasonId.equals(match.getSeason().getId());
    }

    /**
     * Vyhodnocuje, zda registrace patří k zápasu v aktuálně vybrané sezóně.
     *
     * @param registration Registrace, která se má vyhodnotit.
     * @return True, pokud registrace patří do aktuální sezóny, jinak false.
     */
    private boolean isRegistrationInCurrentSeason(MatchRegistrationEntity registration) {
        if (registration == null) {
            return false;
        }
        return isMatchInCurrentSeason(registration.getMatch());
    }

    /**
     * Vrací identifikátor sezóny používané pro filtrování registrací.
     *
     * Primárně se používá sezóna uložená v CurrentSeasonService. Pokud není k dispozici, použije se
     * globálně aktivní sezóna získaná ze SeasonService.
     *
     * @return Identifikátor aktuální nebo aktivní sezóny.
     */
    private Long getCurrentSeasonIdOrActive() {
        Long id = currentSeasonService.getCurrentSeasonIdOrDefault();
        if (id != null) {
            return id;
        }
        return seasonService.getActiveSeason().getId();
    }

}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.enums.MatchCancelReason;
import cz.phsoft.hokej.models.dto.*;

import java.util.List;

/**
 * Rozhraní se používá pro správu zápasů v aplikaci.
 *
 * Definuje kontrakt pro práci se zápasy z pohledu business logiky.
 * Zajišťuje vytváření, úpravy, mazání zápasů, získávání přehledů
 * a práci s dostupností zápasů pro konkrétního hráče.
 *
 * Rozhraní je navrženo tak, aby oddělovalo business logiku
 * od persistence vrstvy a poskytovalo jednotný vstupní bod
 * pro controllery a např. plánovače (scheduler).
 */
public interface MatchService {

    /**
     * Vrátí seznam všech zápasů v systému.
     *
     * Metoda se typicky používá pro administrátorské přehledy
     * nebo pro globální seznam zápasů v rámci vybrané sezóny.
     *
     * @return seznam všech zápasů ve formě {@link MatchDTO}
     */
    List<MatchDTO> getAllMatches();

    /**
     * Vrátí seznam všech nadcházejících zápasů.
     *
     * Za nadcházející zápasy se považují ty, které mají
     * datum a čas v budoucnosti podle interně zvolených pravidel.
     *
     * @return seznam nadcházejících zápasů
     */
    List<MatchDTO> getUpcomingMatches();

    /**
     * Vrátí seznam všech již odehraných zápasů.
     *
     * Zápasy jsou obvykle řazené od nejnovějšího po nejstarší.
     *
     * @return seznam minulých zápasů
     */
    List<MatchDTO> getPastMatches();

    /**
     * Vrátí nejbližší nadcházející zápas.
     *
     * Metoda se používá například pro zobrazení
     * „dalšího zápasu“ na dashboardu nebo
     * pro potřeby notifikací.
     *
     * @return nejbližší nadcházející zápas nebo {@code null},
     * pokud žádný neexistuje
     */
    MatchDTO getNextMatch();

    /**
     * Vrátí základní informace o zápasu podle jeho ID.
     *
     * @param id ID zápasu
     * @return zápas ve formě {@link MatchDTO}
     */
    MatchDTO getMatchById(Long id);

    /**
     * Vytvoří nový zápas.
     *
     * Metoda je typicky dostupná pouze pro administrátory
     * nebo manažery. Implementace zajišťuje validaci
     * data v rámci aktivní sezóny a přiřazení sezóny k zápasu.
     *
     * @param dto data nového zápasu
     * @return vytvořený zápas
     */
    MatchDTO createMatch(MatchDTO dto);

    /**
     * Aktualizuje existující zápas.
     *
     * Implementace je odpovědná za načtení stávajícího zápasu,
     * přenesení změn z DTO, validaci a uložení výsledného stavu.
     *
     * @param id  ID zápasu, který má být upraven
     * @param dto nové hodnoty pro zápas
     * @return aktualizovaný zápas
     */
    MatchDTO updateMatch(Long id, MatchDTO dto);

    /**
     * Smaže zápas podle ID.
     *
     * Metoda typicky vrací standardizovanou odpověď
     * s informací o úspěchu operace.
     *
     * @param id ID zápasu, který má být smazán
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO deleteMatch(Long id);

    /**
     * Vrátí detailní informace o zápasu.
     *
     * Oproti metodě {@link #getMatchById(Long)} může detail
     * obsahovat rozšířená data, například statistiky,
     * seznamy hráčů v jednotlivých stavech nebo agregované údaje.
     *
     * @param id ID zápasu
     * @return detail zápasu
     */
    MatchDetailDTO getMatchDetail(Long id);

    /**
     * Vrátí seznam zápasů, na které se daný hráč může registrovat.
     *
     * Implementace obvykle filtruje pouze nadcházející zápasy,
     * kontroluje kapacitu a respektuje pravidla sezóny
     * a případná další business omezení.
     *
     * @param playerId ID hráče
     * @return seznam dostupných zápasů pro hráče
     */
    List<MatchDTO> getAvailableMatchesForPlayer(Long playerId);

    /**
     * Vrátí nadcházející zápasy pro konkrétního hráče.
     *
     * Metoda může zohledňovat, zda je hráč registrovaný,
     * případně další business pravidla. Výsledek je
     * určen pro podrobnější zobrazení seznamu zápasů.
     *
     * @param playerId ID hráče
     * @return seznam nadcházejících zápasů pro daného hráče
     */
    List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId);

    /**
     * Najde ID hráče podle e-mailu uživatele.
     *
     * Metoda se používá jako pomocný nástroj v situaci,
     * kdy je k dispozici e-mail přihlášeného uživatele
     * a je potřeba zjistit navázaného hráče.
     *
     * @param email e-mail uživatele
     * @return ID hráče nebo {@code null}, pokud neexistuje
     */
    Long getPlayerIdByEmail(String email);

    /**
     * Vrátí přehled nadcházejících zápasů pro hráče.
     *
     * Přehled slouží pro zobrazení na dashboardu
     * nebo v jednoduchých seznamech, kde se zobrazují
     * základní informace o zápasech včetně stavu
     * daného hráče.
     *
     * @param playerId ID hráče
     * @return přehled nadcházejících zápasů pro daného hráče
     */
    List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId);

    /**
     * Vrátí přehled všech odehraných zápasů pro hráče.
     *
     * Metoda se používá pro statistiky, historii účasti
     * a přehled minulých zápasů daného hráče v rámci sezóny.
     *
     * @param playerId ID hráče
     * @return přehled všech odehraných zápasů pro daného hráče
     */
    List<MatchOverviewDTO> getAllPassedMatchesForPlayer(Long playerId);

    /**
     * Zruší zápas a nastaví důvod zrušení.
     *
     * Zápas je označen jako zrušený včetně uvedeného důvodu.
     * Implementace může navazovat další logiku, například
     * odeslání notifikací hráčům.
     *
     * @param matchId ID zápasu
     * @param reason  důvod zrušení
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO cancelMatch(Long matchId, MatchCancelReason reason);

    /**
     * Obnoví dříve zrušený zápas.
     *
     * Zápas se vrací do stavu, kdy je opět platný a může se konat,
     * pokud jsou splněny ostatní podmínky (datum, kapacita a podobně).
     *
     * @param matchId ID zápasu
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO unCancelMatch(Long matchId);

}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.*;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.models.dto.*;
import cz.phsoft.hokej.models.mappers.MatchMapper;
import cz.phsoft.hokej.models.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.notification.NotificationService;
import cz.phsoft.hokej.models.services.notification.MatchTimeChangeContext;
import jakarta.transaction.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import cz.phsoft.hokej.data.entities.AppUserEntity;

import java.time.LocalDateTime;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

//TODO KOMENTÁŘE - PROSTÉ
/**
 * Implementace service vrstvy, která se používá pro práci se zápasy.
 *
 * V této třídě se zajišťují CRUD operace nad zápasy v rámci sezón, filtrování nadcházejících a proběhlých zápasů,
 * sestavení detailu zápasu včetně agregovaných statistik a zpracování změn stavu zápasu, jako je zrušení nebo obnova.
 *
 * Součástí odpovědnosti je také doplnění číslování zápasů v sezóně a spouštění notifikací hráčům při vybraných změnách,
 * zejména při změně termínu, zrušení nebo obnovení zápasu. Notifikace se delegují do {@link NotificationService}.
 *
 * Třída neřeší detailní stavové přechody registrací hráčů na zápasy, které jsou spravovány v {@link MatchRegistrationService}.
 * Výběr aktuálního hráče se zajišťuje ve {@link CurrentPlayerService} a v controller vrstvě.
 */
@Service
public class MatchServiceImpl implements MatchService {

    @Value("${app.demo-mode:false}")
    private boolean isDemoMode;

    private static final Logger logger = LoggerFactory.getLogger(MatchServiceImpl.class);

    private static final String ROLE_ADMIN = "ROLE_ADMIN";
    private static final String ROLE_MANAGER = "ROLE_MANAGER";

    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository matchRegistrationRepository;
    private final MatchMapper matchMapper;
    private final MatchRegistrationService registrationService;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodService playerInactivityPeriodService;
    private final PlayerMapper playerMapper;
    private final CurrentPlayerService currentPlayerService;
    private final SeasonService seasonService;
    private final CurrentSeasonService currentSeasonService;
    private final NotificationService notificationService;
    private final AppUserRepository appUserRepository;

    public MatchServiceImpl(MatchRepository matchRepository,
                            MatchRegistrationRepository matchRegistrationRepository,
                            MatchMapper matchMapper,
                            MatchRegistrationService registrationService,
                            PlayerRepository playerRepository,
                            PlayerInactivityPeriodService playerInactivityPeriodService,
                            PlayerMapper playerMapper,
                            CurrentPlayerService currentPlayerService,
                            SeasonService seasonService,
                            CurrentSeasonService currentSeasonService,
                            NotificationService notificationService,
                            AppUserRepository appUserRepository) {
        this.matchRepository = matchRepository;
        this.matchRegistrationRepository = matchRegistrationRepository;
        this.matchMapper = matchMapper;
        this.registrationService = registrationService;
        this.playerRepository = playerRepository;
        this.playerInactivityPeriodService = playerInactivityPeriodService;
        this.playerMapper = playerMapper;
        this.currentPlayerService = currentPlayerService;
        this.seasonService = seasonService;
        this.currentSeasonService = currentSeasonService;
        this.notificationService = notificationService;
        this.appUserRepository = appUserRepository;
    }

    // ======================
    // ZÁKLADNÍ SEZNAMY ZÁPASŮ
    // ======================

    /**
     * Vrací všechny zápasy v rámci aktuálně používané sezóny.
     *
     * Zápasy se načítají z repository vrstvy, seřadí se podle data a času vzestupně a následně se doplní pořadové číslo
     * zápasu v sezóně. Mapování entit na DTO se deleguje do {@link MatchMapper}.
     *
     * @return Seznam zápasů aktuální sezóny převedených do DTO včetně pořadového čísla.
     */
    @Override
    public List<MatchDTO> getAllMatches() {
        Long seasonId = getCurrentSeasonIdOrActive();
        List<MatchEntity> matches =
                matchRepository.findAllBySeasonIdOrderByDateTimeAsc(seasonId);

        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);
        return assignMatchNumbers(matches, matchMapper::toDTO, matchNumberMap);
    }

    /**
     * Vrací všechny nadcházející zápasy v aktuální sezóně.
     *
     * Zápasy se filtrují na základě data a času většího než aktuální okamžik, seřadí se podle data vzestupně
     * a doplní se pořadové číslo zápasu v sezóně.
     *
     * @return Seznam nadcházejících zápasů převedených do DTO včetně pořadového čísla.
     */
    @Override
    public List<MatchDTO> getUpcomingMatches() {
        Long seasonId = getCurrentSeasonIdOrActive();
        List<MatchEntity> upcomingMatches = findUpcomingMatchesForCurrentSeason();

        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);
        return assignMatchNumbers(upcomingMatches, matchMapper::toDTO, matchNumberMap);
    }

    /**
     * Vrací všechny proběhlé zápasy v aktuální sezóně.
     *
     * Zápasy se filtrují na základě data a času menšího než aktuální okamžik, seřadí se podle data sestupně
     * a doplní se pořadové číslo zápasu v sezóně.
     *
     * @return Seznam proběhlých zápasů převedených do DTO včetně pořadového čísla.
     */
    @Override
    public List<MatchDTO> getPastMatches() {
        Long seasonId = getCurrentSeasonIdOrActive();
        List<MatchEntity> pastMatches = findPastMatchesForCurrentSeason();

        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);
        return assignMatchNumbers(pastMatches, matchMapper::toDTO, matchNumberMap);
    }

    /**
     * Vrací nejbližší nadcházející zápas v aktuální sezóně.
     *
     * Pokud žádný nadcházející zápas neexistuje, vrací se null.
     *
     * @return Nejbližší nadcházející zápas převedený do DTO, nebo null pokud žádný neexistuje.
     */
    @Override
    public MatchDTO getNextMatch() {
        return findUpcomingMatchesForCurrentSeason()
                .stream()
                .findFirst()
                .map(matchMapper::toDTO)
                .orElse(null);
    }

    /**
     * Vrací základní informace o zápasu podle identifikátoru.
     *
     * Zápas se načítá z repository vrstvy a mapuje se do DTO. Při neexistenci zápasu se vyhazuje
     * {@link MatchNotFoundException}.
     *
     * @param id Identifikátor zápasu.
     * @return Zápas převedený do {@link MatchDTO}.
     */
    @Override
    public MatchDTO getMatchById(Long id) {
        return matchMapper.toDTO(findMatchOrThrow(id));
    }

    /**
     * Vytváří nový zápas v aktivní sezóně.
     *
     * DTO se mapuje na entitu, ověří se, že datum zápasu spadá do období aktivní sezóny, a k zápasu se přiřadí
     * aktivní sezóna. Identifikátor autora vytvoření a poslední úpravy se nastaví na aktuálně přihlášeného uživatele,
     * pokud je dostupný. Uložení se provádí přes repository vrstvu.
     *
     * @param dto DTO obsahující data vytvářeného zápasu.
     * @return Vytvořený zápas převedený do DTO.
     */
    @Override
    public MatchDTO createMatch(MatchDTO dto) {
        MatchEntity entity = matchMapper.toEntity(dto);
        validateMatchDateInActiveSeason(entity.getDateTime());

        entity.setSeason(seasonService.getActiveSeason());

        Long currentUserId = getCurrentUserIdOrNull();
        entity.setCreatedByUserId(currentUserId);
        entity.setLastModifiedByUserId(currentUserId);

        return matchMapper.toDTO(matchRepository.save(entity));
    }

    /**
     * Aktualizuje existující zápas podle identifikátoru.
     *
     * Zápas se načte z repository vrstvy a vyhodnotí se oprávnění podle role uživatele. Uživatel bez role ADMIN
     * nebo MANAGER může upravovat pouze zápasy patřící do aktivní sezóny a současně se ověřuje, že datum zápasu
     * zůstává v období aktivní sezóny. Následně se přenesou změny z DTO do entity a zápas se uloží.
     *
     * Pokud se změní kapacita zápasu, přepočítají se stavy registrací přes {@link MatchRegistrationService}.
     * Pokud se změní termín zápasu, odešlou se notifikace o změně termínu přes {@link NotificationService}.
     * Při změně vybraných vlastností se nastaví stav zápasu na UPDATED.
     *
     * @param id Identifikátor upravovaného zápasu.
     * @param dto DTO obsahující nová data zápasu.
     * @return Aktualizovaný zápas převedený do DTO.
     * @throws InvalidMatchStatusException Pokud uživatel bez role ADMIN nebo MANAGER upravuje zápas mimo aktivní sezónu.
     * @throws InvalidMatchDateTimeException Pokud by po úpravě zápas spadl do minulosti.
     */
    @Override
    public MatchDTO updateMatch(Long id, MatchDTO dto) {
        MatchEntity entity = findMatchOrThrow(id);

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        boolean isAdminOrManager = hasAdminOrManagerRole(auth);

        if (!isAdminOrManager) {
            Long activeSeasonId = seasonService.getActiveSeason().getId();
            if (!entity.getSeason().getId().equals(activeSeasonId)) {
                throw new InvalidMatchStatusException(
                        id, " - Zápas nepatří do aktuální sezóny, nelze ho upravit."
                );
            }
        }

        Integer oldMaxPlayers = entity.getMaxPlayers();
        LocalDateTime oldDateTime = entity.getDateTime();
        String oldLocation = entity.getLocation();
        Integer oldPrice = entity.getPrice();

        matchMapper.updateEntity(dto, entity);

        Long currentUserId = getCurrentUserIdOrNull();
        entity.setLastModifiedByUserId(currentUserId);

        if (!isAdminOrManager) {
            validateMatchDateInActiveSeason(entity.getDateTime());
        }

        if (entity.getDateTime() != null
                && entity.getDateTime().isBefore(LocalDateTime.now())) {
            throw new InvalidMatchDateTimeException("Zápas by již byl minulostí");
        }

        boolean maxPlayersChanged =
                !java.util.Objects.equals(entity.getMaxPlayers(), oldMaxPlayers);

        boolean dateTimeChanged =
                !java.util.Objects.equals(entity.getDateTime(), oldDateTime);

        boolean locationChanged =
                !java.util.Objects.equals(entity.getLocation(), oldLocation);

        boolean priceChanged =
                !java.util.Objects.equals(entity.getPrice(), oldPrice);

        if (maxPlayersChanged || dateTimeChanged || locationChanged || priceChanged) {
            entity.setMatchStatus(MatchStatus.UPDATED);
        }

        MatchEntity saved = matchRepository.save(entity);

        if (maxPlayersChanged) {
            registrationService.recalcStatusesForMatch(saved.getId());
        }

        if (dateTimeChanged) {
            MatchTimeChangeContext ctx = new MatchTimeChangeContext(saved, oldDateTime);
            notifyPlayersAboutMatchChanges(ctx, MatchStatus.UPDATED);
        }

        return matchMapper.toDTO(saved);
    }

    /**
     * Odstraňuje zápas podle identifikátoru.
     *
     * Zápas se načítá z repository vrstvy a při neexistenci se vyhazuje {@link MatchNotFoundException}.
     * V demo režimu se operace blokuje a vyhazuje se {@link DemoModeOperationNotAllowedException}.
     * Při úspěšném odstranění se vrací standardizovaná odpověď s potvrzením a časovou známkou.
     *
     * @param id Identifikátor odstraňovaného zápasu.
     * @return Standardizovaná odpověď o úspěšném odstranění.
     */
    @Override
    public SuccessResponseDTO deleteMatch(Long id) {
        MatchEntity match = findMatchOrThrow(id);

        if (isDemoMode) {
            throw new DemoModeOperationNotAllowedException(
                    "Zápas nebude odstraněn. Aplikace běží v DEMO režimu."
            );
        }

        matchRepository.delete(match);

        return new SuccessResponseDTO(
                "BE - Zápas " + match.getId() + match.getDateTime() + " byl úspěšně smazán",
                id,
                LocalDateTime.now().toString()
        );
    }

    /**
     * Ruší zápas a ukládá důvod zrušení.
     *
     * Pokud je zápas již zrušen, vyhazuje se {@link InvalidMatchStatusException}. Při úspěšném zrušení se nastaví stav
     * CANCELED, uloží se důvod zrušení a aktualizuje se identifikátor uživatele, který změnu provedl. Následně se odešlou
     * notifikace registrovaným hráčům o zrušení zápasu přes {@link NotificationService}.
     *
     * @param matchId Identifikátor rušeného zápasu.
     * @param reason Důvod zrušení zápasu.
     * @return Standardizovaná odpověď o úspěšném zrušení.
     */
    @Override
    @Transactional
    public SuccessResponseDTO cancelMatch(Long matchId, MatchCancelReason reason) {
        MatchEntity match = findMatchOrThrow(matchId);
        String message = " je již zrušen";

        if (match.getMatchStatus() == MatchStatus.CANCELED) {
            throw new InvalidMatchStatusException(matchId, message);
        }

        match.setMatchStatus(MatchStatus.CANCELED);
        match.setCancelReason(reason);

        Long currentUserId = getCurrentUserIdOrNull();
        match.setLastModifiedByUserId(currentUserId);

        MatchEntity saved = matchRepository.save(match);
        notifyPlayersAboutMatchChanges(saved, MatchStatus.CANCELED);

        return new SuccessResponseDTO(
                "BE - Zápas " + match.getId() + match.getDateTime() + " byl úspěšně zrušen",
                match.getId(),
                LocalDateTime.now().toString()
        );
    }

    /**
     * Obnovuje dříve zrušený zápas.
     *
     * Pokud zápas není ve stavu CANCELED, vyhazuje se {@link InvalidMatchStatusException}. Při úspěšné obnově se odstraní
     * důvod zrušení, nastaví se stav UNCANCELED a aktualizuje se identifikátor uživatele, který změnu provedl. Následně se
     * odešlou notifikace registrovaným hráčům o obnovení zápasu přes {@link NotificationService}.
     *
     * @param matchId Identifikátor obnovovaného zápasu.
     * @return Standardizovaná odpověď o úspěšné obnově.
     */
    @Override
    @Transactional
    public SuccessResponseDTO unCancelMatch(Long matchId) {
        MatchEntity match = findMatchOrThrow(matchId);
        String message = " ještě nebyl zrušen";

        if (match.getMatchStatus() != MatchStatus.CANCELED) {
            throw new InvalidMatchStatusException(matchId, message);
        }

        match.setMatchStatus(MatchStatus.UNCANCELED);
        match.setCancelReason(null);

        Long currentUserId = getCurrentUserIdOrNull();
        match.setLastModifiedByUserId(currentUserId);

        MatchEntity saved = matchRepository.save(match);
        notifyPlayersAboutMatchChanges(saved, MatchStatus.UNCANCELED);

        return new SuccessResponseDTO(
                "BE - Zápas " + match.getId() + match.getDateTime() + " byl úspěšně obnoven",
                match.getId(),
                LocalDateTime.now().toString()
        );
    }

    // ======================
    // DETAIL ZÁPASU
    // ======================

    /**
     * Vrací detail zápasu ve formě {@link MatchDetailDTO}.
     *
     * Nejprve se načte zápas a vyhodnotí se přístupová pravidla dle role uživatele a jeho navázaných hráčů.
     * Následně se sestaví detailní DTO včetně agregovaných statistik a seskupení hráčů podle stavů registrací.
     * Do výsledku se doplní stav aktuálně zvoleného hráče, případné informace o omluvě, stav zápasu a důvod zrušení.
     * Pokud je zápas součástí sezóny, doplní se také pořadové číslo zápasu v sezóně.
     *
     * @param id Identifikátor zápasu.
     * @return Detail zápasu ve formě {@link MatchDetailDTO}.
     */
    @Override
    public MatchDetailDTO getMatchDetail(Long id) {
        MatchEntity match = findMatchOrThrow(id);

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        boolean isAdminOrManager = hasAdminOrManagerRole(auth);

        checkAccessForPlayer(match, auth);

        MatchDetailDTO dto = collectPlayerStatus(match, isAdminOrManager);

        Long currentPlayerId = null;
        try {
            currentPlayerId = currentPlayerService.getCurrentPlayerId();
        } catch (Exception e) {
            logger.debug("Nebyl nalezen currentPlayerId pro match detail {}", id);
        }

        PlayerMatchStatus playerMatchStatus = resolveStatusForPlayer(dto, currentPlayerId);
        dto.setPlayerMatchStatus(playerMatchStatus);

        if (currentPlayerId != null) {
            matchRegistrationRepository.findByPlayerIdAndMatchId(currentPlayerId, match.getId())
                    .ifPresent(reg -> {
                        dto.setExcuseReason(reg.getExcuseReason());
                        dto.setExcuseNote(reg.getExcuseNote());
                    });
        } else {
            dto.setExcuseReason(null);
            dto.setExcuseNote(null);
        }

        dto.setMatchStatus(match.getMatchStatus());
        dto.setCancelReason(match.getCancelReason());

        if (match.getSeason() != null && match.getSeason().getId() != null) {
            Long seasonId = match.getSeason().getId();
            Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);
            Integer number = matchNumberMap.get(match.getId());
            dto.setMatchNumber(number);
        }

        return dto;
    }

    /**
     * Ověřuje, zda má aktuální uživatel přístup k detailu zápasu.
     *
     * Uživatel musí být přihlášen. Uživatel s rolí ADMIN nebo MANAGER má přístup vždy.
     * Uživatel bez administrátorské role musí mít navázaného alespoň jednoho hráče a současně platí omezení podle toho,
     * zda jde o nadcházející nebo proběhlý zápas v rámci aktuální sezóny.
     *
     * Pro nadcházející zápas se ověřuje, že uživatel má alespoň jednoho aktivního hráče pro termín zápasu.
     * Pro proběhlý zápas se ověřuje, že některý z hráčů uživatele byl v zápase registrován ve stavu REGISTERED.
     *
     * @param match Zápas, ke kterému se přístup vyhodnocuje.
     * @param auth Aktuální autentizace z bezpečnostního kontextu.
     */
    private void checkAccessForPlayer(MatchEntity match, Authentication auth) {
        if (auth == null || !auth.isAuthenticated()) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - Musíte být přihlášen."
            );
        }

        boolean isAdminOrManager = hasAdminOrManagerRole(auth);
        if (isAdminOrManager) {
            return;
        }

        Long currentSeasonId = getCurrentSeasonIdOrActive();
        if (match.getSeason() == null || !match.getSeason().getId().equals(currentSeasonId)) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - K detailu zápasu z jiné sezóny nemáte přístup."
            );
        }

        Object principal = auth.getPrincipal();
        if (!(principal instanceof org.springframework.security.core.userdetails.UserDetails userDetails)) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - Nemáte přístup k detailu tohoto zápasu."
            );
        }

        List<PlayerEntity> ownedPlayers =
                playerRepository.findByUser_EmailOrderByIdAsc(userDetails.getUsername());

        if (ownedPlayers.isEmpty()) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - Nemáte přiřazeného žádného hráče."
            );
        }

        LocalDateTime now = now();
        boolean isPastOrNow = !match.getDateTime().isAfter(now);
        List<Long> ownedPlayerIds = ownedPlayers.stream()
                .map(PlayerEntity::getId)
                .toList();

        List<MatchRegistrationDTO> registrations =
                registrationService.getRegistrationsForMatch(match.getId());

        if (!isPastOrNow) {
            boolean hasActivePlayerForMatch = ownedPlayers.stream()
                    .anyMatch(p -> isPlayerActiveForMatch(p, match.getDateTime()));

            if (!hasActivePlayerForMatch) {
                throw new org.springframework.security.access.AccessDeniedException(
                        "BE - Nemáte aktivního hráče pro tento zápas."
                );
            }
            return;
        }

        boolean wasRegistered = registrations.stream()
                .anyMatch(r ->
                        r.getStatus() == PlayerMatchStatus.REGISTERED
                                && ownedPlayerIds.contains(r.getPlayerId())
                );

        if (!wasRegistered) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - K tomuto uplynulému zápasu nemáte oprávnění (nejste mezi registrovanými hráči)."
            );
        }
    }

    /**
     * Sestavuje {@link MatchDetailDTO} pro daný zápas.
     *
     * V rámci sestavení se načtou registrace k zápasu, hráči se seskupí podle stavů registrací a spočítají se agregované
     * hodnoty, zejména počty hráčů v jednotlivých stavech, volná místa a cena na registrovaného hráče.
     *
     * Seznam hráčů bez reakce se do výsledku doplňuje pouze pro role ADMIN a MANAGER.
     *
     * @param match Zápas, pro který se detail sestavuje.
     * @param isAdminOrManager Příznak určující, zda má uživatel oprávnění pro administrátorský pohled.
     * @return Detail zápasu sestavený do DTO.
     */
    private MatchDetailDTO collectPlayerStatus(MatchEntity match, boolean isAdminOrManager) {
        List<MatchRegistrationDTO> registrations =
                registrationService.getRegistrationsForMatch(match.getId());

        var statusToPlayersMap = registrations.stream()
                .map(r -> playerRepository.findById(r.getPlayerId())
                        .map(playerMapper::toDTO)
                        .map(dto -> new AbstractMap.SimpleEntry<>(r.getStatus(), dto))
                )
                .filter(Optional::isPresent)
                .map(Optional::get)
                .collect(Collectors.groupingBy(
                        java.util.Map.Entry::getKey,
                        Collectors.mapping(java.util.Map.Entry::getValue, Collectors.toList())
                ));

        List<PlayerDTO> noResponsePlayers =
                registrationService.getNoResponsePlayers(match.getId());
        List<PlayerDTO> registeredDarkPlayers = getRegisteredPlayersForTeam(registrations, Team.DARK);
        List<PlayerDTO> registeredLightPlayers = getRegisteredPlayersForTeam(registrations, Team.LIGHT);

        int inGamePlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()).size();

        int inGamePlayersDark =
                (int) registrations.stream()
                        .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                        .filter(r -> r.getTeam() == Team.DARK)
                        .count();

        int inGamePlayersLight =
                (int) registrations.stream()
                        .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                        .filter(r -> r.getTeam() == Team.LIGHT)
                        .count();

        int substitutePlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.SUBSTITUTE, List.of()).size();

        int outGamePlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()).size()
                        + statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()).size()
                        + statusToPlayersMap.getOrDefault(PlayerMatchStatus.NO_EXCUSED, List.of()).size();

        int waitingPlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()).size();

        int noExcusedPlayersSum =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.NO_EXCUSED, List.of()).size();

        int noActionPlayers = noResponsePlayers.size();

        int remainingSlots = match.getMaxPlayers() - inGamePlayers;
        double pricePerRegistered = inGamePlayers > 0
                ? match.getPrice() / (double) inGamePlayers
                : match.getPrice();

        MatchDetailDTO dto = new MatchDetailDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setLocation(match.getLocation());
        dto.setDescription(match.getDescription());
        dto.setPrice(match.getPrice());
        dto.setMaxPlayers(match.getMaxPlayers());
        dto.setInGamePlayers(inGamePlayers);
        dto.setInGamePlayersDark(inGamePlayersDark);
        dto.setInGamePlayersLight(inGamePlayersLight);
        dto.setSubstitutePlayers(substitutePlayers);
        dto.setOutGamePlayers(outGamePlayers);
        dto.setWaitingPlayers(waitingPlayers);
        dto.setNoExcusedPlayersSum(noExcusedPlayersSum);
        dto.setNoActionPlayers(noActionPlayers);
        dto.setPricePerRegisteredPlayer(pricePerRegistered);
        dto.setRemainingSlots(remainingSlots);

        dto.setRegisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()));
        dto.setReservedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()));
        dto.setUnregisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()));
        dto.setExcusedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()));
        dto.setSubstitutedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.SUBSTITUTE, List.of()));
        dto.setNoExcusedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.NO_EXCUSED, List.of()));

        dto.setNoResponsePlayers(isAdminOrManager ? noResponsePlayers : null);
        dto.setRegisteredDarkPlayers(registeredDarkPlayers);
        dto.setRegisteredLightPlayers(registeredLightPlayers);

        return dto;
    }

    /**
     * Sestavuje seznam hráčů registrovaných do konkrétního týmu.
     *
     * Seznam se sestavuje pouze ze stavu REGISTERED a používá se pro rychlé zobrazení složení týmů v detailu zápasu.
     * Načítání hráčů se provádí přes repository vrstvu a převod do DTO se deleguje do {@link PlayerMapper}.
     *
     * @param registrations Registrace zápasu, ze kterých se hráči vyhodnocují.
     * @param team Tým, pro který se hráči filtrují.
     * @return Seznam hráčů registrovaných v daném týmu převedených do DTO.
     */
    private List<PlayerDTO> getRegisteredPlayersForTeam(List<MatchRegistrationDTO> registrations, Team team) {
        return registrations.stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .filter(r -> r.getTeam() == team)
                .map(MatchRegistrationDTO::getPlayerId)
                .distinct()
                .map(playerRepository::findById)
                .flatMap(Optional::stream)
                .map(playerMapper::toDTO)
                .toList();
    }

    /**
     * Odvozuje stav konkrétního hráče z detailu zápasu.
     *
     * Stav se vyhodnocuje na základě přítomnosti hráče v seznamech seskupených podle stavu registrace.
     * Pokud hráč není nalezen v žádné kategorii, vrací se NO_RESPONSE.
     *
     * @param dto Detail zápasu obsahující seskupené seznamy hráčů.
     * @param playerId Identifikátor hráče, pro kterého se stav vyhodnocuje.
     * @return Stav hráče vůči zápasu.
     */
    private PlayerMatchStatus resolveStatusForPlayer(MatchDetailDTO dto, Long playerId) {
        if (dto == null || playerId == null) {
            return PlayerMatchStatus.NO_RESPONSE;
        }

        if (isIn(dto.getRegisteredPlayers(), playerId)) {
            return PlayerMatchStatus.REGISTERED;
        }
        if (isIn(dto.getReservedPlayers(), playerId)) {
            return PlayerMatchStatus.RESERVED;
        }
        if (isIn(dto.getExcusedPlayers(), playerId)) {
            return PlayerMatchStatus.EXCUSED;
        }
        if (isIn(dto.getSubstitutedPlayers(), playerId)) {
            return PlayerMatchStatus.SUBSTITUTE;
        }
        if (isIn(dto.getUnregisteredPlayers(), playerId)) {
            return PlayerMatchStatus.UNREGISTERED;
        }
        if (isIn(dto.getNoExcusedPlayers(), playerId)) {
            return PlayerMatchStatus.NO_EXCUSED;
        }

        return PlayerMatchStatus.NO_RESPONSE;
    }

    /**
     * Vyhodnocuje přítomnost hráče v seznamu hráčů podle identifikátoru.
     *
     * @param players Seznam hráčů, ve kterém se vyhledává.
     * @param playerId Identifikátor hráče, který se v seznamu ověřuje.
     * @return True, pokud je hráč v seznamu přítomen, jinak false.
     */
    private boolean isIn(List<PlayerDTO> players, Long playerId) {
        return players != null
                && players.stream().anyMatch(p -> p.getId().equals(playerId));
    }

    // ======================
    // DALŠÍ PUBLIC METODY
    // ======================

    /**
     * Vrací zápasy, ve kterých může daný hráč potenciálně hrát.
     *
     * Zápasy se načítají napříč všemi sezónami a následně se filtrují podle aktivity hráče v termínu zápasu.
     * Vyhodnocení aktivity se deleguje do {@link PlayerInactivityPeriodService}.
     *
     * @param playerId Identifikátor hráče, pro kterého se dostupné zápasy vyhodnocují.
     * @return Seznam zápasů, pro které je hráč v termínu aktivní, převedených do DTO.
     */
    @Override
    public List<MatchDTO> getAvailableMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        return matchRepository.findAll().stream()
                .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                .map(matchMapper::toDTO)
                .toList();
    }

    /**
     * Vyhledává identifikátor hráče podle e-mailu uživatele.
     *
     * Hráč se načítá přes repository vrstvu. Pokud uživatel nemá žádného hráče, vyhazuje se {@link PlayerNotFoundException}.
     *
     * @param email E-mail uživatele, pro který se hráč vyhledává.
     * @return Identifikátor hráče navázaného na uživatele.
     */
    @Override
    public Long getPlayerIdByEmail(String email) {
        return playerRepository.findByUserEmail(email)
                .map(PlayerEntity::getId)
                .orElseThrow(() -> new PlayerNotFoundException(email));
    }

    /**
     * Vrací přehled nadcházejících zápasů pro konkrétního hráče.
     *
     * Nadcházející zápasy se načtou pro aktuální sezónu a omezí se podle typu hráče. Následně se filtrují pouze ty zápasy,
     * pro které je hráč v termínu aktivní. Do výstupu se doplní stav hráče v zápase a pořadové číslo zápasu v sezóně.
     *
     * @param playerId Identifikátor hráče, pro kterého se přehled sestavuje.
     * @return Seznam přehledů zápasů převedených do {@link MatchOverviewDTO}.
     */
    @Override
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        List<MatchEntity> upcomingAll = findUpcomingMatchesForCurrentSeason();
        List<MatchEntity> limited = limitMatchesByPlayerType(upcomingAll, type);

        List<MatchEntity> activeMatches = limited.stream()
                .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                .toList();

        Long seasonId = getCurrentSeasonIdOrActive();
        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);

        return assignMatchNumbers(
                activeMatches,
                match -> toOverviewDTO(match, playerId),
                matchNumberMap
        );
    }

    /**
     * Vrací seznam nadcházejících zápasů pro konkrétního hráče.
     *
     * Nadcházející zápasy se načtou pro aktuální sezónu, omezí se podle typu hráče a následně se filtrují pouze ty zápasy,
     * pro které je hráč v termínu aktivní. Do výstupu se doplní pořadové číslo zápasu v sezóně.
     *
     * @param playerId Identifikátor hráče, pro kterého se zápasy načítají.
     * @return Seznam nadcházejících zápasů převedených do {@link MatchDTO}.
     */
    @Override
    public List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        List<MatchEntity> upcomingAll = findUpcomingMatchesForCurrentSeason();
        List<MatchEntity> limited = limitMatchesByPlayerType(upcomingAll, type);

        List<MatchEntity> activeMatches = limited.stream()
                .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                .toList();

        Long seasonId = getCurrentSeasonIdOrActive();
        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);

        return assignMatchNumbers(activeMatches, matchMapper::toDTO, matchNumberMap);
    }

    /**
     * Vrací přehled proběhlých zápasů aktuální sezóny, kterých se hráč mohl účastnit.
     *
     * Zápasy se filtrují podle data vytvoření hráče a podle aktivity hráče v termínu zápasu. Pro vybranou sadu zápasů
     * se hromadně načtou registrace a pro každý zápas se odvodí stav hráče. Do výstupu se doplní pořadové číslo zápasu
     * v sezóně.
     *
     * @param playerId Identifikátor hráče, pro kterého se přehled sestavuje.
     * @return Seznam přehledů proběhlých zápasů převedených do {@link MatchOverviewDTO}.
     */
    @Override
    public List<MatchOverviewDTO> getAllPassedMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        LocalDateTime playerCreatedDate = player.getTimestamp();

        List<MatchEntity> availableMatches =
                findPastMatchesForCurrentSeason().stream()
                        .filter(match -> match.getDateTime().isAfter(playerCreatedDate))
                        .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                        .toList();

        if (availableMatches.isEmpty()) {
            return List.of();
        }

        List<Long> matchIds = availableMatches.stream()
                .map(MatchEntity::getId)
                .toList();

        List<MatchRegistrationDTO> allRegistrations =
                registrationService.getRegistrationsForMatches(matchIds);

        var statusMap = allRegistrations.stream()
                .collect(Collectors.groupingBy(
                        MatchRegistrationDTO::getMatchId,
                        Collectors.toMap(
                                MatchRegistrationDTO::getPlayerId,
                                MatchRegistrationDTO::getStatus,
                                (a, b) -> a
                        )
                ));

        List<MatchOverviewDTO> overviews = availableMatches.stream()
                .map(match -> {
                    MatchOverviewDTO overview = toOverviewDTO(match);
                    PlayerMatchStatus playerMatchStatus = Optional.ofNullable(statusMap.get(match.getId()))
                            .map(m -> normalizePlayerStatus(m.get(playerId)))
                            .orElse(PlayerMatchStatus.NO_RESPONSE);
                    overview.setPlayerMatchStatus(playerMatchStatus);
                    return overview;
                })
                .toList();

        Long seasonId = getCurrentSeasonIdOrActive();
        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);

        overviews.forEach(o -> o.setMatchNumber(matchNumberMap.get(o.getId())));

        return overviews;
    }

    /**
     * Načítá hráče podle identifikátoru nebo vyhazuje výjimku při neexistenci.
     *
     * @param playerId Identifikátor hráče.
     * @return Načtená entita hráče.
     */
    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    /**
     * Načítá zápas podle identifikátoru nebo vyhazuje výjimku při neexistenci.
     *
     * @param matchId Identifikátor zápasu.
     * @return Načtená entita zápasu.
     */
    private MatchEntity findMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }

    /**
     * Načítá registraci hráče k zápasu nebo vyhazuje výjimku při neexistenci.
     *
     * @param playerId Identifikátor hráče.
     * @param matchId Identifikátor zápasu.
     * @return Načtená entita registrace.
     */
    private MatchRegistrationEntity findMatchRegistrationOrThrow(Long playerId, Long matchId) {
        return matchRegistrationRepository.findByPlayerIdAndMatchId(playerId, matchId)
                .orElseThrow(() -> new MatchRegistrationNotFoundException(playerId, matchId));
    }

    /**
     * Vrací aktuální čas.
     *
     * Metoda se používá pro sjednocení přístupu k času a pro usnadnění testování.
     *
     * @return Aktuální čas jako LocalDateTime.
     */
    private LocalDateTime now() {
        return LocalDateTime.now();
    }

    // ======================
    // POMOCNÉ METODY – DTO MAPOVÁNÍ
    // ======================

    /**
     * Sestavuje základní {@link MatchOverviewDTO} pro daný zápas.
     *
     * DTO obsahuje základní informace o zápasu a počet hráčů se stavem REGISTERED včetně vypočtené ceny na registrovaného
     * hráče. Načtení registrací se deleguje do {@link MatchRegistrationService}.
     *
     * @param match Zápas, pro který se přehled sestavuje.
     * @return Přehled zápasu převedený do {@link MatchOverviewDTO}.
     */
    private MatchOverviewDTO toOverviewDTO(MatchEntity match) {
        MatchOverviewDTO dto = new MatchOverviewDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setLocation(match.getLocation());
        dto.setDescription(match.getDescription());
        dto.setPrice(match.getPrice());
        dto.setMaxPlayers(match.getMaxPlayers());

        int inGamePlayers = registrationService.getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .mapToInt(r -> 1)
                .sum();
        dto.setInGamePlayers(inGamePlayers);

        double pricePerPlayer = inGamePlayers > 0 && match.getPrice() != null
                ? match.getPrice() / (double) inGamePlayers
                : match.getPrice();
        dto.setPricePerRegisteredPlayer(pricePerPlayer);

        return dto;
    }

    /**
     * Sestavuje {@link MatchOverviewDTO} pro daný zápas v kontextu konkrétního hráče.
     *
     * K základním údajům o zápasu se doplní stav hráče v zápase odvozený z registrací. Pokud registrace hráče neexistuje,
     * použije se stav NO_RESPONSE.
     *
     * @param match Zápas, pro který se přehled sestavuje.
     * @param playerId Identifikátor hráče, jehož stav se do přehledu doplňuje.
     * @return Přehled zápasu převedený do {@link MatchOverviewDTO} včetně stavu hráče.
     */
    private MatchOverviewDTO toOverviewDTO(MatchEntity match, Long playerId) {
        MatchOverviewDTO dto = toOverviewDTO(match);

        PlayerMatchStatus playerMatchStatus = registrationService
                .getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getPlayerId().equals(playerId))
                .map(MatchRegistrationDTO::getStatus)
                .findFirst()
                .map(this::normalizePlayerStatus)
                .orElse(PlayerMatchStatus.NO_RESPONSE);

        dto.setPlayerMatchStatus(playerMatchStatus);
        return dto;
    }

    // ======================
    // DALŠÍ POMOCNÉ METODY
    // ======================

    /**
     * Vyhodnocuje, zda má uživatel roli ADMIN nebo MANAGER.
     *
     * @param auth Aktuální autentizace z bezpečnostního kontextu.
     * @return True, pokud má uživatel jednu z administrátorských rolí, jinak false.
     */
    private boolean hasAdminOrManagerRole(Authentication auth) {
        if (auth == null) {
            return false;
        }
        return auth.getAuthorities().stream()
                .anyMatch(a ->
                        ROLE_ADMIN.equals(a.getAuthority()) ||
                                ROLE_MANAGER.equals(a.getAuthority())
                );
    }

    /**
     * Načítá všechny nadcházející zápasy v aktuální sezóně.
     *
     * Zápasy se vybírají podle data a času většího než aktuální okamžik a řadí se vzestupně podle data.
     *
     * @return Seznam nadcházejících zápasů v aktuální sezóně.
     */
    private List<MatchEntity> findUpcomingMatchesForCurrentSeason() {
        return matchRepository.findBySeasonIdAndDateTimeAfterOrderByDateTimeAsc(
                getCurrentSeasonIdOrActive(),
                now()
        );
    }

    /**
     * Načítá všechny proběhlé zápasy v aktuální sezóně.
     *
     * Zápasy se vybírají podle data a času menšího než aktuální okamžik a řadí se sestupně podle data.
     *
     * @return Seznam proběhlých zápasů v aktuální sezóně.
     */
    private List<MatchEntity> findPastMatchesForCurrentSeason() {
        return matchRepository.findBySeasonIdAndDateTimeBeforeOrderByDateTimeDesc(
                getCurrentSeasonIdOrActive(),
                now()
        );
    }

    /**
     * Omezuje počet nadcházejících zápasů podle typu hráče.
     *
     * Pro typ VIP se vrací tři nejbližší zápasy, pro STANDARD dva nejbližší zápasy a pro BASIC jeden nejbližší zápas.
     *
     * @param upcomingAll Seznam všech nadcházejících zápasů.
     * @param type Typ hráče.
     * @return Omezený seznam zápasů podle pravidel typu hráče.
     */
    private List<MatchEntity> limitMatchesByPlayerType(List<MatchEntity> upcomingAll, PlayerType type) {
        if (upcomingAll == null || upcomingAll.isEmpty()) {
            return List.of();
        }

        return switch (type) {
            case VIP -> upcomingAll.stream().limit(3).toList();
            case STANDARD -> upcomingAll.stream().limit(2).toList();
            case BASIC -> List.of(upcomingAll.get(0));
        };
    }

    /**
     * Vyhodnocuje, zda je hráč aktivní pro termín zápasu.
     *
     * Vyhodnocení aktivity se deleguje do {@link PlayerInactivityPeriodService}.
     *
     * @param player Hráč, jehož aktivita se vyhodnocuje.
     * @param dateTime Termín zápasu.
     * @return True, pokud je hráč v termínu zápasu aktivní, jinak false.
     */
    private boolean isPlayerActiveForMatch(PlayerEntity player, LocalDateTime dateTime) {
        return playerInactivityPeriodService.isActive(player, dateTime);
    }

    /**
     * Normalizuje stav registrace hráče pro použití v přehledech.
     *
     * Pokud je stav null nebo je neznámý, vrací se NO_RESPONSE. Podporované stavy se vracejí beze změny.
     *
     * @param status Stav registrace hráče.
     * @return Normalizovaný stav registrace pro použití v přehledech.
     */
    private PlayerMatchStatus normalizePlayerStatus(PlayerMatchStatus status) {
        if (status == null) {
            return PlayerMatchStatus.NO_RESPONSE;
        }

        return switch (status) {
            case REGISTERED,
                 UNREGISTERED,
                 EXCUSED,
                 SUBSTITUTE,
                 RESERVED,
                 NO_EXCUSED -> status;
            default -> PlayerMatchStatus.NO_RESPONSE;
        };
    }

    /**
     * Ověřuje, že datum zápasu spadá do období aktivní sezóny.
     *
     * Kontrola se používá při vytváření a úpravě zápasu pro uživatele bez administrátorské role. Při porušení období
     * aktivní sezóny se vyhazuje {@link InvalidSeasonPeriodDateException}.
     *
     * @param dateTime Termín zápasu, který se ověřuje.
     */
    private void validateMatchDateInActiveSeason(LocalDateTime dateTime) {
        var activeSeason = seasonService.getActiveSeason();
        var date = dateTime.toLocalDate();

        if (date.isBefore(activeSeason.getStartDate()) ||
                date.isAfter(activeSeason.getEndDate())) {

            throw new InvalidSeasonPeriodDateException(
                    "BE - Datum zápasu musí být v rozmezí aktivní sezóny (" +
                            activeSeason.getStartDate() + " - " + activeSeason.getEndDate() + ")."
            );
        }
    }

    /**
     * Vrací identifikátor sezóny, která se použije pro práci se zápasy.
     *
     * Primárně se používá sezóna uložená v {@link CurrentSeasonService}. Pokud není k dispozici, použije se globálně
     * aktivní sezóna ze {@link SeasonService}.
     *
     * @return Identifikátor aktuální nebo aktivní sezóny.
     */
    private Long getCurrentSeasonIdOrActive() {
        Long id = currentSeasonService.getCurrentSeasonIdOrDefault();
        if (id != null) {
            return id;
        }
        return seasonService.getActiveSeason().getId();
    }

    /**
     * Doplňuje pořadové číslo zápasu v sezóně do DTO výstupu.
     *
     * Pořadové číslo se doplňuje na základě mapy matchId na pořadí v sezóně. Mapování entity na DTO se předává
     * jako funkce, aby bylo možné metodu použít pro různé DTO implementující {@link NumberedMatchDTO}.
     *
     * @param matches Seznam zápasů, které se mapují do DTO.
     * @param mapper Funkce pro mapování {@link MatchEntity} na DTO.
     * @param matchNumberMap Mapa matchId na pořadové číslo v sezóně.
     * @return Seznam DTO s doplněným pořadovým číslem.
     * @param <D> Typ DTO implementující {@link NumberedMatchDTO}.
     */
    private <D extends NumberedMatchDTO> List<D> assignMatchNumbers(
            List<MatchEntity> matches,
            Function<MatchEntity, D> mapper,
            Map<Long, Integer> matchNumberMap
    ) {
        return matches.stream()
                .map(entity -> {
                    D dto = mapper.apply(entity);
                    Integer number = matchNumberMap.get(entity.getId());
                    dto.setMatchNumber(number);
                    return dto;
                })
                .toList();
    }

    /**
     * Sestavuje mapu matchId na pořadové číslo zápasu v sezóně.
     *
     * Pořadí zápasů se odvozuje z data a času zápasu řazeného vzestupně v rámci sezóny.
     *
     * @param seasonId Identifikátor sezóny, pro kterou se pořadí sestavuje.
     * @return Mapa matchId na pořadové číslo zápasu v sezóně.
     */
    private Map<Long, Integer> buildMatchNumberMapForSeason(Long seasonId) {
        List<MatchEntity> allMatchesInSeason =
                matchRepository.findAllBySeasonIdOrderByDateTimeAsc(seasonId);

        Map<Long, Integer> map = new HashMap<>();
        int counter = 1;
        for (MatchEntity m : allMatchesInSeason) {
            map.put(m.getId(), counter++);
        }
        return map;
    }

    /**
     * Odesílá notifikace hráčům o změnách souvisejících se zápasem.
     *
     * Kontext představuje buď samotný zápas, nebo {@link MatchTimeChangeContext} v případě změny termínu. Na základě
     * stavu změny zápasu se určí typ notifikace a notifikace se odesílají hráčům s registrací ve stavu REGISTERED,
     * RESERVED nebo SUBSTITUTE. Odeslání se deleguje do {@link NotificationService}.
     *
     * @param context Kontext notifikace použitý pro sestavení obsahu zprávy.
     * @param matchStatus Stav změny zápasu, podle kterého se určuje typ notifikace.
     */
    private void notifyPlayersAboutMatchChanges(Object context, MatchStatus matchStatus) {
        MatchEntity match;
        if (context instanceof MatchTimeChangeContext mtc) {
            match = mtc.match();
        } else if (context instanceof MatchEntity m) {
            match = m;
        } else {
            throw new IllegalArgumentException("Nepodporovaný typ contextu: " + context);
        }

        var registrations = matchRegistrationRepository.findByMatchId(match.getId());

        registrations.stream()
                .filter(reg -> reg.getStatus() == PlayerMatchStatus.REGISTERED
                        || reg.getStatus() == PlayerMatchStatus.RESERVED
                        || reg.getStatus() == PlayerMatchStatus.SUBSTITUTE)
                .forEach(reg -> {
                    PlayerEntity player = reg.getPlayer();

                    if (matchStatus == MatchStatus.UPDATED) {
                        notificationService.notifyPlayer(
                                player,
                                NotificationType.MATCH_TIME_CHANGED,
                                context
                        );
                    }

                    if (matchStatus == MatchStatus.CANCELED) {
                        notificationService.notifyPlayer(
                                player,
                                NotificationType.MATCH_CANCELED,
                                match
                        );
                        logger.info("CANCEL notify: matchId={}, regs={}",
                                match.getId(),
                                registrations.stream().map(r -> r.getStatus().name()).toList()
                        );
                    }

                    if (matchStatus == MatchStatus.UNCANCELED) {
                        notificationService.notifyPlayer(
                                player,
                                NotificationType.MATCH_UNCANCELED,
                                match
                        );
                    }
                });
    }

    /**
     * Vrací identifikátor aktuálně přihlášeného uživatele, pokud je dostupný.
     *
     * Identifikátor se odvozuje z aktuální autentizace. Jako klíč se používá e-mail uživatele a dohledání se provádí
     * přes {@link AppUserRepository}. Pokud autentizace není dostupná nebo uživatel neexistuje, vrací se null.
     *
     * @return Identifikátor aktuálního uživatele, nebo null pokud uživatele nelze určit.
     */
    private Long getCurrentUserIdOrNull() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth == null || !auth.isAuthenticated()) {
            return null;
        }

        String email = auth.getName();
        return appUserRepository.findByEmail(email)
                .map(AppUserEntity::getId)
                .orElse(null);
    }

}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\NotificationDecision.java
-----

package cz.phsoft.hokej.models.services;

/**
 * Datový objekt reprezentující výsledek vyhodnocení
 * notifikačních preferencí pro konkrétní událost.
 *
 * Slouží jako přenosový objekt mezi logikou vyhodnocení
 * notifikací a konkrétními kanály odesílání (email, SMS).
 *
 * Objekt jednoznačně určuje:
 * - zda má být odeslán email uživateli (AppUser),
 * - zda má být odeslán email hráči na jeho vlastní kontakt,
 * - zda má být odeslána SMS hráči,
 * - jaké konkrétní kontaktní údaje se mají použít.
 *
 * Třída neřeší:
 * - samotné odesílání notifikací,
 * - sestavení obsahu zpráv,
 * - validaci kontaktních údajů.
 *
 * Používá se typicky v NotificationService
 * jako výsledek rozhodovací logiky.
 */
public class NotificationDecision {

    // ==================================================
    // EMAIL – UŽIVATEL (AppUser)
    // ==================================================

    /**
     * Určuje, zda má být odeslán email uživateli (AppUser).
     *
     * Hodnota {@code true} znamená, že notifikace má být
     * odeslána na email navázaný na uživatelský účet.
     */
    private boolean sendEmailToUser;

    /**
     * Emailová adresa uživatele (AppUser.email),
     * na kterou má být případná notifikace odeslána.
     */
    private String userEmail;

    /**
     * Celé jméno uživatele.
     *
     * Používá se zejména pro personalizaci textu
     * emailové zprávy.
     */
    private String fullname;

    // ==================================================
    // EMAIL – HRÁČ
    // ==================================================

    /**
     * Určuje, zda má být odeslán email přímo hráči.
     *
     * Email se odesílá na kontakt definovaný v nastavení hráče,
     * typicky {@code PlayerSettings.contactEmail}.
     */
    private boolean sendEmailToPlayer;

    /**
     * Emailová adresa hráče.
     *
     * Hodnota obvykle pochází z {@code PlayerSettings.contactEmail},
     * případně může být použita náhradní (fallback) hodnota
     * podle logiky vyhodnocení.
     */
    private String playerEmail;

    // ==================================================
    // SMS – HRÁČ
    // ==================================================

    /**
     * Určuje, zda má být odeslána SMS hráči.
     *
     * Hodnota {@code true} znamená, že hráč má povolené
     * SMS notifikace a je k dispozici platné telefonní číslo.
     */
    private boolean sendSmsToPlayer;

    /**
     * Telefonní číslo hráče.
     *
     * Hodnota obvykle pochází z {@code PlayerSettings.contactPhone},
     * případně se použije fallback hodnota uložená přímo u hráče.
     */
    private String playerPhone;

    // ==================================================
    // GETTERY / SETTERY
    // ==================================================

    public boolean isSendEmailToUser() {
        return sendEmailToUser;
    }

    public void setSendEmailToUser(boolean sendEmailToUser) {
        this.sendEmailToUser = sendEmailToUser;
    }

    public String getUserEmail() {
        return userEmail;
    }

    public void setUserEmail(String userEmail) {
        this.userEmail = userEmail;
    }

    public boolean isSendEmailToPlayer() {
        return sendEmailToPlayer;
    }

    public void setSendEmailToPlayer(boolean sendEmailToPlayer) {
        this.sendEmailToPlayer = sendEmailToPlayer;
    }

    public String getPlayerEmail() {
        return playerEmail;
    }

    public void setPlayerEmail(String playerEmail) {
        this.playerEmail = playerEmail;
    }

    public boolean isSendSmsToPlayer() {
        return sendSmsToPlayer;
    }

    public void setSendSmsToPlayer(boolean sendSmsToPlayer) {
        this.sendSmsToPlayer = sendSmsToPlayer;
    }

    public String getPlayerPhone() {
        return playerPhone;
    }

    public void setPlayerPhone(String playerPhone) {
        this.playerPhone = playerPhone;
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\package-info.java
-----

/**
 * Service vrstva aplikace.
 *
 * Obsahuje aplikační a business logiku systému.
 *
 * Zajišťuje:
 * - zpracování požadavků z controllerů,
 * - koordinaci práce mezi repozitáři,
 * - rozhodovací logiku a validace doménových pravidel,
 * - vyvolávání notifikací a dalších vedlejších procesů.
 *
 * Service vrstva:
 * - neřeší HTTP ani prezentaci,
 * - používá repository pro přístup k datům,
 * - pracuje s DTO objekty.
 */
package cz.phsoft.hokej.models.services;



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerHistoryService.java
-----

package cz.phsoft.hokej.models.services;


import cz.phsoft.hokej.models.dto.PlayerHistoryDTO;

import java.util.List;

/**
 * Servisní rozhraní pro práci s historií hráčů.
 *
 * Slouží pouze pro čtení auditních záznamů.
 */
public interface PlayerHistoryService {

    /**
     * Vrátí historii daného hráče.
     *
     * @param playerId ID hráče
     * @return seznam historických záznamů od nejnovějšího po nejstarší
     */
    List<PlayerHistoryDTO> getHistoryForPlayer(Long playerId);
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerHistoryServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.repositories.PlayerHistoryRepository;
import cz.phsoft.hokej.models.dto.PlayerHistoryDTO;
import cz.phsoft.hokej.models.mappers.PlayerHistoryMapper;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * Implementace servisní vrstvy pro práci s historií hráčů.
 *
 * Neprovádí žádné zápisy do databáze – historické záznamy
 * jsou vytvářeny databázovými triggery.
 */
@Service
public class PlayerHistoryServiceImpl
        implements PlayerHistoryService {

    private final PlayerHistoryRepository repository;
    private final PlayerHistoryMapper mapper;

    public PlayerHistoryServiceImpl(
            PlayerHistoryRepository repository,
            PlayerHistoryMapper mapper
    ) {
        this.repository = repository;
        this.mapper = mapper;
    }

    @Override
    public List<PlayerHistoryDTO> getHistoryForPlayer(Long playerId) {
        return mapper.toDTOList(
                repository.findByPlayerIdOrderByChangedAtDesc(playerId)
        );
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;

import java.time.LocalDateTime;
import java.util.List;

/**
 * Rozhraní pro správu období neaktivity hráčů.
 *
 * Tato service definuje kontrakt pro práci s časovými úseky,
 * ve kterých je hráč považován za neaktivního
 * (zranění, dovolená, dlouhodobá absence a podobné situace).
 *
 * Odpovědnosti:
 * - eviduje období, kdy se hráč nemůže účastnit zápasů,
 * - poskytuje přehledy období neaktivity pro konkrétního hráče i pro administraci,
 * - umožňuje ověření, zda je hráč v daném okamžiku aktivní.
 *
 * Tato service:
 * - pracuje s DTO {@link PlayerInactivityPeriodDTO}, nikoliv přímo s entitami,
 * - odděluje business logiku neaktivity od persistence vrstvy.
 *
 * Tato service neřeší:
 * - autorizaci a role uživatelů,
 * - notifikace,
 * - UI logiku.
 */
public interface PlayerInactivityPeriodService {

    /**
     * Vrátí seznam všech období neaktivity v systému.
     *
     * Typicky se používá v administrátorských přehledech.
     *
     * @return seznam všech období neaktivity ve formě DTO
     */
    List<PlayerInactivityPeriodDTO> getAll();

    /**
     * Vrátí období neaktivity podle jeho ID.
     *
     * @param id ID období neaktivity
     * @return období neaktivity ve formě DTO
     */
    PlayerInactivityPeriodDTO getById(Long id);

    /**
     * Vrátí seznam období neaktivity pro konkrétního hráče.
     *
     * @param playerId ID hráče
     * @return seznam období neaktivity daného hráče
     */
    List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId);

    /**
     * Vytvoří nové období neaktivity hráče.
     *
     * Implementace je zodpovědná za:
     * - validaci časového rozsahu (začátek před koncem),
     * - kontrolu překryvů s existujícími obdobími neaktivity.
     *
     * @param dto data nového období neaktivity
     * @return vytvořené období neaktivity ve formě DTO
     */
    PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto);

    /**
     * Aktualizuje existující období neaktivity.
     *
     * Implementace je zodpovědná za:
     * - validaci časového rozsahu,
     * - kontrolu překryvů s ostatními obdobími neaktivity daného hráče.
     *
     * @param id  ID období neaktivity, které má být upraveno
     * @param dto nové hodnoty období neaktivity
     * @return aktualizované období neaktivity ve formě DTO
     */
    PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto);

    /**
     * Odstraní období neaktivity podle ID.
     *
     * @param id ID období neaktivity, které má být smazáno
     */
    void delete(Long id);

    /**
     * Ověří, zda je hráč v daném okamžiku aktivní.
     *
     * Metoda vrací informaci, zda se zadaný čas
     * nenachází v žádném z evidovaných období neaktivity hráče.
     *
     * Typické použití:
     * - při registraci hráče na zápas,
     * - při validaci účasti hráče v konkrétním čase,
     * - při filtrování dostupných zápasů pro hráče.
     *
     * @param player   hráč, jehož aktivita se ověřuje
     * @param dateTime časový okamžik, pro který se aktivita kontroluje
     * @return true, pokud je hráč v daném čase aktivní, jinak false
     */
    boolean isActive(PlayerEntity player, LocalDateTime dateTime);
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.data.repositories.PlayerInactivityPeriodRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.InactivityPeriodNotFoundException;
import cz.phsoft.hokej.exceptions.InactivityPeriodOverlapException;
import cz.phsoft.hokej.exceptions.InvalidInactivityPeriodDateException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import cz.phsoft.hokej.models.mappers.PlayerInactivityPeriodMapper;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

/**
 * Service implementace pro správu období neaktivity hráčů.
 *
 * Obchodní význam:
 * - určuje, zda je hráč v daném čase aktivní nebo neaktivní,
 * - poskytuje podklady pro rozhodování, zda může být hráč
 *   zařazen do zápasu nebo mít přístup k určitým funkcím.
 *
 * Typické použití:
 * - při filtrování zápasů dostupných pro hráče,
 * - v přístupové logice k detailu zápasu,
 * - při registraci hráče na zápas.
 *
 * Klíčové pravidlo:
 * - hráč nesmí mít překrývající se období neaktivity
 *   (překryv je považován za chybu dat).
 *
 * Tato service:
 * - řeší pouze doménová pravidla pro neaktivitu,
 * - neřeší bezpečnost, role ani notifikace,
 * - využívá mapper {@link PlayerInactivityPeriodMapper}
 *   pro převod mezi entitami a DTO.
 */
@Service
public class PlayerInactivityPeriodServiceImpl implements PlayerInactivityPeriodService {

    private final PlayerInactivityPeriodRepository inactivityRepository;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodMapper mapper;

    public PlayerInactivityPeriodServiceImpl(
            PlayerInactivityPeriodRepository inactivityRepository,
            PlayerRepository playerRepository,
            PlayerInactivityPeriodMapper mapper
    ) {
        this.inactivityRepository = inactivityRepository;
        this.playerRepository = playerRepository;
        this.mapper = mapper;
    }

    // ======================
    // READ OPERACE
    // ======================

    /**
     * Vrátí všechna období neaktivity všech hráčů.
     *
     * Používá se zejména v administrátorských přehledech
     * nebo interních reportech.
     *
     * @return seznam všech období neaktivity ve formě DTO
     */
    @Override
    public List<PlayerInactivityPeriodDTO> getAll() {
        return inactivityRepository.findAll().stream()
                .map(mapper::toDTO)
                .toList();
    }

    /**
     * Vrátí konkrétní období neaktivity podle ID.
     *
     * @param id ID období neaktivity
     * @return DTO reprezentace období neaktivity
     * @throws InactivityPeriodNotFoundException pokud záznam neexistuje
     */
    @Override
    public PlayerInactivityPeriodDTO getById(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new InactivityPeriodNotFoundException(id));

        return mapper.toDTO(entity);
    }

    /**
     * Vrátí všechna období neaktivity konkrétního hráče,
     * seřazená podle začátku neaktivity od nejstaršího.
     *
     * @param playerId ID hráče
     * @return seznam období neaktivity ve formě DTO
     * @throws PlayerNotFoundException pokud hráč neexistuje
     */
    @Override
    public List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId) {
        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));

        return inactivityRepository.findByPlayerOrderByInactiveFromAsc(player).stream()
                .map(mapper::toDTO)
                .toList();
    }

    // ======================
    // CREATE
    // ======================

    /**
     * Vytvoří nové období neaktivity hráče.
     *
     * Před uložením se ověřuje:
     * - existence hráče,
     * - platnost dat (od/do),
     * - nepřekrývání s jinými obdobími neaktivity daného hráče.
     *
     * @param dto data nového období neaktivity
     * @return nově vytvořené období neaktivity ve formě DTO
     * @throws PlayerNotFoundException              pokud hráč neexistuje
     * @throws InvalidInactivityPeriodDateException pokud je rozsah dat neplatný
     * @throws InactivityPeriodOverlapException     pokud se nové období překrývá s existujícím
     */
    @Override
    @Transactional
    public PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto) {

        PlayerEntity player = playerRepository.findById(dto.getPlayerId())
                .orElseThrow(() -> new PlayerNotFoundException(dto.getPlayerId()));

        validateDates(dto);

        // kontrola překryvu existujících období pro daného hráče
        boolean overlaps = !inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        player,
                        dto.getInactiveFrom(),
                        dto.getInactiveTo()
                ).isEmpty();

        if (overlaps) {
            throw new InactivityPeriodOverlapException();
        }

        PlayerInactivityPeriodEntity entity = mapper.toEntity(dto, player);
        PlayerInactivityPeriodEntity saved = inactivityRepository.save(entity);

        return mapper.toDTO(saved);
    }

    // ======================
    // UPDATE
    // ======================

    /**
     * Aktualizuje existující období neaktivity.
     *
     * Oproti vytvoření nového období se při kontrole překryvu
     * ignoruje aktuální záznam (aby nebyl považován za kolizi sám se sebou).
     *
     * @param id  ID upravovaného období
     * @param dto nové hodnoty období neaktivity
     * @return aktualizované období neaktivity ve formě DTO
     * @throws InactivityPeriodNotFoundException     pokud záznam neexistuje
     * @throws InvalidInactivityPeriodDateException  pokud je rozsah dat neplatný
     * @throws InactivityPeriodOverlapException      pokud se upravené období překrývá s jiným
     */
    @Override
    @Transactional
    public PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto) {

        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new InactivityPeriodNotFoundException(id));

        validateDates(dto);

        // kontrola překryvu – existující záznamy kromě aktuálního ID
        boolean overlaps = inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        entity.getPlayer(),
                        dto.getInactiveFrom(),
                        dto.getInactiveTo()
                ).stream()
                .anyMatch(p -> !p.getId().equals(id));

        if (overlaps) {
            throw new InactivityPeriodOverlapException(
                    "BE - Upravené období se překrývá s jiným obdobím neaktivity hráče."
            );
        }

        entity.setInactiveFrom(dto.getInactiveFrom());
        entity.setInactiveTo(dto.getInactiveTo());

        PlayerInactivityPeriodEntity saved = inactivityRepository.save(entity);

        return mapper.toDTO(saved);
    }

    // ======================
    // DELETE
    // ======================

    /**
     * Smaže období neaktivity podle ID.
     *
     * @param id ID období neaktivity
     * @throws InactivityPeriodNotFoundException pokud záznam neexistuje
     */
    @Override
    @Transactional
    public void delete(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new InactivityPeriodNotFoundException(id));

        inactivityRepository.delete(entity);
    }

    // ======================
    // AKTIVITA HRÁČE
    // ======================

    /**
     * Ověří, zda je hráč v daném čase aktivní.
     *
     * Hráč je považován za neaktivního, pokud existuje období neaktivity,
     * které daný časový okamžik zahrnuje. Metoda vrací negaci této podmínky.
     *
     * Typické použití:
     * - v {@link MatchServiceImpl} při filtrování dostupných zápasů,
     * - v přístupové logice k detailu zápasu,
     * - při posuzování, zda má hráč „nárok“ na účast v zápase.
     *
     * @param player   hráč, jehož aktivita se ověřuje
     * @param dateTime časový okamžik, pro který se aktivita kontroluje
     * @return true, pokud hráč není v daném čase v žádném období neaktivity, jinak false
     */
    @Override
    public boolean isActive(PlayerEntity player, LocalDateTime dateTime) {
        // pokud existuje záznam pokrývající daný čas → hráč je neaktivní
        return !inactivityRepository
                .existsByPlayerAndInactiveFromLessThanEqualAndInactiveToGreaterThanEqual(
                        player,
                        dateTime,
                        dateTime
                );
    }

    // ======================
    // PRIVÁTNÍ VALIDACE
    // ======================

    /**
     * Validuje časový rozsah období neaktivity.
     *
     * Kontroluje se:
     * - že datum od i do není null,
     * - že datum od je před datem do.
     *
     * @param dto DTO s daty období neaktivity
     * @throws InvalidInactivityPeriodDateException při neplatném rozsahu dat
     */
    private void validateDates(PlayerInactivityPeriodDTO dto) {
        if (dto.getInactiveFrom() == null || dto.getInactiveTo() == null) {
            throw new InvalidInactivityPeriodDateException(
                    "BE - Datum od a do nesmí být null."
            );
        }

        if (!dto.getInactiveFrom().isBefore(dto.getInactiveTo())) {
            throw new InvalidInactivityPeriodDateException(
                    "BE - Datum 'od' musí být před 'do'."
            );
        }
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;

import java.util.List;

/**
 * Rozhraní pro správu hráčů v aplikaci.
 *
 * Rozhraní definuje kontrakt pro práci s hráči z pohledu business logiky,
 * včetně jejich vytváření, úprav, schvalování a vazby na uživatele.
 *
 * Odpovědnosti:
 * - správa životního cyklu hráčů (vytvoření, úprava, smazání),
 * - správa vazby hráčů na uživatelské účty,
 * - řízení stavu hráče (čekající, schválený, zamítnutý),
 * - správa „aktuálního hráče“ v kontextu uživatele.
 *
 * Rozhraní se používá:
 * - v controllerech pro hráče a administraci,
 * - v dalších service třídách, které potřebují pracovat s hráči na DTO úrovni.
 */
public interface PlayerService {

    /**
     * Vrátí seznam všech hráčů v systému.
     *
     * Metoda se používá typicky v administrátorských přehledech.
     *
     * @return seznam všech hráčů ve formě {@link PlayerDTO}
     */
    List<PlayerDTO> getAllPlayers();

    /**
     * Vrátí hráče podle jeho ID.
     *
     * @param id ID hráče
     * @return hráč ve formě {@link PlayerDTO}
     */
    PlayerDTO getPlayerById(Long id);

    /**
     * Vytvoří nového hráče bez explicitní vazby na uživatele.
     *
     * Typicky se používá v administraci pro ruční založení hráče.
     *
     * @param player data nového hráče
     * @return vytvořený hráč ve formě {@link PlayerDTO}
     */
    PlayerDTO createPlayer(PlayerDTO player);

    /**
     * Vytvoří nového hráče a přiřadí jej ke konkrétnímu uživateli.
     *
     * Metoda se používá v případech, kdy je hráč vytvářen
     * v kontextu již existujícího uživatelského účtu.
     *
     * @param dto       data nového hráče
     * @param userEmail email uživatele, ke kterému má být hráč přiřazen
     * @return vytvořený hráč ve formě {@link PlayerDTO}
     */
    PlayerDTO createPlayerForUser(PlayerDTO dto, String userEmail);

    /**
     * Aktualizuje údaje existujícího hráče.
     *
     * Metoda aktualizuje základní identifikační a kontaktní údaje
     * i parametry hráče (typ, tým, status).
     *
     * @param id     ID hráče, který má být aktualizován
     * @param player nové hodnoty hráče
     * @return aktualizovaný hráč ve formě {@link PlayerDTO}
     */
    PlayerDTO updatePlayer(Long id, PlayerDTO player);

    /**
     * Odstraní hráče ze systému.
     *
     * Typicky se používá v administraci. Návratová hodnota informuje
     * o úspěchu operace ve formě {@link SuccessResponseDTO}.
     *
     * @param id ID hráče, který má být odstraněn
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO deletePlayer(Long id);

    /**
     * Vrátí seznam hráčů přiřazených ke konkrétnímu uživateli.
     *
     * Metoda se používá například při zobrazení hráčů přihlášeného uživatele.
     *
     * @param email email uživatele
     * @return seznam hráčů daného uživatele ve formě {@link PlayerDTO}
     */
    List<PlayerDTO> getPlayersByUser(String email);

    /**
     * Schválí hráče.
     *
     * Po schválení je hráč považován za aktivního
     * a může se účastnit zápasů podle dalších pravidel aplikace.
     *
     * @param id ID hráče
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO approvePlayer(Long id);

    /**
     * Zamítne hráče.
     *
     * Zamítnutý hráč se nepovažuje za aktivního
     * a nemůže se účastnit zápasů.
     *
     * @param id ID hráče
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO rejectPlayer(Long id);

    /**
     * Nastaví aktuálního hráče pro konkrétního uživatele.
     *
     * Metoda slouží k explicitnímu výběru hráče v případě,
     * že má uživatel přiřazeno více hráčů.
     *
     * @param userEmail email uživatele
     * @param playerId  ID hráče, který má být nastaven jako aktuální
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO setCurrentPlayerForUser(String userEmail, Long playerId);

    /**
     * Automaticky zvolí aktuálního hráče pro daného uživatele
     * podle jeho nastavení (AppUserSettings.playerSelectionMode).
     *
     * Typické použití:
     * - po přihlášení uživatele,
     * - při explicitním volání z frontendu (například tlačítko „Vybrat výchozího hráče“).
     *
     * @param userEmail email přihlášeného uživatele
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO autoSelectCurrentPlayerForUser(String userEmail);

    /**
     * Změní přiřazeného uživatele k existujícímu hráči.
     *
     * Metoda slouží k administrátorské úpravě vazby mezi hráčem a
     * uživatelským účtem, například při opravě chybného přiřazení
     * nebo převodu hráče pod jiný uživatelský účet.
     *
     * Implementace mění pouze vazbu hráč → uživatel,
     * ostatní business logika (například změna current player)
     * je ponechána volajícímu.
     *
     * @param id        ID hráče, kterému se má změnit přiřazený uživatel
     * @param newUserId ID nového uživatele, ke kterému má být hráč přiřazen
     */
    void changePlayerUser(Long id, Long newUserId);

}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerSettingsEntity;
import cz.phsoft.hokej.data.enums.PlayerSelectionMode;
import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.notification.NotificationService;
import jakarta.transaction.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import cz.phsoft.hokej.models.dto.PlayerDTO;

import static cz.phsoft.hokej.data.enums.PlayerStatus.APPROVED;
import static cz.phsoft.hokej.data.enums.PlayerStatus.REJECTED;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Service vrstva pro práci s hráči ({@link PlayerEntity}).
 *
 * Tato třída zodpovídá za:
 * - provádění CRUD operací nad hráči,
 * - kontrolu duplicity jména a příjmení,
 * - správu vazby hráče na uživatele ({@link AppUserEntity}),
 * - změnu statusu hráče (APPROVED, REJECTED) včetně spuštění notifikací,
 * - nastavení aktuálního hráče v {@link CurrentPlayerService}
 *   pro přihlášeného uživatele.
 *
 * Tato třída neřeší:
 * - HTTP vrstvu, session a mapování requestů a response (řeší controllery),
 * - autentizaci a autorizaci (řeší Spring Security a controller vrstva),
 * - detailní logiku zápasů (řeší {@link MatchServiceImpl} a navazující služby).
 */
@Service
public class PlayerServiceImpl implements PlayerService {

    @Value("${app.demo-mode:false}")
    private boolean isDemoMode;
    private static final Logger logger = LoggerFactory.getLogger(PlayerServiceImpl.class);

    private final PlayerRepository playerRepository;
    private final PlayerMapper playerMapper;
    private final AppUserRepository appUserRepository;
    private final NotificationService notificationService;
    private final CurrentPlayerService currentPlayerService;
    private final AppUserSettingsService appUserSettingsService;
    private final PlayerSettingsService playerSettingsService;

    public PlayerServiceImpl(
            PlayerRepository playerRepository,
            PlayerMapper playerMapper,
            AppUserRepository appUserRepository,
            NotificationService notificationService,
            CurrentPlayerService currentPlayerService,
            AppUserSettingsService appUserSettingsService,
            PlayerSettingsService playerSettingsService
    ) {
        this.playerRepository = playerRepository;
        this.playerMapper = playerMapper;
        this.appUserRepository = appUserRepository;
        this.notificationService = notificationService;
        this.currentPlayerService = currentPlayerService;
        this.appUserSettingsService = appUserSettingsService;
        this.playerSettingsService = playerSettingsService;
    }

    // ======================
    // CREATE / UPDATE / DELETE
    // ======================

    /**
     * Vytvoří nového hráče bez vazby na uživatele.
     *
     * Před uložením se kontroluje duplicita kombinace jména a příjmení.
     * Po vytvoření se notifikace neodesílá, aby bylo zachováno původní chování.
     *
     * @param dto data nového hráče
     * @return vytvořený hráč ve formě {@link PlayerDTO}
     */
    @Override
    @Transactional
    public PlayerDTO createPlayer(PlayerDTO dto) {
        ensureUniqueNameSurname(dto.getName(), dto.getSurname(), null);

        PlayerEntity entity = playerMapper.toEntity(dto);
        PlayerEntity saved = playerRepository.save(entity);

        return playerMapper.toDTO(saved);
    }

    /**
     * Vytvoří nového hráče a přiřadí jej k uživateli podle emailu.
     *
     * Postup:
     * - vyhledá se uživatel podle emailu,
     * - ověří se, že neexistuje jiný hráč se stejným jménem a příjmením,
     * - namapuje se {@link PlayerDTO} na {@link PlayerEntity},
     * - nastaví se vazba na uživatele a hráč se uloží,
     * - odešle se notifikace {@link NotificationType#PLAYER_CREATED}.
     *
     * @param dto       data nového hráče
     * @param userEmail email uživatele, ke kterému má být hráč přiřazen
     * @return vytvořený hráč ve formě {@link PlayerDTO}
     * @throws UserNotFoundException         pokud uživatel neexistuje
     * @throws DuplicateNameSurnameException pokud existuje hráč se stejným jménem a příjmením
     */
    @Override
    @Transactional
    public PlayerDTO createPlayerForUser(PlayerDTO dto, String userEmail) {
        AppUserEntity user = appUserRepository.findByEmail(userEmail)
                .orElseThrow(() -> new UserNotFoundException(userEmail));

        ensureUniqueNameSurname(dto.getName(), dto.getSurname(), null);

        PlayerEntity player = playerMapper.toEntity(dto);
        player.setUser(user);
        PlayerEntity saved = playerRepository.save(player);

        notifyPlayer(saved, NotificationType.PLAYER_CREATED, saved);

        return playerMapper.toDTO(saved);
    }

    /**
     * Aktualizuje existujícího hráče.
     *
     * Při změně jména nebo příjmení se kontroluje duplicita kombinace jméno + příjmení.
     * Poté se přepíší základní údaje hráče a odešle se notifikace
     * {@link NotificationType#PLAYER_UPDATED}.
     *
     * @param id  ID hráče
     * @param dto nové hodnoty hráče
     * @return aktualizovaný hráč ve formě {@link PlayerDTO}
     * @throws PlayerNotFoundException       pokud hráč neexistuje
     * @throws DuplicateNameSurnameException pokud nová kombinace jméno + příjmení koliduje
     *                                       s jiným hráčem
     */
    @Override
    @Transactional
    public PlayerDTO updatePlayer(Long id, PlayerDTO dto) {
        PlayerEntity existing = findPlayerOrThrow(id);

        boolean nameChanged =
                !existing.getName().equals(dto.getName()) ||
                        !existing.getSurname().equals(dto.getSurname());

        if (nameChanged) {
            ensureUniqueNameSurname(dto.getName(), dto.getSurname(), id);
        }

        existing.setName(dto.getName());
        existing.setSurname(dto.getSurname());
        existing.setNickname(dto.getNickname());
        existing.setPhoneNumber(dto.getPhoneNumber());
        existing.setType(dto.getType());
        existing.setTeam(dto.getTeam());
        if (dto.getPlayerStatus() != null) {
            existing.setPlayerStatus(dto.getPlayerStatus());
        }

        PlayerEntity saved = playerRepository.save(existing);
        notifyPlayer(saved, NotificationType.PLAYER_UPDATED, saved);

        return playerMapper.toDTO(saved);
    }
    // TODO - Nebude probíhat mazání hráče - bude nastaven statut ARCHIVED
    /**
     * Smaže hráče podle ID.
     *
     * Po smazání je odeslána notifikace {@link NotificationType#PLAYER_DELETED}.
     *
     * @param id ID hráče
     * @return {@link SuccessResponseDTO} s potvrzující zprávou
     * @throws PlayerNotFoundException pokud hráč neexistuje
     */
    @Override
    @Transactional
    public SuccessResponseDTO deletePlayer(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);

        if (isDemoMode) {
            throw new DemoModeOperationNotAllowedException(
                    "Hráč nebude smazán. Aplikace běží v DEMO režimu."
            );
        }

        playerRepository.delete(player);

        String message = "Hráč " + player.getFullName() + " byl úspěšně smazán";
        notifyPlayer(player, NotificationType.PLAYER_DELETED, player);

        return buildSuccessResponse(message, id);
    }

   // STATUS – APPROVE / REJECT
    /**
     * Schválí hráče a nastaví mu status {@link PlayerStatus#APPROVED}.
     *
     * Pokud je hráč již schválen, vyhodí se výjimka
     * {@link InvalidPlayerStatusException}. Po schválení se odešle
     * notifikace {@link NotificationType#PLAYER_APPROVED}.
     *
     * @param id ID hráče
     * @return odpověď s výsledkem operace
     */
    @Override
    @Transactional
    public SuccessResponseDTO approvePlayer(Long id) {
        return changePlayerStatus(
                id,
                PlayerStatus.APPROVED,
                PlayerStatus.APPROVED,
                NotificationType.PLAYER_APPROVED,
                "BE - Hráč už je schválen.",
                "Hráč %s byl úspěšně aktivován"
        );
    }
    /**
     * Zamítne hráče a nastaví mu status {@link PlayerStatus#REJECTED}.
     *
     * Pokud je hráč již zamítnut, vyhodí se výjimka
     * {@link InvalidPlayerStatusException}. Po zamítnutí se odešle
     * notifikace {@link NotificationType#PLAYER_REJECTED}.
     *
     * @param id ID hráče
     * @return odpověď s výsledkem operace
     */
    @Override
    @Transactional
    public SuccessResponseDTO rejectPlayer(Long id) {
        return changePlayerStatus(
                id,
                REJECTED,
                REJECTED,
                NotificationType.PLAYER_REJECTED,
                "BE - Hráč už je zamítnut.",
                "Hráč %s byl úspěšně zamítnut"
        );
    }

    /**
     * Změní přiřazeného uživatele k hráči a odešle notifikace
     * o změně vazby hráče a uživatele.
     *
     * Při pokusu převést hráče na stejného uživatele se vyhodí
     * {@link InvalidChangePlayerUserException}.
     *
     * @param id        ID hráče
     * @param newUserId ID nového uživatele
     */
    @Transactional
    public void changePlayerUser(Long id, Long newUserId) {
        PlayerEntity player = findPlayerOrThrow(id);
        AppUserEntity newUser = findUserOrThrow(newUserId);
        AppUserEntity oldUser = player.getUser();

        if (oldUser != null && oldUser.getId().equals(newUserId)) {
            throw new InvalidChangePlayerUserException();
        }
        player.setUser(newUser);
        PlayerEntity saved = playerRepository.save(player);

        notifyPlayer(saved, NotificationType.PLAYER_CHANGE_USER, newUser);
        notifyUser(newUser, NotificationType.PLAYER_CHANGE_USER, player);
    }
    // READ
   /**
     * Vrátí všechny hráče v systému.
     *
     * @return seznam hráčů ve formě {@link PlayerDTO}
     */
    @Override
    public List<PlayerDTO> getAllPlayers() {
        return playerRepository.findAll().stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    /**
     * Vrátí hráče podle ID.
     *
     * @param id ID hráče
     * @return {@link PlayerDTO} odpovídající hráči
     * @throws PlayerNotFoundException pokud hráč s daným ID neexistuje
     */
    @Override
    public PlayerDTO getPlayerById(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);
        return playerMapper.toDTO(player);
    }

    /**
     * Vrátí všechny hráče přiřazené uživateli s daným emailem.
     *
     * Hráči jsou vráceni v pořadí podle ID vzestupně.
     *
     * @param email email uživatele
     * @return seznam hráčů ve formě {@link PlayerDTO}
     */
    @Override
    public List<PlayerDTO> getPlayersByUser(String email) {
        return playerRepository.findByUser_EmailOrderByIdAsc(email).stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    // CURRENT PLAYER – SESSION

    /**
     * Nastaví aktuálního hráče pro daného uživatele.
     *
     * Nejprve se ověří, že hráč existuje a patří danému uživateli
     * (podle emailu). Poté se jeho ID předá do
     * {@link CurrentPlayerService#setCurrentPlayerId(Long)}.
     *
     * @param userEmail email přihlášeného uživatele
     * @param playerId  ID hráče, který má být nastaven jako aktuální
     * @return odpověď s výsledkem operace
     * @throws PlayerNotFoundException        pokud hráč neexistuje
     * @throws ForbiddenPlayerAccessException pokud hráč nepatří danému uživateli
     */
    @Override
    public SuccessResponseDTO setCurrentPlayerForUser(String userEmail, Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        assertPlayerBelongsToUser(player, userEmail);

        currentPlayerService.setCurrentPlayerId(playerId);

        String message = "BE - Aktuální hráč nastaven na ID: " + playerId;
        return buildSuccessResponse(message, playerId);
    }

    /**
     * Automaticky vybere aktuálního hráče pro uživatele podle
     * nastavení v AppUserSettings (playerSelectionMode).
     *
     * Režimy:
     * - FIRST_PLAYER: vždy se vybere první hráč podle ID,
     * - ALWAYS_CHOOSE: automaticky se vybere pouze v případě,
     *   že má uživatel právě jednoho schváleného hráče.
     *
     * @param userEmail email uživatele
     * @return odpověď s výsledkem operace
     */
    @Override
    public SuccessResponseDTO autoSelectCurrentPlayerForUser(String userEmail) {

        var userSettingsDto = appUserSettingsService.getSettingsForUser(userEmail);

        PlayerSelectionMode mode = PlayerSelectionMode.FIRST_PLAYER;
        if (userSettingsDto.getPlayerSelectionMode() != null) {
            mode = PlayerSelectionMode.valueOf(userSettingsDto.getPlayerSelectionMode());
        }

        switch (mode) {
            case FIRST_PLAYER:
                return autoSelectFirstPlayer(userEmail);
            case ALWAYS_CHOOSE:
                return autoSelectIfSinglePlayer(userEmail);
            default:
                return autoSelectFirstPlayer(userEmail);
        }
    }

    /**
     * Pomocná metoda pro režim FIRST_PLAYER.
     *
     * Najde prvního hráče uživatele (podle ID) a nastaví ho
     * jako aktuálního hráče v {@link CurrentPlayerService}.
     * Pokud uživatel nemá žádného hráče nebo hráč není schválen,
     * vyhodí se výjimka.
     *
     * @param userEmail email uživatele
     * @return odpověď s výsledkem operace
     */
    private SuccessResponseDTO autoSelectFirstPlayer(String userEmail) {
        List<PlayerEntity> players = playerRepository.findByUser_EmailOrderByIdAsc(userEmail);

        if (players.isEmpty()) {
            currentPlayerService.clear();
            throw new PlayerNotFoundException(
                    "BE - Uživatel nemá přiřazeného žádného hráče. Nelze automaticky vybrat.",
                    userEmail
            );
        }

        PlayerEntity firstPlayer = players.get(0);
        if (firstPlayer.getPlayerStatus() != APPROVED) {
            throw new InvalidPlayerStatusException(
                    "BE - Nelze zvolit hráče, který není schválen administrátorem."
            );
        }

        currentPlayerService.setCurrentPlayerId(firstPlayer.getId());
        String message = "BE - Automaticky byl vybrán první hráč: " + firstPlayer.getFullName();
        return buildSuccessResponse(message, firstPlayer.getId());
    }

    /**
     * Pomocná metoda pro režim ALWAYS_CHOOSE.
     *
     * Pokud má uživatel právě jednoho schváleného hráče, tento hráč
     * se nastaví jako aktuální. V ostatních případech se current player
     * vyčistí a očekává se ruční výběr na frontendu.
     *
     * @param userEmail email uživatele
     * @return odpověď s výsledkem operace
     */
    private SuccessResponseDTO autoSelectIfSinglePlayer(String userEmail) {
        List<PlayerEntity> players = playerRepository
                .findByUser_EmailOrderByIdAsc(userEmail).stream()
                .filter(p -> p.getPlayerStatus() == APPROVED)
                .toList();

        if (players.isEmpty()) {
            currentPlayerService.clear();

            throw new PlayerNotFoundException(
                    "BE - Uživatel nemá přiřazeného žádného hráče schváleného Administrátorem. Nelze automaticky vybrat.",
                    userEmail
            );
        }
        if (players.size() == 1) {
            PlayerEntity onlyPlayer = players.get(0);

            currentPlayerService.setCurrentPlayerId(onlyPlayer.getId());

            String message = "BE - Byl vybrán jediný schválený hráč: " + onlyPlayer.getFullName();
            return buildSuccessResponse(message, onlyPlayer.getId());
        }

        currentPlayerService.clear();

        StringBuilder sb = new StringBuilder();
        for (PlayerEntity player : players) {
            sb.append(players.indexOf(player) + 1);
            sb.append(". - ");
            sb.append(player.getFullName());
            sb.append(" / ");
        }
        String message = "BE - Uživatel má více hráčů a musí je vybrat manuálně dle nastavení: " + sb;
        return buildSuccessResponse(message, 0L);
    }

    // PRIVATE HELPERY – ENTITY / DUPLICITY

    /**
     * Najde hráče podle ID nebo vyhodí {@link PlayerNotFoundException}.
     *
     * @param id ID hráče
     * @return entita hráče
     */
    private PlayerEntity findPlayerOrThrow(Long id) {
        return playerRepository.findById(id)
                .orElseThrow(() -> new PlayerNotFoundException(id));
    }

    /**
     * Najde uživatele podle ID nebo vyhodí {@link UserNotFoundException}.
     *
     * @param id ID uživatele
     * @return entita uživatele
     */
    private AppUserEntity findUserOrThrow(Long id) {
        return appUserRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException(id));
    }

    /**
     * Zajistí unikátnost kombinace jméno + příjmení.
     *
     * Při vytváření nového hráče se očekává ignoreId null.
     * Při aktualizaci se ignoruje hráč se stejným ID, aby nebyl
     * považován za duplicitního sám se sebou.
     *
     * @param name     jméno hráče
     * @param surname  příjmení hráče
     * @param ignoreId ID hráče, který má být ignorován, nebo null
     */
    private void ensureUniqueNameSurname(String name, String surname, Long ignoreId) {
        Optional<PlayerEntity> duplicateOpt = playerRepository.findByNameAndSurname(name, surname);

        if (duplicateOpt.isPresent()) {
            PlayerEntity duplicate = duplicateOpt.get();

            if (ignoreId == null || !duplicate.getId().equals(ignoreId)) {
                throw new DuplicateNameSurnameException(name, surname);
            }
        }
    }

    /**
     * Ověří, že hráč patří danému uživateli (podle emailu).
     *
     * Pokud hráč uživateli nepatří, vyhodí se {@link ForbiddenPlayerAccessException}.
     *
     * @param player    hráč
     * @param userEmail email uživatele
     */
    private void assertPlayerBelongsToUser(PlayerEntity player, String userEmail) {
        if (player.getUser() == null ||
                player.getUser().getEmail() == null ||
                !player.getUser().getEmail().equals(userEmail)) {

            throw new ForbiddenPlayerAccessException(player.getId());
        }
    }

    /**
     * Vytvoří standardizovanou úspěšnou odpověď {@link SuccessResponseDTO}
     * s danou zprávou a ID.
     *
     * @param message textová zpráva
     * @param id      ID entity, které se operace týkala
     * @return úspěšná odpověď
     */
    private SuccessResponseDTO buildSuccessResponse(String message, Long id) {
        return new SuccessResponseDTO(
                message,
                id,
                LocalDateTime.now().toString()
        );
    }

    /**
     * Obecná pomocná metoda pro změnu statusu hráče (approve/reject).
     *
     * Ověří se, že hráč již není v cílovém stavu, případně se nastaví
     * výchozí nastavení pro hráče při schválení. Po uložení se odešle
     * notifikace podle nového statusu.
     *
     * @param id                     ID hráče
     * @param targetStatus           cílový status
     * @param alreadyStatus          status, který znamená „už je v tomto stavu“
     * @param notificationType       typ notifikace (případně přepsaný podle statusu)
     * @param alreadyMessage         zpráva pro případ, že je hráč již v cílovém stavu
     * @param successMessageTemplate šablona úspěšné zprávy
     * @return odpověď s výsledkem operace
     */
    private SuccessResponseDTO changePlayerStatus(Long id,
                                                  PlayerStatus targetStatus,
                                                  PlayerStatus alreadyStatus,
                                                  NotificationType notificationType,
                                                  String alreadyMessage,
                                                  String successMessageTemplate) {

        PlayerEntity player = findPlayerOrThrow(id);

        if (player.getPlayerStatus() == alreadyStatus) {
            throw new InvalidPlayerStatusException(alreadyMessage);
        }

        player.setPlayerStatus(targetStatus);

        if (targetStatus == APPROVED && player.getSettings() == null) {
            PlayerSettingsEntity settings =
                    playerSettingsService.createDefaultSettingsForPlayer(player);
            player.setSettings(settings);
        }
        PlayerEntity saved = playerRepository.save(player);

        notificationType = resolveNotificationType(targetStatus);
        if (notificationType != null) {
            notifyPlayer(saved, notificationType, saved);
        }

        String message = String.format(successMessageTemplate, saved.getFullName());
        return buildSuccessResponse(message, id);
    }

    // PRIVÁTNÍ HELPERY – NOTIFIKACE

    private void notifyPlayer(PlayerEntity player, NotificationType type, Object context) {
        notificationService.notifyPlayer(player, type, context);
    }

    private void notifyUser(AppUserEntity user, NotificationType type, Object context) {
        notificationService.notifyUser(user, type, context);
    }

    /**
     * Převede status hráče na typ notifikace.
     *
     * Pokud se pro zadaný status notifikace neposílá,
     * vrací se null. Status PENDING se zde nevyužívá,
     * protože notifikace při vytvoření hráče jsou řešeny jinde.
     *
     * @param newStatus nový status hráče
     * @return odpovídající {@link NotificationType} nebo null
     */
    private NotificationType resolveNotificationType(PlayerStatus newStatus) {
        return switch (newStatus) {
            case APPROVED -> NotificationType.PLAYER_APPROVED;
            case REJECTED -> NotificationType.MATCH_REGISTRATION_CANCELED;
            default -> null;
        };
    }

}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerSettingsService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerSettingsEntity;
import cz.phsoft.hokej.models.dto.PlayerSettingsDTO;

/**
 * Service rozhraní pro práci s nastavením hráče ({@link PlayerSettingsEntity}).
 *
 * Odpovědnosti:
 * - poskytovat přístup k nastavení konkrétního hráče,
 * - vytvářet výchozí nastavení hráče,
 * - aktualizovat existující nastavení hráče na základě DTO.
 *
 * Architektura:
 * - pracuje s {@link PlayerSettingsDTO} jako přenosovým objektem mezi backendem a frontendem,
 * - nezajišťuje autorizaci ani kontrolu vlastnictví hráče,
 *   tyto kontroly se provádějí v controlleru nebo ve vyšší servisní vrstvě.
 */
public interface PlayerSettingsService {

    /**
     * Vrátí nastavení pro hráče podle jeho ID.
     *
     * Pokud nastavení ještě neexistuje, vytvoří se z výchozích hodnot
     * a uloží se pro daného hráče. Tím se zajišťuje, že volající vždy
     * obdrží platné nastavení.
     *
     * @param playerId ID hráče
     * @return nastavení hráče ve formě {@link PlayerSettingsDTO}
     */
    PlayerSettingsDTO getSettingsForPlayer(Long playerId);

    /**
     * Aktualizuje nastavení pro hráče podle jeho ID.
     *
     * Pokud hráč ještě nemá nastavení, vytvoří se výchozí nastavení
     * a následně se na něj aplikují hodnoty z DTO.
     *
     * @param playerId ID hráče
     * @param dto      nové hodnoty nastavení
     * @return aktualizované nastavení ve formě {@link PlayerSettingsDTO}
     */
    PlayerSettingsDTO updateSettingsForPlayer(Long playerId, PlayerSettingsDTO dto);

    /**
     * Vytvoří výchozí nastavení pro hráče.
     *
     * Metoda pouze vytváří instanci {@link PlayerSettingsEntity}
     * s nastavovanými default hodnotami. Uložení do databáze
     * je odpovědností volajícího kódu.
     *
     * @param player hráč, ke kterému budou defaultní hodnoty přiřazeny
     * @return nová instance {@link PlayerSettingsEntity} s výchozím nastavením
     */
    PlayerSettingsEntity createDefaultSettingsForPlayer(PlayerEntity player);
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerSettingsServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerSettingsEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.data.repositories.PlayerSettingsRepository;
import cz.phsoft.hokej.models.dto.PlayerSettingsDTO;
import cz.phsoft.hokej.models.mappers.PlayerSettingsMapper;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

/**
 * Implementace služby pro práci s nastavením hráče ({@link PlayerSettingsEntity}).
 *
 * Odpovědnosti:
 * - načítání nastavení hráče podle jeho ID,
 * - vytváření výchozího nastavení pro hráče, pokud ještě neexistuje,
 * - aktualizace existujícího nastavení podle {@link PlayerSettingsDTO}.
 *
 * Tato třída:
 * - neřeší autorizaci ani ověřování vlastnictví hráče (řeší controller),
 * - neodesílá notifikace, pouze spravuje data v databázi,
 * - spolupracuje s:
 *   - {@link PlayerRepository} pro ověření existence hráče,
 *   - {@link PlayerSettingsRepository} pro práci s nastavením,
 *   - {@link PlayerSettingsMapper} pro mapování mezi entitou a DTO.
 */
@Service
@Transactional
public class PlayerSettingsServiceImpl implements PlayerSettingsService {

    private final PlayerRepository playerRepository;
    private final PlayerSettingsRepository playerSettingsRepository;
    private final PlayerSettingsMapper mapper;

    public PlayerSettingsServiceImpl(PlayerRepository playerRepository,
                                     PlayerSettingsRepository playerSettingsRepository,
                                     PlayerSettingsMapper mapper) {
        this.playerRepository = playerRepository;
        this.playerSettingsRepository = playerSettingsRepository;
        this.mapper = mapper;
    }

    /**
     * Vrátí nastavení pro hráče podle jeho ID.
     *
     * Postup:
     * - ověří se existence hráče,
     * - pokusí se načíst existující nastavení hráče,
     * - pokud neexistuje žádný záznam, vytvoří se výchozí nastavení
     *   pomocí {@link #createDefaultSettingsForPlayer(PlayerEntity)} a uloží se,
     * - výsledek se namapuje na {@link PlayerSettingsDTO}.
     *
     * @param playerId ID hráče
     * @return nastavení hráče ve formě {@link PlayerSettingsDTO}
     * @throws PlayerNotFoundException pokud hráč neexistuje
     */
    @Override
    public PlayerSettingsDTO getSettingsForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        Optional<PlayerSettingsEntity> existingOpt =
                playerSettingsRepository.findByPlayer(player);

        PlayerSettingsEntity settings = existingOpt.orElseGet(() -> {
            PlayerSettingsEntity created = createDefaultSettingsForPlayer(player);
            return playerSettingsRepository.save(created);
        });

        return mapper.toDTO(settings);
    }

    /**
     * Aktualizuje nastavení hráče podle jeho ID.
     *
     * Postup:
     * - ověří se existence hráče,
     * - načte se existující nastavení hráče, nebo se vytvoří nové výchozí,
     * - na entitu se aplikují hodnoty z {@link PlayerSettingsDTO},
     * - zajišťuje se navázání na hráče (settings.setPlayer),
     * - entita se uloží a navrátí se ve formě DTO.
     *
     * @param playerId ID hráče
     * @param dto      nové hodnoty nastavení
     * @return aktualizované nastavení ve formě {@link PlayerSettingsDTO}
     * @throws PlayerNotFoundException pokud hráč neexistuje
     */
    @Override
    public PlayerSettingsDTO updateSettingsForPlayer(Long playerId, PlayerSettingsDTO dto) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        PlayerSettingsEntity settings = playerSettingsRepository.findByPlayer(player)
                .orElseGet(() -> createDefaultSettingsForPlayer(player));

        mapper.updateEntityFromDTO(dto, settings);

        // pro jistotu se zajišťuje navázání na hráče
        settings.setPlayer(player);

        PlayerSettingsEntity saved = playerSettingsRepository.save(settings);

        return mapper.toDTO(saved);
    }

    // =========================
    // HELPER METODY
    // =========================

    /**
     * Najde hráče podle ID nebo vyhodí {@link PlayerNotFoundException}.
     *
     * Metoda centralizuje práci s {@link PlayerRepository} a
     * zjednodušuje obsluhu chyb při neexistujícím hráči.
     *
     * @param playerId ID hráče
     * @return entita hráče
     * @throws PlayerNotFoundException pokud hráč s daným ID neexistuje
     */
    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    /**
     * Vytvoří výchozí nastavení pro daného hráče.
     *
     * Výchozí chování:
     * - kontaktní email a telefon jsou ponechány prázdné (null),
     * - emailové notifikace:
     *   - notifyOnRegistration = true,
     *   - notifyOnExcuse = true,
     *   - notifyOnMatchChange = true,
     *   - notifyOnMatchCancel = true,
     *   - notifyOnPayment = false,
     * - připomínky:
     *   - notifyReminders = true,
     *   - reminderHoursBefore = 24.
     *
     * Default hodnoty odpovídají původní logice, která byla dříve
     * uložena přímo v entitě {@link PlayerEntity} (emailEnabled, smsEnabled)
     * a nyní je přesunuta do dedikované entity {@link PlayerSettingsEntity}.
     *
     * Metoda pouze vrací neinicializovanou entitu, uložení do databáze
     * provádí volající kód.
     *
     * @param player hráč, pro kterého se výchozí nastavení vytváří
     * @return nová instance {@link PlayerSettingsEntity} s výchozím nastavením
     */
    @Override
    public PlayerSettingsEntity createDefaultSettingsForPlayer(PlayerEntity player) {
        PlayerSettingsEntity settings = new PlayerSettingsEntity();
        settings.setPlayer(player);

        // explicitně nastavené default hodnoty

        settings.setContactEmail(null);
        settings.setContactPhone(null);

        // původní logika z PlayerEntity.emailEnabled / smsEnabled přesunuta do nastavení hráče
        settings.setEmailEnabled(true);
        settings.setSmsEnabled(true);
        settings.setNotifyOnRegistration(true);
        settings.setNotifyOnExcuse(true);
        settings.setNotifyOnMatchChange(true);
        settings.setNotifyOnMatchCancel(true);
        settings.setNotifyOnPayment(false);

        settings.setNotifyReminders(false);
        settings.setReminderHoursBefore(24);

        return settings;
    }

}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerStatsService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.PlayerStatsDTO;

/**
 * Service rozhraní pro poskytování statistik hráče.
 *
 * Slouží k zapouzdření business logiky výpočtu statistik hráče
 * v rámci aktuální sezóny. Implementace je odpovědná za načtení
 * relevantních zápasů, vyhodnocení aktivity hráče a agregaci
 * registračních statusů do souhrnné podoby.
 *
 * Toto rozhraní je určeno pro použití v aplikační vrstvě
 * (například z controlleru) a odděluje kontrakt od konkrétní
 * implementace výpočtu.
 */
public interface PlayerStatsService {

    /**
     * Vrací statistiku hráče za aktuální sezónu.
     *
     * Statistika zahrnuje celkový počet odehraných zápasů sezóny
     * a počty zápasů rozdělené podle registračního statusu hráče.
     *
     * @param playerId Identifikátor hráče, pro kterého se statistika počítá.
     * @return Datový přenosový objekt obsahující souhrnné statistiky hráče.
     */
    PlayerStatsDTO getPlayerStats(Long playerId);

}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerStatsServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerStatsDTO;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Service vrstva pro výpočet statistik hráče v rámci aktuální sezóny.
 *
 * Zajišťuje výběr odehraných zápasů aktuální sezóny a jejich zúžení podle
 * data vytvoření hráče a jeho aktivity v daném termínu. Následně agreguje
 * registrace hráče do souhrnných počtů podle statusu.
 *
 * Třída koordinuje načtení dat přes repository a deleguje dílčí logiku
 * na související služby (aktuální sezóna, aktivní sezóna, období neaktivity,
 * registrace zápasů).
 */
@Service
public class PlayerStatsServiceImpl implements PlayerStatsService {

    private final PlayerRepository playerRepository;
    private final MatchRepository matchRepository;
    private final CurrentSeasonService currentSeasonService;
    private final SeasonService seasonService;
    private final PlayerInactivityPeriodService playerInactivityPeriodService;
    private final MatchRegistrationService matchRegistrationService;

    /**
     * Vytváří service pro výpočet statistik hráče.
     *
     * Používá se napojení na repository pro načítání hráčů a zápasů a
     * na služby, které poskytují identifikátor aktuální sezóny, aktivní sezónu,
     * vyhodnocení aktivity hráče v čase a registrace zápasů.
     *
     * @param playerRepository Repository pro práci s hráči.
     * @param matchRepository Repository pro práci se zápasy.
     * @param currentSeasonService Service poskytující identifikátor aktuální sezóny.
     * @param seasonService Service poskytující aktivní sezónu jako fallback.
     * @param playerInactivityPeriodService Service pro vyhodnocení aktivity hráče v termínu zápasu.
     * @param matchRegistrationService Service pro načítání registrací hráčů na zápasy.
     */
    public PlayerStatsServiceImpl(PlayerRepository playerRepository,
                                  MatchRepository matchRepository,
                                  CurrentSeasonService currentSeasonService,
                                  SeasonService seasonService,
                                  PlayerInactivityPeriodService playerInactivityPeriodService,
                                  MatchRegistrationService matchRegistrationService) {
        this.playerRepository = playerRepository;
        this.matchRepository = matchRepository;
        this.currentSeasonService = currentSeasonService;
        this.seasonService = seasonService;
        this.playerInactivityPeriodService = playerInactivityPeriodService;
        this.matchRegistrationService = matchRegistrationService;
    }

    /**
     * Vrací statistiky hráče pro odehrané zápasy aktuální sezóny.
     *
     * Nejprve se načte hráč a datum jeho vytvoření. Následně se načtou
     * všechny odehrané zápasy aktuální sezóny a spočítá se jejich celkový počet.
     * Zápasy se dále filtrují tak, aby byly zahrnuty pouze zápasy po vytvoření hráče
     * a pouze ty, ve kterých byl hráč v daném čase aktivní.
     *
     * Pokud pro hráče nejsou žádné relevantní zápasy, vrací se DTO s vyplněným
     * identifikátorem hráče a počtem zápasů v sezóně a ostatní hodnoty zůstávají nulové.
     *
     * Pro relevantní zápasy se načtou registrace a vytvoří se mapování matchId na status
     * pouze pro daného hráče. Pro zápasy bez registrace se použije výchozí status NO_RESPONSE.
     * Nakonec se agregované počty přenesou do návratového DTO.
     *
     * @param playerId Identifikátor hráče, pro kterého se statistiky počítají.
     * @return DTO obsahující souhrnné počty zápasů podle statusů a počet zápasů v sezóně.
     * @throws PlayerNotFoundException Pokud hráč se zadaným identifikátorem neexistuje.
     */
    @Override
    public PlayerStatsDTO getPlayerStats(Long playerId) {
        PlayerEntity player = getPlayerOrThrow(playerId);
        LocalDateTime playerCreatedDate = player.getTimestamp();

        List<MatchEntity> pastMatchesInSeason = findPastMatchesForCurrentSeason();
        int allMatchesInCurrentSeason = pastMatchesInSeason.size();

        List<MatchEntity> availableMatches =
                pastMatchesInSeason.stream()
                        .filter(match -> match.getDateTime().isAfter(playerCreatedDate))
                        .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                        .toList();

        int allMatchesInSeasonForPlayer = availableMatches.size();

        PlayerStatsDTO statsDTO = new PlayerStatsDTO();
        statsDTO.setPlayerId(playerId);
        statsDTO.setAllMatchesInSeason(allMatchesInCurrentSeason);
        statsDTO.setAllMatchesInSeasonForPlayer(allMatchesInSeasonForPlayer);
        statsDTO.setHomeTeam(player.getTeam());

        // vždy připravíme mapu se všemi týmy (ať je výstup stabilní pro FE)
        EnumMap<Team, Integer> registeredByTeam = new EnumMap<>(Team.class);
        for (Team t : Team.values()) {
            registeredByTeam.put(t, 0);
        }

        if (availableMatches.isEmpty()) {
            statsDTO.setRegisteredByTeam(registeredByTeam);
            return statsDTO;
        }

        List<Long> matchIds = availableMatches.stream()
                .map(MatchEntity::getId)
                .toList();

        List<MatchRegistrationDTO> allRegistrations =
                matchRegistrationService.getRegistrationsForMatches(matchIds);

        Map<Long, PlayerMatchStatus> playerStatusByMatchId = allRegistrations.stream()
                .filter(r -> playerId.equals(r.getPlayerId()))
                .collect(Collectors.toMap(
                        MatchRegistrationDTO::getMatchId,
                        MatchRegistrationDTO::getStatus,
                        (a, b) -> a
                ));

        Map<Long, Team> playerTeamByMatchId = allRegistrations.stream()
                .filter(r -> playerId.equals(r.getPlayerId()))
                .collect(Collectors.toMap(
                        MatchRegistrationDTO::getMatchId,
                        MatchRegistrationDTO::getTeam,
                        (a, b) -> a
                ));

        EnumMap<PlayerMatchStatus, Integer> counts = new EnumMap<>(PlayerMatchStatus.class);

        for (MatchEntity match : availableMatches) {
            PlayerMatchStatus status = playerStatusByMatchId.getOrDefault(
                    match.getId(),
                    PlayerMatchStatus.NO_RESPONSE
            );

            counts.merge(status, 1, Integer::sum);

            // jen REGISTERED a jen podle team z registrace
            if (status == PlayerMatchStatus.REGISTERED) {
                Team team = playerTeamByMatchId.get(match.getId());
                if (team != null) {
                    registeredByTeam.merge(team, 1, Integer::sum);
                }
            }
        }

        statsDTO.setRegistered(counts.getOrDefault(PlayerMatchStatus.REGISTERED, 0));
        statsDTO.setUnregistered(counts.getOrDefault(PlayerMatchStatus.UNREGISTERED, 0));
        statsDTO.setExcused(counts.getOrDefault(PlayerMatchStatus.EXCUSED, 0));
        statsDTO.setSubstituted(counts.getOrDefault(PlayerMatchStatus.SUBSTITUTE, 0));
        statsDTO.setReserved(counts.getOrDefault(PlayerMatchStatus.RESERVED, 0));
        statsDTO.setNoResponse(counts.getOrDefault(PlayerMatchStatus.NO_RESPONSE, 0));
        statsDTO.setNoExcused(counts.getOrDefault(PlayerMatchStatus.NO_EXCUSED, 0));

        // stabilní mapa pro FE (obsahuje všechny Team.values())
        statsDTO.setRegisteredByTeam(registeredByTeam);

        return statsDTO;
    }

    /**
     * Načítá odehrané zápasy aktuální sezóny.
     *
     * Zápasy se vybírají podle identifikátoru sezóny a data zápasu menšího než aktuální čas.
     * Výsledek se řadí sestupně podle data zápasu.
     *
     * @return Seznam odehraných zápasů aktuální sezóny.
     */
    private List<MatchEntity> findPastMatchesForCurrentSeason() {
        return matchRepository.findBySeasonIdAndDateTimeBeforeOrderByDateTimeDesc(
                getCurrentSeasonIdOrActive(),
                now()
        );
    }

    /**
     * Vrací hráče podle identifikátoru nebo vyhazuje výjimku, pokud neexistuje.
     *
     * @param playerId Identifikátor hráče.
     * @return Entita hráče.
     * @throws PlayerNotFoundException Pokud hráč se zadaným identifikátorem neexistuje.
     */
    private PlayerEntity getPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    /**
     * Určuje identifikátor sezóny, pro kterou se mají počítat statistiky.
     *
     * Primárně se používá identifikátor aktuální sezóny poskytnutý službou.
     * Pokud není dostupný, použije se identifikátor aktivní sezóny.
     *
     * @return Identifikátor sezóny použitý pro výběr zápasů.
     */
    private Long getCurrentSeasonIdOrActive() {
        Long id = currentSeasonService.getCurrentSeasonIdOrDefault();
        if (id != null) {
            return id;
        }
        return seasonService.getActiveSeason().getId();
    }

    /**
     * Vrací aktuální čas používaný pro porovnání termínu zápasů.
     *
     * @return Aktuální čas.
     */
    private LocalDateTime now() {
        return LocalDateTime.now();
    }

    /**
     * Vyhodnocuje, zda byl hráč aktivní v době konání zápasu.
     *
     * Výsledek se deleguje na službu spravující období neaktivity hráče.
     *
     * @param player Hráč, pro kterého se aktivita vyhodnocuje.
     * @param dateTime Termín zápasu.
     * @return True, pokud byl hráč v daném termínu aktivní.
     */
    private boolean isPlayerActiveForMatch(PlayerEntity player, LocalDateTime dateTime) {
        return playerInactivityPeriodService.isActive(player, dateTime);
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\SeasonHistoryService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.SeasonHistoryDTO;

import java.util.List;

/**
 * Service rozhraní používané pro poskytování historických dat sezóny.
 *
 * Rozhraní definuje kontrakt pro načítání přehledových nebo statistických údajů
 * vztahujících se ke konkrétní sezóně. Implementace je odpovědná za sestavení
 * historických dat z příslušných entit a jejich převod do DTO vrstvy.
 *
 * Vrstva service zajišťuje business logiku a agregace dat. Controller vrstva
 * využívá toto rozhraní pro zpřístupnění historie sezóny klientovi aplikace.
 */
public interface SeasonHistoryService {

    /**
     * Vrací historická data pro zadanou sezónu.
     *
     * Implementace načítá potřebná data pro danou sezónu,
     * provádí agregace nebo výpočty podle business pravidel
     * a výsledek převádí do seznamu {@link SeasonHistoryDTO}.
     *
     * @param seasonId Identifikátor sezóny, pro kterou se historie načítá.
     * @return Seznam historických záznamů sezóny ve formě DTO.
     */
    List<SeasonHistoryDTO> getHistoryForSeason(Long seasonId);
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\SeasonHistoryServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.repositories.SeasonHistoryRepository;
import cz.phsoft.hokej.models.dto.SeasonHistoryDTO;
import cz.phsoft.hokej.models.mappers.SeasonHistoryMapper;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * Implementace service vrstvy používaná pro poskytování historických dat sezóny.
 *
 * Třída zajišťuje načtení záznamů historie sezóny z repository vrstvy a jejich převod do DTO.
 * Načítání dat se deleguje do {@link SeasonHistoryRepository} a mapování entit na DTO se deleguje
 * do {@link SeasonHistoryMapper}.
 *
 * Implementace neposkytuje zápisovou logiku a slouží pouze pro čtení a prezentaci historie sezóny
 * vyšším vrstvám aplikace, typicky controller vrstvě.
 */
@Service
public class SeasonHistoryServiceImpl implements SeasonHistoryService {

    private final SeasonHistoryRepository repository;
    private final SeasonHistoryMapper mapper;

    public SeasonHistoryServiceImpl(
            SeasonHistoryRepository repository,
            SeasonHistoryMapper mapper
    ) {
        this.repository = repository;
        this.mapper = mapper;
    }

    /**
     * Vrací historická data pro zadanou sezónu seřazená od nejnovější změny.
     *
     * Data se načítají z repository vrstvy filtrováním podle identifikátoru sezóny.
     * Výsledek se převádí do {@link SeasonHistoryDTO} pomocí mapper vrstvy.
     *
     * @param seasonId Identifikátor sezóny, pro kterou se historie načítá.
     * @return Seznam historických záznamů sezóny ve formě DTO seřazený sestupně podle času změny.
     */
    @Override
    public List<SeasonHistoryDTO> getHistoryForSeason(Long seasonId) {
        return mapper.toDTOList(
                repository.findBySeasonIdOrderByChangedAtDesc(seasonId)
        );
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\SeasonService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.SeasonEntity;
import cz.phsoft.hokej.models.dto.SeasonDTO;

import java.util.List;

/**
 * Rozhraní pro správu sezón v aplikaci.
 *
 * Odpovědnosti:
 * - definovat kontrakt pro práci se sezónami jako časovým rámcem pro zápasy a statistiky,
 * - poskytovat operace pro vytvoření, úpravu a načtení sezón,
 * - určovat aktivní sezónu, která se používá v ostatních službách (např. MatchServiceImpl).
 *
 * Architektura:
 * - většina operací pracuje s {@link SeasonDTO} jako přenosovým objektem,
 * - metoda {@link #getActiveSeason()} vrací entitu {@link SeasonEntity}
 *   pro interní business logiku v jiných službách.
 */
public interface SeasonService {

    /**
     * Vytvoří novou sezónu.
     *
     * Odpovědnost implementace:
     * - validovat datumové rozmezí sezóny,
     * - zajistit, aby se období sezóny nepřekrývalo s jinými sezónami.
     *
     * @param season data nové sezóny
     * @return vytvořená sezóna ve formě {@link SeasonDTO}
     */
    SeasonDTO createSeason(SeasonDTO season);

    /**
     * Aktualizuje existující sezónu.
     *
     * Implementace typicky:
     * - ověřuje existenci sezóny,
     * - validuje datumové rozmezí a překryvy,
     * - aplikuje změny z DTO do entity.
     *
     * @param id     ID sezóny, která má být aktualizována
     * @param season nové hodnoty sezóny
     * @return aktualizovaná sezóna ve formě {@link SeasonDTO}
     */
    SeasonDTO updateSeason(Long id, SeasonDTO season);

    /**
     * Vrátí aktuálně aktivní sezónu.
     *
     * Aktivní sezóna představuje časový rámec, ve kterém se považují
     * zápasy a jejich statistiky za „platné“. Hodnota se používá
     * v dalších službách, například v {@code MatchServiceImpl}.
     *
     * @return aktivní sezóna jako entita {@link SeasonEntity}
     */
    SeasonEntity getActiveSeason();

    /**
     * Vrátí seznam všech sezón v systému.
     *
     * Metoda se typicky používá v administrátorských přehledech
     * a v UI pro správu sezón.
     *
     * @return seznam všech sezón ve formě {@link SeasonDTO}
     */
    List<SeasonDTO> getAllSeasons();

    /**
     * Nastaví zadanou sezónu jako aktivní.
     *
     * Implementace zajišťuje, že v systému existuje
     * vždy nejvýše jedna aktivní sezóna.
     *
     * @param seasonId ID sezóny, která má být nastavena jako aktivní
     */
    void setActiveSeason(Long seasonId);

    /**
     * Vrátí aktivní sezónu ve formě {@link SeasonDTO} nebo null,
     * pokud žádná aktivní sezóna není nastavena.
     *
     * Metoda se používá tam, kde je absence aktivní sezóny
     * platným a očekávaným stavem.
     *
     * @return aktivní sezóna nebo null
     */
    SeasonDTO getActiveSeasonOrNull();

    /**
     * Vrátí sezónu podle jejího ID.
     *
     * Používá se v administrátorské části a interní logice,
     * kde je potřeba pracovat s konkrétní sezónou.
     *
     * @param id ID sezóny
     * @return sezóna ve formě {@link SeasonDTO}
     */
    SeasonDTO getSeasonById(Long id);
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\SeasonServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.SeasonEntity;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.SeasonRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.models.dto.SeasonDTO;
import cz.phsoft.hokej.models.mappers.SeasonMapper;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;

import java.time.LocalDate;
import java.util.List;

/**
 * Implementace service vrstvy používaná pro správu sezón.
 *
 * Třída zajišťuje vytváření a úpravy sezón včetně validace datumového rozsahu, kontroly překryvů a kontroly duplicity názvu.
 * Současně se zajišťuje správa aktivní sezóny tak, aby byl v systému v jeden okamžik aktivní právě jeden záznam.
 *
 * Načítání a ukládání dat se deleguje do {@link SeasonRepository} a převod mezi entitou a DTO se deleguje do {@link SeasonMapper}.
 * Identifikátor autora vytvoření sezóny se odvozuje z bezpečnostního kontextu a dohledává se přes {@link AppUserRepository}.
 *
 * Třída neřeší autorizaci endpointů, protože kontrola oprávnění se předpokládá v controller vrstvě.
 * Zároveň se zde neodesílají notifikace a řeší se pouze konzistence doménového stavu sezón.
 */
@Service
public class SeasonServiceImpl implements SeasonService {

    private final SeasonRepository seasonRepository;
    private final SeasonMapper mapper;
    private final AppUserRepository appUserRepository;

    public SeasonServiceImpl(SeasonRepository seasonRepository,
                             SeasonMapper mapper,
                             AppUserRepository appUserRepository) {
        this.seasonRepository = seasonRepository;
        this.mapper = mapper;
        this.appUserRepository = appUserRepository;
    }

    // CREATE

    /**
     * Vytváří novou sezónu.
     *
     * Před uložením se provádí validace datumového rozmezí, kontrola překryvu s existujícími sezónami a kontrola duplicity názvu.
     * Následně se DTO převede na entitu a uloží se přes repository vrstvu. Do entity se doplní identifikátor uživatele,
     * který sezónu vytvořil, pokud je možné jej odvodit z autentizace.
     *
     * Po uložení se vynucuje invariant aktivní sezóny. Pokud je nová sezóna označena jako aktivní, nastaví se jako jediná aktivní.
     * Pokud aktivní sezóna v systému neexistuje, nastaví se vytvořená sezóna jako aktivní automaticky.
     *
     * @param seasonDTO Vstupní data sezóny.
     * @return Vytvořená sezóna ve formě {@link SeasonDTO}.
     * @throws InvalidSeasonPeriodDateException Pokud jsou neplatná data od a do.
     * @throws SeasonPeriodOverlapException Pokud se sezóna překrývá s existující sezónou.
     * @throws DuplicateSeasonNameException Pokud již existuje sezóna se stejným názvem.
     */
    @Override
    @Transactional
    public SeasonDTO createSeason(SeasonDTO seasonDTO) {
        validateDates(seasonDTO, null);
        checkSeasonName(seasonDTO, null);

        SeasonEntity entity = mapper.toEntity(seasonDTO);

        // *** NOVÉ *** – nastavíme ID uživatele, který sezónu vytvořil
        Long currentUserId = getCurrentUserIdOrNull();
        entity.setCreatedByUserId(currentUserId);

        SeasonEntity saved = seasonRepository.save(entity);

        long activeCount = seasonRepository.countByActiveTrue();

        if (seasonDTO.isActive()) {
            setOnlyActiveSeason(saved.getId());
        } else if (activeCount == 0) {
            setOnlyActiveSeason(saved.getId());
        }

        return mapper.toDTO(saved);
    }

    // UPDATE

    /**
     * Aktualizuje existující sezónu.
     *
     * Nejprve se ověří existence sezóny podle identifikátoru. Poté se zvaliduje datumové rozmezí a překryvy s ostatními sezónami
     * s tím, že upravovaná sezóna se při kontrole překryvů ignoruje. Současně se kontroluje duplicita názvu sezóny.
     *
     * Při pokusu o deaktivaci aktivní sezóny se ověřuje, že v systému zůstane alespoň jedna aktivní sezóna.
     * Následně se změny z DTO promítnou do entity pomocí mapper vrstvy a sezóna se uloží přes repository vrstvu.
     *
     * Pokud se sezóna stane nově aktivní, nastaví se jako jediná aktivní sezóna a ostatní sezóny se deaktivují.
     *
     * @param id Identifikátor upravované sezóny.
     * @param seasonDTO Nové hodnoty sezóny.
     * @return Aktualizovaná sezóna ve formě {@link SeasonDTO}.
     * @throws SeasonNotFoundException Pokud sezóna s daným ID neexistuje.
     * @throws InvalidSeasonPeriodDateException Pokud jsou neplatná data od a do.
     * @throws SeasonPeriodOverlapException Pokud se sezóna překrývá s jinou sezónou.
     * @throws InvalidSeasonStateException Pokud se pokouší deaktivovat jediná aktivní sezóna.
     * @throws DuplicateSeasonNameException Pokud již existuje sezóna se stejným názvem.
     */
    @Override
    @Transactional
    public SeasonDTO updateSeason(Long id, SeasonDTO seasonDTO) {
        SeasonEntity existing = seasonRepository.findById(id)
                .orElseThrow(() -> new SeasonNotFoundException(id));

        validateDates(seasonDTO, id);
        checkSeasonName(seasonDTO, id);

        boolean wasActive = existing.isActive();
        boolean willBeActive = seasonDTO.isActive();

        if (wasActive && !willBeActive) {
            long activeCount = seasonRepository.countByActiveTrue();
            if (activeCount <= 1) {
                throw new InvalidSeasonStateException(
                        "BE - Nelze deaktivovat jedinou aktivní sezónu. " +
                                "Nejprve nastav jinou sezónu jako aktivní."
                );
            }
        }

        mapper.updateEntityFromDTO(seasonDTO, existing);
        SeasonEntity saved = seasonRepository.save(existing);

        if (!wasActive && saved.isActive()) {
            setOnlyActiveSeason(saved.getId());
        }

        return mapper.toDTO(saved);
    }

    // AKTIVNÍ SEZÓNA

    /**
     * Vrací aktuálně aktivní sezónu jako entitu.
     *
     * Metoda se používá v service vrstvě jako zdroj pravdy pro aktuální sezónu, typicky pro filtrování zápasů nebo dalších dat.
     * Načtení se deleguje do {@link SeasonRepository}. Pokud aktivní sezóna není nastavena, vyhazuje se {@link SeasonNotFoundException}.
     *
     * @return Aktuálně aktivní sezóna jako {@link SeasonEntity}.
     * @throws SeasonNotFoundException Pokud není nastavena žádná aktivní sezóna.
     */
    @Override
    public SeasonEntity getActiveSeason() {
        return seasonRepository.findByActiveTrue()
                .orElseThrow(() -> new SeasonNotFoundException(
                        "BE - Není nastavena žádná aktivní sezóna."
                ));
    }

    /**
     * Vrací aktuálně aktivní sezónu ve formě DTO nebo null.
     *
     * Metoda se používá v místech, kde je absence aktivní sezóny akceptovatelná a nemá být považována za chybový stav.
     * Načtení se deleguje do {@link SeasonRepository} a mapování se deleguje do {@link SeasonMapper}.
     *
     * @return Aktivní sezóna ve formě {@link SeasonDTO}, nebo null pokud aktivní sezóna neexistuje.
     */
    @Override
    public SeasonDTO getActiveSeasonOrNull() {
        return seasonRepository.findByActiveTrue()
                .map(mapper::toDTO)
                .orElse(null);
    }

    /**
     * Vrací sezónu podle identifikátoru ve formě DTO.
     *
     * Sezóna se načítá z repository vrstvy. Pokud sezóna neexistuje, vyhazuje se {@link SeasonNotFoundException}.
     * Mapování entity na DTO se deleguje do {@link SeasonMapper}.
     *
     * @param id Identifikátor sezóny.
     * @return Sezóna ve formě {@link SeasonDTO}.
     * @throws SeasonNotFoundException Pokud sezóna s daným ID neexistuje.
     */
    @Override
    public SeasonDTO getSeasonById(Long id) {
        SeasonEntity entity = seasonRepository.findById(id)
                .orElseThrow(() -> new SeasonNotFoundException(id));
        return mapper.toDTO(entity);
    }

    // SEZNAM VŠECH SEZÓN

    /**
     * Vrací všechny sezóny seřazené podle začátku vzestupně.
     *
     * Načtení se deleguje do {@link SeasonRepository} a mapování na DTO se deleguje do {@link SeasonMapper}.
     * Metoda se používá pro administrativní přehledy a pro zobrazení seznamu sezón v uživatelském rozhraní.
     *
     * @return Seznam všech sezón ve formě {@link SeasonDTO}.
     */
    @Override
    public List<SeasonDTO> getAllSeasons() {
        return seasonRepository.findAllByOrderByStartDateAsc()
                .stream()
                .map(mapper::toDTO)
                .toList();
    }

    // NASTAVENÍ AKTIVNÍ SEZÓNY

    /**
     * Nastavuje konkrétní sezónu jako aktivní.
     *
     * Nejprve se ověřuje existence sezóny podle identifikátoru. Následně se provede nastavení sezóny jako jediné aktivní
     * pomocí interní metody {@link #setOnlyActiveSeason(Long)}, která současně deaktivuje všechny ostatní sezóny.
     *
     * @param seasonId Identifikátor sezóny, která má být nastavena jako aktivní.
     * @throws SeasonNotFoundException Pokud sezóna s daným ID neexistuje.
     */
    @Override
    @Transactional
    public void setActiveSeason(Long seasonId) {
        SeasonEntity toActivate = seasonRepository.findById(seasonId)
                .orElseThrow(() -> new SeasonNotFoundException(seasonId));

        setOnlyActiveSeason(toActivate.getId());
    }

    // PRIVÁTNÍ VALIDACE DAT

    /**
     * Validuje datumové rozmezí sezóny a kontroluje překryv s ostatními sezónami.
     *
     * Kontroluje se, že datum začátku a konce není null, že datum začátku předchází datu konce a že rozsah sezóny
     * není v překryvu s jinou sezónou. Při aktualizaci se z kontroly překryvu vynechává sezóna s identifikátorem
     * currentSeasonId.
     *
     * @param seasonDTO DTO s daty sezóny.
     * @param currentSeasonId Identifikátor aktuální sezóny při aktualizaci, nebo null při vytváření.
     * @throws InvalidSeasonPeriodDateException Pokud jsou data neplatná.
     * @throws SeasonPeriodOverlapException Pokud se sezóna překrývá s jinou sezónou.
     */
    private void validateDates(SeasonDTO seasonDTO, Long currentSeasonId) {
        LocalDate start = seasonDTO.getStartDate();
        LocalDate end = seasonDTO.getEndDate();

        if (start == null || end == null) {
            throw new InvalidSeasonPeriodDateException("BE - Datum od a do nesmí být null.");
        }
        if (!start.isBefore(end)) {
            throw new InvalidSeasonPeriodDateException("BE - Datum 'od' musí být před 'do'.");
        }

        boolean overlaps;
        if (currentSeasonId == null) {
            overlaps = seasonRepository
                    .existsByStartDateLessThanEqualAndEndDateGreaterThanEqual(end, start);
        } else {
            overlaps = seasonRepository
                    .existsByStartDateLessThanEqualAndEndDateGreaterThanEqualAndIdNot(
                            end,
                            start,
                            currentSeasonId
                    );
        }

        if (overlaps) {
            throw new SeasonPeriodOverlapException("BE - Sezóna se překrývá s existující sezónou.");
        }
    }

    /**
     * Validuje název sezóny kontrolou duplicity vůči ostatním sezónám.
     *
     * Při vytváření se ověřuje existence názvu vůči všem sezónám. Při aktualizaci se kontrola provádí vůči všem sezónám
     * s tím, že sezóna s identifikátorem currentSeasonId se z kontroly vynechává.
     *
     * @param seasonDTO DTO s daty sezóny.
     * @param currentSeasonId Identifikátor aktuální sezóny při aktualizaci, nebo null při vytváření.
     * @throws DuplicateSeasonNameException Pokud již existuje sezóna se stejným názvem.
     */
    private void checkSeasonName(SeasonDTO seasonDTO, Long currentSeasonId) {
        String seasonName = seasonDTO.getName().trim();

        boolean existSeasonName;
        if (currentSeasonId == null) {
            existSeasonName = seasonRepository.existsByName(seasonName);
        } else {
            existSeasonName = seasonRepository.existsByNameAndIdNot(seasonName, currentSeasonId);
        }

        if (existSeasonName) {
            throw new DuplicateSeasonNameException(seasonName);
        }
    }

    // PRIVÁTNÍ POMOCNÁ METODA

    /**
     * Nastavuje zadanou sezónu jako jedinou aktivní.
     *
     * Všechny sezóny se načtou z repository vrstvy a následně se u sezóny se zadaným identifikátorem nastaví active na true,
     * zatímco u všech ostatních sezón se active nastaví na false. Změny se uloží hromadně přes {@link SeasonRepository}.
     * Tím se vynucuje invariant, že v systému existuje v jeden okamžik právě jedna aktivní sezóna.
     *
     * @param activeSeasonId Identifikátor sezóny, která má být nastavena jako jediná aktivní.
     */
    private void setOnlyActiveSeason(Long activeSeasonId) {
        List<SeasonEntity> all = seasonRepository.findAll();
        for (SeasonEntity season : all) {
            season.setActive(season.getId().equals(activeSeasonId));
        }
        seasonRepository.saveAll(all);
    }

    /**
     * Vrací identifikátor aktuálně přihlášeného uživatele nebo null, pokud není možné uživatele určit.
     *
     * Identifikátor se odvozuje z autentizace v bezpečnostním kontextu. Jako klíč se používá e-mail uživatele
     * a dohledání se provádí přes {@link AppUserRepository}. Pokud autentizace neexistuje, uživatel není přihlášen
     * nebo záznam uživatele nelze dohledat, vrací se null.
     *
     * @return Identifikátor aktuálního uživatele, nebo null pokud jej nelze určit.
     */
    private Long getCurrentUserIdOrNull() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth == null || !auth.isAuthenticated()) {
            return null;
        }

        String email = auth.getName();
        return appUserRepository.findByEmail(email)
                .map(AppUserEntity::getId)
                .orElse(null);
    }
}


