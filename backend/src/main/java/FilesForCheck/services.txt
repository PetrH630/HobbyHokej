Balíček (složka): services
Cesta: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services

Seznam souborů:
AppUserHistoryService.java
AppUserHistoryServiceImpl.java
AppUserService.java
AppUserServiceImpl.java
AppUserSettingsService.java
AppUserSettingsServiceImpl.java
CurrentPlayerService.java
CurrentPlayerServiceImpl.java
CurrentSeasonService.java
CurrentSeasonServiceImpl.java
MatchHistoryService.java
MatchHistoryServiceImpl.java
MatchRegistrationHistoryService.java
MatchRegistrationHistoryServiceImpl.java
MatchRegistrationService.java
MatchRegistrationServiceImpl.java
MatchService.java
MatchServiceImpl.java
NotificationDecision.java
package-info.java
PlayerHistoryService.java
PlayerHistoryServiceImpl.java
PlayerInactivityPeriodService.java
PlayerInactivityPeriodServiceImpl.java
PlayerService.java
PlayerServiceImpl.java
PlayerSettingsService.java
PlayerSettingsServiceImpl.java
PlayerStatsService.java
PlayerStatsServiceImpl.java
SeasonHistoryService.java
SeasonHistoryServiceImpl.java
SeasonService.java
SeasonServiceImpl.java


-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserHistoryService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.AppUserHistoryDTO;

import java.util.List;

/**
 * ServisnĂ­ rozhranĂ­ pro prĂˇci s historiĂ­ uĹľivatelskĂ˝ch ĂşÄŤtĹŻ.
 *
 * SlouĹľĂ­ k naÄŤĂ­tĂˇnĂ­ historickĂ˝ch zĂˇznamĹŻ uĹľivatele
 * pro auditnĂ­ a pĹ™ehledovĂ© ĂşÄŤely. HistorickĂ© zĂˇznamy
 * jsou typicky vytvĂˇĹ™eny databĂˇzovĂ˝mi triggery a
 * nĂˇslednÄ› pĹ™evĂˇdÄ›ny na DTO objekty pomocĂ­ mapperu.
 *
 * RozhranĂ­ je implementovĂˇno servisnĂ­ tĹ™Ă­dou,
 * kterĂˇ zajiĹˇĹĄuje komunikaci s repozitĂˇĹ™em
 * a pĹ™evod entit na DTO.
 */
public interface AppUserHistoryService {

    /**
     * VrĂˇtĂ­ historii zmÄ›n uĹľivatele podle jeho e-mailovĂ© adresy.
     *
     * @param email e-mailovĂˇ adresa uĹľivatele
     * @return seznam historickĂ˝ch zĂˇznamĹŻ uĹľivatele
     */
    List<AppUserHistoryDTO> getHistoryForUser(String email);

    /**
     * VrĂˇtĂ­ historii zmÄ›n uĹľivatele podle jeho identifikĂˇtoru.
     *
     * @param id identifikĂˇtor uĹľivatele
     * @return seznam historickĂ˝ch zĂˇznamĹŻ uĹľivatele
     */
    List<AppUserHistoryDTO> getHistoryForUser(Long id);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserHistoryServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.repositories.AppUserHistoryRepository;
import cz.phsoft.hokej.models.dto.AppUserHistoryDTO;
import cz.phsoft.hokej.models.mappers.AppUserHistoryMapper;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * Implementace servisnĂ­ vrstvy pro prĂˇci s historiĂ­ uĹľivatelskĂ˝ch ĂşÄŤtĹŻ.
 *
 * ZajiĹˇĹĄuje naÄŤĂ­tĂˇnĂ­ historickĂ˝ch zĂˇznamĹŻ uĹľivatele z databĂˇze
 * prostĹ™ednictvĂ­m repozitĂˇĹ™e a jejich pĹ™evod na DTO objekty
 * pomocĂ­ mapperu.
 *
 * TĹ™Ă­da neprovĂˇdĂ­ ĹľĂˇdnĂ© zĂˇpisy do databĂˇze. HistorickĂ© zĂˇznamy
 * jsou vytvĂˇĹ™eny databĂˇzovĂ˝mi triggery a tato sluĹľba slouĹľĂ­
 * vĂ˝hradnÄ› pro ÄŤtecĂ­ a auditnĂ­ ĂşÄŤely.
 */
@Service
public class AppUserHistoryServiceImpl implements AppUserHistoryService {

    private final AppUserHistoryRepository repository;
    private final AppUserHistoryMapper mapper;

    /**
     * VytvoĹ™Ă­ instanci servisnĂ­ tĹ™Ă­dy.
     *
     * @param repository repozitĂˇĹ™ pro pĹ™Ă­stup k historickĂ˝m zĂˇznamĹŻm uĹľivatelĹŻ
     * @param mapper mapper pro pĹ™evod entit na DTO objekty
     */
    public AppUserHistoryServiceImpl(
            AppUserHistoryRepository repository,
            AppUserHistoryMapper mapper
    ) {
        this.repository = repository;
        this.mapper = mapper;
    }

    /**
     * VrĂˇtĂ­ historii zmÄ›n uĹľivatele podle jeho e-mailovĂ© adresy.
     *
     * ZĂˇznamy jsou naÄŤteny z databĂˇze v sestupnĂ©m poĹ™adĂ­
     * podle ÄŤasu zmÄ›ny a nĂˇslednÄ› pĹ™evedeny na DTO objekty.
     *
     * @param email e-mailovĂˇ adresa uĹľivatele
     * @return seznam historickĂ˝ch zĂˇznamĹŻ uĹľivatele
     */
    @Override
    public List<AppUserHistoryDTO> getHistoryForUser(String email) {
        return mapper.toDTOList(
                repository.findByEmailOrderByChangedAtDesc(email)
        );
    }

    /**
     * VrĂˇtĂ­ historii zmÄ›n uĹľivatele podle jeho identifikĂˇtoru.
     *
     * ZĂˇznamy jsou naÄŤteny z databĂˇze v sestupnĂ©m poĹ™adĂ­
     * podle ÄŤasu zmÄ›ny a nĂˇslednÄ› pĹ™evedeny na DTO objekty.
     *
     * @param id identifikĂˇtor uĹľivatele
     * @return seznam historickĂ˝ch zĂˇznamĹŻ uĹľivatele
     */
    @Override
    public List<AppUserHistoryDTO> getHistoryForUser(Long id) {
        return mapper.toDTOList(
                repository.findByUserIdOrderByChangedAtDesc(id)
        );
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.ForgottenPasswordResetDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;

import java.util.List;

/**
 * RozhranĂ­ pro sprĂˇvu uĹľivatelskĂ˝ch ĂşÄŤtĹŻ aplikace.
 *
 * Definuje se smlouva pro registraci uĹľivatelĹŻ, zmÄ›nu a reset hesla,
 * aktivaci nebo deaktivaci ĂşÄŤtĹŻ a ÄŤtenĂ­ seznamĹŻ uĹľivatelĹŻ. RozhranĂ­
 * se pouĹľĂ­vĂˇ v controller vrstvĂˇch a v dalĹˇĂ­ch service tĹ™Ă­dĂˇch.
 *
 * Implementace pracuje s DTO objekty a zajiĹˇĹĄuje napojenĂ­
 * na perzistenÄŤnĂ­ vrstvu (repozitĂˇĹ™e) a notifikaÄŤnĂ­ mechanismy.
 */
public interface AppUserService {

    /**
     * Zaregistruje novĂ©ho uĹľivatele do systĂ©mu.
     *
     * ProvĂˇdĂ­ se kontrola jedineÄŤnosti emailu, shody hesla a jeho potvrzenĂ­
     * a dalĹˇĂ­ validaÄŤnĂ­ pravidla. NovĂ˝ ĂşÄŤet se typicky zaklĂˇdĂˇ jako neaktivnĂ­
     * a jeho aktivace se dokonÄŤuje pĹ™es aktivaÄŤnĂ­ odkaz.
     *
     * @param registerUserDTO registraÄŤnĂ­ data novĂ©ho uĹľivatele
     */
    void register(RegisterUserDTO registerUserDTO);

    /**
     * Aktualizuje Ăşdaje uĹľivatele podle emailu.
     *
     * PouĹľĂ­vĂˇ se pro zmÄ›ny bÄ›ĹľnĂ˝ch ĂşdajĹŻ (jmĂ©no, pĹ™Ă­jmenĂ­, email).
     * BezpeÄŤnost a oprĂˇvnÄ›nĂ­ se kontrolujĂ­ v controller vrstvÄ›.
     *
     * @param email email uĹľivatele, kterĂ˝ mĂˇ bĂ˝t aktualizovĂˇn
     * @param dto   novĂ© hodnoty uĹľivatelskĂ˝ch ĂşdajĹŻ
     */
    void updateUser(String email, AppUserDTO dto);

    /**
     * VracĂ­ aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele podle emailu.
     *
     * Metoda se pouĹľĂ­vĂˇ zejmĂ©na v kontextu endpointĹŻ typu "/me".
     *
     * @param email email pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @return DTO reprezentace aktuĂˇlnĂ­ho uĹľivatele
     */
    AppUserDTO getCurrentUser(String email);

    /**
     * VracĂ­ seznam vĹˇech uĹľivatelĹŻ v systĂ©mu.
     *
     * Typicky se pouĹľĂ­vĂˇ v administrĂˇtorskĂ©m rozhranĂ­
     * pro sprĂˇvu uĹľivatelĹŻ.
     *
     * @return seznam uĹľivatelĹŻ ve formÄ› DTO
     */
    List<AppUserDTO> getAllUsers();

    /**
     * VracĂ­ uĹľivatele podle ID.
     *
     * PouĹľĂ­vĂˇ se v administraci, kde je potĹ™eba pracovat
     * s konkrĂ©tnĂ­m ĂşÄŤtem podle jeho identifikĂˇtoru.
     *
     * @param userId ID uĹľivatele
     * @return uĹľivatel ve formÄ› DTO
     */
    AppUserDTO getUserById(Long userId);

    /**
     * ZmÄ›nĂ­ heslo uĹľivatele.
     *
     * OvÄ›Ĺ™uje se sprĂˇvnost pĹŻvodnĂ­ho hesla, shoda novĂ©ho hesla
     * a jeho potvrzenĂ­ a pĹ™Ă­padnĂ© bezpeÄŤnostnĂ­ poĹľadavky.
     *
     * @param email              email uĹľivatele
     * @param oldPassword        pĹŻvodnĂ­ heslo
     * @param newPassword        novĂ© heslo
     * @param newPasswordConfirm potvrzenĂ­ novĂ©ho hesla
     */
    void changePassword(
            String email,
            String oldPassword,
            String newPassword,
            String newPasswordConfirm
    );

    /**
     * Resetuje heslo uĹľivatele na vĂ˝chozĂ­ hodnotu.
     *
     * Operace se typicky pouĹľĂ­vĂˇ v administraci, kde se Ĺ™eĹˇĂ­
     * problĂ©my s pĹ™ihlĂˇĹˇenĂ­m. KonkrĂ©tnĂ­ politika bezpeÄŤnĂ©ho
     * zachĂˇzenĂ­ s takovĂ˝m heslem se Ĺ™eĹˇĂ­ v aplikaÄŤnĂ­ logice.
     *
     * @param userId ID uĹľivatele, jehoĹľ heslo mĂˇ bĂ˝t resetovĂˇno
     */
    void resetPassword(Long userId);

    /**
     * Aktivuje uĹľivatelskĂ˝ ĂşÄŤet na zĂˇkladÄ› aktivaÄŤnĂ­ho tokenu.
     *
     * Metoda se pouĹľĂ­vĂˇ po registraci uĹľivatele, kdy je odkaz
     * zaslĂˇn v aktivaÄŤnĂ­m emailu. PĹ™i ĂşspÄ›chu se ĂşÄŤet oznaÄŤĂ­
     * jako povolenĂ˝ k pĹ™ihlĂˇĹˇenĂ­.
     *
     * @param token aktivaÄŤnĂ­ token
     * @return true, pokud byla aktivace ĂşspÄ›ĹˇnĂˇ, jinak false
     */
    boolean activateUser(String token);

    /**
     * Aktivuje uĹľivatelskĂ˝ ĂşÄŤet v administraci.
     *
     * Aktivace se provĂˇdĂ­ bez pouĹľitĂ­ aktivaÄŤnĂ­ho tokenu,
     * typicky v situaci, kdy mĂˇ uĹľivatel technickĂ˝ problĂ©m
     * s aktivaÄŤnĂ­m emailem.
     *
     * @param id ID uĹľivatele
     */
    void activateUserByAdmin(Long id);

    /**
     * Deaktivuje uĹľivatelskĂ˝ ĂşÄŤet v administraci.
     *
     * ĂšÄŤet se ponechĂˇ v databĂˇzi, ale uĹľivatel se nemĹŻĹľe
     * doÄŤasnÄ› pĹ™ihlĂˇsit do aplikace.
     *
     * @param id ID uĹľivatele
     */
    void deactivateUserByAdmin(Long id);

    /**
     * VytvoĹ™Ă­ poĹľadavek na reset zapomenutĂ©ho hesla.
     *
     * Pro danĂ˝ email se vygeneruje resetovacĂ­ token a odeĹˇle
     * se odpovĂ­dajĂ­cĂ­ notifikace (napĹ™Ă­klad email s odkazem
     * na formulĂˇĹ™ pro nastavenĂ­ novĂ©ho hesla).
     *
     * @param email email uĹľivatele
     */
    void requestForgottenPasswordReset(String email);

    /**
     * VracĂ­ email uĹľivatele pro zadanĂ˝ resetovacĂ­ token.
     *
     * Metoda se pouĹľĂ­vĂˇ pĹ™i naÄŤĂ­tĂˇnĂ­ formulĂˇĹ™e pro nastavenĂ­
     * novĂ©ho hesla, aby se ovÄ›Ĺ™ilo, ke kterĂ©mu ĂşÄŤtu token patĹ™Ă­.
     *
     * @param token resetovacĂ­ token
     * @return email uĹľivatele
     */
    String getForgottenPasswordResetEmail(String token);

    /**
     * NastavĂ­ novĂ© heslo na zĂˇkladÄ› tokenu pro zapomenutĂ© heslo.
     *
     * Token se ovÄ›Ĺ™Ă­, zkontroluje se shoda hesla a jeho potvrzenĂ­
     * a potĂ© se heslo uloĹľĂ­ v zahashovanĂ© podobÄ›.
     *
     * @param dto data pro reset zapomenutĂ©ho hesla
     */
    void forgottenPasswordReset(ForgottenPasswordResetDTO dto);

    void onSuccessfulLogin(String email);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.EmailVerificationTokenEntity;
import cz.phsoft.hokej.data.entities.ForgottenPasswordResetTokenEntity;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.EmailVerificationTokenRepository;
import cz.phsoft.hokej.data.repositories.ForgottenPasswordResetTokenRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.ForgottenPasswordResetDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;
import cz.phsoft.hokej.models.mappers.AppUserMapper;
import cz.phsoft.hokej.models.services.email.EmailService;
import cz.phsoft.hokej.models.services.notification.ForgottenPasswordResetContext;
import cz.phsoft.hokej.models.services.notification.NotificationService;
import cz.phsoft.hokej.models.services.notification.UserActivationContext;
import cz.phsoft.hokej.models.services.demo.DemoModeGuard;
import jakarta.transaction.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

import java.time.Clock;
import java.time.Instant;

/**
 * Implementace servisnĂ­ vrstvy pro sprĂˇvu aplikaÄŤnĂ­ch uĹľivatelskĂ˝ch ĂşÄŤtĹŻ.
 *
 * ZajiĹˇĹĄuje registraci uĹľivatele, aktivaci a deaktivaci ĂşÄŤtu,
 * zmÄ›nu a reset hesla a aktualizaci zĂˇkladnĂ­ch ĂşdajĹŻ.
 * SouÄŤĂˇstĂ­ odpovÄ›dnosti je bezpeÄŤnĂ© uloĹľenĂ­ hesel pomocĂ­ BCrypt
 * a sprĂˇva ovÄ›Ĺ™ovacĂ­ch a resetovacĂ­ch tokenĹŻ.
 *
 * Notifikace o udĂˇlostech jsou odesĂ­lĂˇny prostĹ™ednictvĂ­m NotificationService.
 * Autentizace a autorizace jsou Ĺ™eĹˇeny v rĂˇmci Spring Security
 * a nejsou souÄŤĂˇstĂ­ odpovÄ›dnosti tĂ©to tĹ™Ă­dy.
 */
@Service
public class AppUserServiceImpl implements AppUserService {

    @Value("${app.frontend-base-url}")
    private String frontendBasUrl;
    @Value("${app.demo-mode:false}")
    private boolean isDemoMode;

    private static final Logger log = LoggerFactory.getLogger(AppUserServiceImpl.class);

    /**
     * VĂ˝chozĂ­ heslo pouĹľĂ­vanĂ© pĹ™i resetu ĂşÄŤtu administrĂˇtorem.
     */
    private static final String DEFAULT_RESET_PASSWORD = "Player123";

    /**
     * ZĂˇkladnĂ­ URL aplikace pouĹľĂ­vanĂˇ pro sestavenĂ­ odkazĹŻ
     * v aktivaÄŤnĂ­ch a resetovacĂ­ch notifikacĂ­ch.
     */
    @Value("${app.base-url}")
    private String baseUrl;

    private final AppUserRepository userRepository;
    private final BCryptPasswordEncoder passwordEncoder;
    private final AppUserMapper appUserMapper;
    private final EmailService emailService;
    private final EmailVerificationTokenRepository tokenRepository;
    private final AppUserSettingsService appUserSettingsService;
    private final NotificationService notificationService;
    private final ForgottenPasswordResetTokenRepository forgottenPasswordResetTokenRepository;
    private final DemoModeGuard demoModeGuard;
    private final Clock clock;

    /**
     * VytvoĹ™Ă­ instanci servisnĂ­ tĹ™Ă­dy.
     *
     * ZĂˇvislosti jsou pĹ™edĂˇny pomocĂ­ konstruktoru a jsou pouĹľĂ­vĂˇny
     * pro prĂˇci s databĂˇzĂ­, mapovĂˇnĂ­ dat a odesĂ­lĂˇnĂ­ notifikacĂ­.
     *
     * @param userRepository repozitĂˇĹ™ pro prĂˇci s uĹľivatelskĂ˝mi ĂşÄŤty
     * @param passwordEncoder encoder pro hashovĂˇnĂ­ a ovÄ›Ĺ™enĂ­ hesel
     * @param appUserMapper mapper pro pĹ™evod mezi entitami a DTO
     * @param emailService servis pro odesĂ­lĂˇnĂ­ e-mailĹŻ
     * @param tokenRepository repozitĂˇĹ™ pro ovÄ›Ĺ™ovacĂ­ tokeny
     * @param appUserSettingsService servis pro sprĂˇvu uĹľivatelskĂ˝ch nastavenĂ­
     * @param notificationService servis pro odesĂ­lĂˇnĂ­ notifikacĂ­
     * @param forgottenPasswordResetTokenRepository repozitĂˇĹ™ pro resetovacĂ­ tokeny
     */
    public AppUserServiceImpl(AppUserRepository userRepository,
                              BCryptPasswordEncoder passwordEncoder,
                              AppUserMapper appUserMapper,
                              EmailService emailService,
                              EmailVerificationTokenRepository tokenRepository,
                              AppUserSettingsService appUserSettingsService,
                              NotificationService notificationService,
                              ForgottenPasswordResetTokenRepository forgottenPasswordResetTokenRepository,
                              DemoModeGuard demoModeGuard,
                              Clock clock) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
        this.appUserMapper = appUserMapper;
        this.emailService = emailService;
        this.tokenRepository = tokenRepository;
        this.appUserSettingsService = appUserSettingsService;
        this.notificationService = notificationService;
        this.forgottenPasswordResetTokenRepository = forgottenPasswordResetTokenRepository;
        this.demoModeGuard = demoModeGuard;
        this.clock = clock;
    }

    /**
     * Zaregistruje novĂ©ho uĹľivatele.
     *
     * PĹ™ed vytvoĹ™enĂ­m ĂşÄŤtu se ovÄ›Ĺ™uje shoda zadanĂ˝ch hesel
     * a jedineÄŤnost e-mailovĂ© adresy. ĂšÄŤet je vytvoĹ™en jako neaktivnĂ­,
     * je vygenerovĂˇn ovÄ›Ĺ™ovacĂ­ token a je odeslĂˇna notifikace
     * obsahujĂ­cĂ­ aktivaÄŤnĂ­ odkaz.
     *
     * @param dto registraÄŤnĂ­ Ăşdaje uĹľivatele
     */
    @Override
    @Transactional
    public void register(RegisterUserDTO dto) {
        ensurePasswordsMatch(dto.getPassword(), dto.getPasswordConfirm(), null);
        ensureEmailNotUsed(dto.getEmail(), null);

        AppUserEntity user = createUserFromRegisterDto(dto);
        AppUserEntity savedUser = userRepository.save(user);

        EmailVerificationTokenEntity verificationToken =
                createVerificationToken(savedUser);

        String activationLink = buildActivationLink(verificationToken);
        log.info("AktivaÄŤnĂ­ odkaz pro {}: {}", user.getEmail(), activationLink);

        notificationService.notifyUser(
                savedUser,
                NotificationType.USER_CREATED,
                new UserActivationContext(savedUser, activationLink)
        );
    }

    /**
     * Aktivuje uĹľivatelskĂ˝ ĂşÄŤet na zĂˇkladÄ› ovÄ›Ĺ™ovacĂ­ho tokenu.
     *
     * Token je vyhledĂˇn a je ovÄ›Ĺ™ena jeho platnost. Pokud je token neplatnĂ˝
     * nebo expirovanĂ˝, je vrĂˇcena hodnota false. PĹ™i ĂşspÄ›ĹˇnĂ© aktivaci
     * je ĂşÄŤet povolen a v pĹ™Ă­padÄ› chybÄ›jĂ­cĂ­ konfigurace jsou vytvoĹ™ena
     * vĂ˝chozĂ­ uĹľivatelskĂˇ nastavenĂ­. PouĹľitĂ˝ token je odstranÄ›n.
     *
     * Po ĂşspÄ›ĹˇnĂ© aktivaci je odeslĂˇna notifikace o aktivaci ĂşÄŤtu.
     *
     * @param token aktivaÄŤnĂ­ token
     * @return true, pokud byla aktivace provedena, jinak false
     */
    @Override
    @Transactional
    public boolean activateUser(String token) {
        EmailVerificationTokenEntity verificationToken =
                tokenRepository.findByToken(token).orElse(null);

        if (verificationToken == null ||
                verificationToken.getExpiresAt().isBefore(LocalDateTime.now())) {
            return false;
        }

        AppUserEntity user = verificationToken.getUser();
        boolean newlyActivated = false;

        if (!user.isEnabled()) {
            user.setEnabled(true);
            newlyActivated = true;

            if (user.getSettings() == null) {
                appUserSettingsService.createDefaultSettingsForUser(user);
            }
            userRepository.save(user);
        }

        tokenRepository.delete(verificationToken);

        if (newlyActivated) {
            notifyUser(user, NotificationType.USER_ACTIVATED);
        }
        return true;
    }

    /**
     * Aktivuje uĹľivatelskĂ˝ ĂşÄŤet v administraci.
     *
     * OvÄ›Ĺ™uje se, zda se nejednĂˇ o administrĂˇtorskĂ˝ ĂşÄŤet a zda ĂşÄŤet jiĹľ nenĂ­ aktivnĂ­.
     * PĹ™i ĂşspÄ›ĹˇnĂ© aktivaci jsou pĹ™Ă­padnĂˇ chybÄ›jĂ­cĂ­ uĹľivatelskĂˇ nastavenĂ­ vytvoĹ™ena
     * a vĹˇechny ovÄ›Ĺ™ovacĂ­ tokeny uĹľivatele jsou odstranÄ›ny.
     *
     * Po ĂşspÄ›ĹˇnĂ© aktivaci je odeslĂˇna notifikace o aktivaci ĂşÄŤtu.
     *
     * @param id identifikĂˇtor uĹľivatele
     */
    @Override
    public void activateUserByAdmin(Long id) {
        AppUserEntity user = findUserByIdOrThrow(id);

        if (user.getRole() == Role.ROLE_ADMIN) {
            throw new InvalidAdminActivateDeactivateException(
                    "BE - AdministrĂˇtorskĂ˝ ĂşÄŤet nelze deaktivovat"
            );
        }

        if (user.isEnabled()) {
            throw new InvalidUserActivationException(
                    "BE - Aktivace ĂşÄŤtu jiĹľ byla provedena"
            );
        }
        boolean newlyActivated = false;

        if (!user.isEnabled()) {
            user.setEnabled(true);
            newlyActivated = true;

            if (user.getSettings() == null) {
                appUserSettingsService.createDefaultSettingsForUser(user);
            }

            userRepository.save(user);
        }

        tokenRepository.deleteByUser(user);

        if (newlyActivated) {
            notifyUser(user, NotificationType.USER_ACTIVATED);
        }
    }

    /**
     * Aktualizuje zĂˇkladnĂ­ Ăşdaje uĹľivatele podle e-mailovĂ© adresy.
     *
     * PĹ™i zmÄ›nÄ› e-mailu se ovÄ›Ĺ™uje, Ĺľe novĂˇ e-mailovĂˇ adresa nenĂ­ pouĹľĂ­vĂˇna
     * jinĂ˝m ĂşÄŤtem. V demo reĹľimu je operace pĹ™ed zĂˇpisem do databĂˇze zakĂˇzĂˇna.
     * Po ĂşspÄ›ĹˇnĂ© aktualizaci je odeslĂˇna notifikace o zmÄ›nÄ› ĂşdajĹŻ.
     *
     * @param email e-mailovĂˇ adresa aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @param dto aktualizovanĂˇ data ĂşÄŤtu
     */
    @Override
    @Transactional
    public void updateUser(String email, AppUserDTO dto) {
        AppUserEntity user = findUserByEmailOrThrow(email);

        if (!user.getEmail().equals(dto.getEmail())) {
            ensureEmailNotUsed(dto.getEmail(), user.getId());
        }

        demoModeGuard.write(
                user.getId(),
                "UĹľivatel, kterĂ˝ byl vytvoĹ™en aplikacĂ­, nebude zmÄ›nÄ›n. " +
                        "Aplikace bÄ›ĹľĂ­ v DEMO reĹľimu. ZmÄ›ny budou skuteÄŤnÄ› provedeny " +
                        "pouze u vĂˇmi vytvoĹ™enĂ˝ch uĹľivatelĹŻ."
        );

        user.setName(dto.getName());
        user.setSurname(dto.getSurname());
        user.setEmail(dto.getEmail());

        userRepository.save(user);
        notifyUser(user, NotificationType.USER_UPDATED);
    }

    /**
     * VrĂˇtĂ­ detail aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * UĹľivatel je vyhledĂˇn podle e-mailovĂ© adresy a je pĹ™eveden na DTO.
     *
     * @param email e-mailovĂˇ adresa uĹľivatele
     * @return DTO reprezentace uĹľivatele
     */
    @Override
    public AppUserDTO getCurrentUser(String email) {
        AppUserEntity user = findUserByEmailOrThrow(email);
        return appUserMapper.toDTO(user);
    }

    /**
     * VrĂˇtĂ­ seznam vĹˇech uĹľivatelĹŻ systĂ©mu.
     *
     * ZĂˇznamy jsou naÄŤteny z databĂˇze a jsou mapovĂˇny na DTO.
     * Metoda se pouĹľĂ­vĂˇ v administraci pro pĹ™ehled a sprĂˇvu ĂşÄŤtĹŻ.
     *
     * @return seznam uĹľivatelĹŻ ve formÄ› DTO
     */
    @Override
    public List<AppUserDTO> getAllUsers() {
        return userRepository.findAll().stream()
                .map(appUserMapper::toDTO)
                .toList();
    }

    /**
     * ZmÄ›nĂ­ heslo aktuĂˇlnĂ­ho uĹľivatele.
     *
     * OvÄ›Ĺ™uje se shoda novĂ©ho hesla a jeho potvrzenĂ­ a nĂˇslednÄ› se ovÄ›Ĺ™uje
     * pĹŻvodnĂ­ heslo. V demo reĹľimu je operace pĹ™ed zĂˇpisem do databĂˇze zakĂˇzĂˇna.
     * Po ĂşspÄ›ĹˇnĂ© zmÄ›nÄ› hesla je odeslĂˇna notifikace.
     *
     * @param email e-mailovĂˇ adresa uĹľivatele
     * @param oldPassword pĹŻvodnĂ­ heslo
     * @param newPassword novĂ© heslo
     * @param newPasswordConfirm potvrzenĂ­ novĂ©ho hesla
     */
    @Override
    @Transactional
    public void changePassword(String email,
                               String oldPassword,
                               String newPassword,
                               String newPasswordConfirm) {

        ensurePasswordsMatch(
                newPassword,
                newPasswordConfirm,
                "BE - NovĂ© heslo a potvrzenĂ­ novĂ©ho hesla se neshodujĂ­"
        );

        AppUserEntity user = findUserByEmailOrThrow(email);

        if (!passwordEncoder.matches(oldPassword, user.getPassword())) {
            throw new InvalidOldPasswordException();
        }

        demoModeGuard.write(
                user.getId(),
                "Heslo u uĹľivatele, kterĂ˝ byl vytvoĹ™en aplikacĂ­, nebude zmÄ›nÄ›no. " +
                        "Aplikace bÄ›ĹľĂ­ v DEMO reĹľimu. ZmÄ›na hesla bude skuteÄŤnÄ› provedena " +
                        "pouze u vĂˇmi vytvoĹ™enĂ˝ch uĹľivatelĹŻ."
        );

        user.setPassword(passwordEncoder.encode(newPassword));
        userRepository.save(user);

        notifyUser(user, NotificationType.USER_CHANGE_PASSWORD);
    }

    /**
     * Resetuje heslo uĹľivatele na vĂ˝chozĂ­ hodnotu.
     *
     * Metoda se pouĹľĂ­vĂˇ v administraci pĹ™i ruÄŤnĂ­m resetu hesla.
     * V demo reĹľimu je operace pĹ™ed zĂˇpisem do databĂˇze zakĂˇzĂˇna.
     * Po ĂşspÄ›ĹˇnĂ©m resetu je odeslĂˇna notifikace.
     *
     * @param userId identifikĂˇtor uĹľivatele
     */
    @Override
    @Transactional
    public void resetPassword(Long userId) {
        AppUserEntity user = findUserByIdOrThrow(userId);

        if (isDemoMode) {
            throw new DemoModeOperationNotAllowedException(
                    "Heslo nebude resetovĂˇno. Aplikace bÄ›ĹľĂ­ v DEMO reĹľimu."
            );
        }

        user.setPassword(passwordEncoder.encode(DEFAULT_RESET_PASSWORD));
        userRepository.save(user);

        notifyUser(user, NotificationType.PASSWORD_RESET);
    }

    /**
     * Deaktivuje uĹľivatelskĂ˝ ĂşÄŤet v administraci.
     *
     * OvÄ›Ĺ™uje se, zda se nejednĂˇ o administrĂˇtorskĂ˝ ĂşÄŤet a zda ĂşÄŤet jiĹľ nenĂ­ deaktivovanĂ˝.
     * Po ĂşspÄ›ĹˇnĂ© deaktivaci je odeslĂˇna notifikace o deaktivaci ĂşÄŤtu.
     *
     * @param id identifikĂˇtor uĹľivatele
     */
    @Override
    public void deactivateUserByAdmin(Long id) {
        AppUserEntity user = findUserByIdOrThrow(id);

        if (user.getRole() == Role.ROLE_ADMIN) {
            throw new InvalidAdminActivateDeactivateException(
                    "BE - AdministrĂˇtorskĂ˝ ĂşÄŤet nelze deaktivovat"
            );
        }

        if (!user.isEnabled()) {
            throw new InvalidUserActivationException(
                    "BE - Deaktivace ĂşÄŤtu jiĹľ byla provedena"
            );
        }

        demoModeGuard.write(
                user.getId(),
                "UĹľivatel, kterĂ˝ byl vytvoĹ™en aplikacĂ­, nebude deaktivovĂˇn. " +
                        "Aplikace bÄ›ĹľĂ­ v DEMO reĹľimu. Deaktivace bude skuteÄŤnÄ› provedena " +
                        "pouze u vĂˇmi vytvoĹ™enĂ˝ch uĹľivatelĹŻ."
        );

        user.setEnabled(false);
        userRepository.save(user);

        notifyUser(user, NotificationType.USER_DEACTIVATED);
    }


    /**
     * VrĂˇtĂ­ uĹľivatele podle identifikĂˇtoru ve formÄ› DTO.
     *
     * Metoda se pouĹľĂ­vĂˇ v administraci pĹ™i zobrazenĂ­ detailu ĂşÄŤtu.
     *
     * @param id identifikĂˇtor uĹľivatele
     * @return DTO reprezentace uĹľivatele
     */
    public AppUserDTO getUserById(Long id) {
        AppUserEntity user = findUserByIdOrThrow(id);
        return appUserMapper.toDTO(user);
    }

    /**
     * VytvoĹ™Ă­ poĹľadavek na reset zapomenutĂ©ho hesla.
     *
     * Pokud uĹľivatel pro danĂ˝ e-mail neexistuje, nenĂ­ vyhozena chyba
     * a metoda se ukonÄŤĂ­, aby nebylo moĹľnĂ© odvodit existenci ĂşÄŤtu.
     * PĹ™ed vygenerovĂˇnĂ­m novĂ©ho tokenu jsou odstranÄ›ny pĹ™Ă­padnĂ© starĂ© tokeny.
     * NĂˇslednÄ› je odeslĂˇna notifikace obsahujĂ­cĂ­ odkaz pro nastavenĂ­ novĂ©ho hesla.
     *
     * @param email e-mailovĂˇ adresa uĹľivatele
     */
    @Override
    @Transactional
    public void requestForgottenPasswordReset(String email) {
        AppUserEntity user = userRepository.findByEmail(email)
                .orElse(null);

        if (user == null) {
            log.info("PoĹľadavek na forgotten password reset pro neexistujĂ­cĂ­ email: {}", email);
            return;
        }

        forgottenPasswordResetTokenRepository.deleteByUser(user);

        ForgottenPasswordResetTokenEntity forgottenPasswordToken = createResetPasswordToken(user);
        String resetPasswordlink = buildResetPasswordlink(forgottenPasswordToken);

        log.info("Odkaz pro reset hesla {}: {}", user.getEmail(), resetPasswordlink);

        notifyUser(
                user,
                NotificationType.FORGOTTEN_PASSWORD_RESET_REQUEST,
                new ForgottenPasswordResetContext(user, resetPasswordlink)
        );
    }

    /**
     * VrĂˇtĂ­ e-mailovou adresu uĹľivatele svĂˇzanou se zadanĂ˝m resetovacĂ­m tokenem.
     *
     * Token je vyhledĂˇn a je ovÄ›Ĺ™ena jeho platnost. Metoda se pouĹľĂ­vĂˇ
     * pĹ™i naÄŤĂ­tĂˇnĂ­ formulĂˇĹ™e pro zadĂˇnĂ­ novĂ©ho hesla.
     *
     * @param token resetovacĂ­ token
     * @return e-mailovĂˇ adresa uĹľivatele
     */
    @Override
    @Transactional
    public String getForgottenPasswordResetEmail(String token) {
        ForgottenPasswordResetTokenEntity resetToken =
                forgottenPasswordResetTokenRepository.findByToken(token)
                        .orElseThrow(InvalidResetTokenException::new);

        if (resetToken.getExpiresAt().isBefore(LocalDateTime.now())) {
            throw new InvalidResetTokenException("BE - Reset token expiroval.");
        }

        return resetToken.getUser().getEmail();
    }

    /**
     * NastavĂ­ novĂ© heslo na zĂˇkladÄ› resetovacĂ­ho tokenu.
     *
     * OvÄ›Ĺ™uje se shoda novĂ©ho hesla a jeho potvrzenĂ­ a platnost tokenu.
     * NovĂ© heslo je uloĹľeno v zahashovanĂ© podobÄ› a pouĹľitĂ˝ token je odstranÄ›n.
     * Po ĂşspÄ›ĹˇnĂ©m dokonÄŤenĂ­ je odeslĂˇna notifikace o dokonÄŤenĂ©m resetu hesla.
     *
     * @param dto data pro reset zapomenutĂ©ho hesla
     */
    @Override
    @Transactional
    public void forgottenPasswordReset(ForgottenPasswordResetDTO dto) {
        ensurePasswordsMatch(
                dto.getNewPassword(),
                dto.getNewPasswordConfirm(),
                "BE - NovĂ© heslo a potvrzenĂ­ novĂ©ho hesla se neshodujĂ­"
        );

        ForgottenPasswordResetTokenEntity resetToken =
                forgottenPasswordResetTokenRepository.findByToken(dto.getToken())
                        .orElseThrow(InvalidResetTokenException::new);

        if (resetToken.getExpiresAt().isBefore(LocalDateTime.now())) {
            throw new InvalidResetTokenException("BE - Reset token expiroval.");
        }

        AppUserEntity user = resetToken.getUser();


        demoModeGuard.writeWithFinalize(
                user.getId(),
                "Heslo u uĹľivatele, kterĂ˝ byl vytvoĹ™en aplikacĂ­, nebude ve skuteÄŤnosti resetovĂˇno. " +
                        "Aplikace bÄ›ĹľĂ­ v DEMO reĹľimu. Reset a zmÄ›na zapomenutĂ©ho hesla bude skuteÄŤnÄ› provedena " +
                        "pouze u vĂˇmi vytvoĹ™enĂ˝ch uĹľivatelĹŻ.",
                () -> {
                    user.setPassword(passwordEncoder.encode(dto.getNewPassword()));
                    userRepository.save(user);
                    forgottenPasswordResetTokenRepository.delete(resetToken);
                    notifyUser(user, NotificationType.FORGOTTEN_PASSWORD_RESET_COMPLETED);
                },
                () -> {
                    forgottenPasswordResetTokenRepository.delete(resetToken);
                    notifyUser(user, NotificationType.FORGOTTEN_PASSWORD_RESET_COMPLETED);
                }
        );
    }

    /**
     * Aktualizuje ÄŤasovĂˇ razĂ­tka pĹ™ihlĂˇĹˇenĂ­ uĹľivatele.
     *
     * PĹ™i ĂşspÄ›ĹˇnĂ©m pĹ™ihlĂˇĹˇenĂ­ se pĹŻvodnĂ­ hodnota currentLoginAt
     * uloĹľĂ­ do lastLoginAt a currentLoginAt se nastavĂ­ na aktuĂˇlnĂ­ ÄŤas.
     * Metoda se pouĹľĂ­vĂˇ v bezpeÄŤnostnĂ­ vrstvÄ› po ĂşspÄ›ĹˇnĂ© autentizaci.
     *
     * @param email e-mailovĂˇ adresa pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     */
    @Transactional
    public void onSuccessfulLogin(String email) {
        AppUserEntity user = findUserByEmailOrThrow(email);

        Instant now = Instant.now(clock);

        user.setLastLoginAt(user.getCurrentLoginAt());
        user.setCurrentLoginAt(now);

        userRepository.save(user);

        log.info("AktualizovĂˇna pĹ™ihlĂˇĹˇenĂ­ uĹľivatele {}: lastLoginAt={}, currentLoginAt={}",
                email, user.getLastLoginAt(), user.getCurrentLoginAt());
    }

    // ==================================================
    // HELPER METODY
    // ==================================================

    private String buildActivationLink(EmailVerificationTokenEntity token) {
        return frontendBasUrl + "/verify?token=" + token.getToken();
    }

    private String buildResetPasswordlink(ForgottenPasswordResetTokenEntity token) {
        return baseUrl + "/api/auth/reset-password?token=" + token.getToken();
    }

    private AppUserEntity findUserByEmailOrThrow(String email) {
        return userRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException(email));
    }

    private AppUserEntity findUserByIdOrThrow(Long id) {
        return userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException(id));
    }

    /**
     * OvÄ›Ĺ™Ă­ shodu hesla a jeho potvrzenĂ­.
     *
     * Pokud se hodnoty neshodujĂ­, je vyhozena vĂ˝jimka PasswordsDoNotMatchException.
     * Pokud je pĹ™edĂˇn vlastnĂ­ text, je pouĹľit jako chybovĂˇ zprĂˇva vĂ˝jimky.
     *
     * @param password heslo
     * @param confirm potvrzenĂ­ hesla
     * @param customMessage volitelnĂˇ vlastnĂ­ chybovĂˇ zprĂˇva
     */
    private void ensurePasswordsMatch(String password,
                                      String confirm,
                                      String customMessage) {
        if (password == null || confirm == null || !password.equals(confirm)) {
            if (customMessage == null) {
                throw new PasswordsDoNotMatchException();
            }
            throw new PasswordsDoNotMatchException(customMessage);
        }
    }

    /**
     * OvÄ›Ĺ™Ă­, Ĺľe e-mailovĂˇ adresa nenĂ­ pouĹľĂ­vĂˇna jinĂ˝m uĹľivatelem.
     *
     * PĹ™i registraci je currentUserId null. PĹ™i aktualizaci ĂşÄŤtu se kontroluje,
     * zda pĹ™Ă­padnÄ› nalezenĂ˝ uĹľivatel nenĂ­ totoĹľnĂ˝ s aktualizovanĂ˝m ĂşÄŤtem.
     *
     * @param email e-mailovĂˇ adresa urÄŤenĂˇ ke kontrole
     * @param currentUserId identifikĂˇtor aktuĂˇlnĂ­ho uĹľivatele nebo null pĹ™i registraci
     */
    private void ensureEmailNotUsed(String email, Long currentUserId) {
        userRepository.findByEmail(email).ifPresent(existing -> {
            if (currentUserId == null || !existing.getId().equals(currentUserId)) {
                throw new UserAlreadyExistsException(
                        "BE - UĹľivatel s tĂ­mto emailem jiĹľ existuje"
                );
            }
        });
    }

    /**
     * VytvoĹ™Ă­ novĂ©ho uĹľivatele na zĂˇkladÄ› registraÄŤnĂ­ho DTO.
     *
     * Heslo je uloĹľeno v zahashovanĂ© podobÄ›. ĂšÄŤet je vytvoĹ™en jako neaktivnĂ­
     * a je mu nastavena vĂ˝chozĂ­ role ROLE_PLAYER.
     *
     * @param dto registraÄŤnĂ­ data
     * @return novĂˇ entita uĹľivatele pĹ™ipravenĂˇ k uloĹľenĂ­
     */
    private AppUserEntity createUserFromRegisterDto(RegisterUserDTO dto) {
        AppUserEntity user = appUserMapper.fromRegisterDto(dto);
        user.setPassword(passwordEncoder.encode(dto.getPassword()));
        user.setRole(Role.ROLE_PLAYER);
        user.setEnabled(false);
        return user;
    }

    /**
     * VytvoĹ™Ă­ a uloĹľĂ­ ovÄ›Ĺ™ovacĂ­ token pro aktivaci ĂşÄŤtu.
     *
     * Token mĂˇ omezenou platnost a je pouĹľĂ­vĂˇn pĹ™i aktivaci ĂşÄŤtu pĹ™es odkaz.
     *
     * @param user uĹľivatel, pro kterĂ©ho se token vytvĂˇĹ™Ă­
     * @return uloĹľenĂ˝ ovÄ›Ĺ™ovacĂ­ token
     */
    private EmailVerificationTokenEntity createVerificationToken(AppUserEntity user) {
        EmailVerificationTokenEntity token = new EmailVerificationTokenEntity();
        token.setToken(UUID.randomUUID().toString());
        token.setUser(user);
        token.setExpiresAt(LocalDateTime.now().plusHours(24));
        return tokenRepository.save(token);
    }

    /**
     * VytvoĹ™Ă­ a uloĹľĂ­ resetovacĂ­ token pro proces resetu zapomenutĂ©ho hesla.
     *
     * Token mĂˇ omezenou platnost a je pouĹľĂ­vĂˇn pro autorizaci nastavenĂ­ novĂ©ho hesla.
     *
     * @param user uĹľivatel, pro kterĂ©ho se token vytvĂˇĹ™Ă­
     * @return uloĹľenĂ˝ resetovacĂ­ token
     */
    private ForgottenPasswordResetTokenEntity createResetPasswordToken(AppUserEntity user) {
        ForgottenPasswordResetTokenEntity token = new ForgottenPasswordResetTokenEntity();
        token.setToken(UUID.randomUUID().toString());
        token.setUser(user);
        token.setExpiresAt(LocalDateTime.now().plusHours(1));
        return forgottenPasswordResetTokenRepository.save(token);
    }

    /**
     * OdeĹˇle notifikaci uĹľivateli bez kontextu.
     *
     * VolĂˇnĂ­ je delegovĂˇno do NotificationService.
     *
     * @param user uĹľivatel, kterĂ©mu se notifikace odesĂ­lĂˇ
     * @param type typ notifikace
     */
    private void notifyUser(AppUserEntity user, NotificationType type) {
        notificationService.notifyUser(user, type, null);
    }

    /**
     * OdeĹˇle notifikaci uĹľivateli s volitelnĂ˝m kontextem.
     *
     * VolĂˇnĂ­ je delegovĂˇno do NotificationService.
     *
     * @param user uĹľivatel, kterĂ©mu se notifikace odesĂ­lĂˇ
     * @param type typ notifikace
     * @param context kontextovĂˇ data pro Ĺˇablonu notifikace
     */
    private void notifyUser(AppUserEntity user, NotificationType type, Object context) {
        notificationService.notifyUser(user, type, context);
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserSettingsService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.AppUserSettingsEntity;
import cz.phsoft.hokej.models.dto.AppUserSettingsDTO;

/**
 * Service se pouĹľĂ­vĂˇ pro prĂˇci s uĹľivatelskĂ˝m nastavenĂ­m.
 *
 * OdpovÄ›dnostĂ­ je zĂ­skĂˇvĂˇnĂ­, vytvĂˇĹ™enĂ­ a aktualizace nastavenĂ­
 * v kontextu uĹľivatelskĂ©ho ĂşÄŤtu, nikoli v kontextu hrĂˇÄŤe.
 * V tĂ©to vrstvÄ› se pouĹľĂ­vĂˇ typ AppUserSettingsDTO, aby byla
 * oddÄ›lena prezentaÄŤnĂ­ vrstva od perzistentnĂ­ch entit.
 */
public interface AppUserSettingsService {

    /**
     * VrĂˇtĂ­ nastavenĂ­ pro uĹľivatele identifikovanĂ©ho e-mailem.
     * Pokud nastavenĂ­ neexistuje, vytvoĹ™Ă­ se novĂ˝ zĂˇznam
     * s vĂ˝chozĂ­mi hodnotami a uloĹľĂ­ se k danĂ©mu uĹľivateli.
     *
     * Metoda se typicky pouĹľĂ­vĂˇ v controlleru pro naÄŤtenĂ­
     * dat do formulĂˇĹ™e na frontendu.
     *
     * @param userEmail e-mail uĹľivatele, kterĂ˝ slouĹľĂ­ jako unikĂˇtnĂ­ login
     * @return nastavenĂ­ uĹľivatele pĹ™evedenĂ© do AppUserSettingsDTO
     */
    AppUserSettingsDTO getSettingsForUser(String userEmail);

    /**
     * Aktualizuje nastavenĂ­ pro uĹľivatele identifikovanĂ©ho e-mailem.
     * Pokud uĹľivatel nemĂˇ dosud ĹľĂˇdnĂ© nastavenĂ­, vytvoĹ™Ă­ se nejprve
     * vĂ˝chozĂ­ zĂˇznam a potĂ© se na nÄ›j aplikujĂ­ hodnoty z DTO.
     *
     * Metoda se obvykle volĂˇ z controlleru po odeslĂˇnĂ­ formulĂˇĹ™e
     * s uĹľivatelskĂ˝mi preferencemi.
     *
     * @param userEmail e-mail uĹľivatele, pro kterĂ©ho se nastavenĂ­ aktualizuje
     * @param dto novĂ© hodnoty nastavenĂ­ z frontendu
     * @return aktuĂˇlnĂ­ stav nastavenĂ­ po uloĹľenĂ­ v podobÄ› AppUserSettingsDTO
     */
    AppUserSettingsDTO updateSettingsForUser(String userEmail, AppUserSettingsDTO dto);

    /**
     * VytvoĹ™Ă­ vĂ˝chozĂ­ nastavenĂ­ pro danĂ©ho uĹľivatele.
     *
     * Metoda se pouĹľĂ­vĂˇ internÄ› pĹ™i prvnĂ­m pĹ™Ă­stupu k nastavenĂ­,
     * kdy neexistuje ĹľĂˇdnĂ˝ zĂˇznam v tabulce s nastavenĂ­m.
     * VĂ˝chozĂ­ hodnoty se nastavĂ­ tak, aby byla aplikace pouĹľitelnĂˇ
     * i bez ruÄŤnĂ­ho nastavenĂ­.
     *
     * @param user entita uĹľivatele, ke kterĂ© se nastavenĂ­ navĂˇĹľe
     * @return novÄ› vytvoĹ™enĂˇ entita AppUserSettingsEntity s vĂ˝chozĂ­mi hodnotami
     */
    AppUserSettingsEntity createDefaultSettingsForUser(AppUserEntity user);

}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserSettingsServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.AppUserSettingsEntity;
import cz.phsoft.hokej.data.enums.GlobalNotificationLevel;
import cz.phsoft.hokej.data.enums.PlayerSelectionMode;
import cz.phsoft.hokej.data.repositories.AppUserSettingsRepository;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.exceptions.UserNotFoundException;
import cz.phsoft.hokej.models.dto.AppUserSettingsDTO;
import cz.phsoft.hokej.models.mappers.AppUserSettingsMapper;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

/**
 * Implementace service pro prĂˇci s uĹľivatelskĂ˝m nastavenĂ­m.
 *
 * OdpovÄ›dnostĂ­ je vyhledĂˇvĂˇnĂ­ uĹľivatele podle e-mailu,
 * zĂ­skĂˇvĂˇnĂ­ nebo vytvĂˇĹ™enĂ­ odpovĂ­dajĂ­cĂ­ho AppUserSettingsEntity
 * a mapovĂˇnĂ­ na AppUserSettingsDTO. V rĂˇmci tĂ©to tĹ™Ă­dy se udrĹľuje
 * vazba mezi nastavenĂ­m a uĹľivatelskĂ˝m ĂşÄŤtem.
 *
 * TĹ™Ă­da pĹ™edstavuje transakÄŤnĂ­ hranici pro operace s uĹľivatelskĂ˝m
 * nastavenĂ­m. Validace vstupĹŻ z HTTP vrstvy a autorizace se Ĺ™eĹˇĂ­
 * v controllerech a bezpeÄŤnostnĂ­ vrstvÄ›.
 */
@Service
@Transactional
public class AppUserSettingsServiceImpl implements AppUserSettingsService {

    private final AppUserRepository appUserRepository;
    private final AppUserSettingsRepository appUserSettingsRepository;
    private final AppUserSettingsMapper mapper;

    /**
     * VytvoĹ™Ă­ instanci service s repository a mapperem.
     *
     * Repository se pouĹľĂ­vajĂ­ pro prĂˇci s entitami AppUserEntity
     * a AppUserSettingsEntity. Mapper zajiĹˇĹĄuje pĹ™evod mezi entitou
     * a AppUserSettingsDTO pro komunikaci s frontendem.
     *
     * @param appUserRepository repository pro uĹľivatelskĂ© ĂşÄŤty
     * @param appUserSettingsRepository repository pro uĹľivatelskĂˇ nastavenĂ­
     * @param mapper mapper pro pĹ™evod mezi entitou a DTO
     */
    public AppUserSettingsServiceImpl(AppUserRepository appUserRepository,
                                      AppUserSettingsRepository appUserSettingsRepository,
                                      AppUserSettingsMapper mapper) {
        this.appUserRepository = appUserRepository;
        this.appUserSettingsRepository = appUserSettingsRepository;
        this.mapper = mapper;
    }

    /**
     * NaÄŤte nastavenĂ­ pro uĹľivatele identifikovanĂ©ho e-mailem.
     *
     * Pokud nastavenĂ­ neexistuje, vytvoĹ™Ă­ se novĂˇ entita s vĂ˝chozĂ­mi
     * hodnotami pomocĂ­ metody createDefaultSettingsForUser a uloĹľĂ­ se.
     * VolajĂ­cĂ­ ÄŤĂˇst aplikace tak vĹľdy obdrĹľĂ­ validnĂ­ nastavenĂ­.
     *
     * @param userEmail e-mail uĹľivatele, pro kterĂ©ho se nastavenĂ­ naÄŤĂ­tĂˇ
     * @return AppUserSettingsDTO s aktuĂˇlnĂ­m nastavenĂ­m uĹľivatele
     * @throws UserNotFoundException pokud uĹľivatel s danĂ˝m e-mailem neexistuje
     */
    @Override
    public AppUserSettingsDTO getSettingsForUser(String userEmail) {
        AppUserEntity user = findUserByEmailOrThrow(userEmail);

        Optional<AppUserSettingsEntity> existingOpt = appUserSettingsRepository.findByUser(user);

        AppUserSettingsEntity settings = existingOpt.orElseGet(() -> {
            AppUserSettingsEntity created = createDefaultSettingsForUser(user);
            return appUserSettingsRepository.save(created);
        });

        return mapper.toDTO(settings);
    }

    /**
     * Aktualizuje nastavenĂ­ pro uĹľivatele identifikovanĂ©ho e-mailem.
     *
     * Pokud uĹľivatel ĹľĂˇdnĂ© nastavenĂ­ nemĂˇ, vytvoĹ™Ă­ se novĂˇ entita
     * s vĂ˝chozĂ­mi hodnotami a nĂˇslednÄ› se do nĂ­ aplikujĂ­ hodnoty
     * z pĹ™edanĂ©ho DTO. Je zajiĹˇtÄ›no, Ĺľe nastavenĂ­ je navĂˇzĂˇno
     * na sprĂˇvnĂ©ho uĹľivatele.
     *
     * @param userEmail e-mail uĹľivatele, pro kterĂ©ho se nastavenĂ­ aktualizuje
     * @param dto novĂ© hodnoty nastavenĂ­ z frontendu
     * @return AppUserSettingsDTO reprezentujĂ­cĂ­ uloĹľenĂ© nastavenĂ­
     * @throws UserNotFoundException pokud uĹľivatel s danĂ˝m e-mailem neexistuje
     */
    @Override
    public AppUserSettingsDTO updateSettingsForUser(String userEmail, AppUserSettingsDTO dto) {
        AppUserEntity user = findUserByEmailOrThrow(userEmail);

        AppUserSettingsEntity settings = appUserSettingsRepository.findByUser(user)
                .orElseGet(() -> createDefaultSettingsForUser(user));

        mapper.updateEntityFromDTO(dto, settings);

        settings.setUser(user);

        AppUserSettingsEntity saved = appUserSettingsRepository.save(settings);

        return mapper.toDTO(saved);
    }

    // =========================================
    // Helper metody
    // =========================================

    /**
     * Najde uĹľivatele podle e-mailu nebo vyhodĂ­ vĂ˝jimku.
     *
     * Metoda centralizuje logiku pro vyhledĂˇvĂˇnĂ­ uĹľivatele v databĂˇzi.
     *
     * @param email e-mail hledanĂ©ho uĹľivatele
     * @return entita AppUserEntity, pokud byla nalezena
     * @throws UserNotFoundException pokud uĹľivatel s danĂ˝m e-mailem neexistuje
     */
    private AppUserEntity findUserByEmailOrThrow(String email) {
        return appUserRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException(email));
    }

    /**
     * VytvoĹ™Ă­ vĂ˝chozĂ­ nastavenĂ­ pro danĂ©ho uĹľivatele.
     *
     * VĂ˝chozĂ­ hodnoty jsou nastaveny explicitnÄ›, aby byly
     * snadno dohledatelnĂ© na jednom mĂ­stÄ›. Metoda se pouĹľĂ­vĂˇ
     * pĹ™i prvnĂ­m naÄŤtenĂ­ nastavenĂ­ nebo pĹ™i zaklĂˇdĂˇnĂ­ novĂ©ho ĂşÄŤtu.
     *
     * @param user entita uĹľivatele, ke kterĂ© se nastavenĂ­ navĂˇĹľe
     * @return entita AppUserSettingsEntity s vĂ˝chozĂ­mi hodnotami
     */
    @Override
    public AppUserSettingsEntity createDefaultSettingsForUser(AppUserEntity user) {
        AppUserSettingsEntity settings = new AppUserSettingsEntity();
        settings.setUser(user);

        settings.setPlayerSelectionMode(PlayerSelectionMode.FIRST_PLAYER);
        settings.setGlobalNotificationLevel(GlobalNotificationLevel.ALL);
        settings.setManagerNotificationLevel(GlobalNotificationLevel.ALL);
        settings.setCopyAllPlayerNotificationsToUserEmail(false);
        settings.setReceiveNotificationsForPlayersWithOwnEmail(false);
        settings.setEmailDigestEnabled(false);
        settings.setEmailDigestTime(null);
        settings.setUiLanguage("cs");
        settings.setTimezone("Europe/Prague");
        settings.setDefaultLandingPage("DASHBOARD");

        appUserSettingsRepository.save(settings);

        return settings;
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\CurrentPlayerService.java
-----
package cz.phsoft.hokej.models.services;

/**
 * RozhranĂ­ se pouĹľĂ­vĂˇ pro sprĂˇvu aktuĂˇlnÄ› zvolenĂ©ho hrĂˇÄŤe pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
 *
 * UĹľivatel mĹŻĹľe mĂ­t v systĂ©mu vĂ­ce hrĂˇÄŤĹŻ, ale vÄ›tĹˇina aplikaÄŤnĂ­ch operacĂ­
 * (registrace na zĂˇpasy, pĹ™ehledy, statistiky) pracuje vĹľdy s jednĂ­m
 * jednoznaÄŤnÄ› urÄŤenĂ˝m hrĂˇÄŤem. RozhranĂ­ definuje jednotnĂ˝ kontrakt
 * pro prĂˇci s tĂ­mto kontextem napĹ™Ă­ÄŤ aplikacĂ­.
 *
 * RozhranĂ­ oddÄ›luje prĂˇci s uĹľivatelskĂ˝m kontextem od business logiky.
 * KonkrĂ©tnĂ­ implementace obvykle uklĂˇdĂˇ identifikĂˇtor hrĂˇÄŤe do uĹľivatelskĂ©
 * session. OvÄ›Ĺ™enĂ­ existence a stavu hrĂˇÄŤe je odpovÄ›dnostĂ­ implementace.
 */
public interface CurrentPlayerService {

    /**
     * VrĂˇtĂ­ identifikĂˇtor aktuĂˇlnÄ› zvolenĂ©ho hrĂˇÄŤe.
     *
     * @return ID hrĂˇÄŤe nebo null, pokud aktuĂˇlnĂ­ hrĂˇÄŤ nenĂ­ nastaven
     */
    Long getCurrentPlayerId();

    /**
     * NastavĂ­ aktuĂˇlnĂ­ho hrĂˇÄŤe v uĹľivatelskĂ©m kontextu.
     *
     * Metoda slouĹľĂ­ ke zmÄ›nÄ› kontextu pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * na konkrĂ©tnĂ­ho hrĂˇÄŤe. Implementace je odpovÄ›dnĂˇ za to,
     * aby byl zvolen pouze platnĂ˝ hrĂˇÄŤ v odpovĂ­dajĂ­cĂ­m stavu.
     *
     * @param playerId ID hrĂˇÄŤe, kterĂ˝ mĂˇ bĂ˝t nastaven jako aktuĂˇlnĂ­
     */
    void setCurrentPlayerId(Long playerId);

    /**
     * OvÄ›Ĺ™Ă­, Ĺľe je aktuĂˇlnĂ­ hrĂˇÄŤ nastaven.
     *
     * Metoda se pouĹľĂ­vĂˇ pĹ™ed operacemi, kterĂ© vyĹľadujĂ­ kontext
     * aktuĂˇlnÄ› zvolenĂ©ho hrĂˇÄŤe. Pokud hrĂˇÄŤ nenĂ­ zvolen, je vyhozena vĂ˝jimka.
     *
     * @throws RuntimeException pokud aktuĂˇlnĂ­ hrĂˇÄŤ nenĂ­ nastaven
     */
    void requireCurrentPlayer();

    /**
     * OdstranĂ­ informaci o aktuĂˇlnĂ­m hrĂˇÄŤi z uĹľivatelskĂ©ho kontextu.
     *
     * Metoda se pouĹľĂ­vĂˇ zejmĂ©na pĹ™i odhlĂˇĹˇenĂ­ uĹľivatele nebo pĹ™i
     * explicitnĂ­m resetu uĹľivatelskĂ©ho kontextu.
     */
    void clear();
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\CurrentPlayerServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.CurrentPlayerNotSelectedException;
import cz.phsoft.hokej.exceptions.InvalidPlayerStatusException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.security.SessionKeys;
import cz.phsoft.hokej.security.impersonation.ImpersonationContext;
import jakarta.servlet.http.HttpSession;
import org.springframework.stereotype.Service;

/**
 * Implementace rozhranĂ­ CurrentPlayerService.
 *
 * TĹ™Ă­da spravuje identifikĂˇtor aktuĂˇlnÄ› zvolenĂ©ho hrĂˇÄŤe v HTTP session
 * pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele. V session se uklĂˇdĂˇ pouze ID hrĂˇÄŤe, nikoli
 * celĂˇ entita.
 *
 * Pokud je aktivnĂ­ reĹľim zastoupenĂ­ administrĂˇtorem, je jako aktuĂˇlnĂ­ hrĂˇÄŤ
 * vracen hrĂˇÄŤ urÄŤenĂ˝ v impersonaÄŤnĂ­m kontextu. V takovĂ©m pĹ™Ă­padÄ› se hodnota
 * v session nepouĹľĂ­vĂˇ a zĹŻstĂˇvĂˇ beze zmÄ›ny.
 *
 * PomocĂ­ PlayerRepository se ovÄ›Ĺ™uje, zda hrĂˇÄŤ existuje a zda je ve stavu
 * vhodnĂ©m pro pouĹľitĂ­ v aplikaci.
 *
 * TĹ™Ă­da neĹ™eĹˇĂ­ oprĂˇvnÄ›nĂ­ uĹľivatele k danĂ©mu hrĂˇÄŤi ani business logiku
 * zĂˇpasĹŻ a registracĂ­. Tyto oblasti jsou pokryty jinĂ˝mi service tĹ™Ă­dami.
 */
@Service
public class CurrentPlayerServiceImpl implements CurrentPlayerService {

    /**
     * HTTP session vĂˇzanĂˇ na pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     * SlouĹľĂ­ k uchovĂˇnĂ­ identifikĂˇtoru aktuĂˇlnĂ­ho hrĂˇÄŤe.
     */
    private final HttpSession session;

    /**
     * Repository pro prĂˇci s entitami hrĂˇÄŤĹŻ.
     * PouĹľĂ­vĂˇ se k ovÄ›Ĺ™enĂ­ existence hrĂˇÄŤe a jeho aktuĂˇlnĂ­ho stavu.
     */
    private final PlayerRepository playerRepository;

    public CurrentPlayerServiceImpl(HttpSession session,
                                    PlayerRepository playerRepository) {
        this.session = session;
        this.playerRepository = playerRepository;
    }

    /**
     * VrĂˇtĂ­ identifikĂˇtor aktuĂˇlnĂ­ho hrĂˇÄŤe.
     *
     * Pokud je aktivnĂ­ reĹľim zastoupenĂ­, je vrĂˇcen identifikĂˇtor impersonovanĂ©ho
     * hrĂˇÄŤe. V opaÄŤnĂ©m pĹ™Ă­padÄ› je vrĂˇcen identifikĂˇtor uloĹľenĂ˝ v HTTP session.
     *
     * @return ID hrĂˇÄŤe nebo null, pokud aktuĂˇlnĂ­ hrĂˇÄŤ jeĹˇtÄ› nebyl zvolen
     */
    @Override
    public Long getCurrentPlayerId() {
        Long impersonatedPlayerId = ImpersonationContext.getImpersonatedPlayerId();
        if (impersonatedPlayerId != null) {
            return impersonatedPlayerId;
        }
        return (Long) session.getAttribute(SessionKeys.CURRENT_PLAYER_ID);
    }

    /**
     * NastavĂ­ aktuĂˇlnĂ­ho hrĂˇÄŤe do HTTP session.
     *
     * PĹ™ed uloĹľenĂ­m do session se ovÄ›Ĺ™Ă­, Ĺľe hrĂˇÄŤ existuje
     * a Ĺľe je ve stavu PlayerStatus.APPROVED. Pokud nÄ›kterĂˇ
     * z podmĂ­nek nenĂ­ splnÄ›na, je vyhozena vĂ˝jimka.
     *
     * ReĹľim zastoupenĂ­ tuto operaci nemÄ›nĂ­. ZvolenĂ˝ hrĂˇÄŤ se uklĂˇdĂˇ
     * do session a pouĹľĂ­vĂˇ se pĹ™i bÄ›ĹľnĂ©m reĹľimu bez impersonace.
     *
     * @param playerId ID hrĂˇÄŤe, kterĂ˝ mĂˇ bĂ˝t nastaven jako aktuĂˇlnĂ­
     * @throws PlayerNotFoundException pokud hrĂˇÄŤ s danĂ˝m ID neexistuje
     * @throws InvalidPlayerStatusException pokud hrĂˇÄŤ nenĂ­ ve schvĂˇlenĂ©m stavu
     */
    @Override
    public void setCurrentPlayerId(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        validatePlayerSelectable(player);

        session.setAttribute(SessionKeys.CURRENT_PLAYER_ID, playerId);
    }

    /**
     * OvÄ›Ĺ™Ă­, Ĺľe je aktuĂˇlnĂ­ hrĂˇÄŤ nastaven.
     *
     * Metoda se pouĹľĂ­vĂˇ pĹ™ed operacemi, kterĂ© vyĹľadujĂ­ kontext
     * aktuĂˇlnĂ­ho hrĂˇÄŤe, napĹ™Ă­klad pĹ™ed registracĂ­ na zĂˇpas
     * nebo pĹ™i volĂˇnĂ­ endpointĹŻ pracujĂ­cĂ­ch s â€ž/meâ€ś.
     *
     * Pokud je aktivnĂ­ reĹľim zastoupenĂ­, je podmĂ­nka povaĹľovĂˇna
     * za splnÄ›nou, protoĹľe aktuĂˇlnĂ­ hrĂˇÄŤ je urÄŤen impersonaÄŤnĂ­m kontextem.
     *
     * @throws CurrentPlayerNotSelectedException pokud aktuĂˇlnĂ­ hrĂˇÄŤ nenĂ­ nastaven
     */
    @Override
    public void requireCurrentPlayer() {
        Long currentPlayerId = getCurrentPlayerId();
        if (currentPlayerId == null) {
            throw new CurrentPlayerNotSelectedException();
        }
    }

    /**
     * OdstranĂ­ informaci o aktuĂˇlnĂ­m hrĂˇÄŤi z HTTP session.
     *
     * Metoda se pouĹľĂ­vĂˇ pĹ™i odhlĂˇĹˇenĂ­ uĹľivatele nebo pĹ™i resetu
     * uĹľivatelskĂ©ho kontextu, kdy jiĹľ nemĂˇ bĂ˝t vazba na konkrĂ©tnĂ­ho hrĂˇÄŤe.
     *
     * ReĹľim zastoupenĂ­ se neuklĂˇdĂˇ do session a jeho vyÄŤiĹˇtÄ›nĂ­ se Ĺ™eĹˇĂ­
     * na Ăşrovni request filtru.
     */
    @Override
    public void clear() {
        session.removeAttribute(SessionKeys.CURRENT_PLAYER_ID);
    }

    // ==================================================
    // Helper metody
    // ==================================================

    /**
     * Najde hrĂˇÄŤe podle ID nebo vyhodĂ­ vĂ˝jimku.
     *
     * @param playerId ID hledanĂ©ho hrĂˇÄŤe
     * @return entita PlayerEntity odpovĂ­dajĂ­cĂ­ zadanĂ©mu ID
     * @throws PlayerNotFoundException pokud hrĂˇÄŤ s danĂ˝m ID neexistuje
     */
    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    /**
     * OvÄ›Ĺ™Ă­, zda mĹŻĹľe bĂ˝t hrĂˇÄŤ zvolen jako aktuĂˇlnĂ­.
     *
     * V souÄŤasnĂ© dobÄ› je povolen pouze stav PlayerStatus.APPROVED.
     * OstatnĂ­ stavy jsou povaĹľovĂˇny za neplatnĂ© pro pouĹľitĂ­
     * v kontextu pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * @param player entita hrĂˇÄŤe, kterĂˇ mĂˇ bĂ˝t ovÄ›Ĺ™ena
     * @throws InvalidPlayerStatusException pokud hrĂˇÄŤ nenĂ­ ve schvĂˇlenĂ©m stavu
     */
    private void validatePlayerSelectable(PlayerEntity player) {
        if (player.getPlayerStatus() != PlayerStatus.APPROVED) {
            throw new InvalidPlayerStatusException(
                    "BE - Nelze zvolit hrĂˇÄŤe, kterĂ˝ nenĂ­ schvĂˇlen administrĂˇtorem."
            );
        }
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\CurrentSeasonService.java
-----
package cz.phsoft.hokej.models.services;

/**
 * RozhranĂ­ se pouĹľĂ­vĂˇ pro sprĂˇvu aktuĂˇlnÄ› zvolenĂ© sezĂłny
 * v kontextu pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
 *
 * SezĂłna slouĹľĂ­ jako globĂˇlnĂ­ kontextovĂ˝ filtr pro vÄ›tĹˇinu
 * aplikaÄŤnĂ­ch operacĂ­, jako jsou zĂˇpasy, statistiky a pĹ™ehledy.
 * UĹľivatel mĹŻĹľe pracovat buÄŹ s automaticky zvolenou aktivnĂ­ sezĂłnou,
 * nebo si mĹŻĹľe sezĂłnu explicitnÄ› vybrat.
 *
 * RozhranĂ­ definuje jednotnĂ˝ kontrakt pro prĂˇci s aktuĂˇlnĂ­ sezĂłnou
 * a oddÄ›luje prĂˇci se session od business logiky sprĂˇvy sezĂłn.
 */
public interface CurrentSeasonService {

    /**
     * VrĂˇtĂ­ identifikĂˇtor aktuĂˇlnÄ› pouĹľĂ­vanĂ© sezĂłny.
     *
     * Pokud je v session uloĹľena sezĂłna, kterou si uĹľivatel
     * explicitnÄ› zvolil, vrĂˇtĂ­ se tato hodnota.
     * Pokud sezĂłna nastavena nenĂ­ nebo nebyla zvolena vÄ›domÄ›,
     * pouĹľije se globĂˇlnÄ› aktivnĂ­ sezĂłna definovanĂˇ v systĂ©mu.
     *
     * PĹ™i pouĹľitĂ­ globĂˇlnÄ› aktivnĂ­ sezĂłny se jejĂ­ identifikĂˇtor
     * uloĹľĂ­ do session jako automaticky zvolenĂ˝.
     *
     * @return ID aktuĂˇlnĂ­ sezĂłny nebo null, pokud neexistuje ĹľĂˇdnĂˇ aktivnĂ­ sezĂłna
     */
    Long getCurrentSeasonIdOrDefault();

    /**
     * NastavĂ­ sezĂłnu jako aktuĂˇlnĂ­ pro pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * Metoda se pouĹľĂ­vĂˇ v okamĹľiku, kdy si uĹľivatel sezĂłnu
     * explicitnÄ› vybere. ZvolenĂˇ sezĂłna je uloĹľena do session
     * jako uĹľivatelskĂˇ volba.
     *
     * @param seasonId ID sezĂłny, kterĂˇ mĂˇ bĂ˝t nastavena jako aktuĂˇlnĂ­
     */
    void setCurrentSeasonId(Long seasonId);

    /**
     * OdstranĂ­ informaci o aktuĂˇlnĂ­ sezĂłnÄ› z uĹľivatelskĂ©ho kontextu.
     *
     * Metoda se pouĹľĂ­vĂˇ zejmĂ©na pĹ™i odhlĂˇĹˇenĂ­ uĹľivatele
     * nebo pĹ™i resetu session.
     */
    void clearCurrentSeason();
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\CurrentSeasonServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.SeasonDTO;
import jakarta.servlet.http.HttpSession;
import org.springframework.stereotype.Service;

/**
 * Implementace rozhranĂ­ CurrentSeasonService.
 *
 * TĹ™Ă­da spravuje identifikĂˇtor aktuĂˇlnÄ› zvolenĂ© sezĂłny
 * v HTTP session pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
 * RozliĹˇuje se, zda byla sezĂłna zvolena explicitnÄ› uĹľivatelem,
 * nebo byla nastavena automaticky na zĂˇkladÄ› globĂˇlnÄ› aktivnĂ­ sezĂłny.
 *
 * SprĂˇva samotnĂ˝ch sezĂłn a jejich ĹľivotnĂ­ho cyklu nenĂ­
 * odpovÄ›dnostĂ­ tĂ©to tĹ™Ă­dy a je Ĺ™eĹˇena v SeasonService.
 */
@Service
public class CurrentSeasonServiceImpl implements CurrentSeasonService {

    /**
     * NĂˇzev session atributu pro uloĹľenĂ­ ID aktuĂˇlnĂ­ sezĂłny.
     */
    private static final String CURRENT_SEASON_SESSION_ATTR = "CURRENT_SEASON_ID";

    /**
     * Session atribut urÄŤujĂ­cĂ­, zda byla sezĂłna zvolena uĹľivatelem.
     *
     * Hodnota true znaÄŤĂ­ explicitnĂ­ uĹľivatelskou volbu.
     * Hodnota false nebo null znaÄŤĂ­ automatickĂ© nastavenĂ­.
     */
    private static final String CURRENT_SEASON_CUSTOM_ATTR = "CURRENT_SEASON_CUSTOM";

    /**
     * HTTP session pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     */
    private final HttpSession session;

    /**
     * Service poskytujĂ­cĂ­ informace o sezĂłnĂˇch.
     *
     * PouĹľĂ­vĂˇ se k zĂ­skĂˇnĂ­ globĂˇlnÄ› aktivnĂ­ sezĂłny.
     */
    private final SeasonService seasonService;

    public CurrentSeasonServiceImpl(HttpSession session,
                                    SeasonService seasonService) {
        this.session = session;
        this.seasonService = seasonService;
    }

    /**
     * VrĂˇtĂ­ identifikĂˇtor aktuĂˇlnĂ­ sezĂłny podle stanovenĂ© priority.
     *
     * Nejprve se zohlednĂ­ sezĂłna explicitnÄ› zvolenĂˇ uĹľivatelem.
     * Pokud takovĂˇ volba neexistuje, pouĹľije se globĂˇlnÄ› aktivnĂ­ sezĂłna.
     * PĹ™i automatickĂ©m nastavenĂ­ se identifikĂˇtor sezĂłny uloĹľĂ­ do session.
     *
     * @return ID aktuĂˇlnĂ­ sezĂłny nebo null, pokud nenĂ­ k dispozici ĹľĂˇdnĂˇ aktivnĂ­ sezĂłna
     */
    @Override
    public Long getCurrentSeasonIdOrDefault() {
        Object value = session.getAttribute(CURRENT_SEASON_SESSION_ATTR);
        Boolean custom = (Boolean) session.getAttribute(CURRENT_SEASON_CUSTOM_ATTR);

        if (Boolean.TRUE.equals(custom) && value != null) {
            return toLong(value);
        }

        SeasonDTO active = seasonService.getActiveSeasonOrNull();
        if (active != null) {
            Long id = active.getId();
            session.setAttribute(CURRENT_SEASON_SESSION_ATTR, id);
            session.setAttribute(CURRENT_SEASON_CUSTOM_ATTR, Boolean.FALSE);
            return id;
        }

        return null;
    }

    /**
     * NastavĂ­ sezĂłnu jako aktuĂˇlnĂ­ pro pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * SezĂłna je uloĹľena do session a oznaÄŤena jako
     * explicitnĂ­ uĹľivatelskĂˇ volba.
     *
     * @param seasonId ID sezĂłny, kterĂˇ mĂˇ bĂ˝t nastavena
     */
    @Override
    public void setCurrentSeasonId(Long seasonId) {
        session.setAttribute(CURRENT_SEASON_SESSION_ATTR, seasonId);
        session.setAttribute(CURRENT_SEASON_CUSTOM_ATTR, Boolean.TRUE);
    }

    /**
     * OdstranĂ­ informaci o aktuĂˇlnĂ­ sezĂłnÄ› z HTTP session.
     *
     * Metoda se pouĹľĂ­vĂˇ pĹ™i odhlĂˇĹˇenĂ­ uĹľivatele
     * nebo pĹ™i resetu uĹľivatelskĂ©ho kontextu.
     */
    @Override
    public void clearCurrentSeason() {
        session.removeAttribute(CURRENT_SEASON_SESSION_ATTR);
        session.removeAttribute(CURRENT_SEASON_CUSTOM_ATTR);
    }

    /**
     * ZajistĂ­ bezpeÄŤnĂ˝ pĹ™evod hodnoty ze session na typ Long.
     *
     * Metoda slouĹľĂ­ jako ochrana proti rozdĂ­lnĂ˝m typĹŻm hodnot,
     * kterĂ© mĹŻĹľe servlet container vrĂˇtit.
     *
     * @param value hodnota naÄŤtenĂˇ ze session
     * @return hodnota pĹ™evedenĂˇ na Long
     */
    private Long toLong(Object value) {
        if (value instanceof Long l) return l;
        if (value instanceof Integer i) return i.longValue();
        return Long.valueOf(value.toString());
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchHistoryService.java
-----
package cz.phsoft.hokej.models.services;


import cz.phsoft.hokej.models.dto.MatchHistoryDTO;

import java.util.List;

/**
     * ServisnĂ­ rozhranĂ­ pro prĂˇci s historiĂ­ zĂˇpasĹŻ.
     *
     * SlouĹľĂ­ pouze pro ÄŤtenĂ­ auditnĂ­ch zĂˇznamĹŻ,
     * zĂˇpis se provĂˇdĂ­ pĹ™es databĂˇzovĂ© triggery.
     */
    public interface MatchHistoryService {

        /**
         * VrĂˇtĂ­ historii danĂ©ho zĂˇpasu podle jeho ID.
         *
         * @param matchId ID zĂˇpasu z hlavnĂ­ tabulky matches
         * @return seznam historickĂ˝ch zĂˇznamĹŻ od nejnovÄ›jĹˇĂ­ho po nejstarĹˇĂ­
         */
        List<MatchHistoryDTO> getHistoryForMatch(Long matchId);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchHistoryServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.repositories.MatchHistoryRepository;
import cz.phsoft.hokej.models.dto.MatchHistoryDTO;
import cz.phsoft.hokej.models.mappers.MatchHistoryMapper;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * Implementace servisnĂ­ vrstvy pro prĂˇci s historiĂ­ zĂˇpasĹŻ.
 *
 * ZajiĹˇĹĄuje pĹ™evod entit na DTO a volĂˇnĂ­ repozitĂˇĹ™e.
 * NemÄ›nĂ­ ani nevytvĂˇĹ™Ă­ historickĂ© zĂˇznamy â€“ o to se starajĂ­
 * databĂˇzovĂ© triggery.
 */
@Service
public class MatchHistoryServiceImpl implements MatchHistoryService {

    private final MatchHistoryRepository repository;
    private final MatchHistoryMapper mapper;

    public MatchHistoryServiceImpl(
            MatchHistoryRepository repository,
            MatchHistoryMapper mapper
    ) {
        this.repository = repository;
        this.mapper = mapper;
    }

    @Override
    public List<MatchHistoryDTO> getHistoryForMatch(Long matchId) {
        return mapper.toDTOList(
                repository.findByMatchIdOrderByChangedAtDesc(matchId)
        );
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationHistoryService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.MatchRegistrationHistoryDTO;

import java.util.List;

/**
 * Service se pouĹľĂ­vĂˇ pro prĂˇci s historickĂ˝mi (auditnĂ­mi) zĂˇznamy
 * registracĂ­ hrĂˇÄŤĹŻ k zĂˇpasĹŻm.
 *
 * Tato service je ÄŤistÄ› pro ÄŤtenĂ­. Pracuje s historickĂ˝mi daty,
 * neprovĂˇdĂ­ ĹľĂˇdnĂ© zmÄ›ny v databĂˇzi a neobsahuje vlastnĂ­ business logiku.
 * SlouĹľĂ­ k oddÄ›lenĂ­ auditnĂ­ch dotazĹŻ od hlavnĂ­ logiky registracĂ­.
 *
 * TypickĂ˝m pouĹľitĂ­m je zobrazenĂ­ historie zmÄ›n registrace
 * aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho hrĂˇÄŤe nebo provĂˇdÄ›nĂ­ administrativnĂ­ho auditu
 * registracĂ­ konkrĂ©tnĂ­ho hrĂˇÄŤe k danĂ©mu zĂˇpasu.
 */
public interface MatchRegistrationHistoryService {

    /**
     * VrĂˇtĂ­ historii vĹˇech zmÄ›n registrace aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho hrĂˇÄŤe
     * pro zadanĂ˝ zĂˇpas.
     *
     * Metoda pracuje s kontextem aktuĂˇlnĂ­ho hrĂˇÄŤe
     * a vracĂ­ pouze zĂˇznamy, kterĂ© se k tomuto hrĂˇÄŤi vztahujĂ­.
     * Historie je seĹ™azena sestupnÄ› podle ÄŤasu zmÄ›ny, takĹľe
     * nejnovÄ›jĹˇĂ­ zmÄ›na je na prvnĂ­m mĂ­stÄ›.
     *
     * @param matchId ID zĂˇpasu, ke kterĂ©mu se historie naÄŤĂ­tĂˇ
     * @return seznam historickĂ˝ch zĂˇznamĹŻ registrace hrĂˇÄŤe k zĂˇpasu
     */
    List<MatchRegistrationHistoryDTO> getHistoryForCurrentPlayerAndMatch(Long matchId);

    /**
     * VrĂˇtĂ­ historii vĹˇech zmÄ›n registrace zadanĂ©ho hrĂˇÄŤe
     * k danĂ©mu zĂˇpasu.
     *
     * Metoda se pouĹľĂ­vĂˇ zejmĂ©na pro administrativnĂ­ a auditnĂ­ ĂşÄŤely,
     * napĹ™Ă­klad pĹ™i kontrole zĂˇsahĹŻ do registracĂ­ hrĂˇÄŤĹŻ
     * nebo pĹ™i Ĺ™eĹˇenĂ­ sporĹŻ a reklamacĂ­.
     * Historie je seĹ™azena sestupnÄ› podle ÄŤasu zmÄ›ny.
     *
     * @param matchId  ID zĂˇpasu
     * @param playerId ID hrĂˇÄŤe
     * @return seznam historickĂ˝ch zĂˇznamĹŻ registrace hrĂˇÄŤe k zĂˇpasu
     */
    List<MatchRegistrationHistoryDTO> getHistoryForPlayerAndMatch(Long matchId, Long playerId);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationHistoryServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.repositories.MatchRegistrationHistoryRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.exceptions.MatchNotFoundException;
import cz.phsoft.hokej.models.dto.MatchRegistrationHistoryDTO;
import cz.phsoft.hokej.models.mappers.MatchRegistrationHistoryMapper;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * Implementace rozhranĂ­ MatchRegistrationHistoryService.
 *
 * TĹ™Ă­da zajiĹˇĹĄuje naÄŤĂ­tĂˇnĂ­ historickĂ˝ch zĂˇznamĹŻ registracĂ­ hrĂˇÄŤĹŻ
 * k zĂˇpasĹŻm z databĂˇze a jejich pĹ™evod do DTO. OdpovÄ›dnostĂ­ je
 * ovÄ›Ĺ™enĂ­ existence zĂˇpasu, provedenĂ­ dotazu do historie a mapovĂˇnĂ­
 * vĂ˝sledkĹŻ do podoby vhodnĂ© pro controller a frontend.
 *
 * TĹ™Ă­da neprovĂˇdĂ­ ĹľĂˇdnĂ© zmÄ›ny stavu systĂ©mu. SlouĹľĂ­ jako read-only
 * vrstva nad auditnĂ­mi daty a nenahrazuje hlavnĂ­ logiku registracĂ­.
 */
@Service
public class MatchRegistrationHistoryServiceImpl implements MatchRegistrationHistoryService {

    /**
     * Repository pro ÄŤtenĂ­ historickĂ˝ch zĂˇznamĹŻ registracĂ­.
     */
    private final MatchRegistrationHistoryRepository historyRepository;

    /**
     * Mapper pro pĹ™evod historickĂ˝ch entit do DTO.
     */
    private final MatchRegistrationHistoryMapper historyMapper;

    /**
     * Service pro prĂˇci s aktuĂˇlnÄ› zvolenĂ˝m hrĂˇÄŤem.
     *
     * PouĹľĂ­vĂˇ se pĹ™i naÄŤĂ­tĂˇnĂ­ historie pro pĹ™ihlĂˇĹˇenĂ©ho hrĂˇÄŤe.
     */
    private final CurrentPlayerService currentPlayerService;

    /**
     * Repository pro prĂˇci se zĂˇpasy.
     *
     * PouĹľĂ­vĂˇ se k ovÄ›Ĺ™enĂ­, Ĺľe poĹľadovanĂ˝ zĂˇpas existuje.
     */
    private final MatchRepository matchRepository;

    public MatchRegistrationHistoryServiceImpl(
            MatchRegistrationHistoryRepository historyRepository,
            MatchRegistrationHistoryMapper historyMapper,
            CurrentPlayerService currentPlayerService,
            MatchRepository matchRepository
    ) {
        this.historyRepository = historyRepository;
        this.historyMapper = historyMapper;
        this.currentPlayerService = currentPlayerService;
        this.matchRepository = matchRepository;
    }

    /**
     * NaÄŤte historii registracĂ­ aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho hrĂˇÄŤe pro danĂ˝ zĂˇpas.
     *
     * Nejprve se ovÄ›Ĺ™Ă­, Ĺľe zĂˇpas existuje. PotĂ© se ovÄ›Ĺ™Ă­,
     * Ĺľe je nastaven aktuĂˇlnĂ­ hrĂˇÄŤ, a zĂ­skĂˇ se jeho identifikĂˇtor.
     * NĂˇslednÄ› se naÄŤtou auditnĂ­ zĂˇznamy pro kombinaci danĂ©ho zĂˇpasu
     * a aktuĂˇlnĂ­ho hrĂˇÄŤe. VĂ˝sledky jsou mapovĂˇny do DTO.
     *
     * @param matchId ID zĂˇpasu
     * @return seznam historickĂ˝ch zĂˇznamĹŻ registrace aktuĂˇlnĂ­ho hrĂˇÄŤe k zĂˇpasu
     * @throws MatchNotFoundException pokud zĂˇpas s danĂ˝m ID neexistuje
     */
    @Override
    public List<MatchRegistrationHistoryDTO> getHistoryForCurrentPlayerAndMatch(Long matchId) {
        MatchEntity match = matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));

        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        var history = historyRepository
                .findByMatchIdAndPlayerIdOrderByChangedAtDesc(match.getId(), currentPlayerId);

        return historyMapper.toDTOList(history);
    }

    /**
     * NaÄŤte historii registracĂ­ zadanĂ©ho hrĂˇÄŤe pro danĂ˝ zĂˇpas.
     *
     * Metoda je vhodnĂˇ pro administrativnĂ­ a auditnĂ­ endpointy,
     * kde se nepracuje s kontextem aktuĂˇlnĂ­ho hrĂˇÄŤe, ale s konkrĂ©tnĂ­m
     * hrĂˇÄŤem urÄŤenĂ˝m parametrem. Nejprve se ovÄ›Ĺ™Ă­ existence zĂˇpasu,
     * potĂ© se naÄŤtou odpovĂ­dajĂ­cĂ­ historickĂ© zĂˇznamy a pĹ™evedou se do DTO.
     *
     * @param matchId  ID zĂˇpasu
     * @param playerId ID hrĂˇÄŤe
     * @return seznam historickĂ˝ch zĂˇznamĹŻ registrace hrĂˇÄŤe k zĂˇpasu
     * @throws MatchNotFoundException pokud zĂˇpas s danĂ˝m ID neexistuje
     */
    @Override
    public List<MatchRegistrationHistoryDTO> getHistoryForPlayerAndMatch(Long matchId, Long playerId) {
        MatchEntity match = matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));

        var history = historyRepository
                .findByMatchIdAndPlayerIdOrderByChangedAtDesc(match.getId(), playerId);

        return historyMapper.toDTOList(history);
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;

import java.util.List;

/**
 * RozhranĂ­ se pouĹľĂ­vĂˇ pro sprĂˇvu registracĂ­ hrĂˇÄŤĹŻ na zĂˇpasy.
 * <p>
 * Definuje kontrakt pro prĂˇci s ĂşÄŤastĂ­ hrĂˇÄŤĹŻ na zĂˇpasech
 * z pohledu business logiky aplikace. Poskytuje operace pro
 * vytvoĹ™enĂ­ nebo zmÄ›nu registrace, zĂ­skĂˇvĂˇnĂ­ pĹ™ehledĹŻ a
 * administrativnĂ­ zĂˇsahy do stavĹŻ registracĂ­.
 * <p>
 * RozhranĂ­ pracuje s DTO objekty a oddÄ›luje business logiku
 * od persistence vrstvy. Implementace je odpovÄ›dnĂˇ za validace
 * a pĹ™echody stavĹŻ registracĂ­.
 */
public interface MatchRegistrationService {

    /**
     * VytvoĹ™Ă­ nebo aktualizuje registraci hrĂˇÄŤe na zĂˇpas.
     * <p>
     * Metoda slouĹľĂ­ jako jednotnĂ˝ vstupnĂ­ bod pro reakci hrĂˇÄŤe
     * na zĂˇpas. Registrace se podle potĹ™eby vytvoĹ™Ă­ nebo upravĂ­.
     * Implementace zajiĹˇĹĄuje validaci vstupnĂ­ch dat, kontrolu
     * povolenĂ˝ch pĹ™echodĹŻ stavĹŻ a uloĹľenĂ­ vĂ˝slednĂ© registrace.
     * <p>
     * TypickĂ˝m scĂ©nĂˇĹ™em je pĹ™ihlĂˇĹˇenĂ­ hrĂˇÄŤe k zĂˇpasu, odhlĂˇĹˇenĂ­
     * nebo omluva z ĂşÄŤasti.
     *
     * @param playerId ID hrĂˇÄŤe, kterĂ˝ reaguje na zĂˇpas
     * @param request  poĹľadavek obsahujĂ­cĂ­ data o registraci
     * @return DTO reprezentace vĂ˝slednĂ©ho stavu registrace
     */
    MatchRegistrationDTO upsertRegistration(
            Long playerId,
            MatchRegistrationRequest request
    );

    /**
     * VrĂˇtĂ­ seznam registracĂ­ pro konkrĂ©tnĂ­ zĂˇpas.
     *
     * @param matchId ID zĂˇpasu
     * @return seznam registracĂ­ hrĂˇÄŤĹŻ k danĂ©mu zĂˇpasu
     */
    List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId);

    /**
     * VrĂˇtĂ­ seznam registracĂ­ pro vĂ­ce zĂˇpasĹŻ.
     * <p>
     * Metoda se typicky pouĹľĂ­vĂˇ pro hromadnĂ© pĹ™ehledy
     * nebo statistiky pĹ™es vĂ­ce zĂˇpasĹŻ.
     *
     * @param matchIds seznam ID zĂˇpasĹŻ
     * @return seznam registracĂ­ pro zadanĂ© zĂˇpasy
     */
    List<MatchRegistrationDTO> getRegistrationsForMatches(List<Long> matchIds);

    /**
     * VrĂˇtĂ­ vĹˇechny registrace v systĂ©mu omezenĂ©
     * na relevantnĂ­ sezĂłnu podle implementace.
     * <p>
     * Metoda se pouĹľĂ­vĂˇ zejmĂ©na pro administrĂˇtorskĂ© pĹ™ehledy.
     *
     * @return seznam vĹˇech registracĂ­
     */
    List<MatchRegistrationDTO> getAllRegistrations();

    /**
     * VrĂˇtĂ­ seznam registracĂ­ konkrĂ©tnĂ­ho hrĂˇÄŤe.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return seznam registracĂ­ danĂ©ho hrĂˇÄŤe
     */
    List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId);

    /**
     * VrĂˇtĂ­ seznam hrĂˇÄŤĹŻ, kteĹ™Ă­ dosud nereagovali na danĂ˝ zĂˇpas.
     * <p>
     * Metoda se pouĹľĂ­vĂˇ napĹ™Ă­klad pro pĹ™ipomĂ­nkovĂ© notifikace
     * nebo pro pĹ™ehledy nevyĹ™eĹˇenĂ© ĂşÄŤasti.
     *
     * @param matchId ID zĂˇpasu
     * @return seznam hrĂˇÄŤĹŻ bez reakce na zĂˇpas
     */
    List<PlayerDTO> getNoResponsePlayers(Long matchId);

    /**
     * PĹ™epoÄŤĂ­tĂˇ stavy registracĂ­ pro danĂ˝ zĂˇpas.
     * <p>
     * Metoda slouĹľĂ­ k zajiĹˇtÄ›nĂ­ konzistence stavĹŻ registrovanĂ˝ch
     * a rezervnĂ­ch hrĂˇÄŤĹŻ podle kapacity zĂˇpasu, typicky po zmÄ›nĂˇch
     * provedenĂ˝ch administrĂˇtorem.
     *
     * @param matchId ID zĂˇpasu
     */
    void recalcStatusesForMatch(Long matchId);

    /**
     * ZmÄ›nĂ­ stav registrace hrĂˇÄŤe na zĂˇpas.
     * <p>
     * Metoda se pouĹľĂ­vĂˇ pĹ™evĂˇĹľnÄ› v administrĂˇtorskĂ©m kontextu,
     * kde je nutnĂ© ruÄŤnÄ› upravit stav registrace. NastavenĂ­
     * stavu NO_EXCUSED mĂˇ vlastnĂ­ logiku a Ĺ™eĹˇĂ­ se samostatnÄ›.
     *
     * @param matchId  ID zĂˇpasu
     * @param playerId ID hrĂˇÄŤe
     * @param status   novĂ˝ stav registrace
     * @return DTO reprezentace aktualizovanĂ© registrace
     */
    MatchRegistrationDTO updateStatus(
            Long matchId,
            Long playerId,
            PlayerMatchStatus status
    );

    /**
     * OznaÄŤĂ­ hrĂˇÄŤe jako neomluvenĂ©ho pro konkrĂ©tnĂ­ zĂˇpas.
     * <p>
     * Metoda se pouĹľĂ­vĂˇ v administrĂˇtorskĂ©m kontextu po vyhodnocenĂ­
     * ĂşÄŤasti na zĂˇpase. PĹŻvodnĂ­ omluva se odstranĂ­ a registrace
     * se nastavĂ­ do stavu NO_EXCUSED vÄŤetnÄ› poznĂˇmky administrĂˇtora.
     *
     * @param matchId   ID zĂˇpasu
     * @param playerId  ID hrĂˇÄŤe
     * @param adminNote poznĂˇmka administrĂˇtora
     * @return DTO reprezentace aktualizovanĂ© registrace
     */
    MatchRegistrationDTO markNoExcused(
            Long matchId,
            Long playerId,
            String adminNote
    );

    MatchRegistrationDTO cancelNoExcused(Long matchId,
                                         Long playerId,
                                         ExcuseReason excuseReason,
                                         String excuseNote);



    MatchRegistrationDTO changeRegistrationTeam(Long matchId,
                                                Long playerId);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.*;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.mappers.MatchRegistrationMapper;
import cz.phsoft.hokej.models.mappers.PlayerMapper;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;
import cz.phsoft.hokej.models.services.notification.NotificationService;
import cz.phsoft.hokej.models.services.sms.SmsMessageBuilder;
import cz.phsoft.hokej.models.services.sms.SmsService;
import jakarta.transaction.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Implementace service vrstvy, kterĂˇ se pouĹľĂ­vĂˇ pro sprĂˇvu registracĂ­ hrĂˇÄŤĹŻ na zĂˇpasy.
 *
 * V tĂ©to tĹ™Ă­dÄ› se zajiĹˇĹĄuje vytvĂˇĹ™enĂ­ a aktualizace registracĂ­, vyhodnocovĂˇnĂ­ stavovĂ˝ch pĹ™echodĹŻ
 * podle kapacity zĂˇpasu a poskytovĂˇnĂ­ pĹ™ehledĹŻ registracĂ­ pro zĂˇpas, hrĂˇÄŤe nebo sadu zĂˇpasĹŻ.
 *
 * SouÄŤĂˇstĂ­ odpovÄ›dnosti je takĂ© spouĹˇtÄ›nĂ­ notifikacĂ­ hrĂˇÄŤĹŻm podle typu zmÄ›ny registrace a v pĹ™Ă­padÄ› potĹ™eby
 * takĂ© odesĂ­lĂˇnĂ­ SMS zprĂˇv registrovanĂ˝m hrĂˇÄŤĹŻm.
 *
 * TĹ™Ă­da obsahuje business logiku registracĂ­ a souvisejĂ­cĂ­ch pravidel. NeĹ™eĹˇĂ­ prezentaci, UI logiku ani vĂ˝bÄ›r
 * aktuĂˇlnĂ­ho hrĂˇÄŤe, kterĂ© nĂˇleĹľĂ­ jinĂ˝m vrstvĂˇm aplikace.
 */
@Service
public class MatchRegistrationServiceImpl implements MatchRegistrationService {

    private static final Logger log = LoggerFactory.getLogger(MatchRegistrationServiceImpl.class);

    private final MatchRegistrationRepository registrationRepository;
    private final MatchRepository matchRepository;
    private final PlayerRepository playerRepository;
    private final MatchRegistrationMapper matchRegistrationMapper;
    private final PlayerMapper playerMapper;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;
    private final NotificationService notificationService;
    private final SeasonService seasonService;
    private final CurrentSeasonService currentSeasonService;

    public MatchRegistrationServiceImpl(
            MatchRegistrationRepository registrationRepository,
            MatchRepository matchRepository,
            PlayerRepository playerRepository,
            MatchRegistrationMapper matchRegistrationMapper,
            PlayerMapper playerMapper,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder,
            NotificationService notificationService,
            SeasonService seasonService,
            CurrentSeasonService currentSeasonService
    ) {
        this.registrationRepository = registrationRepository;
        this.matchRepository = matchRepository;
        this.playerRepository = playerRepository;
        this.matchRegistrationMapper = matchRegistrationMapper;
        this.playerMapper = playerMapper;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
        this.notificationService = notificationService;
        this.seasonService = seasonService;
        this.currentSeasonService = currentSeasonService;
    }

    // ==========================================
    // HLAVNĂŤ METODA â€“ UPSERT REGISTRACE HRĂÄŚE
    // ==========================================

    /**
     * VytvĂˇĹ™Ă­ nebo aktualizuje registraci hrĂˇÄŤe na zĂˇpas.
     *
     * Nejprve se naÄŤte zĂˇpas a hrĂˇÄŤ a ovÄ›Ĺ™Ă­ se, Ĺľe zĂˇpas patĹ™Ă­ do aktivnĂ­ sezĂłny.
     * NĂˇslednÄ› se vyhodnotĂ­, zda aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ˝ uĹľivatel mĹŻĹľe registraci upravovat s ohledem na roli
     * a ÄŤas zĂˇpasu.
     *
     * Podle obsahu poĹľadavku se zvolĂ­ vÄ›tev pro odhlĂˇĹˇenĂ­, omluvu nebo registraci a urÄŤĂ­ se cĂ­lovĂ˝ stav registrace.
     * SpoleÄŤnĂ© Ăşdaje se pĹ™evezmou z poĹľadavku, registrace se uloĹľĂ­ a pĹ™i odhlĂˇĹˇenĂ­ se pĹ™epoÄŤĂ­tajĂ­ stavy registracĂ­
     * pro danĂ˝ zĂˇpas. Po uloĹľenĂ­ se podle vĂ˝slednĂ©ho stavu odeĹˇlou notifikace.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, jehoĹľ registrace se upravuje.
     * @param request PoĹľadavek obsahujĂ­cĂ­ parametry zmÄ›ny registrace.
     * @return DTO uloĹľenĂ© registrace se stavem odpovĂ­dajĂ­cĂ­m vyhodnocenĂ˝m pravidlĹŻm.
     */
    @Transactional
    @Override
    public MatchRegistrationDTO upsertRegistration(Long playerId, MatchRegistrationRequest request) {

        MatchEntity match = getMatchOrThrow(request.getMatchId());
        PlayerEntity player = getPlayerOrThrow(playerId);

        // OvÄ›Ĺ™enĂ­, Ĺľe zĂˇpas patĹ™Ă­ do aktuĂˇlnÄ› aktivnĂ­ sezĂłny.
        // ZĂˇpisy do neaktivnĂ­ sezĂłny nejsou povoleny.
        assertMatchInActiveSeason(match);

        // OvÄ›Ĺ™enĂ­, zda aktuĂˇlnĂ­ uĹľivatel smĂ­ mÄ›nit registraci
        // s ohledem na svou roli a ÄŤas zĂˇpasu.
        assertPlayerCanModifyMatch(match);

        MatchRegistrationEntity registration =
                getRegistrationOrNull(playerId, request.getMatchId());

        if (registration == null && !request.isUnregister()) {
            registration = new MatchRegistrationEntity();
            registration.setMatch(match);
            registration.setPlayer(player);
        }

        PlayerMatchStatus newStatus;

        if (request.isUnregister()) {
            newStatus = handleUnregister(request, playerId, registration);
        } else if (request.getExcuseReason() != null) {
            newStatus = handleExcuse(request, match, player, registration);
        } else {
            newStatus = handleRegisterOrReserveOrSubstitute(request, match, player, registration);
        }

        applyRequestDetails(registration, request);

        registration.setStatus(newStatus);
        registration.setTimestamp(now());
        registration.setCreatedBy("user");

        registration = registrationRepository.save(registration);

        if (request.isUnregister()) {
            recalcStatusesForMatch(request.getMatchId());
        }

        NotificationType notificationType = resolveNotificationType(newStatus);
        if (notificationType != null) {
            notifyPlayer(player, notificationType, registration);
        }

        return matchRegistrationMapper.toDTO(registration);
    }

    /**
     * Vyhodnocuje registraci typu REGISTERED, RESERVED nebo SUBSTITUTE a vracĂ­ cĂ­lovĂ˝ stav registrace.
     *
     * OpakovanĂˇ registrace hrĂˇÄŤe, kterĂ˝ je jiĹľ ve stavu REGISTERED, se neumoĹľĹuje.
     * PĹ™i volbÄ› SUBSTITUTE se nastavĂ­ stav nĂˇhradnĂ­ka, kterĂ˝ neblokuje kapacitu zĂˇpasu.
     * PĹ™i standardnĂ­ registraci se podle kapacity zĂˇpasu urÄŤĂ­ stav REGISTERED nebo RESERVED.
     *
     * PĹ™Ă­padnĂˇ omluva uloĹľenĂˇ na registraci se pĹ™ed nastavenĂ­m cĂ­lovĂ©ho stavu odstranĂ­.
     *
     * @param request PoĹľadavek obsahujĂ­cĂ­ parametry zmÄ›ny registrace.
     * @param match ZĂˇpas, ke kterĂ©mu se registrace vztahuje.
     * @param player HrĂˇÄŤ, jehoĹľ registrace se upravuje.
     * @param registration ExistujĂ­cĂ­ registrace, nebo null v pĹ™Ă­padÄ› prvnĂ­ho zĂˇpisu.
     * @return CĂ­lovĂ˝ stav registrace odpovĂ­dajĂ­cĂ­ vyhodnocenĂ˝m pravidlĹŻm.
     */
    private PlayerMatchStatus handleRegisterOrReserveOrSubstitute(
            MatchRegistrationRequest request,
            MatchEntity match,
            PlayerEntity player,
            MatchRegistrationEntity registration
    ) {
        PlayerMatchStatus currentStatus =
                (registration != null) ? registration.getStatus() : null;

        boolean isAlreadyRegistered = currentStatus == PlayerMatchStatus.REGISTERED;

        if (isAlreadyRegistered) {
            throw new DuplicateRegistrationException(request.getMatchId(), player.getId());
        }

        // Registrace jako nĂˇhradnĂ­k (SUBSTITUTE) â€“ hrĂˇÄŤ je oznaÄŤen jako â€žmoĹľnĂˇâ€ś
        // a neblokuje kapacitu ani poĹ™adĂ­.
        if (request.isSubstitute()) {
            if (currentStatus == PlayerMatchStatus.SUBSTITUTE) {
                throw new DuplicateRegistrationException(
                        request.getMatchId(),
                        player.getId(),
                        "HrĂˇÄŤ jiĹľ mĂˇ zaregistrovĂˇno - moĹľnĂˇ"
                );
            }

            clearExcuseIfNeeded(registration);
            return PlayerMatchStatus.SUBSTITUTE;
        }

        PlayerMatchStatus newStatus =
                isSlotAvailable(match) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;

        clearExcuseIfNeeded(registration);
        return newStatus;
    }

    /**
     * ZpracovĂˇvĂˇ odhlĂˇĹˇenĂ­ hrĂˇÄŤe ze zĂˇpasu a vracĂ­ cĂ­lovĂ˝ stav UNREGISTERED.
     *
     * OdhlĂˇĹˇenĂ­ se umoĹľĹuje pouze v pĹ™Ă­padÄ›, Ĺľe registrace existuje a nachĂˇzĂ­ se ve stavu REGISTERED nebo RESERVED.
     * V opaÄŤnĂ©m pĹ™Ă­padÄ› se vyhodĂ­ vĂ˝jimka signalizujĂ­cĂ­ neexistujĂ­cĂ­ nebo nepovolenou registraci pro odhlĂˇĹˇenĂ­.
     *
     * PĹ™i ĂşspÄ›ĹˇnĂ©m odhlĂˇĹˇenĂ­ se uloĹľĂ­ informace o omluvÄ› z poĹľadavku.
     *
     * @param request PoĹľadavek obsahujĂ­cĂ­ parametry odhlĂˇĹˇenĂ­.
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, jehoĹľ registrace se odhlaĹˇuje.
     * @param registration ExistujĂ­cĂ­ registrace hrĂˇÄŤe na zĂˇpas.
     * @return Stav UNREGISTERED, kterĂ˝ se mĂˇ na registraci uloĹľit.
     */
    private PlayerMatchStatus handleUnregister(
            MatchRegistrationRequest request,
            Long playerId,
            MatchRegistrationEntity registration
    ) {
        boolean isAllowedUnregisterStatus =
                registration != null &&
                        (registration.getStatus() == PlayerMatchStatus.REGISTERED
                                || registration.getStatus() == PlayerMatchStatus.RESERVED);

        if (!isAllowedUnregisterStatus) {
            throw new RegistrationNotFoundException(request.getMatchId(), playerId);
        }

        registration.setExcuseReason(request.getExcuseReason());
        registration.setExcuseNote(request.getExcuseNote());

        return PlayerMatchStatus.UNREGISTERED;
    }

    /**
     * ZpracovĂˇvĂˇ omluvu hrĂˇÄŤe z ĂşÄŤasti na zĂˇpase a vracĂ­ cĂ­lovĂ˝ stav EXCUSED.
     *
     * Omluva se umoĹľĹuje pouze v pĹ™Ă­padÄ›, Ĺľe hrĂˇÄŤ dosud nereagoval na zĂˇpas, je veden jako nĂˇhradnĂ­k,
     * nebo je ve stavu NO_EXCUSED. PĹ™i poruĹˇenĂ­ pravidel se vyhodĂ­ vĂ˝jimka signalizujĂ­cĂ­ nepovolenĂ˝ pĹ™echod.
     *
     * PĹ™i ĂşspÄ›ĹˇnĂ© omluvÄ› se uloĹľĂ­ dĹŻvod a poznĂˇmka omluvy z poĹľadavku.
     *
     * @param request PoĹľadavek obsahujĂ­cĂ­ parametry omluvy.
     * @param match ZĂˇpas, ke kterĂ©mu se omluva vztahuje.
     * @param player HrĂˇÄŤ, jehoĹľ omluva se zpracovĂˇvĂˇ.
     * @param registration ExistujĂ­cĂ­ registrace, nebo null v pĹ™Ă­padÄ› prvnĂ­ho zĂˇpisu.
     * @return Stav EXCUSED, kterĂ˝ se mĂˇ na registraci uloĹľit.
     */
    private PlayerMatchStatus handleExcuse(
            MatchRegistrationRequest request,
            MatchEntity match,
            PlayerEntity player,
            MatchRegistrationEntity registration
    ) {
        boolean isNoResponseOrSubstitute =
                (registration == null
                        || registration.getStatus() == null
                        || registration.getStatus() == PlayerMatchStatus.SUBSTITUTE
                        || registration.getStatus() == PlayerMatchStatus.NO_EXCUSED);

        if (!isNoResponseOrSubstitute) {
            throw new DuplicateRegistrationException(
                    request.getMatchId(),
                    player.getId(),
                    "BE - Omluva je moĹľnĂˇ pouze pokud hrĂˇÄŤ dosud nereagoval na zĂˇpas, nebo byl nĂˇhradnĂ­k."
            );
        }

        registration.setExcuseReason(request.getExcuseReason());
        registration.setExcuseNote(request.getExcuseNote());

        return PlayerMatchStatus.EXCUSED;
    }

    /**
     * Nastavuje registraci do stavu NO_EXCUSED na zĂˇkladÄ› rozhodnutĂ­ administrĂˇtora.
     *
     * ZĂˇpas musĂ­ bĂ˝t jiĹľ odehranĂ˝ a pĹ™edchozĂ­ stav registrace musĂ­ bĂ˝t REGISTERED.
     * PĹ™Ă­padnĂˇ omluva se odstranĂ­ a uloĹľĂ­ se poznĂˇmka administrĂˇtora. Po zmÄ›nÄ› se odeĹˇle notifikace
     * odpovĂ­dajĂ­cĂ­ vĂ˝slednĂ©mu stavu.
     *
     * @param matchId IdentifikĂˇtor zĂˇpasu, pro kterĂ˝ se stav upravuje.
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, jehoĹľ registrace se upravuje.
     * @param adminNote PoznĂˇmka administrĂˇtora, kterĂˇ se uloĹľĂ­ k registraci.
     * @return DTO aktualizovanĂ© registrace po zmÄ›nÄ› stavu.
     */
    @Override
    @Transactional
    public MatchRegistrationDTO markNoExcused(Long matchId,
                                              Long playerId,
                                              String adminNote) {

        MatchEntity match = getMatchOrThrow(matchId);
        PlayerEntity player = getPlayerOrThrow(playerId);

        if (match.getDateTime().isAfter(now())) {
            throw new InvalidPlayerStatusException(
                    "BE - Status NO_EXCUSED lze nastavit pouze u jiĹľ probÄ›hlĂ©ho zĂˇpasu."
            );
        }

        MatchRegistrationEntity registration = getRegistrationOrThrow(playerId, matchId);

        if (registration.getStatus() != PlayerMatchStatus.REGISTERED) {
            throw new InvalidPlayerStatusException(
                    "BE - Status NO_EXCUSED lze nastavit pouze z registrace REGISTERED."
            );
        }

        registration.setExcuseReason(null);
        registration.setExcuseNote(null);

        if (adminNote == null || adminNote.isBlank()) {
            registration.setAdminNote("Nedostavil se bez omluvy");
        } else {
            registration.setAdminNote(adminNote);
        }

        MatchRegistrationEntity updated =
                updateRegistrationStatus(
                        registration,
                        PlayerMatchStatus.NO_EXCUSED,
                        "admin",
                        true
                );

        PlayerMatchStatus newStatus = PlayerMatchStatus.NO_EXCUSED;

        NotificationType notificationType = resolveNotificationType(newStatus);
        if (notificationType != null) {
            notifyPlayer(player, notificationType, updated);
        }

        return matchRegistrationMapper.toDTO(updated);
    }

    /**
     * Nastavuje registraci do stavu EXCUSED na zĂˇkladÄ› rozhodnutĂ­ administrĂˇtora nebo manaĹľera po pĹ™edchozĂ­m NO_EXCUSED.
     *
     * ZĂˇpas musĂ­ bĂ˝t jiĹľ odehranĂ˝ a pĹ™edchozĂ­ stav registrace musĂ­ bĂ˝t NO_EXCUSED.
     * AdministrĂˇtorskĂˇ poznĂˇmka se odstranĂ­ a uloĹľĂ­ se dĹŻvod a poznĂˇmka omluvy.
     * V tĂ©to operaci se notifikace neodesĂ­lajĂ­.
     *
     * @param matchId IdentifikĂˇtor zĂˇpasu, pro kterĂ˝ se stav upravuje.
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, jehoĹľ registrace se upravuje.
     * @param excuseReason DĹŻvod omluvy, kterĂ˝ se uloĹľĂ­ k registraci.
     * @param excuseNote PoznĂˇmka omluvy, kterĂˇ se uloĹľĂ­ k registraci.
     * @return DTO aktualizovanĂ© registrace po zmÄ›nÄ› stavu.
     */
    @Override
    @Transactional
    public MatchRegistrationDTO cancelNoExcused(Long matchId,
                                                Long playerId,
                                                ExcuseReason excuseReason,
                                                String excuseNote) {

        MatchEntity match = getMatchOrThrow(matchId);
        PlayerEntity player = getPlayerOrThrow(playerId);

        if (match.getDateTime().isAfter(now())) {
            throw new InvalidPlayerStatusException(
                    "BE - Status EXCUSED po NO-EXCUSED lze nastavit pouze u jiĹľ probÄ›hlĂ©ho zĂˇpasu."
            );
        }

        MatchRegistrationEntity registration = getRegistrationOrThrow(playerId, matchId);

        if (registration.getStatus() != PlayerMatchStatus.NO_EXCUSED) {
            throw new InvalidPlayerStatusException(
                    "BE - Status EXCUSED (zruĹˇenĂ­ neomluvenĂ­) lze nastavit pouze u hrĂˇÄŤe se statutem NO_EXCUSED."
            );
        }

        registration.setExcuseReason(ExcuseReason.JINE);
        registration.setAdminNote(null);
        if (excuseNote == null || excuseNote.isBlank()) {
            registration.setExcuseNote("Opravdu nemohl");
        } else {
            registration.setExcuseNote(excuseNote);
        }

        MatchRegistrationEntity updated =
                updateRegistrationStatus(
                        registration,
                        PlayerMatchStatus.EXCUSED,
                        "manager",
                        true
                );

        return matchRegistrationMapper.toDTO(updated);
    }

    /**
     * ZmÄ›nĂ­ tĂ˝m hrĂˇÄŤe u existujĂ­cĂ­ registrace na zĂˇpas.
     *
     * Metoda je pouĹľĂ­vĂˇna pro pĹ™epnutĂ­ hrĂˇÄŤe mezi tĂ˝mem LIGHT a DARK.
     * Nejprve je ovÄ›Ĺ™ena existence zĂˇpasu a hrĂˇÄŤe. NĂˇslednÄ› je zkontrolovĂˇno, Ĺľe
     * bÄ›ĹľnĂ˝ hrĂˇÄŤ (ROLE_PLAYER) nemÄ›nĂ­ tĂ˝m u jiĹľ probÄ›hlĂ©ho zĂˇpasu. AdministrĂˇtor
     * nebo manaĹľer tuto operaci mohou provĂˇdÄ›t i zpÄ›tnÄ›.
     *
     * Pokud jsou splnÄ›ny validaÄŤnĂ­ podmĂ­nky, je provedena aktualizace registrace.
     * Stav registrace zĹŻstĂˇvĂˇ REGISTERED, ale je pĹ™epnut tĂ˝m na opaÄŤnĂ˝.
     *
     * Po ĂşspÄ›ĹˇnĂ© zmÄ›nÄ› je vyhodnocen typ notifikace a v pĹ™Ă­padÄ› potĹ™eby
     * je hrĂˇÄŤi odeslĂˇna odpovĂ­dajĂ­cĂ­ notifikace.
     *
     * Na zĂˇvÄ›r je aktualizovanĂˇ entita pĹ™evedena na DTO pomocĂ­ mapperu
     * a vrĂˇcena volajĂ­cĂ­ vrstvÄ›.
     *
     * @param matchId identifikĂˇtor zĂˇpasu, u kterĂ©ho mĂˇ bĂ˝t tĂ˝m zmÄ›nÄ›n
     * @param playerId identifikĂˇtor hrĂˇÄŤe, jehoĹľ registrace mĂˇ bĂ˝t upravena
     * @return aktualizovanĂˇ registrace pĹ™evedenĂˇ do DTO
     * @throws InvalidMatchDateTimeException pokud bÄ›ĹľnĂ˝ hrĂˇÄŤ mÄ›nĂ­ tĂ˝m u jiĹľ probÄ›hlĂ©ho zĂˇpasu
     * @throws InvalidPlayerStatusException pokud registrace nenĂ­ ve stavu REGISTERED
     */
    public MatchRegistrationDTO changeRegistrationTeam(Long playerId,
                                                       Long matchId) {

        MatchEntity match = getMatchOrThrow(matchId);
        PlayerEntity player = getPlayerOrThrow(playerId);

        // Debug informativnÄ› â€“ aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ˝ uĹľivatel a jeho autority
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth != null) {
            log.debug("changeRegistrationTeam â€“ current user: {}", auth.getName());
            log.debug("changeRegistrationTeam â€“ authorities: {}", auth.getAuthorities());
        } else {
            log.debug("changeRegistrationTeam â€“ no authenticated user");
        }

        // ÄŚasovĂ© omezenĂ­ platĂ­ pouze pro hrĂˇÄŤe (ROLE_PLAYER).
        // Admin / Manager mohou mÄ›nit tĂ˝m i u minulĂ˝ch zĂˇpasĹŻ.
        if (match.getDateTime().isBefore(now()) && isCurrentUserPlayer()) {
            throw new InvalidMatchDateTimeException(
                    "BE - Team lze zmÄ›nit pouze u zĂˇpasu, kterĂ© teprve budou."
            );
        }

        MatchRegistrationEntity registration = getRegistrationOrThrow(playerId, matchId);
        Team oldTeam = registration.getTeam();

        if (registration.getStatus() != PlayerMatchStatus.REGISTERED) {
            throw new InvalidPlayerStatusException(
                    "BE - Team lze zmÄ›nit pouze z registrace REGISTERED."
            );
        }

        PlayerMatchStatus newStatus = PlayerMatchStatus.REGISTERED;
        Team newTeam = oldTeam.opposite();

        registration.setTeam(newTeam);

        registration = registrationRepository.save(registration);
        NotificationType notificationType = resolveNotificationType(newStatus);
        if (notificationType != null) {
            notifyPlayer(player, notificationType, registration);
        }
        return matchRegistrationMapper.toDTO(registration);
    }

    /**
     * Nastavuje do registrace spoleÄŤnĂ© Ăşdaje pĹ™evzatĂ© z poĹľadavku.
     *
     * V rĂˇmci zĂˇpisu se upravuje tĂ˝m, administrĂˇtorskĂˇ poznĂˇmka a informace o omluvÄ›,
     * pokud jsou v poĹľadavku uvedeny.
     *
     * @param registration Registrace, kterĂˇ se mĂˇ aktualizovat.
     * @param request PoĹľadavek obsahujĂ­cĂ­ hodnoty, kterĂ© se majĂ­ zapsat do registrace.
     */
    private void applyRequestDetails(MatchRegistrationEntity registration,
                                     MatchRegistrationRequest request) {

        if (request.getTeam() != null) {
            registration.setTeam(request.getTeam());
        }

        if (request.getAdminNote() != null) {
            registration.setAdminNote(request.getAdminNote());
        }

        if (request.getExcuseReason() != null) {
            registration.setExcuseReason(request.getExcuseReason());
        }

        if (request.getExcuseNote() != null) {
            registration.setExcuseNote(request.getExcuseNote());
        }
    }

    /*
     SpoleÄŤnĂ˝ helper pro pĹ™echody, kde se nemĂˇ zachovat omluva.
     */
    private void clearExcuseIfNeeded(MatchRegistrationEntity registration) {
        if (registration == null) {
            return;
        }
        if (registration.getExcuseReason() != null || registration.getExcuseNote() != null) {
            registration.setExcuseReason(null);
            registration.setExcuseNote(null);
        }
    }

    /**
     * VracĂ­ registrace pro danĂ˝ zĂˇpas omezenĂ© na aktuĂˇlnÄ› vybranou sezĂłnu.
     *
     * Pokud zĂˇpas nepatĹ™Ă­ do aktuĂˇlnÄ› vybranĂ© sezĂłny, vracĂ­ se prĂˇzdnĂ˝ seznam.
     *
     * @param matchId IdentifikĂˇtor zĂˇpasu, pro kterĂ˝ se registrace naÄŤĂ­tajĂ­.
     * @return Seznam registracĂ­ pĹ™evedenĂ˝ch do DTO pro danĂ˝ zĂˇpas v rĂˇmci aktuĂˇlnĂ­ sezĂłny.
     */
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);

        if (!isMatchInCurrentSeason(match)) {
            return List.of();
        }

        return matchRegistrationMapper.toDTOList(
                registrationRepository.findByMatchId(matchId)
        );
    }

    /**
     * VracĂ­ registrace pro zadanou sadu zĂˇpasĹŻ omezenĂ© na aktuĂˇlnÄ› vybranou sezĂłnu.
     *
     * Pokud je seznam identifikĂˇtorĹŻ zĂˇpasĹŻ null nebo prĂˇzdnĂ˝, vracĂ­ se prĂˇzdnĂ˝ seznam.
     *
     * @param matchIds Seznam identifikĂˇtorĹŻ zĂˇpasĹŻ, pro kterĂ© se registrace naÄŤĂ­tajĂ­.
     * @return Seznam registracĂ­ pĹ™evedenĂ˝ch do DTO pro zadanĂ© zĂˇpasy v rĂˇmci aktuĂˇlnĂ­ sezĂłny.
     */
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatches(List<Long> matchIds) {
        if (matchIds == null || matchIds.isEmpty()) {
            return List.of();
        }

        List<MatchRegistrationEntity> regsInSeason = registrationRepository
                .findByMatchIdIn(matchIds).stream()
                .filter(this::isRegistrationInCurrentSeason)
                .toList();

        return matchRegistrationMapper.toDTOList(regsInSeason);
    }

    /**
     * VracĂ­ vĹˇechny registrace v systĂ©mu omezenĂ© na aktuĂˇlnÄ› vybranou sezĂłnu.
     *
     * @return Seznam vĹˇech registracĂ­ pĹ™evedenĂ˝ch do DTO v rĂˇmci aktuĂˇlnĂ­ sezĂłny.
     */
    @Override
    public List<MatchRegistrationDTO> getAllRegistrations() {
        List<MatchRegistrationEntity> regsInSeason = registrationRepository
                .findAll().stream()
                .filter(this::isRegistrationInCurrentSeason)
                .toList();

        return matchRegistrationMapper.toDTOList(regsInSeason);
    }

    /**
     * VracĂ­ registrace zadanĂ©ho hrĂˇÄŤe omezenĂ© na aktuĂˇlnÄ› vybranou sezĂłnu.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, jehoĹľ registrace se naÄŤĂ­tajĂ­.
     * @return Seznam registracĂ­ hrĂˇÄŤe pĹ™evedenĂ˝ch do DTO v rĂˇmci aktuĂˇlnĂ­ sezĂłny.
     */
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId) {
        List<MatchRegistrationEntity> regsInSeason = registrationRepository
                .findByPlayerId(playerId).stream()
                .filter(this::isRegistrationInCurrentSeason)
                .toList();

        return matchRegistrationMapper.toDTOList(regsInSeason);
    }

    /**
     * VracĂ­ hrĂˇÄŤe, kteĹ™Ă­ na danĂ˝ zĂˇpas nijak nereagovali.
     *
     * Pokud zĂˇpas nepatĹ™Ă­ do aktuĂˇlnÄ› vybranĂ© sezĂłny, vracĂ­ se prĂˇzdnĂ˝ seznam.
     * PĹ™i vyhodnocovĂˇnĂ­ se pouĹľĂ­vĂˇ mnoĹľina hrĂˇÄŤĹŻ, kteĹ™Ă­ majĂ­ k zĂˇpasu uloĹľenou registraci v jakĂ©mkoliv stavu.
     *
     * @param matchId IdentifikĂˇtor zĂˇpasu, pro kterĂ˝ se hrĂˇÄŤi bez reakce vyhodnocujĂ­.
     * @return Seznam hrĂˇÄŤĹŻ bez reakce pĹ™evedenĂ˝ch do DTO v rĂˇmci aktuĂˇlnĂ­ sezĂłny.
     */
    @Override
    public List<PlayerDTO> getNoResponsePlayers(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);

        if (!isMatchInCurrentSeason(match)) {
            return List.of();
        }

        Set<Long> respondedIds = getRespondedPlayerIds(matchId);

        List<PlayerEntity> noResponsePlayers = playerRepository.findAll().stream()
                .filter(p -> !respondedIds.contains(p.getId()))
                .toList();

        return noResponsePlayers.stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    /**
     * PĹ™epoÄŤĂ­tĂˇvĂˇ stavy REGISTERED a RESERVED pro danĂ˝ zĂˇpas podle kapacity zĂˇpasu.
     *
     * Registrace se seĹ™adĂ­ podle ÄŤasu vytvoĹ™enĂ­ a prvnĂ­m hrĂˇÄŤĹŻm do vĂ˝Ĺˇe kapacity zĂˇpasu se nastavĂ­ stav REGISTERED.
     * OstatnĂ­m hrĂˇÄŤĹŻm se nastavĂ­ stav RESERVED. Registrace ve stavu SUBSTITUTE se do pĹ™epoÄŤtu nezahrnujĂ­.
     *
     * @param matchId IdentifikĂˇtor zĂˇpasu, pro kterĂ˝ se stavy pĹ™epoÄŤĂ­tĂˇvajĂ­.
     */
    @Override
    @Transactional
    public void recalcStatusesForMatch(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);
        int maxPlayers = match.getMaxPlayers();

        List<MatchRegistrationEntity> regs = registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED
                        || r.getStatus() == PlayerMatchStatus.RESERVED)
                .sorted((a, b) -> a.getTimestamp().compareTo(b.getTimestamp()))
                .toList();

        for (int i = 0; i < regs.size(); i++) {
            MatchRegistrationEntity reg = regs.get(i);
            PlayerMatchStatus newStatus =
                    (i < maxPlayers) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;

            if (reg.getStatus() != newStatus) {
                updateRegistrationStatus(reg, newStatus, "system", false);
            }
        }
    }

    // =========================
    // SMS â€“ HROMADNĂ‰ ODESĂŤLĂNĂŤ
    // =========================

    /**
     * OdesĂ­lĂˇ SMS vĹˇem hrĂˇÄŤĹŻm registrovanĂ˝m na danĂ˝ zĂˇpas ve stavu REGISTERED, kteĹ™Ă­ majĂ­ povolenĂ© SMS notifikace.
     *
     * Z registracĂ­ se naÄŤtou hrĂˇÄŤi a vyhodnotĂ­ se jejich nastavenĂ­ notifikacĂ­. Pokud je SMS notifikace povolena,
     * sestavĂ­ se text zprĂˇvy a provede se odeslĂˇnĂ­ pĹ™es SmsService.
     *
     * @param matchId IdentifikĂˇtor zĂˇpasu, pro kterĂ˝ se SMS zprĂˇvy odesĂ­lajĂ­.
     */
    @Transactional
    public void sendSmsToRegisteredPlayers(Long matchId) {
        registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .forEach(r -> {
                    PlayerEntity player = r.getPlayer();
                    if (player == null) {
                        return;
                    }

                    var settings = player.getSettings();
                    if (settings == null || !settings.isSmsEnabled()) {
                        return;
                    }

                    sendSms(r, smsMessageBuilder.buildMessageFinal(r));
                });
    }

    /**
     * ProvĂˇdĂ­ administrĂˇtorskou zmÄ›nu stavu registrace.
     *
     * PĹ™ed zmÄ›nou se ovÄ›Ĺ™Ă­ existence zĂˇpasu, hrĂˇÄŤe i registrace. Stav NO_EXCUSED se touto metodou nenastavuje,
     * protoĹľe pro tento stav se pouĹľĂ­vĂˇ samostatnĂˇ operace s vlastnĂ­ business logikou.
     *
     * @param matchId IdentifikĂˇtor zĂˇpasu, pro kterĂ˝ se stav upravuje.
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, jehoĹľ registrace se upravuje.
     * @param status CĂ­lovĂ˝ stav registrace, kterĂ˝ se mĂˇ nastavit.
     * @return DTO aktualizovanĂ© registrace po zmÄ›nÄ› stavu.
     */
    @Override
    @Transactional
    public MatchRegistrationDTO updateStatus(Long matchId, Long playerId, PlayerMatchStatus status) {

        getMatchOrThrow(matchId);
        getPlayerOrThrow(playerId);

        if (status == PlayerMatchStatus.NO_EXCUSED) {
            throw new InvalidPlayerStatusException(
                    "BE - Status NO_EXCUSED musĂ­ bĂ˝t nastaven pĹ™es speciĂˇlnĂ­ endpoint / logiku."
            );
        }

        MatchRegistrationEntity registration = getRegistrationOrThrow(playerId, matchId);

        MatchRegistrationEntity updated =
                updateRegistrationStatus(registration, status, "admin", true);

        return matchRegistrationMapper.toDTO(updated);
    }

    // ====================================================
    // PRIVĂTNĂŤ HELPERY â€“ NAÄŚĂŤTĂNĂŤ ENTIT A ZĂKLADNĂŤ LOGIKA
    // ====================================================

    /**
     * Deleguje odeslĂˇnĂ­ notifikace hrĂˇÄŤi do NotificationService.
     *
     * Metoda se pouĹľĂ­vĂˇ pro centralizaci volĂˇnĂ­ notifikaÄŤnĂ­ sluĹľby a pĹ™edĂˇnĂ­ kontextu,
     * kterĂ˝ se pouĹľije pĹ™i sestavenĂ­ obsahu notifikace.
     *
     * @param player HrĂˇÄŤ, kterĂ©mu se notifikace odesĂ­lĂˇ.
     * @param type Typ notifikace urÄŤujĂ­cĂ­ Ĺˇablonu a vĂ˝znam zprĂˇvy.
     * @param context Kontext notifikace, kterĂ˝ se pĹ™edĂˇvĂˇ do notifikaÄŤnĂ­ vrstvy.
     */
    private void notifyPlayer(PlayerEntity player, NotificationType type, Object context) {
        notificationService.notifyPlayer(player, type, context);
    }

    /**
     * VracĂ­ mnoĹľinu identifikĂˇtorĹŻ hrĂˇÄŤĹŻ, kteĹ™Ă­ majĂ­ k zĂˇpasu uloĹľenou registraci v jakĂ©mkoliv stavu.
     *
     * @param matchId IdentifikĂˇtor zĂˇpasu, pro kterĂ˝ se ID hrĂˇÄŤĹŻ naÄŤĂ­tajĂ­.
     * @return MnoĹľina identifikĂˇtorĹŻ hrĂˇÄŤĹŻ, kteĹ™Ă­ na zĂˇpas reagovali vytvoĹ™enĂ­m registrace.
     */
    private Set<Long> getRespondedPlayerIds(Long matchId) {
        return registrationRepository.findByMatchId(matchId).stream()
                .map(r -> r.getPlayer().getId())
                .collect(Collectors.toSet());
    }

    /**
     * NaÄŤĂ­tĂˇ zĂˇpas podle identifikĂˇtoru nebo vyhazuje vĂ˝jimku pĹ™i neexistenci.
     *
     * @param matchId IdentifikĂˇtor zĂˇpasu.
     * @return NaÄŤtenĂˇ entita zĂˇpasu.
     */
    private MatchEntity getMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }

    /**
     * NaÄŤĂ­tĂˇ hrĂˇÄŤe podle identifikĂˇtoru nebo vyhazuje vĂ˝jimku pĹ™i neexistenci.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe.
     * @return NaÄŤtenĂˇ entita hrĂˇÄŤe.
     */
    private PlayerEntity getPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    /**
     * NaÄŤĂ­tĂˇ registraci hrĂˇÄŤe na zĂˇpas, pokud existuje.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe.
     * @param matchId IdentifikĂˇtor zĂˇpasu.
     * @return Entita registrace, nebo null pokud registrace neexistuje.
     */
    private MatchRegistrationEntity getRegistrationOrNull(Long playerId, Long matchId) {
        return registrationRepository
                .findByPlayerIdAndMatchId(playerId, matchId)
                .orElse(null);
    }

    /**
     * NaÄŤĂ­tĂˇ registraci hrĂˇÄŤe na zĂˇpas nebo vyhazuje vĂ˝jimku pĹ™i neexistenci.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe.
     * @param matchId IdentifikĂˇtor zĂˇpasu.
     * @return NaÄŤtenĂˇ entita registrace.
     */
    private MatchRegistrationEntity getRegistrationOrThrow(Long playerId, Long matchId) {
        return registrationRepository
                .findByPlayerIdAndMatchId(playerId, matchId)
                .orElseThrow(() -> new RegistrationNotFoundException(matchId, playerId));
    }

    /**
     * Vyhodnocuje, zda je v zĂˇpase dostupnĂ© mĂ­sto pro registraci ve stavu REGISTERED.
     *
     * @param match ZĂˇpas, pro kterĂ˝ se dostupnost mĂ­sta vyhodnocuje.
     * @return True, pokud poÄŤet registrovanĂ˝ch hrĂˇÄŤĹŻ nedosahuje kapacity zĂˇpasu, jinak false.
     */
    private boolean isSlotAvailable(MatchEntity match) {
        long registeredCount = registrationRepository
                .countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);
        return registeredCount < match.getMaxPlayers();
    }

    /**
     * OdesĂ­lĂˇ SMS zprĂˇvu hrĂˇÄŤi navĂˇzanĂ©mu na registraci, pokud je k dispozici telefonnĂ­ ÄŤĂ­slo.
     *
     * Pokud registrace nebo hrĂˇÄŤ neexistujĂ­, metoda se ukonÄŤĂ­ bez provedenĂ­. TelefonnĂ­ ÄŤĂ­slo se vyhodnocuje
     * primĂˇrnÄ› z nastavenĂ­ hrĂˇÄŤe a sekundĂˇrnÄ› z hodnoty uloĹľenĂ© na hrĂˇÄŤi. PĹ™Ă­padnĂ© chyby pĹ™i odesĂ­lĂˇnĂ­ se pouze zalogujĂ­.
     *
     * @param registration Registrace, pro kterou se zprĂˇva odesĂ­lĂˇ.
     * @param message Text SMS zprĂˇvy.
     */
    private void sendSms(MatchRegistrationEntity registration, String message) {
        if (registration == null || registration.getPlayer() == null) {
            return;
        }

        PlayerEntity player = registration.getPlayer();
        var settings = player.getSettings();

        String phone = null;
        if (settings != null && settings.getContactPhone() != null && !settings.getContactPhone().isBlank()) {
            phone = settings.getContactPhone();
        } else if (player.getPhoneNumber() != null && !player.getPhoneNumber().isBlank()) {
            phone = player.getPhoneNumber();
        }

        if (phone == null || phone.isBlank()) {
            log.debug("sendSms: hrĂˇÄŤ {} nemĂˇ ĹľĂˇdnĂ© telefonnĂ­ ÄŤĂ­slo â€“ SMS se nepoĹˇle", player.getId());
            return;
        }

        try {
            smsService.sendSms(phone, message);
        } catch (Exception e) {
            log.error(
                    "Chyba pĹ™i odesĂ­lĂˇnĂ­ SMS pro registraci {}: {}",
                    registration.getId(),
                    e.getMessage(),
                    e
            );
        }
    }

    /**
     * Aktualizuje stav registrace a uklĂˇdĂˇ zmÄ›nu do databĂˇze.
     *
     * V rĂˇmci zmÄ›ny se nastavĂ­ novĂ˝ stav, identifikace pĹŻvodce zmÄ›ny a volitelnÄ› se aktualizuje ÄŤas zmÄ›ny.
     * ZĂˇpis se provĂˇdĂ­ pĹ™es repository vrstvu s okamĹľitĂ˝m flush pro zajiĹˇtÄ›nĂ­ konzistence nĂˇslednĂ˝ch operacĂ­.
     *
     * @param registration Registrace, kterĂˇ se mĂˇ aktualizovat.
     * @param status CĂ­lovĂ˝ stav registrace.
     * @param updatedBy Identifikace pĹŻvodce zmÄ›ny.
     * @param updateTimestamp PĹ™Ă­znak urÄŤujĂ­cĂ­, zda se mĂˇ nastavit aktuĂˇlnĂ­ ÄŤas zmÄ›ny.
     * @return UloĹľenĂˇ entita registrace po zmÄ›nÄ› stavu.
     */
    private MatchRegistrationEntity updateRegistrationStatus(
            MatchRegistrationEntity registration,
            PlayerMatchStatus status,
            String updatedBy,
            boolean updateTimestamp
    ) {
        registration.setStatus(status);
        registration.setCreatedBy(updatedBy);
        if (updateTimestamp) {
            registration.setTimestamp(LocalDateTime.now());
        }
        return registrationRepository.saveAndFlush(registration);
    }

    /**
     * Mapuje stav registrace na typ notifikace.
     *
     * Pokud se pro danĂ˝ stav notifikace neodesĂ­lĂˇ, vracĂ­ se null.
     *
     * @param newStatus Stav registrace, pro kterĂ˝ se typ notifikace vyhodnocuje.
     * @return Typ notifikace odpovĂ­dajĂ­cĂ­ stavu, nebo null pokud se notifikace neposĂ­lĂˇ.
     */
    private NotificationType resolveNotificationType(PlayerMatchStatus newStatus) {
        return switch (newStatus) {
            case REGISTERED -> NotificationType.MATCH_REGISTRATION_CREATED;
            case UNREGISTERED -> NotificationType.MATCH_REGISTRATION_CANCELED;
            case EXCUSED -> NotificationType.PLAYER_EXCUSED;
            case RESERVED -> NotificationType.MATCH_REGISTRATION_RESERVED;
            case NO_RESPONSE -> NotificationType.MATCH_REGISTRATION_NO_RESPONSE;
            case SUBSTITUTE -> NotificationType.MATCH_REGISTRATION_SUBSTITUTE;
            case NO_EXCUSED -> NotificationType.PLAYER_NO_EXCUSED;
            default -> null;
        };
    }

    /**
     * VracĂ­ aktuĂˇlnĂ­ ÄŤas.
     *
     * Metoda se pouĹľĂ­vĂˇ pro sjednocenĂ­ pĹ™Ă­stupu k ÄŤasu a pro usnadnÄ›nĂ­ testovĂˇnĂ­.
     *
     * @return AktuĂˇlnĂ­ ÄŤas jako LocalDateTime.
     */
    private LocalDateTime now() {
        return LocalDateTime.now();
    }

    /**
     * OvÄ›Ĺ™uje, Ĺľe zĂˇpas patĹ™Ă­ do aktivnĂ­ sezĂłny.
     *
     * Kontrola se pouĹľĂ­vĂˇ pĹ™ed zĂˇpisem registrace, aby se zabrĂˇnilo zmÄ›nĂˇm v neaktivnĂ­ch sezĂłnĂˇch.
     *
     * @param match ZĂˇpas, kterĂ˝ se mĂˇ ovÄ›Ĺ™it.
     */
    private void assertMatchInActiveSeason(MatchEntity match) {
        if (match.getSeason() == null || !match.getSeason().isActive()) {
            throw new InvalidSeasonStateException(
                    "BE - Registrace lze mÄ›nit pouze u zĂˇpasĹŻ v aktivnĂ­ sezĂłnÄ›."
            );
        }
    }

    /**
     * OvÄ›Ĺ™uje, zda aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ˝ uĹľivatel mĹŻĹľe mÄ›nit registraci na danĂ˝ zĂˇpas.
     *
     * UĹľivatel s rolĂ­ ADMIN nebo MANAGER nenĂ­ ÄŤasovÄ› omezen. UĹľivatel s rolĂ­ PLAYER mĹŻĹľe registraci mÄ›nit pouze
     * v definovanĂ©m ÄŤasovĂ©m oknÄ› po zaÄŤĂˇtku zĂˇpasu. PĹ™i poruĹˇenĂ­ pravidel se vyhazuje vĂ˝jimka signalizujĂ­cĂ­
     * nepovolenou zmÄ›nu.
     *
     * @param match ZĂˇpas, pro kterĂ˝ se oprĂˇvnÄ›nĂ­ vyhodnocuje.
     */
    private void assertPlayerCanModifyMatch(MatchEntity match) {
        if (!isCurrentUserPlayer()) {
            return;
        }

        if (!isMatchEditableForPlayer(match)) {
            throw new InvalidPlayerStatusException(
                    "BE - Jako hrĂˇÄŤ mĹŻĹľeĹˇ mÄ›nit registraci pouze do 30 minut po zaÄŤĂˇtku zĂˇpasu."
            );
        }
    }

    /**
     * Vyhodnocuje, zda je zĂˇpas v ÄŤasovĂ©m oknÄ›, ve kterĂ©m mĹŻĹľe hrĂˇÄŤ mÄ›nit registraci.
     *
     * ZĂˇpas se povaĹľuje za editovatelnĂ˝ pro hrĂˇÄŤe do tĹ™iceti minut po zaÄŤĂˇtku zĂˇpasu.
     *
     * @param match ZĂˇpas, ke kterĂ©mu se editovatelnost vyhodnocuje.
     * @return True, pokud je zmÄ›na registrace jeĹˇtÄ› povolena, jinak false.
     */
    private boolean isMatchEditableForPlayer(MatchEntity match) {
        LocalDateTime editLimit = match.getDateTime().plusMinutes(30);
        return now().isBefore(editLimit);
    }

    /**
     * Vyhodnocuje, zda mĂˇ aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ˝ uĹľivatel roli ROLE_PLAYER.
     *
     * Metoda se pouĹľĂ­vĂˇ pro aplikaci ÄŤasovĂ©ho omezenĂ­, kterĂ© se vztahuje pouze na hrĂˇÄŤe.
     *
     * @return True, pokud mĂˇ uĹľivatel roli ROLE_PLAYER, jinak false.
     */
    private boolean isCurrentUserPlayer() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth == null) {
            return false;
        }

        return auth.getAuthorities().stream()
                .anyMatch(a -> "ROLE_PLAYER".equals(a.getAuthority()));
    }

    // ======================================
    // SEASON â€“ POMOCNĂ‰ METODY PRO CURRENT SEASON
    // ======================================

    /**
     * Vyhodnocuje, zda zĂˇpas patĹ™Ă­ do aktuĂˇlnÄ› vybranĂ© sezĂłny.
     *
     * PorovnĂˇvĂˇ se identifikĂˇtor sezĂłny zĂˇpasu s identifikĂˇtorem sezĂłny vrĂˇcenĂ˝m metodou getCurrentSeasonIdOrActive.
     *
     * @param match ZĂˇpas, kterĂ˝ se mĂˇ vyhodnotit.
     * @return True, pokud zĂˇpas patĹ™Ă­ do aktuĂˇlnĂ­ sezĂłny, jinak false.
     */
    private boolean isMatchInCurrentSeason(MatchEntity match) {
        if (match == null || match.getSeason() == null) {
            return false;
        }
        Long seasonId = getCurrentSeasonIdOrActive();
        return seasonId.equals(match.getSeason().getId());
    }

    /**
     * Vyhodnocuje, zda registrace patĹ™Ă­ k zĂˇpasu v aktuĂˇlnÄ› vybranĂ© sezĂłnÄ›.
     *
     * @param registration Registrace, kterĂˇ se mĂˇ vyhodnotit.
     * @return True, pokud registrace patĹ™Ă­ do aktuĂˇlnĂ­ sezĂłny, jinak false.
     */
    private boolean isRegistrationInCurrentSeason(MatchRegistrationEntity registration) {
        if (registration == null) {
            return false;
        }
        return isMatchInCurrentSeason(registration.getMatch());
    }

    /**
     * VracĂ­ identifikĂˇtor sezĂłny pouĹľĂ­vanĂ© pro filtrovĂˇnĂ­ registracĂ­.
     *
     * PrimĂˇrnÄ› se pouĹľĂ­vĂˇ sezĂłna uloĹľenĂˇ v CurrentSeasonService. Pokud nenĂ­ k dispozici, pouĹľije se
     * globĂˇlnÄ› aktivnĂ­ sezĂłna zĂ­skanĂˇ ze SeasonService.
     *
     * @return IdentifikĂˇtor aktuĂˇlnĂ­ nebo aktivnĂ­ sezĂłny.
     */
    private Long getCurrentSeasonIdOrActive() {
        Long id = currentSeasonService.getCurrentSeasonIdOrDefault();
        if (id != null) {
            return id;
        }
        return seasonService.getActiveSeason().getId();
    }

}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.enums.MatchCancelReason;
import cz.phsoft.hokej.models.dto.*;

import java.util.List;

/**
 * RozhranĂ­ se pouĹľĂ­vĂˇ pro sprĂˇvu zĂˇpasĹŻ v aplikaci.
 *
 * Definuje kontrakt pro prĂˇci se zĂˇpasy z pohledu business logiky.
 * ZajiĹˇĹĄuje vytvĂˇĹ™enĂ­, Ăşpravy, mazĂˇnĂ­ zĂˇpasĹŻ, zĂ­skĂˇvĂˇnĂ­ pĹ™ehledĹŻ
 * a prĂˇci s dostupnostĂ­ zĂˇpasĹŻ pro konkrĂ©tnĂ­ho hrĂˇÄŤe.
 *
 * RozhranĂ­ je navrĹľeno tak, aby oddÄ›lovalo business logiku
 * od persistence vrstvy a poskytovalo jednotnĂ˝ vstupnĂ­ bod
 * pro controllery a napĹ™. plĂˇnovaÄŤe (scheduler).
 */
public interface MatchService {

    /**
     * VrĂˇtĂ­ seznam vĹˇech zĂˇpasĹŻ v systĂ©mu.
     *
     * Metoda se typicky pouĹľĂ­vĂˇ pro administrĂˇtorskĂ© pĹ™ehledy
     * nebo pro globĂˇlnĂ­ seznam zĂˇpasĹŻ v rĂˇmci vybranĂ© sezĂłny.
     *
     * @return seznam vĹˇech zĂˇpasĹŻ ve formÄ› {@link MatchDTO}
     */
    List<MatchDTO> getAllMatches();

    /**
     * VrĂˇtĂ­ seznam vĹˇech nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ.
     *
     * Za nadchĂˇzejĂ­cĂ­ zĂˇpasy se povaĹľujĂ­ ty, kterĂ© majĂ­
     * datum a ÄŤas v budoucnosti podle internÄ› zvolenĂ˝ch pravidel.
     *
     * @return seznam nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ
     */
    List<MatchDTO> getUpcomingMatches();

    /**
     * VrĂˇtĂ­ seznam vĹˇech jiĹľ odehranĂ˝ch zĂˇpasĹŻ.
     *
     * ZĂˇpasy jsou obvykle Ĺ™azenĂ© od nejnovÄ›jĹˇĂ­ho po nejstarĹˇĂ­.
     *
     * @return seznam minulĂ˝ch zĂˇpasĹŻ
     */
    List<MatchDTO> getPastMatches();

    /**
     * VrĂˇtĂ­ nejbliĹľĹˇĂ­ nadchĂˇzejĂ­cĂ­ zĂˇpas.
     *
     * Metoda se pouĹľĂ­vĂˇ napĹ™Ă­klad pro zobrazenĂ­
     * â€ždalĹˇĂ­ho zĂˇpasuâ€ś na dashboardu nebo
     * pro potĹ™eby notifikacĂ­.
     *
     * @return nejbliĹľĹˇĂ­ nadchĂˇzejĂ­cĂ­ zĂˇpas nebo {@code null},
     * pokud ĹľĂˇdnĂ˝ neexistuje
     */
    MatchDTO getNextMatch();

    /**
     * VrĂˇtĂ­ zĂˇkladnĂ­ informace o zĂˇpasu podle jeho ID.
     *
     * @param id ID zĂˇpasu
     * @return zĂˇpas ve formÄ› {@link MatchDTO}
     */
    MatchDTO getMatchById(Long id);

    /**
     * VytvoĹ™Ă­ novĂ˝ zĂˇpas.
     *
     * Metoda je typicky dostupnĂˇ pouze pro administrĂˇtory
     * nebo manaĹľery. Implementace zajiĹˇĹĄuje validaci
     * data v rĂˇmci aktivnĂ­ sezĂłny a pĹ™iĹ™azenĂ­ sezĂłny k zĂˇpasu.
     *
     * @param dto data novĂ©ho zĂˇpasu
     * @return vytvoĹ™enĂ˝ zĂˇpas
     */
    MatchDTO createMatch(MatchDTO dto);

    /**
     * Aktualizuje existujĂ­cĂ­ zĂˇpas.
     *
     * Implementace je odpovÄ›dnĂˇ za naÄŤtenĂ­ stĂˇvajĂ­cĂ­ho zĂˇpasu,
     * pĹ™enesenĂ­ zmÄ›n z DTO, validaci a uloĹľenĂ­ vĂ˝slednĂ©ho stavu.
     *
     * @param id  ID zĂˇpasu, kterĂ˝ mĂˇ bĂ˝t upraven
     * @param dto novĂ© hodnoty pro zĂˇpas
     * @return aktualizovanĂ˝ zĂˇpas
     */
    MatchDTO updateMatch(Long id, MatchDTO dto);

    /**
     * SmaĹľe zĂˇpas podle ID.
     *
     * Metoda typicky vracĂ­ standardizovanou odpovÄ›ÄŹ
     * s informacĂ­ o ĂşspÄ›chu operace.
     *
     * @param id ID zĂˇpasu, kterĂ˝ mĂˇ bĂ˝t smazĂˇn
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     */
    SuccessResponseDTO deleteMatch(Long id);

    /**
     * VrĂˇtĂ­ detailnĂ­ informace o zĂˇpasu.
     *
     * Oproti metodÄ› {@link #getMatchById(Long)} mĹŻĹľe detail
     * obsahovat rozĹˇĂ­Ĺ™enĂˇ data, napĹ™Ă­klad statistiky,
     * seznamy hrĂˇÄŤĹŻ v jednotlivĂ˝ch stavech nebo agregovanĂ© Ăşdaje.
     *
     * @param id ID zĂˇpasu
     * @return detail zĂˇpasu
     */
    MatchDetailDTO getMatchDetail(Long id);

    /**
     * VrĂˇtĂ­ seznam zĂˇpasĹŻ, na kterĂ© se danĂ˝ hrĂˇÄŤ mĹŻĹľe registrovat.
     *
     * Implementace obvykle filtruje pouze nadchĂˇzejĂ­cĂ­ zĂˇpasy,
     * kontroluje kapacitu a respektuje pravidla sezĂłny
     * a pĹ™Ă­padnĂˇ dalĹˇĂ­ business omezenĂ­.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return seznam dostupnĂ˝ch zĂˇpasĹŻ pro hrĂˇÄŤe
     */
    List<MatchDTO> getAvailableMatchesForPlayer(Long playerId);

    /**
     * VrĂˇtĂ­ nadchĂˇzejĂ­cĂ­ zĂˇpasy pro konkrĂ©tnĂ­ho hrĂˇÄŤe.
     *
     * Metoda mĹŻĹľe zohledĹovat, zda je hrĂˇÄŤ registrovanĂ˝,
     * pĹ™Ă­padnÄ› dalĹˇĂ­ business pravidla. VĂ˝sledek je
     * urÄŤen pro podrobnÄ›jĹˇĂ­ zobrazenĂ­ seznamu zĂˇpasĹŻ.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return seznam nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ pro danĂ©ho hrĂˇÄŤe
     */
    List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId);

    /**
     * Najde ID hrĂˇÄŤe podle e-mailu uĹľivatele.
     *
     * Metoda se pouĹľĂ­vĂˇ jako pomocnĂ˝ nĂˇstroj v situaci,
     * kdy je k dispozici e-mail pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * a je potĹ™eba zjistit navĂˇzanĂ©ho hrĂˇÄŤe.
     *
     * @param email e-mail uĹľivatele
     * @return ID hrĂˇÄŤe nebo {@code null}, pokud neexistuje
     */
    Long getPlayerIdByEmail(String email);

    /**
     * VrĂˇtĂ­ pĹ™ehled nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ pro hrĂˇÄŤe.
     *
     * PĹ™ehled slouĹľĂ­ pro zobrazenĂ­ na dashboardu
     * nebo v jednoduchĂ˝ch seznamech, kde se zobrazujĂ­
     * zĂˇkladnĂ­ informace o zĂˇpasech vÄŤetnÄ› stavu
     * danĂ©ho hrĂˇÄŤe.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return pĹ™ehled nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ pro danĂ©ho hrĂˇÄŤe
     */
    List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId);

    /**
     * VrĂˇtĂ­ pĹ™ehled vĹˇech odehranĂ˝ch zĂˇpasĹŻ pro hrĂˇÄŤe.
     *
     * Metoda se pouĹľĂ­vĂˇ pro statistiky, historii ĂşÄŤasti
     * a pĹ™ehled minulĂ˝ch zĂˇpasĹŻ danĂ©ho hrĂˇÄŤe v rĂˇmci sezĂłny.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return pĹ™ehled vĹˇech odehranĂ˝ch zĂˇpasĹŻ pro danĂ©ho hrĂˇÄŤe
     */
    List<MatchOverviewDTO> getAllPassedMatchesForPlayer(Long playerId);

    /**
     * ZruĹˇĂ­ zĂˇpas a nastavĂ­ dĹŻvod zruĹˇenĂ­.
     *
     * ZĂˇpas je oznaÄŤen jako zruĹˇenĂ˝ vÄŤetnÄ› uvedenĂ©ho dĹŻvodu.
     * Implementace mĹŻĹľe navazovat dalĹˇĂ­ logiku, napĹ™Ă­klad
     * odeslĂˇnĂ­ notifikacĂ­ hrĂˇÄŤĹŻm.
     *
     * @param matchId ID zĂˇpasu
     * @param reason  dĹŻvod zruĹˇenĂ­
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     */
    SuccessResponseDTO cancelMatch(Long matchId, MatchCancelReason reason);

    /**
     * ObnovĂ­ dĹ™Ă­ve zruĹˇenĂ˝ zĂˇpas.
     *
     * ZĂˇpas se vracĂ­ do stavu, kdy je opÄ›t platnĂ˝ a mĹŻĹľe se konat,
     * pokud jsou splnÄ›ny ostatnĂ­ podmĂ­nky (datum, kapacita a podobnÄ›).
     *
     * @param matchId ID zĂˇpasu
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     */
    SuccessResponseDTO unCancelMatch(Long matchId);

}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.*;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.models.dto.*;
import cz.phsoft.hokej.models.mappers.MatchMapper;
import cz.phsoft.hokej.models.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.notification.NotificationService;
import cz.phsoft.hokej.models.services.notification.MatchTimeChangeContext;
import jakarta.transaction.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import cz.phsoft.hokej.data.entities.AppUserEntity;

import java.time.LocalDateTime;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

//TODO KOMENTĂĹE - PROSTĂ‰
/**
 * Implementace service vrstvy, kterĂˇ se pouĹľĂ­vĂˇ pro prĂˇci se zĂˇpasy.
 *
 * V tĂ©to tĹ™Ă­dÄ› se zajiĹˇĹĄujĂ­ CRUD operace nad zĂˇpasy v rĂˇmci sezĂłn, filtrovĂˇnĂ­ nadchĂˇzejĂ­cĂ­ch a probÄ›hlĂ˝ch zĂˇpasĹŻ,
 * sestavenĂ­ detailu zĂˇpasu vÄŤetnÄ› agregovanĂ˝ch statistik a zpracovĂˇnĂ­ zmÄ›n stavu zĂˇpasu, jako je zruĹˇenĂ­ nebo obnova.
 *
 * SouÄŤĂˇstĂ­ odpovÄ›dnosti je takĂ© doplnÄ›nĂ­ ÄŤĂ­slovĂˇnĂ­ zĂˇpasĹŻ v sezĂłnÄ› a spouĹˇtÄ›nĂ­ notifikacĂ­ hrĂˇÄŤĹŻm pĹ™i vybranĂ˝ch zmÄ›nĂˇch,
 * zejmĂ©na pĹ™i zmÄ›nÄ› termĂ­nu, zruĹˇenĂ­ nebo obnovenĂ­ zĂˇpasu. Notifikace se delegujĂ­ do {@link NotificationService}.
 *
 * TĹ™Ă­da neĹ™eĹˇĂ­ detailnĂ­ stavovĂ© pĹ™echody registracĂ­ hrĂˇÄŤĹŻ na zĂˇpasy, kterĂ© jsou spravovĂˇny v {@link MatchRegistrationService}.
 * VĂ˝bÄ›r aktuĂˇlnĂ­ho hrĂˇÄŤe se zajiĹˇĹĄuje ve {@link CurrentPlayerService} a v controller vrstvÄ›.
 */
@Service
public class MatchServiceImpl implements MatchService {

    @Value("${app.demo-mode:false}")
    private boolean isDemoMode;

    private static final Logger logger = LoggerFactory.getLogger(MatchServiceImpl.class);

    private static final String ROLE_ADMIN = "ROLE_ADMIN";
    private static final String ROLE_MANAGER = "ROLE_MANAGER";

    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository matchRegistrationRepository;
    private final MatchMapper matchMapper;
    private final MatchRegistrationService registrationService;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodService playerInactivityPeriodService;
    private final PlayerMapper playerMapper;
    private final CurrentPlayerService currentPlayerService;
    private final SeasonService seasonService;
    private final CurrentSeasonService currentSeasonService;
    private final NotificationService notificationService;
    private final AppUserRepository appUserRepository;

    public MatchServiceImpl(MatchRepository matchRepository,
                            MatchRegistrationRepository matchRegistrationRepository,
                            MatchMapper matchMapper,
                            MatchRegistrationService registrationService,
                            PlayerRepository playerRepository,
                            PlayerInactivityPeriodService playerInactivityPeriodService,
                            PlayerMapper playerMapper,
                            CurrentPlayerService currentPlayerService,
                            SeasonService seasonService,
                            CurrentSeasonService currentSeasonService,
                            NotificationService notificationService,
                            AppUserRepository appUserRepository) {
        this.matchRepository = matchRepository;
        this.matchRegistrationRepository = matchRegistrationRepository;
        this.matchMapper = matchMapper;
        this.registrationService = registrationService;
        this.playerRepository = playerRepository;
        this.playerInactivityPeriodService = playerInactivityPeriodService;
        this.playerMapper = playerMapper;
        this.currentPlayerService = currentPlayerService;
        this.seasonService = seasonService;
        this.currentSeasonService = currentSeasonService;
        this.notificationService = notificationService;
        this.appUserRepository = appUserRepository;
    }

    // ======================
    // ZĂKLADNĂŤ SEZNAMY ZĂPASĹ®
    // ======================

    /**
     * VracĂ­ vĹˇechny zĂˇpasy v rĂˇmci aktuĂˇlnÄ› pouĹľĂ­vanĂ© sezĂłny.
     *
     * ZĂˇpasy se naÄŤĂ­tajĂ­ z repository vrstvy, seĹ™adĂ­ se podle data a ÄŤasu vzestupnÄ› a nĂˇslednÄ› se doplnĂ­ poĹ™adovĂ© ÄŤĂ­slo
     * zĂˇpasu v sezĂłnÄ›. MapovĂˇnĂ­ entit na DTO se deleguje do {@link MatchMapper}.
     *
     * @return Seznam zĂˇpasĹŻ aktuĂˇlnĂ­ sezĂłny pĹ™evedenĂ˝ch do DTO vÄŤetnÄ› poĹ™adovĂ©ho ÄŤĂ­sla.
     */
    @Override
    public List<MatchDTO> getAllMatches() {
        Long seasonId = getCurrentSeasonIdOrActive();
        List<MatchEntity> matches =
                matchRepository.findAllBySeasonIdOrderByDateTimeAsc(seasonId);

        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);
        return assignMatchNumbers(matches, matchMapper::toDTO, matchNumberMap);
    }

    /**
     * VracĂ­ vĹˇechny nadchĂˇzejĂ­cĂ­ zĂˇpasy v aktuĂˇlnĂ­ sezĂłnÄ›.
     *
     * ZĂˇpasy se filtrujĂ­ na zĂˇkladÄ› data a ÄŤasu vÄ›tĹˇĂ­ho neĹľ aktuĂˇlnĂ­ okamĹľik, seĹ™adĂ­ se podle data vzestupnÄ›
     * a doplnĂ­ se poĹ™adovĂ© ÄŤĂ­slo zĂˇpasu v sezĂłnÄ›.
     *
     * @return Seznam nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ pĹ™evedenĂ˝ch do DTO vÄŤetnÄ› poĹ™adovĂ©ho ÄŤĂ­sla.
     */
    @Override
    public List<MatchDTO> getUpcomingMatches() {
        Long seasonId = getCurrentSeasonIdOrActive();
        List<MatchEntity> upcomingMatches = findUpcomingMatchesForCurrentSeason();

        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);
        return assignMatchNumbers(upcomingMatches, matchMapper::toDTO, matchNumberMap);
    }

    /**
     * VracĂ­ vĹˇechny probÄ›hlĂ© zĂˇpasy v aktuĂˇlnĂ­ sezĂłnÄ›.
     *
     * ZĂˇpasy se filtrujĂ­ na zĂˇkladÄ› data a ÄŤasu menĹˇĂ­ho neĹľ aktuĂˇlnĂ­ okamĹľik, seĹ™adĂ­ se podle data sestupnÄ›
     * a doplnĂ­ se poĹ™adovĂ© ÄŤĂ­slo zĂˇpasu v sezĂłnÄ›.
     *
     * @return Seznam probÄ›hlĂ˝ch zĂˇpasĹŻ pĹ™evedenĂ˝ch do DTO vÄŤetnÄ› poĹ™adovĂ©ho ÄŤĂ­sla.
     */
    @Override
    public List<MatchDTO> getPastMatches() {
        Long seasonId = getCurrentSeasonIdOrActive();
        List<MatchEntity> pastMatches = findPastMatchesForCurrentSeason();

        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);
        return assignMatchNumbers(pastMatches, matchMapper::toDTO, matchNumberMap);
    }

    /**
     * VracĂ­ nejbliĹľĹˇĂ­ nadchĂˇzejĂ­cĂ­ zĂˇpas v aktuĂˇlnĂ­ sezĂłnÄ›.
     *
     * Pokud ĹľĂˇdnĂ˝ nadchĂˇzejĂ­cĂ­ zĂˇpas neexistuje, vracĂ­ se null.
     *
     * @return NejbliĹľĹˇĂ­ nadchĂˇzejĂ­cĂ­ zĂˇpas pĹ™evedenĂ˝ do DTO, nebo null pokud ĹľĂˇdnĂ˝ neexistuje.
     */
    @Override
    public MatchDTO getNextMatch() {
        return findUpcomingMatchesForCurrentSeason()
                .stream()
                .findFirst()
                .map(matchMapper::toDTO)
                .orElse(null);
    }

    /**
     * VracĂ­ zĂˇkladnĂ­ informace o zĂˇpasu podle identifikĂˇtoru.
     *
     * ZĂˇpas se naÄŤĂ­tĂˇ z repository vrstvy a mapuje se do DTO. PĹ™i neexistenci zĂˇpasu se vyhazuje
     * {@link MatchNotFoundException}.
     *
     * @param id IdentifikĂˇtor zĂˇpasu.
     * @return ZĂˇpas pĹ™evedenĂ˝ do {@link MatchDTO}.
     */
    @Override
    public MatchDTO getMatchById(Long id) {
        return matchMapper.toDTO(findMatchOrThrow(id));
    }

    /**
     * VytvĂˇĹ™Ă­ novĂ˝ zĂˇpas v aktivnĂ­ sezĂłnÄ›.
     *
     * DTO se mapuje na entitu, ovÄ›Ĺ™Ă­ se, Ĺľe datum zĂˇpasu spadĂˇ do obdobĂ­ aktivnĂ­ sezĂłny, a k zĂˇpasu se pĹ™iĹ™adĂ­
     * aktivnĂ­ sezĂłna. IdentifikĂˇtor autora vytvoĹ™enĂ­ a poslednĂ­ Ăşpravy se nastavĂ­ na aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele,
     * pokud je dostupnĂ˝. UloĹľenĂ­ se provĂˇdĂ­ pĹ™es repository vrstvu.
     *
     * @param dto DTO obsahujĂ­cĂ­ data vytvĂˇĹ™enĂ©ho zĂˇpasu.
     * @return VytvoĹ™enĂ˝ zĂˇpas pĹ™evedenĂ˝ do DTO.
     */
    @Override
    public MatchDTO createMatch(MatchDTO dto) {
        MatchEntity entity = matchMapper.toEntity(dto);
        validateMatchDateInActiveSeason(entity.getDateTime());

        entity.setSeason(seasonService.getActiveSeason());

        Long currentUserId = getCurrentUserIdOrNull();
        entity.setCreatedByUserId(currentUserId);
        entity.setLastModifiedByUserId(currentUserId);

        return matchMapper.toDTO(matchRepository.save(entity));
    }

    /**
     * Aktualizuje existujĂ­cĂ­ zĂˇpas podle identifikĂˇtoru.
     *
     * ZĂˇpas se naÄŤte z repository vrstvy a vyhodnotĂ­ se oprĂˇvnÄ›nĂ­ podle role uĹľivatele. UĹľivatel bez role ADMIN
     * nebo MANAGER mĹŻĹľe upravovat pouze zĂˇpasy patĹ™Ă­cĂ­ do aktivnĂ­ sezĂłny a souÄŤasnÄ› se ovÄ›Ĺ™uje, Ĺľe datum zĂˇpasu
     * zĹŻstĂˇvĂˇ v obdobĂ­ aktivnĂ­ sezĂłny. NĂˇslednÄ› se pĹ™enesou zmÄ›ny z DTO do entity a zĂˇpas se uloĹľĂ­.
     *
     * Pokud se zmÄ›nĂ­ kapacita zĂˇpasu, pĹ™epoÄŤĂ­tajĂ­ se stavy registracĂ­ pĹ™es {@link MatchRegistrationService}.
     * Pokud se zmÄ›nĂ­ termĂ­n zĂˇpasu, odeĹˇlou se notifikace o zmÄ›nÄ› termĂ­nu pĹ™es {@link NotificationService}.
     * PĹ™i zmÄ›nÄ› vybranĂ˝ch vlastnostĂ­ se nastavĂ­ stav zĂˇpasu na UPDATED.
     *
     * @param id IdentifikĂˇtor upravovanĂ©ho zĂˇpasu.
     * @param dto DTO obsahujĂ­cĂ­ novĂˇ data zĂˇpasu.
     * @return AktualizovanĂ˝ zĂˇpas pĹ™evedenĂ˝ do DTO.
     * @throws InvalidMatchStatusException Pokud uĹľivatel bez role ADMIN nebo MANAGER upravuje zĂˇpas mimo aktivnĂ­ sezĂłnu.
     * @throws InvalidMatchDateTimeException Pokud by po ĂşpravÄ› zĂˇpas spadl do minulosti.
     */
    @Override
    public MatchDTO updateMatch(Long id, MatchDTO dto) {
        MatchEntity entity = findMatchOrThrow(id);

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        boolean isAdminOrManager = hasAdminOrManagerRole(auth);

        if (!isAdminOrManager) {
            Long activeSeasonId = seasonService.getActiveSeason().getId();
            if (!entity.getSeason().getId().equals(activeSeasonId)) {
                throw new InvalidMatchStatusException(
                        id, " - ZĂˇpas nepatĹ™Ă­ do aktuĂˇlnĂ­ sezĂłny, nelze ho upravit."
                );
            }
        }

        Integer oldMaxPlayers = entity.getMaxPlayers();
        LocalDateTime oldDateTime = entity.getDateTime();
        String oldLocation = entity.getLocation();
        Integer oldPrice = entity.getPrice();

        matchMapper.updateEntity(dto, entity);

        Long currentUserId = getCurrentUserIdOrNull();
        entity.setLastModifiedByUserId(currentUserId);

        if (!isAdminOrManager) {
            validateMatchDateInActiveSeason(entity.getDateTime());
        }

        if (entity.getDateTime() != null
                && entity.getDateTime().isBefore(LocalDateTime.now())) {
            throw new InvalidMatchDateTimeException("ZĂˇpas by jiĹľ byl minulostĂ­");
        }

        boolean maxPlayersChanged =
                !java.util.Objects.equals(entity.getMaxPlayers(), oldMaxPlayers);

        boolean dateTimeChanged =
                !java.util.Objects.equals(entity.getDateTime(), oldDateTime);

        boolean locationChanged =
                !java.util.Objects.equals(entity.getLocation(), oldLocation);

        boolean priceChanged =
                !java.util.Objects.equals(entity.getPrice(), oldPrice);

        if (maxPlayersChanged || dateTimeChanged || locationChanged || priceChanged) {
            entity.setMatchStatus(MatchStatus.UPDATED);
        }

        MatchEntity saved = matchRepository.save(entity);

        if (maxPlayersChanged) {
            registrationService.recalcStatusesForMatch(saved.getId());
        }

        if (dateTimeChanged) {
            MatchTimeChangeContext ctx = new MatchTimeChangeContext(saved, oldDateTime);
            notifyPlayersAboutMatchChanges(ctx, MatchStatus.UPDATED);
        }

        return matchMapper.toDTO(saved);
    }

    /**
     * OdstraĹuje zĂˇpas podle identifikĂˇtoru.
     *
     * ZĂˇpas se naÄŤĂ­tĂˇ z repository vrstvy a pĹ™i neexistenci se vyhazuje {@link MatchNotFoundException}.
     * V demo reĹľimu se operace blokuje a vyhazuje se {@link DemoModeOperationNotAllowedException}.
     * PĹ™i ĂşspÄ›ĹˇnĂ©m odstranÄ›nĂ­ se vracĂ­ standardizovanĂˇ odpovÄ›ÄŹ s potvrzenĂ­m a ÄŤasovou znĂˇmkou.
     *
     * @param id IdentifikĂˇtor odstraĹovanĂ©ho zĂˇpasu.
     * @return StandardizovanĂˇ odpovÄ›ÄŹ o ĂşspÄ›ĹˇnĂ©m odstranÄ›nĂ­.
     */
    @Override
    public SuccessResponseDTO deleteMatch(Long id) {
        MatchEntity match = findMatchOrThrow(id);

        if (isDemoMode) {
            throw new DemoModeOperationNotAllowedException(
                    "ZĂˇpas nebude odstranÄ›n. Aplikace bÄ›ĹľĂ­ v DEMO reĹľimu."
            );
        }

        matchRepository.delete(match);

        return new SuccessResponseDTO(
                "BE - ZĂˇpas " + match.getId() + match.getDateTime() + " byl ĂşspÄ›ĹˇnÄ› smazĂˇn",
                id,
                LocalDateTime.now().toString()
        );
    }

    /**
     * RuĹˇĂ­ zĂˇpas a uklĂˇdĂˇ dĹŻvod zruĹˇenĂ­.
     *
     * Pokud je zĂˇpas jiĹľ zruĹˇen, vyhazuje se {@link InvalidMatchStatusException}. PĹ™i ĂşspÄ›ĹˇnĂ©m zruĹˇenĂ­ se nastavĂ­ stav
     * CANCELED, uloĹľĂ­ se dĹŻvod zruĹˇenĂ­ a aktualizuje se identifikĂˇtor uĹľivatele, kterĂ˝ zmÄ›nu provedl. NĂˇslednÄ› se odeĹˇlou
     * notifikace registrovanĂ˝m hrĂˇÄŤĹŻm o zruĹˇenĂ­ zĂˇpasu pĹ™es {@link NotificationService}.
     *
     * @param matchId IdentifikĂˇtor ruĹˇenĂ©ho zĂˇpasu.
     * @param reason DĹŻvod zruĹˇenĂ­ zĂˇpasu.
     * @return StandardizovanĂˇ odpovÄ›ÄŹ o ĂşspÄ›ĹˇnĂ©m zruĹˇenĂ­.
     */
    @Override
    @Transactional
    public SuccessResponseDTO cancelMatch(Long matchId, MatchCancelReason reason) {
        MatchEntity match = findMatchOrThrow(matchId);
        String message = " je jiĹľ zruĹˇen";

        if (match.getMatchStatus() == MatchStatus.CANCELED) {
            throw new InvalidMatchStatusException(matchId, message);
        }

        match.setMatchStatus(MatchStatus.CANCELED);
        match.setCancelReason(reason);

        Long currentUserId = getCurrentUserIdOrNull();
        match.setLastModifiedByUserId(currentUserId);

        MatchEntity saved = matchRepository.save(match);
        notifyPlayersAboutMatchChanges(saved, MatchStatus.CANCELED);

        return new SuccessResponseDTO(
                "BE - ZĂˇpas " + match.getId() + match.getDateTime() + " byl ĂşspÄ›ĹˇnÄ› zruĹˇen",
                match.getId(),
                LocalDateTime.now().toString()
        );
    }

    /**
     * Obnovuje dĹ™Ă­ve zruĹˇenĂ˝ zĂˇpas.
     *
     * Pokud zĂˇpas nenĂ­ ve stavu CANCELED, vyhazuje se {@link InvalidMatchStatusException}. PĹ™i ĂşspÄ›ĹˇnĂ© obnovÄ› se odstranĂ­
     * dĹŻvod zruĹˇenĂ­, nastavĂ­ se stav UNCANCELED a aktualizuje se identifikĂˇtor uĹľivatele, kterĂ˝ zmÄ›nu provedl. NĂˇslednÄ› se
     * odeĹˇlou notifikace registrovanĂ˝m hrĂˇÄŤĹŻm o obnovenĂ­ zĂˇpasu pĹ™es {@link NotificationService}.
     *
     * @param matchId IdentifikĂˇtor obnovovanĂ©ho zĂˇpasu.
     * @return StandardizovanĂˇ odpovÄ›ÄŹ o ĂşspÄ›ĹˇnĂ© obnovÄ›.
     */
    @Override
    @Transactional
    public SuccessResponseDTO unCancelMatch(Long matchId) {
        MatchEntity match = findMatchOrThrow(matchId);
        String message = " jeĹˇtÄ› nebyl zruĹˇen";

        if (match.getMatchStatus() != MatchStatus.CANCELED) {
            throw new InvalidMatchStatusException(matchId, message);
        }

        match.setMatchStatus(MatchStatus.UNCANCELED);
        match.setCancelReason(null);

        Long currentUserId = getCurrentUserIdOrNull();
        match.setLastModifiedByUserId(currentUserId);

        MatchEntity saved = matchRepository.save(match);
        notifyPlayersAboutMatchChanges(saved, MatchStatus.UNCANCELED);

        return new SuccessResponseDTO(
                "BE - ZĂˇpas " + match.getId() + match.getDateTime() + " byl ĂşspÄ›ĹˇnÄ› obnoven",
                match.getId(),
                LocalDateTime.now().toString()
        );
    }

    // ======================
    // DETAIL ZĂPASU
    // ======================

    /**
     * VracĂ­ detail zĂˇpasu ve formÄ› {@link MatchDetailDTO}.
     *
     * Nejprve se naÄŤte zĂˇpas a vyhodnotĂ­ se pĹ™Ă­stupovĂˇ pravidla dle role uĹľivatele a jeho navĂˇzanĂ˝ch hrĂˇÄŤĹŻ.
     * NĂˇslednÄ› se sestavĂ­ detailnĂ­ DTO vÄŤetnÄ› agregovanĂ˝ch statistik a seskupenĂ­ hrĂˇÄŤĹŻ podle stavĹŻ registracĂ­.
     * Do vĂ˝sledku se doplnĂ­ stav aktuĂˇlnÄ› zvolenĂ©ho hrĂˇÄŤe, pĹ™Ă­padnĂ© informace o omluvÄ›, stav zĂˇpasu a dĹŻvod zruĹˇenĂ­.
     * Pokud je zĂˇpas souÄŤĂˇstĂ­ sezĂłny, doplnĂ­ se takĂ© poĹ™adovĂ© ÄŤĂ­slo zĂˇpasu v sezĂłnÄ›.
     *
     * @param id IdentifikĂˇtor zĂˇpasu.
     * @return Detail zĂˇpasu ve formÄ› {@link MatchDetailDTO}.
     */
    @Override
    public MatchDetailDTO getMatchDetail(Long id) {
        MatchEntity match = findMatchOrThrow(id);

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        boolean isAdminOrManager = hasAdminOrManagerRole(auth);

        checkAccessForPlayer(match, auth);

        MatchDetailDTO dto = collectPlayerStatus(match, isAdminOrManager);

        Long currentPlayerId = null;
        try {
            currentPlayerId = currentPlayerService.getCurrentPlayerId();
        } catch (Exception e) {
            logger.debug("Nebyl nalezen currentPlayerId pro match detail {}", id);
        }

        PlayerMatchStatus playerMatchStatus = resolveStatusForPlayer(dto, currentPlayerId);
        dto.setPlayerMatchStatus(playerMatchStatus);

        if (currentPlayerId != null) {
            matchRegistrationRepository.findByPlayerIdAndMatchId(currentPlayerId, match.getId())
                    .ifPresent(reg -> {
                        dto.setExcuseReason(reg.getExcuseReason());
                        dto.setExcuseNote(reg.getExcuseNote());
                    });
        } else {
            dto.setExcuseReason(null);
            dto.setExcuseNote(null);
        }

        dto.setMatchStatus(match.getMatchStatus());
        dto.setCancelReason(match.getCancelReason());

        if (match.getSeason() != null && match.getSeason().getId() != null) {
            Long seasonId = match.getSeason().getId();
            Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);
            Integer number = matchNumberMap.get(match.getId());
            dto.setMatchNumber(number);
        }

        return dto;
    }

    /**
     * OvÄ›Ĺ™uje, zda mĂˇ aktuĂˇlnĂ­ uĹľivatel pĹ™Ă­stup k detailu zĂˇpasu.
     *
     * UĹľivatel musĂ­ bĂ˝t pĹ™ihlĂˇĹˇen. UĹľivatel s rolĂ­ ADMIN nebo MANAGER mĂˇ pĹ™Ă­stup vĹľdy.
     * UĹľivatel bez administrĂˇtorskĂ© role musĂ­ mĂ­t navĂˇzanĂ©ho alespoĹ jednoho hrĂˇÄŤe a souÄŤasnÄ› platĂ­ omezenĂ­ podle toho,
     * zda jde o nadchĂˇzejĂ­cĂ­ nebo probÄ›hlĂ˝ zĂˇpas v rĂˇmci aktuĂˇlnĂ­ sezĂłny.
     *
     * Pro nadchĂˇzejĂ­cĂ­ zĂˇpas se ovÄ›Ĺ™uje, Ĺľe uĹľivatel mĂˇ alespoĹ jednoho aktivnĂ­ho hrĂˇÄŤe pro termĂ­n zĂˇpasu.
     * Pro probÄ›hlĂ˝ zĂˇpas se ovÄ›Ĺ™uje, Ĺľe nÄ›kterĂ˝ z hrĂˇÄŤĹŻ uĹľivatele byl v zĂˇpase registrovĂˇn ve stavu REGISTERED.
     *
     * @param match ZĂˇpas, ke kterĂ©mu se pĹ™Ă­stup vyhodnocuje.
     * @param auth AktuĂˇlnĂ­ autentizace z bezpeÄŤnostnĂ­ho kontextu.
     */
    private void checkAccessForPlayer(MatchEntity match, Authentication auth) {
        if (auth == null || !auth.isAuthenticated()) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - MusĂ­te bĂ˝t pĹ™ihlĂˇĹˇen."
            );
        }

        boolean isAdminOrManager = hasAdminOrManagerRole(auth);
        if (isAdminOrManager) {
            return;
        }

        Long currentSeasonId = getCurrentSeasonIdOrActive();
        if (match.getSeason() == null || !match.getSeason().getId().equals(currentSeasonId)) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - K detailu zĂˇpasu z jinĂ© sezĂłny nemĂˇte pĹ™Ă­stup."
            );
        }

        Object principal = auth.getPrincipal();
        if (!(principal instanceof org.springframework.security.core.userdetails.UserDetails userDetails)) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - NemĂˇte pĹ™Ă­stup k detailu tohoto zĂˇpasu."
            );
        }

        List<PlayerEntity> ownedPlayers =
                playerRepository.findByUser_EmailOrderByIdAsc(userDetails.getUsername());

        if (ownedPlayers.isEmpty()) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - NemĂˇte pĹ™iĹ™azenĂ©ho ĹľĂˇdnĂ©ho hrĂˇÄŤe."
            );
        }

        LocalDateTime now = now();
        boolean isPastOrNow = !match.getDateTime().isAfter(now);
        List<Long> ownedPlayerIds = ownedPlayers.stream()
                .map(PlayerEntity::getId)
                .toList();

        List<MatchRegistrationDTO> registrations =
                registrationService.getRegistrationsForMatch(match.getId());

        if (!isPastOrNow) {
            boolean hasActivePlayerForMatch = ownedPlayers.stream()
                    .anyMatch(p -> isPlayerActiveForMatch(p, match.getDateTime()));

            if (!hasActivePlayerForMatch) {
                throw new org.springframework.security.access.AccessDeniedException(
                        "BE - NemĂˇte aktivnĂ­ho hrĂˇÄŤe pro tento zĂˇpas."
                );
            }
            return;
        }

        boolean wasRegistered = registrations.stream()
                .anyMatch(r ->
                        r.getStatus() == PlayerMatchStatus.REGISTERED
                                && ownedPlayerIds.contains(r.getPlayerId())
                );

        if (!wasRegistered) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - K tomuto uplynulĂ©mu zĂˇpasu nemĂˇte oprĂˇvnÄ›nĂ­ (nejste mezi registrovanĂ˝mi hrĂˇÄŤi)."
            );
        }
    }

    /**
     * Sestavuje {@link MatchDetailDTO} pro danĂ˝ zĂˇpas.
     *
     * V rĂˇmci sestavenĂ­ se naÄŤtou registrace k zĂˇpasu, hrĂˇÄŤi se seskupĂ­ podle stavĹŻ registracĂ­ a spoÄŤĂ­tajĂ­ se agregovanĂ©
     * hodnoty, zejmĂ©na poÄŤty hrĂˇÄŤĹŻ v jednotlivĂ˝ch stavech, volnĂˇ mĂ­sta a cena na registrovanĂ©ho hrĂˇÄŤe.
     *
     * Seznam hrĂˇÄŤĹŻ bez reakce se do vĂ˝sledku doplĹuje pouze pro role ADMIN a MANAGER.
     *
     * @param match ZĂˇpas, pro kterĂ˝ se detail sestavuje.
     * @param isAdminOrManager PĹ™Ă­znak urÄŤujĂ­cĂ­, zda mĂˇ uĹľivatel oprĂˇvnÄ›nĂ­ pro administrĂˇtorskĂ˝ pohled.
     * @return Detail zĂˇpasu sestavenĂ˝ do DTO.
     */
    private MatchDetailDTO collectPlayerStatus(MatchEntity match, boolean isAdminOrManager) {
        List<MatchRegistrationDTO> registrations =
                registrationService.getRegistrationsForMatch(match.getId());

        var statusToPlayersMap = registrations.stream()
                .map(r -> playerRepository.findById(r.getPlayerId())
                        .map(playerMapper::toDTO)
                        .map(dto -> new AbstractMap.SimpleEntry<>(r.getStatus(), dto))
                )
                .filter(Optional::isPresent)
                .map(Optional::get)
                .collect(Collectors.groupingBy(
                        java.util.Map.Entry::getKey,
                        Collectors.mapping(java.util.Map.Entry::getValue, Collectors.toList())
                ));

        List<PlayerDTO> noResponsePlayers =
                registrationService.getNoResponsePlayers(match.getId());
        List<PlayerDTO> registeredDarkPlayers = getRegisteredPlayersForTeam(registrations, Team.DARK);
        List<PlayerDTO> registeredLightPlayers = getRegisteredPlayersForTeam(registrations, Team.LIGHT);

        int inGamePlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()).size();

        int inGamePlayersDark =
                (int) registrations.stream()
                        .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                        .filter(r -> r.getTeam() == Team.DARK)
                        .count();

        int inGamePlayersLight =
                (int) registrations.stream()
                        .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                        .filter(r -> r.getTeam() == Team.LIGHT)
                        .count();

        int substitutePlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.SUBSTITUTE, List.of()).size();

        int outGamePlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()).size()
                        + statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()).size()
                        + statusToPlayersMap.getOrDefault(PlayerMatchStatus.NO_EXCUSED, List.of()).size();

        int waitingPlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()).size();

        int noExcusedPlayersSum =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.NO_EXCUSED, List.of()).size();

        int noActionPlayers = noResponsePlayers.size();

        int remainingSlots = match.getMaxPlayers() - inGamePlayers;
        double pricePerRegistered = inGamePlayers > 0
                ? match.getPrice() / (double) inGamePlayers
                : match.getPrice();

        MatchDetailDTO dto = new MatchDetailDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setLocation(match.getLocation());
        dto.setDescription(match.getDescription());
        dto.setPrice(match.getPrice());
        dto.setMaxPlayers(match.getMaxPlayers());
        dto.setInGamePlayers(inGamePlayers);
        dto.setInGamePlayersDark(inGamePlayersDark);
        dto.setInGamePlayersLight(inGamePlayersLight);
        dto.setSubstitutePlayers(substitutePlayers);
        dto.setOutGamePlayers(outGamePlayers);
        dto.setWaitingPlayers(waitingPlayers);
        dto.setNoExcusedPlayersSum(noExcusedPlayersSum);
        dto.setNoActionPlayers(noActionPlayers);
        dto.setPricePerRegisteredPlayer(pricePerRegistered);
        dto.setRemainingSlots(remainingSlots);

        dto.setRegisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()));
        dto.setReservedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()));
        dto.setUnregisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()));
        dto.setExcusedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()));
        dto.setSubstitutedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.SUBSTITUTE, List.of()));
        dto.setNoExcusedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.NO_EXCUSED, List.of()));

        dto.setNoResponsePlayers(isAdminOrManager ? noResponsePlayers : null);
        dto.setRegisteredDarkPlayers(registeredDarkPlayers);
        dto.setRegisteredLightPlayers(registeredLightPlayers);

        return dto;
    }

    /**
     * Sestavuje seznam hrĂˇÄŤĹŻ registrovanĂ˝ch do konkrĂ©tnĂ­ho tĂ˝mu.
     *
     * Seznam se sestavuje pouze ze stavu REGISTERED a pouĹľĂ­vĂˇ se pro rychlĂ© zobrazenĂ­ sloĹľenĂ­ tĂ˝mĹŻ v detailu zĂˇpasu.
     * NaÄŤĂ­tĂˇnĂ­ hrĂˇÄŤĹŻ se provĂˇdĂ­ pĹ™es repository vrstvu a pĹ™evod do DTO se deleguje do {@link PlayerMapper}.
     *
     * @param registrations Registrace zĂˇpasu, ze kterĂ˝ch se hrĂˇÄŤi vyhodnocujĂ­.
     * @param team TĂ˝m, pro kterĂ˝ se hrĂˇÄŤi filtrujĂ­.
     * @return Seznam hrĂˇÄŤĹŻ registrovanĂ˝ch v danĂ©m tĂ˝mu pĹ™evedenĂ˝ch do DTO.
     */
    private List<PlayerDTO> getRegisteredPlayersForTeam(List<MatchRegistrationDTO> registrations, Team team) {
        return registrations.stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .filter(r -> r.getTeam() == team)
                .map(MatchRegistrationDTO::getPlayerId)
                .distinct()
                .map(playerRepository::findById)
                .flatMap(Optional::stream)
                .map(playerMapper::toDTO)
                .toList();
    }

    /**
     * Odvozuje stav konkrĂ©tnĂ­ho hrĂˇÄŤe z detailu zĂˇpasu.
     *
     * Stav se vyhodnocuje na zĂˇkladÄ› pĹ™Ă­tomnosti hrĂˇÄŤe v seznamech seskupenĂ˝ch podle stavu registrace.
     * Pokud hrĂˇÄŤ nenĂ­ nalezen v ĹľĂˇdnĂ© kategorii, vracĂ­ se NO_RESPONSE.
     *
     * @param dto Detail zĂˇpasu obsahujĂ­cĂ­ seskupenĂ© seznamy hrĂˇÄŤĹŻ.
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, pro kterĂ©ho se stav vyhodnocuje.
     * @return Stav hrĂˇÄŤe vĹŻÄŤi zĂˇpasu.
     */
    private PlayerMatchStatus resolveStatusForPlayer(MatchDetailDTO dto, Long playerId) {
        if (dto == null || playerId == null) {
            return PlayerMatchStatus.NO_RESPONSE;
        }

        if (isIn(dto.getRegisteredPlayers(), playerId)) {
            return PlayerMatchStatus.REGISTERED;
        }
        if (isIn(dto.getReservedPlayers(), playerId)) {
            return PlayerMatchStatus.RESERVED;
        }
        if (isIn(dto.getExcusedPlayers(), playerId)) {
            return PlayerMatchStatus.EXCUSED;
        }
        if (isIn(dto.getSubstitutedPlayers(), playerId)) {
            return PlayerMatchStatus.SUBSTITUTE;
        }
        if (isIn(dto.getUnregisteredPlayers(), playerId)) {
            return PlayerMatchStatus.UNREGISTERED;
        }
        if (isIn(dto.getNoExcusedPlayers(), playerId)) {
            return PlayerMatchStatus.NO_EXCUSED;
        }

        return PlayerMatchStatus.NO_RESPONSE;
    }

    /**
     * Vyhodnocuje pĹ™Ă­tomnost hrĂˇÄŤe v seznamu hrĂˇÄŤĹŻ podle identifikĂˇtoru.
     *
     * @param players Seznam hrĂˇÄŤĹŻ, ve kterĂ©m se vyhledĂˇvĂˇ.
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, kterĂ˝ se v seznamu ovÄ›Ĺ™uje.
     * @return True, pokud je hrĂˇÄŤ v seznamu pĹ™Ă­tomen, jinak false.
     */
    private boolean isIn(List<PlayerDTO> players, Long playerId) {
        return players != null
                && players.stream().anyMatch(p -> p.getId().equals(playerId));
    }

    // ======================
    // DALĹ ĂŤ PUBLIC METODY
    // ======================

    /**
     * VracĂ­ zĂˇpasy, ve kterĂ˝ch mĹŻĹľe danĂ˝ hrĂˇÄŤ potenciĂˇlnÄ› hrĂˇt.
     *
     * ZĂˇpasy se naÄŤĂ­tajĂ­ napĹ™Ă­ÄŤ vĹˇemi sezĂłnami a nĂˇslednÄ› se filtrujĂ­ podle aktivity hrĂˇÄŤe v termĂ­nu zĂˇpasu.
     * VyhodnocenĂ­ aktivity se deleguje do {@link PlayerInactivityPeriodService}.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, pro kterĂ©ho se dostupnĂ© zĂˇpasy vyhodnocujĂ­.
     * @return Seznam zĂˇpasĹŻ, pro kterĂ© je hrĂˇÄŤ v termĂ­nu aktivnĂ­, pĹ™evedenĂ˝ch do DTO.
     */
    @Override
    public List<MatchDTO> getAvailableMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        return matchRepository.findAll().stream()
                .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                .map(matchMapper::toDTO)
                .toList();
    }

    /**
     * VyhledĂˇvĂˇ identifikĂˇtor hrĂˇÄŤe podle e-mailu uĹľivatele.
     *
     * HrĂˇÄŤ se naÄŤĂ­tĂˇ pĹ™es repository vrstvu. Pokud uĹľivatel nemĂˇ ĹľĂˇdnĂ©ho hrĂˇÄŤe, vyhazuje se {@link PlayerNotFoundException}.
     *
     * @param email E-mail uĹľivatele, pro kterĂ˝ se hrĂˇÄŤ vyhledĂˇvĂˇ.
     * @return IdentifikĂˇtor hrĂˇÄŤe navĂˇzanĂ©ho na uĹľivatele.
     */
    @Override
    public Long getPlayerIdByEmail(String email) {
        return playerRepository.findByUserEmail(email)
                .map(PlayerEntity::getId)
                .orElseThrow(() -> new PlayerNotFoundException(email));
    }

    /**
     * VracĂ­ pĹ™ehled nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ pro konkrĂ©tnĂ­ho hrĂˇÄŤe.
     *
     * NadchĂˇzejĂ­cĂ­ zĂˇpasy se naÄŤtou pro aktuĂˇlnĂ­ sezĂłnu a omezĂ­ se podle typu hrĂˇÄŤe. NĂˇslednÄ› se filtrujĂ­ pouze ty zĂˇpasy,
     * pro kterĂ© je hrĂˇÄŤ v termĂ­nu aktivnĂ­. Do vĂ˝stupu se doplnĂ­ stav hrĂˇÄŤe v zĂˇpase a poĹ™adovĂ© ÄŤĂ­slo zĂˇpasu v sezĂłnÄ›.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, pro kterĂ©ho se pĹ™ehled sestavuje.
     * @return Seznam pĹ™ehledĹŻ zĂˇpasĹŻ pĹ™evedenĂ˝ch do {@link MatchOverviewDTO}.
     */
    @Override
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        List<MatchEntity> upcomingAll = findUpcomingMatchesForCurrentSeason();
        List<MatchEntity> limited = limitMatchesByPlayerType(upcomingAll, type);

        List<MatchEntity> activeMatches = limited.stream()
                .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                .toList();

        Long seasonId = getCurrentSeasonIdOrActive();
        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);

        return assignMatchNumbers(
                activeMatches,
                match -> toOverviewDTO(match, playerId),
                matchNumberMap
        );
    }

    /**
     * VracĂ­ seznam nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ pro konkrĂ©tnĂ­ho hrĂˇÄŤe.
     *
     * NadchĂˇzejĂ­cĂ­ zĂˇpasy se naÄŤtou pro aktuĂˇlnĂ­ sezĂłnu, omezĂ­ se podle typu hrĂˇÄŤe a nĂˇslednÄ› se filtrujĂ­ pouze ty zĂˇpasy,
     * pro kterĂ© je hrĂˇÄŤ v termĂ­nu aktivnĂ­. Do vĂ˝stupu se doplnĂ­ poĹ™adovĂ© ÄŤĂ­slo zĂˇpasu v sezĂłnÄ›.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, pro kterĂ©ho se zĂˇpasy naÄŤĂ­tajĂ­.
     * @return Seznam nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ pĹ™evedenĂ˝ch do {@link MatchDTO}.
     */
    @Override
    public List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        List<MatchEntity> upcomingAll = findUpcomingMatchesForCurrentSeason();
        List<MatchEntity> limited = limitMatchesByPlayerType(upcomingAll, type);

        List<MatchEntity> activeMatches = limited.stream()
                .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                .toList();

        Long seasonId = getCurrentSeasonIdOrActive();
        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);

        return assignMatchNumbers(activeMatches, matchMapper::toDTO, matchNumberMap);
    }

    /**
     * VracĂ­ pĹ™ehled probÄ›hlĂ˝ch zĂˇpasĹŻ aktuĂˇlnĂ­ sezĂłny, kterĂ˝ch se hrĂˇÄŤ mohl ĂşÄŤastnit.
     *
     * ZĂˇpasy se filtrujĂ­ podle data vytvoĹ™enĂ­ hrĂˇÄŤe a podle aktivity hrĂˇÄŤe v termĂ­nu zĂˇpasu. Pro vybranou sadu zĂˇpasĹŻ
     * se hromadnÄ› naÄŤtou registrace a pro kaĹľdĂ˝ zĂˇpas se odvodĂ­ stav hrĂˇÄŤe. Do vĂ˝stupu se doplnĂ­ poĹ™adovĂ© ÄŤĂ­slo zĂˇpasu
     * v sezĂłnÄ›.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, pro kterĂ©ho se pĹ™ehled sestavuje.
     * @return Seznam pĹ™ehledĹŻ probÄ›hlĂ˝ch zĂˇpasĹŻ pĹ™evedenĂ˝ch do {@link MatchOverviewDTO}.
     */
    @Override
    public List<MatchOverviewDTO> getAllPassedMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        LocalDateTime playerCreatedDate = player.getTimestamp();

        List<MatchEntity> availableMatches =
                findPastMatchesForCurrentSeason().stream()
                        .filter(match -> match.getDateTime().isAfter(playerCreatedDate))
                        .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                        .toList();

        if (availableMatches.isEmpty()) {
            return List.of();
        }

        List<Long> matchIds = availableMatches.stream()
                .map(MatchEntity::getId)
                .toList();

        List<MatchRegistrationDTO> allRegistrations =
                registrationService.getRegistrationsForMatches(matchIds);

        var statusMap = allRegistrations.stream()
                .collect(Collectors.groupingBy(
                        MatchRegistrationDTO::getMatchId,
                        Collectors.toMap(
                                MatchRegistrationDTO::getPlayerId,
                                MatchRegistrationDTO::getStatus,
                                (a, b) -> a
                        )
                ));

        List<MatchOverviewDTO> overviews = availableMatches.stream()
                .map(match -> {
                    MatchOverviewDTO overview = toOverviewDTO(match);
                    PlayerMatchStatus playerMatchStatus = Optional.ofNullable(statusMap.get(match.getId()))
                            .map(m -> normalizePlayerStatus(m.get(playerId)))
                            .orElse(PlayerMatchStatus.NO_RESPONSE);
                    overview.setPlayerMatchStatus(playerMatchStatus);
                    return overview;
                })
                .toList();

        Long seasonId = getCurrentSeasonIdOrActive();
        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);

        overviews.forEach(o -> o.setMatchNumber(matchNumberMap.get(o.getId())));

        return overviews;
    }

    /**
     * NaÄŤĂ­tĂˇ hrĂˇÄŤe podle identifikĂˇtoru nebo vyhazuje vĂ˝jimku pĹ™i neexistenci.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe.
     * @return NaÄŤtenĂˇ entita hrĂˇÄŤe.
     */
    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    /**
     * NaÄŤĂ­tĂˇ zĂˇpas podle identifikĂˇtoru nebo vyhazuje vĂ˝jimku pĹ™i neexistenci.
     *
     * @param matchId IdentifikĂˇtor zĂˇpasu.
     * @return NaÄŤtenĂˇ entita zĂˇpasu.
     */
    private MatchEntity findMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }

    /**
     * NaÄŤĂ­tĂˇ registraci hrĂˇÄŤe k zĂˇpasu nebo vyhazuje vĂ˝jimku pĹ™i neexistenci.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe.
     * @param matchId IdentifikĂˇtor zĂˇpasu.
     * @return NaÄŤtenĂˇ entita registrace.
     */
    private MatchRegistrationEntity findMatchRegistrationOrThrow(Long playerId, Long matchId) {
        return matchRegistrationRepository.findByPlayerIdAndMatchId(playerId, matchId)
                .orElseThrow(() -> new MatchRegistrationNotFoundException(playerId, matchId));
    }

    /**
     * VracĂ­ aktuĂˇlnĂ­ ÄŤas.
     *
     * Metoda se pouĹľĂ­vĂˇ pro sjednocenĂ­ pĹ™Ă­stupu k ÄŤasu a pro usnadnÄ›nĂ­ testovĂˇnĂ­.
     *
     * @return AktuĂˇlnĂ­ ÄŤas jako LocalDateTime.
     */
    private LocalDateTime now() {
        return LocalDateTime.now();
    }

    // ======================
    // POMOCNĂ‰ METODY â€“ DTO MAPOVĂNĂŤ
    // ======================

    /**
     * Sestavuje zĂˇkladnĂ­ {@link MatchOverviewDTO} pro danĂ˝ zĂˇpas.
     *
     * DTO obsahuje zĂˇkladnĂ­ informace o zĂˇpasu a poÄŤet hrĂˇÄŤĹŻ se stavem REGISTERED vÄŤetnÄ› vypoÄŤtenĂ© ceny na registrovanĂ©ho
     * hrĂˇÄŤe. NaÄŤtenĂ­ registracĂ­ se deleguje do {@link MatchRegistrationService}.
     *
     * @param match ZĂˇpas, pro kterĂ˝ se pĹ™ehled sestavuje.
     * @return PĹ™ehled zĂˇpasu pĹ™evedenĂ˝ do {@link MatchOverviewDTO}.
     */
    private MatchOverviewDTO toOverviewDTO(MatchEntity match) {
        MatchOverviewDTO dto = new MatchOverviewDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setLocation(match.getLocation());
        dto.setDescription(match.getDescription());
        dto.setPrice(match.getPrice());
        dto.setMaxPlayers(match.getMaxPlayers());

        int inGamePlayers = registrationService.getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .mapToInt(r -> 1)
                .sum();
        dto.setInGamePlayers(inGamePlayers);

        double pricePerPlayer = inGamePlayers > 0 && match.getPrice() != null
                ? match.getPrice() / (double) inGamePlayers
                : match.getPrice();
        dto.setPricePerRegisteredPlayer(pricePerPlayer);

        return dto;
    }

    /**
     * Sestavuje {@link MatchOverviewDTO} pro danĂ˝ zĂˇpas v kontextu konkrĂ©tnĂ­ho hrĂˇÄŤe.
     *
     * K zĂˇkladnĂ­m ĂşdajĹŻm o zĂˇpasu se doplnĂ­ stav hrĂˇÄŤe v zĂˇpase odvozenĂ˝ z registracĂ­. Pokud registrace hrĂˇÄŤe neexistuje,
     * pouĹľije se stav NO_RESPONSE.
     *
     * @param match ZĂˇpas, pro kterĂ˝ se pĹ™ehled sestavuje.
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, jehoĹľ stav se do pĹ™ehledu doplĹuje.
     * @return PĹ™ehled zĂˇpasu pĹ™evedenĂ˝ do {@link MatchOverviewDTO} vÄŤetnÄ› stavu hrĂˇÄŤe.
     */
    private MatchOverviewDTO toOverviewDTO(MatchEntity match, Long playerId) {
        MatchOverviewDTO dto = toOverviewDTO(match);

        PlayerMatchStatus playerMatchStatus = registrationService
                .getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getPlayerId().equals(playerId))
                .map(MatchRegistrationDTO::getStatus)
                .findFirst()
                .map(this::normalizePlayerStatus)
                .orElse(PlayerMatchStatus.NO_RESPONSE);

        dto.setPlayerMatchStatus(playerMatchStatus);
        return dto;
    }

    // ======================
    // DALĹ ĂŤ POMOCNĂ‰ METODY
    // ======================

    /**
     * Vyhodnocuje, zda mĂˇ uĹľivatel roli ADMIN nebo MANAGER.
     *
     * @param auth AktuĂˇlnĂ­ autentizace z bezpeÄŤnostnĂ­ho kontextu.
     * @return True, pokud mĂˇ uĹľivatel jednu z administrĂˇtorskĂ˝ch rolĂ­, jinak false.
     */
    private boolean hasAdminOrManagerRole(Authentication auth) {
        if (auth == null) {
            return false;
        }
        return auth.getAuthorities().stream()
                .anyMatch(a ->
                        ROLE_ADMIN.equals(a.getAuthority()) ||
                                ROLE_MANAGER.equals(a.getAuthority())
                );
    }

    /**
     * NaÄŤĂ­tĂˇ vĹˇechny nadchĂˇzejĂ­cĂ­ zĂˇpasy v aktuĂˇlnĂ­ sezĂłnÄ›.
     *
     * ZĂˇpasy se vybĂ­rajĂ­ podle data a ÄŤasu vÄ›tĹˇĂ­ho neĹľ aktuĂˇlnĂ­ okamĹľik a Ĺ™adĂ­ se vzestupnÄ› podle data.
     *
     * @return Seznam nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ v aktuĂˇlnĂ­ sezĂłnÄ›.
     */
    private List<MatchEntity> findUpcomingMatchesForCurrentSeason() {
        return matchRepository.findBySeasonIdAndDateTimeAfterOrderByDateTimeAsc(
                getCurrentSeasonIdOrActive(),
                now()
        );
    }

    /**
     * NaÄŤĂ­tĂˇ vĹˇechny probÄ›hlĂ© zĂˇpasy v aktuĂˇlnĂ­ sezĂłnÄ›.
     *
     * ZĂˇpasy se vybĂ­rajĂ­ podle data a ÄŤasu menĹˇĂ­ho neĹľ aktuĂˇlnĂ­ okamĹľik a Ĺ™adĂ­ se sestupnÄ› podle data.
     *
     * @return Seznam probÄ›hlĂ˝ch zĂˇpasĹŻ v aktuĂˇlnĂ­ sezĂłnÄ›.
     */
    private List<MatchEntity> findPastMatchesForCurrentSeason() {
        return matchRepository.findBySeasonIdAndDateTimeBeforeOrderByDateTimeDesc(
                getCurrentSeasonIdOrActive(),
                now()
        );
    }

    /**
     * Omezuje poÄŤet nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ podle typu hrĂˇÄŤe.
     *
     * Pro typ VIP se vracĂ­ tĹ™i nejbliĹľĹˇĂ­ zĂˇpasy, pro STANDARD dva nejbliĹľĹˇĂ­ zĂˇpasy a pro BASIC jeden nejbliĹľĹˇĂ­ zĂˇpas.
     *
     * @param upcomingAll Seznam vĹˇech nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ.
     * @param type Typ hrĂˇÄŤe.
     * @return OmezenĂ˝ seznam zĂˇpasĹŻ podle pravidel typu hrĂˇÄŤe.
     */
    private List<MatchEntity> limitMatchesByPlayerType(List<MatchEntity> upcomingAll, PlayerType type) {
        if (upcomingAll == null || upcomingAll.isEmpty()) {
            return List.of();
        }

        return switch (type) {
            case VIP -> upcomingAll.stream().limit(3).toList();
            case STANDARD -> upcomingAll.stream().limit(2).toList();
            case BASIC -> List.of(upcomingAll.get(0));
        };
    }

    /**
     * Vyhodnocuje, zda je hrĂˇÄŤ aktivnĂ­ pro termĂ­n zĂˇpasu.
     *
     * VyhodnocenĂ­ aktivity se deleguje do {@link PlayerInactivityPeriodService}.
     *
     * @param player HrĂˇÄŤ, jehoĹľ aktivita se vyhodnocuje.
     * @param dateTime TermĂ­n zĂˇpasu.
     * @return True, pokud je hrĂˇÄŤ v termĂ­nu zĂˇpasu aktivnĂ­, jinak false.
     */
    private boolean isPlayerActiveForMatch(PlayerEntity player, LocalDateTime dateTime) {
        return playerInactivityPeriodService.isActive(player, dateTime);
    }

    /**
     * Normalizuje stav registrace hrĂˇÄŤe pro pouĹľitĂ­ v pĹ™ehledech.
     *
     * Pokud je stav null nebo je neznĂˇmĂ˝, vracĂ­ se NO_RESPONSE. PodporovanĂ© stavy se vracejĂ­ beze zmÄ›ny.
     *
     * @param status Stav registrace hrĂˇÄŤe.
     * @return NormalizovanĂ˝ stav registrace pro pouĹľitĂ­ v pĹ™ehledech.
     */
    private PlayerMatchStatus normalizePlayerStatus(PlayerMatchStatus status) {
        if (status == null) {
            return PlayerMatchStatus.NO_RESPONSE;
        }

        return switch (status) {
            case REGISTERED,
                 UNREGISTERED,
                 EXCUSED,
                 SUBSTITUTE,
                 RESERVED,
                 NO_EXCUSED -> status;
            default -> PlayerMatchStatus.NO_RESPONSE;
        };
    }

    /**
     * OvÄ›Ĺ™uje, Ĺľe datum zĂˇpasu spadĂˇ do obdobĂ­ aktivnĂ­ sezĂłny.
     *
     * Kontrola se pouĹľĂ­vĂˇ pĹ™i vytvĂˇĹ™enĂ­ a ĂşpravÄ› zĂˇpasu pro uĹľivatele bez administrĂˇtorskĂ© role. PĹ™i poruĹˇenĂ­ obdobĂ­
     * aktivnĂ­ sezĂłny se vyhazuje {@link InvalidSeasonPeriodDateException}.
     *
     * @param dateTime TermĂ­n zĂˇpasu, kterĂ˝ se ovÄ›Ĺ™uje.
     */
    private void validateMatchDateInActiveSeason(LocalDateTime dateTime) {
        var activeSeason = seasonService.getActiveSeason();
        var date = dateTime.toLocalDate();

        if (date.isBefore(activeSeason.getStartDate()) ||
                date.isAfter(activeSeason.getEndDate())) {

            throw new InvalidSeasonPeriodDateException(
                    "BE - Datum zĂˇpasu musĂ­ bĂ˝t v rozmezĂ­ aktivnĂ­ sezĂłny (" +
                            activeSeason.getStartDate() + " - " + activeSeason.getEndDate() + ")."
            );
        }
    }

    /**
     * VracĂ­ identifikĂˇtor sezĂłny, kterĂˇ se pouĹľije pro prĂˇci se zĂˇpasy.
     *
     * PrimĂˇrnÄ› se pouĹľĂ­vĂˇ sezĂłna uloĹľenĂˇ v {@link CurrentSeasonService}. Pokud nenĂ­ k dispozici, pouĹľije se globĂˇlnÄ›
     * aktivnĂ­ sezĂłna ze {@link SeasonService}.
     *
     * @return IdentifikĂˇtor aktuĂˇlnĂ­ nebo aktivnĂ­ sezĂłny.
     */
    private Long getCurrentSeasonIdOrActive() {
        Long id = currentSeasonService.getCurrentSeasonIdOrDefault();
        if (id != null) {
            return id;
        }
        return seasonService.getActiveSeason().getId();
    }

    /**
     * DoplĹuje poĹ™adovĂ© ÄŤĂ­slo zĂˇpasu v sezĂłnÄ› do DTO vĂ˝stupu.
     *
     * PoĹ™adovĂ© ÄŤĂ­slo se doplĹuje na zĂˇkladÄ› mapy matchId na poĹ™adĂ­ v sezĂłnÄ›. MapovĂˇnĂ­ entity na DTO se pĹ™edĂˇvĂˇ
     * jako funkce, aby bylo moĹľnĂ© metodu pouĹľĂ­t pro rĹŻznĂ© DTO implementujĂ­cĂ­ {@link NumberedMatchDTO}.
     *
     * @param matches Seznam zĂˇpasĹŻ, kterĂ© se mapujĂ­ do DTO.
     * @param mapper Funkce pro mapovĂˇnĂ­ {@link MatchEntity} na DTO.
     * @param matchNumberMap Mapa matchId na poĹ™adovĂ© ÄŤĂ­slo v sezĂłnÄ›.
     * @return Seznam DTO s doplnÄ›nĂ˝m poĹ™adovĂ˝m ÄŤĂ­slem.
     * @param <D> Typ DTO implementujĂ­cĂ­ {@link NumberedMatchDTO}.
     */
    private <D extends NumberedMatchDTO> List<D> assignMatchNumbers(
            List<MatchEntity> matches,
            Function<MatchEntity, D> mapper,
            Map<Long, Integer> matchNumberMap
    ) {
        return matches.stream()
                .map(entity -> {
                    D dto = mapper.apply(entity);
                    Integer number = matchNumberMap.get(entity.getId());
                    dto.setMatchNumber(number);
                    return dto;
                })
                .toList();
    }

    /**
     * Sestavuje mapu matchId na poĹ™adovĂ© ÄŤĂ­slo zĂˇpasu v sezĂłnÄ›.
     *
     * PoĹ™adĂ­ zĂˇpasĹŻ se odvozuje z data a ÄŤasu zĂˇpasu Ĺ™azenĂ©ho vzestupnÄ› v rĂˇmci sezĂłny.
     *
     * @param seasonId IdentifikĂˇtor sezĂłny, pro kterou se poĹ™adĂ­ sestavuje.
     * @return Mapa matchId na poĹ™adovĂ© ÄŤĂ­slo zĂˇpasu v sezĂłnÄ›.
     */
    private Map<Long, Integer> buildMatchNumberMapForSeason(Long seasonId) {
        List<MatchEntity> allMatchesInSeason =
                matchRepository.findAllBySeasonIdOrderByDateTimeAsc(seasonId);

        Map<Long, Integer> map = new HashMap<>();
        int counter = 1;
        for (MatchEntity m : allMatchesInSeason) {
            map.put(m.getId(), counter++);
        }
        return map;
    }

    /**
     * OdesĂ­lĂˇ notifikace hrĂˇÄŤĹŻm o zmÄ›nĂˇch souvisejĂ­cĂ­ch se zĂˇpasem.
     *
     * Kontext pĹ™edstavuje buÄŹ samotnĂ˝ zĂˇpas, nebo {@link MatchTimeChangeContext} v pĹ™Ă­padÄ› zmÄ›ny termĂ­nu. Na zĂˇkladÄ›
     * stavu zmÄ›ny zĂˇpasu se urÄŤĂ­ typ notifikace a notifikace se odesĂ­lajĂ­ hrĂˇÄŤĹŻm s registracĂ­ ve stavu REGISTERED,
     * RESERVED nebo SUBSTITUTE. OdeslĂˇnĂ­ se deleguje do {@link NotificationService}.
     *
     * @param context Kontext notifikace pouĹľitĂ˝ pro sestavenĂ­ obsahu zprĂˇvy.
     * @param matchStatus Stav zmÄ›ny zĂˇpasu, podle kterĂ©ho se urÄŤuje typ notifikace.
     */
    private void notifyPlayersAboutMatchChanges(Object context, MatchStatus matchStatus) {
        MatchEntity match;
        if (context instanceof MatchTimeChangeContext mtc) {
            match = mtc.match();
        } else if (context instanceof MatchEntity m) {
            match = m;
        } else {
            throw new IllegalArgumentException("NepodporovanĂ˝ typ contextu: " + context);
        }

        var registrations = matchRegistrationRepository.findByMatchId(match.getId());

        registrations.stream()
                .filter(reg -> reg.getStatus() == PlayerMatchStatus.REGISTERED
                        || reg.getStatus() == PlayerMatchStatus.RESERVED
                        || reg.getStatus() == PlayerMatchStatus.SUBSTITUTE)
                .forEach(reg -> {
                    PlayerEntity player = reg.getPlayer();

                    if (matchStatus == MatchStatus.UPDATED) {
                        notificationService.notifyPlayer(
                                player,
                                NotificationType.MATCH_TIME_CHANGED,
                                context
                        );
                    }

                    if (matchStatus == MatchStatus.CANCELED) {
                        notificationService.notifyPlayer(
                                player,
                                NotificationType.MATCH_CANCELED,
                                match
                        );
                        logger.info("CANCEL notify: matchId={}, regs={}",
                                match.getId(),
                                registrations.stream().map(r -> r.getStatus().name()).toList()
                        );
                    }

                    if (matchStatus == MatchStatus.UNCANCELED) {
                        notificationService.notifyPlayer(
                                player,
                                NotificationType.MATCH_UNCANCELED,
                                match
                        );
                    }
                });
    }

    /**
     * VracĂ­ identifikĂˇtor aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele, pokud je dostupnĂ˝.
     *
     * IdentifikĂˇtor se odvozuje z aktuĂˇlnĂ­ autentizace. Jako klĂ­ÄŤ se pouĹľĂ­vĂˇ e-mail uĹľivatele a dohledĂˇnĂ­ se provĂˇdĂ­
     * pĹ™es {@link AppUserRepository}. Pokud autentizace nenĂ­ dostupnĂˇ nebo uĹľivatel neexistuje, vracĂ­ se null.
     *
     * @return IdentifikĂˇtor aktuĂˇlnĂ­ho uĹľivatele, nebo null pokud uĹľivatele nelze urÄŤit.
     */
    private Long getCurrentUserIdOrNull() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth == null || !auth.isAuthenticated()) {
            return null;
        }

        String email = auth.getName();
        return appUserRepository.findByEmail(email)
                .map(AppUserEntity::getId)
                .orElse(null);
    }

}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\NotificationDecision.java
-----
package cz.phsoft.hokej.models.services;

/**
 * DatovĂ˝ objekt reprezentujĂ­cĂ­ vĂ˝sledek vyhodnocenĂ­
 * notifikaÄŤnĂ­ch preferencĂ­ pro konkrĂ©tnĂ­ udĂˇlost.
 *
 * SlouĹľĂ­ jako pĹ™enosovĂ˝ objekt mezi logikou vyhodnocenĂ­
 * notifikacĂ­ a konkrĂ©tnĂ­mi kanĂˇly odesĂ­lĂˇnĂ­ (email, SMS).
 *
 * Objekt jednoznaÄŤnÄ› urÄŤuje:
 * - zda mĂˇ bĂ˝t odeslĂˇn email uĹľivateli (AppUser),
 * - zda mĂˇ bĂ˝t odeslĂˇn email hrĂˇÄŤi na jeho vlastnĂ­ kontakt,
 * - zda mĂˇ bĂ˝t odeslĂˇna SMS hrĂˇÄŤi,
 * - jakĂ© konkrĂ©tnĂ­ kontaktnĂ­ Ăşdaje se majĂ­ pouĹľĂ­t.
 *
 * TĹ™Ă­da neĹ™eĹˇĂ­:
 * - samotnĂ© odesĂ­lĂˇnĂ­ notifikacĂ­,
 * - sestavenĂ­ obsahu zprĂˇv,
 * - validaci kontaktnĂ­ch ĂşdajĹŻ.
 *
 * PouĹľĂ­vĂˇ se typicky v NotificationService
 * jako vĂ˝sledek rozhodovacĂ­ logiky.
 */
public class NotificationDecision {

    // ==================================================
    // EMAIL â€“ UĹ˝IVATEL (AppUser)
    // ==================================================

    /**
     * UrÄŤuje, zda mĂˇ bĂ˝t odeslĂˇn email uĹľivateli (AppUser).
     *
     * Hodnota {@code true} znamenĂˇ, Ĺľe notifikace mĂˇ bĂ˝t
     * odeslĂˇna na email navĂˇzanĂ˝ na uĹľivatelskĂ˝ ĂşÄŤet.
     */
    private boolean sendEmailToUser;

    /**
     * EmailovĂˇ adresa uĹľivatele (AppUser.email),
     * na kterou mĂˇ bĂ˝t pĹ™Ă­padnĂˇ notifikace odeslĂˇna.
     */
    private String userEmail;

    /**
     * CelĂ© jmĂ©no uĹľivatele.
     *
     * PouĹľĂ­vĂˇ se zejmĂ©na pro personalizaci textu
     * emailovĂ© zprĂˇvy.
     */
    private String fullname;

    // ==================================================
    // EMAIL â€“ HRĂÄŚ
    // ==================================================

    /**
     * UrÄŤuje, zda mĂˇ bĂ˝t odeslĂˇn email pĹ™Ă­mo hrĂˇÄŤi.
     *
     * Email se odesĂ­lĂˇ na kontakt definovanĂ˝ v nastavenĂ­ hrĂˇÄŤe,
     * typicky {@code PlayerSettings.contactEmail}.
     */
    private boolean sendEmailToPlayer;

    /**
     * EmailovĂˇ adresa hrĂˇÄŤe.
     *
     * Hodnota obvykle pochĂˇzĂ­ z {@code PlayerSettings.contactEmail},
     * pĹ™Ă­padnÄ› mĹŻĹľe bĂ˝t pouĹľita nĂˇhradnĂ­ (fallback) hodnota
     * podle logiky vyhodnocenĂ­.
     */
    private String playerEmail;

    // ==================================================
    // SMS â€“ HRĂÄŚ
    // ==================================================

    /**
     * UrÄŤuje, zda mĂˇ bĂ˝t odeslĂˇna SMS hrĂˇÄŤi.
     *
     * Hodnota {@code true} znamenĂˇ, Ĺľe hrĂˇÄŤ mĂˇ povolenĂ©
     * SMS notifikace a je k dispozici platnĂ© telefonnĂ­ ÄŤĂ­slo.
     */
    private boolean sendSmsToPlayer;

    /**
     * TelefonnĂ­ ÄŤĂ­slo hrĂˇÄŤe.
     *
     * Hodnota obvykle pochĂˇzĂ­ z {@code PlayerSettings.contactPhone},
     * pĹ™Ă­padnÄ› se pouĹľije fallback hodnota uloĹľenĂˇ pĹ™Ă­mo u hrĂˇÄŤe.
     */
    private String playerPhone;

    // ==================================================
    // GETTERY / SETTERY
    // ==================================================

    public boolean isSendEmailToUser() {
        return sendEmailToUser;
    }

    public void setSendEmailToUser(boolean sendEmailToUser) {
        this.sendEmailToUser = sendEmailToUser;
    }

    public String getUserEmail() {
        return userEmail;
    }

    public void setUserEmail(String userEmail) {
        this.userEmail = userEmail;
    }

    public boolean isSendEmailToPlayer() {
        return sendEmailToPlayer;
    }

    public void setSendEmailToPlayer(boolean sendEmailToPlayer) {
        this.sendEmailToPlayer = sendEmailToPlayer;
    }

    public String getPlayerEmail() {
        return playerEmail;
    }

    public void setPlayerEmail(String playerEmail) {
        this.playerEmail = playerEmail;
    }

    public boolean isSendSmsToPlayer() {
        return sendSmsToPlayer;
    }

    public void setSendSmsToPlayer(boolean sendSmsToPlayer) {
        this.sendSmsToPlayer = sendSmsToPlayer;
    }

    public String getPlayerPhone() {
        return playerPhone;
    }

    public void setPlayerPhone(String playerPhone) {
        this.playerPhone = playerPhone;
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\package-info.java
-----
/**
 * Service vrstva aplikace.
 *
 * Obsahuje aplikaÄŤnĂ­ a business logiku systĂ©mu.
 *
 * ZajiĹˇĹĄuje:
 * - zpracovĂˇnĂ­ poĹľadavkĹŻ z controllerĹŻ,
 * - koordinaci prĂˇce mezi repozitĂˇĹ™i,
 * - rozhodovacĂ­ logiku a validace domĂ©novĂ˝ch pravidel,
 * - vyvolĂˇvĂˇnĂ­ notifikacĂ­ a dalĹˇĂ­ch vedlejĹˇĂ­ch procesĹŻ.
 *
 * Service vrstva:
 * - neĹ™eĹˇĂ­ HTTP ani prezentaci,
 * - pouĹľĂ­vĂˇ repository pro pĹ™Ă­stup k datĹŻm,
 * - pracuje s DTO objekty.
 */
package cz.phsoft.hokej.models.services;

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerHistoryService.java
-----
package cz.phsoft.hokej.models.services;


import cz.phsoft.hokej.models.dto.PlayerHistoryDTO;

import java.util.List;

/**
 * ServisnĂ­ rozhranĂ­ pro prĂˇci s historiĂ­ hrĂˇÄŤĹŻ.
 *
 * SlouĹľĂ­ pouze pro ÄŤtenĂ­ auditnĂ­ch zĂˇznamĹŻ.
 */
public interface PlayerHistoryService {

    /**
     * VrĂˇtĂ­ historii danĂ©ho hrĂˇÄŤe.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return seznam historickĂ˝ch zĂˇznamĹŻ od nejnovÄ›jĹˇĂ­ho po nejstarĹˇĂ­
     */
    List<PlayerHistoryDTO> getHistoryForPlayer(Long playerId);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerHistoryServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.repositories.PlayerHistoryRepository;
import cz.phsoft.hokej.models.dto.PlayerHistoryDTO;
import cz.phsoft.hokej.models.mappers.PlayerHistoryMapper;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * Implementace servisnĂ­ vrstvy pro prĂˇci s historiĂ­ hrĂˇÄŤĹŻ.
 *
 * NeprovĂˇdĂ­ ĹľĂˇdnĂ© zĂˇpisy do databĂˇze â€“ historickĂ© zĂˇznamy
 * jsou vytvĂˇĹ™eny databĂˇzovĂ˝mi triggery.
 */
@Service
public class PlayerHistoryServiceImpl
        implements PlayerHistoryService {

    private final PlayerHistoryRepository repository;
    private final PlayerHistoryMapper mapper;

    public PlayerHistoryServiceImpl(
            PlayerHistoryRepository repository,
            PlayerHistoryMapper mapper
    ) {
        this.repository = repository;
        this.mapper = mapper;
    }

    @Override
    public List<PlayerHistoryDTO> getHistoryForPlayer(Long playerId) {
        return mapper.toDTOList(
                repository.findByPlayerIdOrderByChangedAtDesc(playerId)
        );
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;

import java.time.LocalDateTime;
import java.util.List;

/**
 * RozhranĂ­ pro sprĂˇvu obdobĂ­ neaktivity hrĂˇÄŤĹŻ.
 *
 * Tato service definuje kontrakt pro prĂˇci s ÄŤasovĂ˝mi Ăşseky,
 * ve kterĂ˝ch je hrĂˇÄŤ povaĹľovĂˇn za neaktivnĂ­ho
 * (zranÄ›nĂ­, dovolenĂˇ, dlouhodobĂˇ absence a podobnĂ© situace).
 *
 * OdpovÄ›dnosti:
 * - eviduje obdobĂ­, kdy se hrĂˇÄŤ nemĹŻĹľe ĂşÄŤastnit zĂˇpasĹŻ,
 * - poskytuje pĹ™ehledy obdobĂ­ neaktivity pro konkrĂ©tnĂ­ho hrĂˇÄŤe i pro administraci,
 * - umoĹľĹuje ovÄ›Ĺ™enĂ­, zda je hrĂˇÄŤ v danĂ©m okamĹľiku aktivnĂ­.
 *
 * Tato service:
 * - pracuje s DTO {@link PlayerInactivityPeriodDTO}, nikoliv pĹ™Ă­mo s entitami,
 * - oddÄ›luje business logiku neaktivity od persistence vrstvy.
 *
 * Tato service neĹ™eĹˇĂ­:
 * - autorizaci a role uĹľivatelĹŻ,
 * - notifikace,
 * - UI logiku.
 */
public interface PlayerInactivityPeriodService {

    /**
     * VrĂˇtĂ­ seznam vĹˇech obdobĂ­ neaktivity v systĂ©mu.
     *
     * Typicky se pouĹľĂ­vĂˇ v administrĂˇtorskĂ˝ch pĹ™ehledech.
     *
     * @return seznam vĹˇech obdobĂ­ neaktivity ve formÄ› DTO
     */
    List<PlayerInactivityPeriodDTO> getAll();

    /**
     * VrĂˇtĂ­ obdobĂ­ neaktivity podle jeho ID.
     *
     * @param id ID obdobĂ­ neaktivity
     * @return obdobĂ­ neaktivity ve formÄ› DTO
     */
    PlayerInactivityPeriodDTO getById(Long id);

    /**
     * VrĂˇtĂ­ seznam obdobĂ­ neaktivity pro konkrĂ©tnĂ­ho hrĂˇÄŤe.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return seznam obdobĂ­ neaktivity danĂ©ho hrĂˇÄŤe
     */
    List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId);

    /**
     * VytvoĹ™Ă­ novĂ© obdobĂ­ neaktivity hrĂˇÄŤe.
     *
     * Implementace je zodpovÄ›dnĂˇ za:
     * - validaci ÄŤasovĂ©ho rozsahu (zaÄŤĂˇtek pĹ™ed koncem),
     * - kontrolu pĹ™ekryvĹŻ s existujĂ­cĂ­mi obdobĂ­mi neaktivity.
     *
     * @param dto data novĂ©ho obdobĂ­ neaktivity
     * @return vytvoĹ™enĂ© obdobĂ­ neaktivity ve formÄ› DTO
     */
    PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto);

    /**
     * Aktualizuje existujĂ­cĂ­ obdobĂ­ neaktivity.
     *
     * Implementace je zodpovÄ›dnĂˇ za:
     * - validaci ÄŤasovĂ©ho rozsahu,
     * - kontrolu pĹ™ekryvĹŻ s ostatnĂ­mi obdobĂ­mi neaktivity danĂ©ho hrĂˇÄŤe.
     *
     * @param id  ID obdobĂ­ neaktivity, kterĂ© mĂˇ bĂ˝t upraveno
     * @param dto novĂ© hodnoty obdobĂ­ neaktivity
     * @return aktualizovanĂ© obdobĂ­ neaktivity ve formÄ› DTO
     */
    PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto);

    /**
     * OdstranĂ­ obdobĂ­ neaktivity podle ID.
     *
     * @param id ID obdobĂ­ neaktivity, kterĂ© mĂˇ bĂ˝t smazĂˇno
     */
    void delete(Long id);

    /**
     * OvÄ›Ĺ™Ă­, zda je hrĂˇÄŤ v danĂ©m okamĹľiku aktivnĂ­.
     *
     * Metoda vracĂ­ informaci, zda se zadanĂ˝ ÄŤas
     * nenachĂˇzĂ­ v ĹľĂˇdnĂ©m z evidovanĂ˝ch obdobĂ­ neaktivity hrĂˇÄŤe.
     *
     * TypickĂ© pouĹľitĂ­:
     * - pĹ™i registraci hrĂˇÄŤe na zĂˇpas,
     * - pĹ™i validaci ĂşÄŤasti hrĂˇÄŤe v konkrĂ©tnĂ­m ÄŤase,
     * - pĹ™i filtrovĂˇnĂ­ dostupnĂ˝ch zĂˇpasĹŻ pro hrĂˇÄŤe.
     *
     * @param player   hrĂˇÄŤ, jehoĹľ aktivita se ovÄ›Ĺ™uje
     * @param dateTime ÄŤasovĂ˝ okamĹľik, pro kterĂ˝ se aktivita kontroluje
     * @return true, pokud je hrĂˇÄŤ v danĂ©m ÄŤase aktivnĂ­, jinak false
     */
    boolean isActive(PlayerEntity player, LocalDateTime dateTime);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.data.repositories.PlayerInactivityPeriodRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.InactivityPeriodNotFoundException;
import cz.phsoft.hokej.exceptions.InactivityPeriodOverlapException;
import cz.phsoft.hokej.exceptions.InvalidInactivityPeriodDateException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import cz.phsoft.hokej.models.mappers.PlayerInactivityPeriodMapper;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

/**
 * Service implementace pro sprĂˇvu obdobĂ­ neaktivity hrĂˇÄŤĹŻ.
 *
 * ObchodnĂ­ vĂ˝znam:
 * - urÄŤuje, zda je hrĂˇÄŤ v danĂ©m ÄŤase aktivnĂ­ nebo neaktivnĂ­,
 * - poskytuje podklady pro rozhodovĂˇnĂ­, zda mĹŻĹľe bĂ˝t hrĂˇÄŤ
 *   zaĹ™azen do zĂˇpasu nebo mĂ­t pĹ™Ă­stup k urÄŤitĂ˝m funkcĂ­m.
 *
 * TypickĂ© pouĹľitĂ­:
 * - pĹ™i filtrovĂˇnĂ­ zĂˇpasĹŻ dostupnĂ˝ch pro hrĂˇÄŤe,
 * - v pĹ™Ă­stupovĂ© logice k detailu zĂˇpasu,
 * - pĹ™i registraci hrĂˇÄŤe na zĂˇpas.
 *
 * KlĂ­ÄŤovĂ© pravidlo:
 * - hrĂˇÄŤ nesmĂ­ mĂ­t pĹ™ekrĂ˝vajĂ­cĂ­ se obdobĂ­ neaktivity
 *   (pĹ™ekryv je povaĹľovĂˇn za chybu dat).
 *
 * Tato service:
 * - Ĺ™eĹˇĂ­ pouze domĂ©novĂˇ pravidla pro neaktivitu,
 * - neĹ™eĹˇĂ­ bezpeÄŤnost, role ani notifikace,
 * - vyuĹľĂ­vĂˇ mapper {@link PlayerInactivityPeriodMapper}
 *   pro pĹ™evod mezi entitami a DTO.
 */
@Service
public class PlayerInactivityPeriodServiceImpl implements PlayerInactivityPeriodService {

    private final PlayerInactivityPeriodRepository inactivityRepository;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodMapper mapper;

    public PlayerInactivityPeriodServiceImpl(
            PlayerInactivityPeriodRepository inactivityRepository,
            PlayerRepository playerRepository,
            PlayerInactivityPeriodMapper mapper
    ) {
        this.inactivityRepository = inactivityRepository;
        this.playerRepository = playerRepository;
        this.mapper = mapper;
    }

    // ======================
    // READ OPERACE
    // ======================

    /**
     * VrĂˇtĂ­ vĹˇechna obdobĂ­ neaktivity vĹˇech hrĂˇÄŤĹŻ.
     *
     * PouĹľĂ­vĂˇ se zejmĂ©na v administrĂˇtorskĂ˝ch pĹ™ehledech
     * nebo internĂ­ch reportech.
     *
     * @return seznam vĹˇech obdobĂ­ neaktivity ve formÄ› DTO
     */
    @Override
    public List<PlayerInactivityPeriodDTO> getAll() {
        return inactivityRepository.findAll().stream()
                .map(mapper::toDTO)
                .toList();
    }

    /**
     * VrĂˇtĂ­ konkrĂ©tnĂ­ obdobĂ­ neaktivity podle ID.
     *
     * @param id ID obdobĂ­ neaktivity
     * @return DTO reprezentace obdobĂ­ neaktivity
     * @throws InactivityPeriodNotFoundException pokud zĂˇznam neexistuje
     */
    @Override
    public PlayerInactivityPeriodDTO getById(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new InactivityPeriodNotFoundException(id));

        return mapper.toDTO(entity);
    }

    /**
     * VrĂˇtĂ­ vĹˇechna obdobĂ­ neaktivity konkrĂ©tnĂ­ho hrĂˇÄŤe,
     * seĹ™azenĂˇ podle zaÄŤĂˇtku neaktivity od nejstarĹˇĂ­ho.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return seznam obdobĂ­ neaktivity ve formÄ› DTO
     * @throws PlayerNotFoundException pokud hrĂˇÄŤ neexistuje
     */
    @Override
    public List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId) {
        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));

        return inactivityRepository.findByPlayerOrderByInactiveFromAsc(player).stream()
                .map(mapper::toDTO)
                .toList();
    }

    // ======================
    // CREATE
    // ======================

    /**
     * VytvoĹ™Ă­ novĂ© obdobĂ­ neaktivity hrĂˇÄŤe.
     *
     * PĹ™ed uloĹľenĂ­m se ovÄ›Ĺ™uje:
     * - existence hrĂˇÄŤe,
     * - platnost dat (od/do),
     * - nepĹ™ekrĂ˝vĂˇnĂ­ s jinĂ˝mi obdobĂ­mi neaktivity danĂ©ho hrĂˇÄŤe.
     *
     * @param dto data novĂ©ho obdobĂ­ neaktivity
     * @return novÄ› vytvoĹ™enĂ© obdobĂ­ neaktivity ve formÄ› DTO
     * @throws PlayerNotFoundException              pokud hrĂˇÄŤ neexistuje
     * @throws InvalidInactivityPeriodDateException pokud je rozsah dat neplatnĂ˝
     * @throws InactivityPeriodOverlapException     pokud se novĂ© obdobĂ­ pĹ™ekrĂ˝vĂˇ s existujĂ­cĂ­m
     */
    @Override
    @Transactional
    public PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto) {

        PlayerEntity player = playerRepository.findById(dto.getPlayerId())
                .orElseThrow(() -> new PlayerNotFoundException(dto.getPlayerId()));

        validateDates(dto);

        // kontrola pĹ™ekryvu existujĂ­cĂ­ch obdobĂ­ pro danĂ©ho hrĂˇÄŤe
        boolean overlaps = !inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        player,
                        dto.getInactiveFrom(),
                        dto.getInactiveTo()
                ).isEmpty();

        if (overlaps) {
            throw new InactivityPeriodOverlapException();
        }

        PlayerInactivityPeriodEntity entity = mapper.toEntity(dto, player);
        PlayerInactivityPeriodEntity saved = inactivityRepository.save(entity);

        return mapper.toDTO(saved);
    }

    // ======================
    // UPDATE
    // ======================

    /**
     * Aktualizuje existujĂ­cĂ­ obdobĂ­ neaktivity.
     *
     * Oproti vytvoĹ™enĂ­ novĂ©ho obdobĂ­ se pĹ™i kontrole pĹ™ekryvu
     * ignoruje aktuĂˇlnĂ­ zĂˇznam (aby nebyl povaĹľovĂˇn za kolizi sĂˇm se sebou).
     *
     * @param id  ID upravovanĂ©ho obdobĂ­
     * @param dto novĂ© hodnoty obdobĂ­ neaktivity
     * @return aktualizovanĂ© obdobĂ­ neaktivity ve formÄ› DTO
     * @throws InactivityPeriodNotFoundException     pokud zĂˇznam neexistuje
     * @throws InvalidInactivityPeriodDateException  pokud je rozsah dat neplatnĂ˝
     * @throws InactivityPeriodOverlapException      pokud se upravenĂ© obdobĂ­ pĹ™ekrĂ˝vĂˇ s jinĂ˝m
     */
    @Override
    @Transactional
    public PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto) {

        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new InactivityPeriodNotFoundException(id));

        validateDates(dto);

        // kontrola pĹ™ekryvu â€“ existujĂ­cĂ­ zĂˇznamy kromÄ› aktuĂˇlnĂ­ho ID
        boolean overlaps = inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        entity.getPlayer(),
                        dto.getInactiveFrom(),
                        dto.getInactiveTo()
                ).stream()
                .anyMatch(p -> !p.getId().equals(id));

        if (overlaps) {
            throw new InactivityPeriodOverlapException(
                    "BE - UpravenĂ© obdobĂ­ se pĹ™ekrĂ˝vĂˇ s jinĂ˝m obdobĂ­m neaktivity hrĂˇÄŤe."
            );
        }

        entity.setInactiveFrom(dto.getInactiveFrom());
        entity.setInactiveTo(dto.getInactiveTo());

        PlayerInactivityPeriodEntity saved = inactivityRepository.save(entity);

        return mapper.toDTO(saved);
    }

    // ======================
    // DELETE
    // ======================

    /**
     * SmaĹľe obdobĂ­ neaktivity podle ID.
     *
     * @param id ID obdobĂ­ neaktivity
     * @throws InactivityPeriodNotFoundException pokud zĂˇznam neexistuje
     */
    @Override
    @Transactional
    public void delete(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new InactivityPeriodNotFoundException(id));

        inactivityRepository.delete(entity);
    }

    // ======================
    // AKTIVITA HRĂÄŚE
    // ======================

    /**
     * OvÄ›Ĺ™Ă­, zda je hrĂˇÄŤ v danĂ©m ÄŤase aktivnĂ­.
     *
     * HrĂˇÄŤ je povaĹľovĂˇn za neaktivnĂ­ho, pokud existuje obdobĂ­ neaktivity,
     * kterĂ© danĂ˝ ÄŤasovĂ˝ okamĹľik zahrnuje. Metoda vracĂ­ negaci tĂ©to podmĂ­nky.
     *
     * TypickĂ© pouĹľitĂ­:
     * - v {@link MatchServiceImpl} pĹ™i filtrovĂˇnĂ­ dostupnĂ˝ch zĂˇpasĹŻ,
     * - v pĹ™Ă­stupovĂ© logice k detailu zĂˇpasu,
     * - pĹ™i posuzovĂˇnĂ­, zda mĂˇ hrĂˇÄŤ â€žnĂˇrokâ€ś na ĂşÄŤast v zĂˇpase.
     *
     * @param player   hrĂˇÄŤ, jehoĹľ aktivita se ovÄ›Ĺ™uje
     * @param dateTime ÄŤasovĂ˝ okamĹľik, pro kterĂ˝ se aktivita kontroluje
     * @return true, pokud hrĂˇÄŤ nenĂ­ v danĂ©m ÄŤase v ĹľĂˇdnĂ©m obdobĂ­ neaktivity, jinak false
     */
    @Override
    public boolean isActive(PlayerEntity player, LocalDateTime dateTime) {
        // pokud existuje zĂˇznam pokrĂ˝vajĂ­cĂ­ danĂ˝ ÄŤas â†’ hrĂˇÄŤ je neaktivnĂ­
        return !inactivityRepository
                .existsByPlayerAndInactiveFromLessThanEqualAndInactiveToGreaterThanEqual(
                        player,
                        dateTime,
                        dateTime
                );
    }

    // ======================
    // PRIVĂTNĂŤ VALIDACE
    // ======================

    /**
     * Validuje ÄŤasovĂ˝ rozsah obdobĂ­ neaktivity.
     *
     * Kontroluje se:
     * - Ĺľe datum od i do nenĂ­ null,
     * - Ĺľe datum od je pĹ™ed datem do.
     *
     * @param dto DTO s daty obdobĂ­ neaktivity
     * @throws InvalidInactivityPeriodDateException pĹ™i neplatnĂ©m rozsahu dat
     */
    private void validateDates(PlayerInactivityPeriodDTO dto) {
        if (dto.getInactiveFrom() == null || dto.getInactiveTo() == null) {
            throw new InvalidInactivityPeriodDateException(
                    "BE - Datum od a do nesmĂ­ bĂ˝t null."
            );
        }

        if (!dto.getInactiveFrom().isBefore(dto.getInactiveTo())) {
            throw new InvalidInactivityPeriodDateException(
                    "BE - Datum 'od' musĂ­ bĂ˝t pĹ™ed 'do'."
            );
        }
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;

import java.util.List;

/**
 * RozhranĂ­ pro sprĂˇvu hrĂˇÄŤĹŻ v aplikaci.
 *
 * RozhranĂ­ definuje kontrakt pro prĂˇci s hrĂˇÄŤi z pohledu business logiky,
 * vÄŤetnÄ› jejich vytvĂˇĹ™enĂ­, Ăşprav, schvalovĂˇnĂ­ a vazby na uĹľivatele.
 *
 * OdpovÄ›dnosti:
 * - sprĂˇva ĹľivotnĂ­ho cyklu hrĂˇÄŤĹŻ (vytvoĹ™enĂ­, Ăşprava, smazĂˇnĂ­),
 * - sprĂˇva vazby hrĂˇÄŤĹŻ na uĹľivatelskĂ© ĂşÄŤty,
 * - Ĺ™Ă­zenĂ­ stavu hrĂˇÄŤe (ÄŤekajĂ­cĂ­, schvĂˇlenĂ˝, zamĂ­tnutĂ˝),
 * - sprĂˇva â€žaktuĂˇlnĂ­ho hrĂˇÄŤeâ€ś v kontextu uĹľivatele.
 *
 * RozhranĂ­ se pouĹľĂ­vĂˇ:
 * - v controllerech pro hrĂˇÄŤe a administraci,
 * - v dalĹˇĂ­ch service tĹ™Ă­dĂˇch, kterĂ© potĹ™ebujĂ­ pracovat s hrĂˇÄŤi na DTO Ăşrovni.
 */
public interface PlayerService {

    /**
     * VrĂˇtĂ­ seznam vĹˇech hrĂˇÄŤĹŻ v systĂ©mu.
     *
     * Metoda se pouĹľĂ­vĂˇ typicky v administrĂˇtorskĂ˝ch pĹ™ehledech.
     *
     * @return seznam vĹˇech hrĂˇÄŤĹŻ ve formÄ› {@link PlayerDTO}
     */
    List<PlayerDTO> getAllPlayers();

    /**
     * VrĂˇtĂ­ hrĂˇÄŤe podle jeho ID.
     *
     * @param id ID hrĂˇÄŤe
     * @return hrĂˇÄŤ ve formÄ› {@link PlayerDTO}
     */
    PlayerDTO getPlayerById(Long id);

    /**
     * VytvoĹ™Ă­ novĂ©ho hrĂˇÄŤe bez explicitnĂ­ vazby na uĹľivatele.
     *
     * Typicky se pouĹľĂ­vĂˇ v administraci pro ruÄŤnĂ­ zaloĹľenĂ­ hrĂˇÄŤe.
     *
     * @param player data novĂ©ho hrĂˇÄŤe
     * @return vytvoĹ™enĂ˝ hrĂˇÄŤ ve formÄ› {@link PlayerDTO}
     */
    PlayerDTO createPlayer(PlayerDTO player);

    /**
     * VytvoĹ™Ă­ novĂ©ho hrĂˇÄŤe a pĹ™iĹ™adĂ­ jej ke konkrĂ©tnĂ­mu uĹľivateli.
     *
     * Metoda se pouĹľĂ­vĂˇ v pĹ™Ă­padech, kdy je hrĂˇÄŤ vytvĂˇĹ™en
     * v kontextu jiĹľ existujĂ­cĂ­ho uĹľivatelskĂ©ho ĂşÄŤtu.
     *
     * @param dto       data novĂ©ho hrĂˇÄŤe
     * @param userEmail email uĹľivatele, ke kterĂ©mu mĂˇ bĂ˝t hrĂˇÄŤ pĹ™iĹ™azen
     * @return vytvoĹ™enĂ˝ hrĂˇÄŤ ve formÄ› {@link PlayerDTO}
     */
    PlayerDTO createPlayerForUser(PlayerDTO dto, String userEmail);

    /**
     * Aktualizuje Ăşdaje existujĂ­cĂ­ho hrĂˇÄŤe.
     *
     * Metoda aktualizuje zĂˇkladnĂ­ identifikaÄŤnĂ­ a kontaktnĂ­ Ăşdaje
     * i parametry hrĂˇÄŤe (typ, tĂ˝m, status).
     *
     * @param id     ID hrĂˇÄŤe, kterĂ˝ mĂˇ bĂ˝t aktualizovĂˇn
     * @param player novĂ© hodnoty hrĂˇÄŤe
     * @return aktualizovanĂ˝ hrĂˇÄŤ ve formÄ› {@link PlayerDTO}
     */
    PlayerDTO updatePlayer(Long id, PlayerDTO player);

    /**
     * OdstranĂ­ hrĂˇÄŤe ze systĂ©mu.
     *
     * Typicky se pouĹľĂ­vĂˇ v administraci. NĂˇvratovĂˇ hodnota informuje
     * o ĂşspÄ›chu operace ve formÄ› {@link SuccessResponseDTO}.
     *
     * @param id ID hrĂˇÄŤe, kterĂ˝ mĂˇ bĂ˝t odstranÄ›n
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     */
    SuccessResponseDTO deletePlayer(Long id);

    /**
     * VrĂˇtĂ­ seznam hrĂˇÄŤĹŻ pĹ™iĹ™azenĂ˝ch ke konkrĂ©tnĂ­mu uĹľivateli.
     *
     * Metoda se pouĹľĂ­vĂˇ napĹ™Ă­klad pĹ™i zobrazenĂ­ hrĂˇÄŤĹŻ pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * @param email email uĹľivatele
     * @return seznam hrĂˇÄŤĹŻ danĂ©ho uĹľivatele ve formÄ› {@link PlayerDTO}
     */
    List<PlayerDTO> getPlayersByUser(String email);

    /**
     * SchvĂˇlĂ­ hrĂˇÄŤe.
     *
     * Po schvĂˇlenĂ­ je hrĂˇÄŤ povaĹľovĂˇn za aktivnĂ­ho
     * a mĹŻĹľe se ĂşÄŤastnit zĂˇpasĹŻ podle dalĹˇĂ­ch pravidel aplikace.
     *
     * @param id ID hrĂˇÄŤe
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     */
    SuccessResponseDTO approvePlayer(Long id);

    /**
     * ZamĂ­tne hrĂˇÄŤe.
     *
     * ZamĂ­tnutĂ˝ hrĂˇÄŤ se nepovaĹľuje za aktivnĂ­ho
     * a nemĹŻĹľe se ĂşÄŤastnit zĂˇpasĹŻ.
     *
     * @param id ID hrĂˇÄŤe
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     */
    SuccessResponseDTO rejectPlayer(Long id);

    /**
     * NastavĂ­ aktuĂˇlnĂ­ho hrĂˇÄŤe pro konkrĂ©tnĂ­ho uĹľivatele.
     *
     * Metoda slouĹľĂ­ k explicitnĂ­mu vĂ˝bÄ›ru hrĂˇÄŤe v pĹ™Ă­padÄ›,
     * Ĺľe mĂˇ uĹľivatel pĹ™iĹ™azeno vĂ­ce hrĂˇÄŤĹŻ.
     *
     * @param userEmail email uĹľivatele
     * @param playerId  ID hrĂˇÄŤe, kterĂ˝ mĂˇ bĂ˝t nastaven jako aktuĂˇlnĂ­
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     */
    SuccessResponseDTO setCurrentPlayerForUser(String userEmail, Long playerId);

    /**
     * Automaticky zvolĂ­ aktuĂˇlnĂ­ho hrĂˇÄŤe pro danĂ©ho uĹľivatele
     * podle jeho nastavenĂ­ (AppUserSettings.playerSelectionMode).
     *
     * TypickĂ© pouĹľitĂ­:
     * - po pĹ™ihlĂˇĹˇenĂ­ uĹľivatele,
     * - pĹ™i explicitnĂ­m volĂˇnĂ­ z frontendu (napĹ™Ă­klad tlaÄŤĂ­tko â€žVybrat vĂ˝chozĂ­ho hrĂˇÄŤeâ€ś).
     *
     * @param userEmail email pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     */
    SuccessResponseDTO autoSelectCurrentPlayerForUser(String userEmail);

    /**
     * ZmÄ›nĂ­ pĹ™iĹ™azenĂ©ho uĹľivatele k existujĂ­cĂ­mu hrĂˇÄŤi.
     *
     * Metoda slouĹľĂ­ k administrĂˇtorskĂ© ĂşpravÄ› vazby mezi hrĂˇÄŤem a
     * uĹľivatelskĂ˝m ĂşÄŤtem, napĹ™Ă­klad pĹ™i opravÄ› chybnĂ©ho pĹ™iĹ™azenĂ­
     * nebo pĹ™evodu hrĂˇÄŤe pod jinĂ˝ uĹľivatelskĂ˝ ĂşÄŤet.
     *
     * Implementace mÄ›nĂ­ pouze vazbu hrĂˇÄŤ â†’ uĹľivatel,
     * ostatnĂ­ business logika (napĹ™Ă­klad zmÄ›na current player)
     * je ponechĂˇna volajĂ­cĂ­mu.
     *
     * @param id        ID hrĂˇÄŤe, kterĂ©mu se mĂˇ zmÄ›nit pĹ™iĹ™azenĂ˝ uĹľivatel
     * @param newUserId ID novĂ©ho uĹľivatele, ke kterĂ©mu mĂˇ bĂ˝t hrĂˇÄŤ pĹ™iĹ™azen
     */
    void changePlayerUser(Long id, Long newUserId);

}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerSettingsEntity;
import cz.phsoft.hokej.data.enums.PlayerSelectionMode;
import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.notification.NotificationService;
import jakarta.transaction.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import cz.phsoft.hokej.models.dto.PlayerDTO;

import static cz.phsoft.hokej.data.enums.PlayerStatus.APPROVED;
import static cz.phsoft.hokej.data.enums.PlayerStatus.REJECTED;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Service vrstva pro prĂˇci s hrĂˇÄŤi ({@link PlayerEntity}).
 *
 * Tato tĹ™Ă­da zodpovĂ­dĂˇ za:
 * - provĂˇdÄ›nĂ­ CRUD operacĂ­ nad hrĂˇÄŤi,
 * - kontrolu duplicity jmĂ©na a pĹ™Ă­jmenĂ­,
 * - sprĂˇvu vazby hrĂˇÄŤe na uĹľivatele ({@link AppUserEntity}),
 * - zmÄ›nu statusu hrĂˇÄŤe (APPROVED, REJECTED) vÄŤetnÄ› spuĹˇtÄ›nĂ­ notifikacĂ­,
 * - nastavenĂ­ aktuĂˇlnĂ­ho hrĂˇÄŤe v {@link CurrentPlayerService}
 *   pro pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
 *
 * Tato tĹ™Ă­da neĹ™eĹˇĂ­:
 * - HTTP vrstvu, session a mapovĂˇnĂ­ requestĹŻ a response (Ĺ™eĹˇĂ­ controllery),
 * - autentizaci a autorizaci (Ĺ™eĹˇĂ­ Spring Security a controller vrstva),
 * - detailnĂ­ logiku zĂˇpasĹŻ (Ĺ™eĹˇĂ­ {@link MatchServiceImpl} a navazujĂ­cĂ­ sluĹľby).
 */
@Service
public class PlayerServiceImpl implements PlayerService {

    @Value("${app.demo-mode:false}")
    private boolean isDemoMode;
    private static final Logger logger = LoggerFactory.getLogger(PlayerServiceImpl.class);

    private final PlayerRepository playerRepository;
    private final PlayerMapper playerMapper;
    private final AppUserRepository appUserRepository;
    private final NotificationService notificationService;
    private final CurrentPlayerService currentPlayerService;
    private final AppUserSettingsService appUserSettingsService;
    private final PlayerSettingsService playerSettingsService;

    public PlayerServiceImpl(
            PlayerRepository playerRepository,
            PlayerMapper playerMapper,
            AppUserRepository appUserRepository,
            NotificationService notificationService,
            CurrentPlayerService currentPlayerService,
            AppUserSettingsService appUserSettingsService,
            PlayerSettingsService playerSettingsService
    ) {
        this.playerRepository = playerRepository;
        this.playerMapper = playerMapper;
        this.appUserRepository = appUserRepository;
        this.notificationService = notificationService;
        this.currentPlayerService = currentPlayerService;
        this.appUserSettingsService = appUserSettingsService;
        this.playerSettingsService = playerSettingsService;
    }

    // ======================
    // CREATE / UPDATE / DELETE
    // ======================

    /**
     * VytvoĹ™Ă­ novĂ©ho hrĂˇÄŤe bez vazby na uĹľivatele.
     *
     * PĹ™ed uloĹľenĂ­m se kontroluje duplicita kombinace jmĂ©na a pĹ™Ă­jmenĂ­.
     * Po vytvoĹ™enĂ­ se notifikace neodesĂ­lĂˇ, aby bylo zachovĂˇno pĹŻvodnĂ­ chovĂˇnĂ­.
     *
     * @param dto data novĂ©ho hrĂˇÄŤe
     * @return vytvoĹ™enĂ˝ hrĂˇÄŤ ve formÄ› {@link PlayerDTO}
     */
    @Override
    @Transactional
    public PlayerDTO createPlayer(PlayerDTO dto) {
        ensureUniqueNameSurname(dto.getName(), dto.getSurname(), null);

        PlayerEntity entity = playerMapper.toEntity(dto);
        PlayerEntity saved = playerRepository.save(entity);

        return playerMapper.toDTO(saved);
    }

    /**
     * VytvoĹ™Ă­ novĂ©ho hrĂˇÄŤe a pĹ™iĹ™adĂ­ jej k uĹľivateli podle emailu.
     *
     * Postup:
     * - vyhledĂˇ se uĹľivatel podle emailu,
     * - ovÄ›Ĺ™Ă­ se, Ĺľe neexistuje jinĂ˝ hrĂˇÄŤ se stejnĂ˝m jmĂ©nem a pĹ™Ă­jmenĂ­m,
     * - namapuje se {@link PlayerDTO} na {@link PlayerEntity},
     * - nastavĂ­ se vazba na uĹľivatele a hrĂˇÄŤ se uloĹľĂ­,
     * - odeĹˇle se notifikace {@link NotificationType#PLAYER_CREATED}.
     *
     * @param dto       data novĂ©ho hrĂˇÄŤe
     * @param userEmail email uĹľivatele, ke kterĂ©mu mĂˇ bĂ˝t hrĂˇÄŤ pĹ™iĹ™azen
     * @return vytvoĹ™enĂ˝ hrĂˇÄŤ ve formÄ› {@link PlayerDTO}
     * @throws UserNotFoundException         pokud uĹľivatel neexistuje
     * @throws DuplicateNameSurnameException pokud existuje hrĂˇÄŤ se stejnĂ˝m jmĂ©nem a pĹ™Ă­jmenĂ­m
     */
    @Override
    @Transactional
    public PlayerDTO createPlayerForUser(PlayerDTO dto, String userEmail) {
        AppUserEntity user = appUserRepository.findByEmail(userEmail)
                .orElseThrow(() -> new UserNotFoundException(userEmail));

        ensureUniqueNameSurname(dto.getName(), dto.getSurname(), null);

        PlayerEntity player = playerMapper.toEntity(dto);
        player.setUser(user);
        PlayerEntity saved = playerRepository.save(player);

        notifyPlayer(saved, NotificationType.PLAYER_CREATED, saved);

        return playerMapper.toDTO(saved);
    }

    /**
     * Aktualizuje existujĂ­cĂ­ho hrĂˇÄŤe.
     *
     * PĹ™i zmÄ›nÄ› jmĂ©na nebo pĹ™Ă­jmenĂ­ se kontroluje duplicita kombinace jmĂ©no + pĹ™Ă­jmenĂ­.
     * PotĂ© se pĹ™epĂ­ĹˇĂ­ zĂˇkladnĂ­ Ăşdaje hrĂˇÄŤe a odeĹˇle se notifikace
     * {@link NotificationType#PLAYER_UPDATED}.
     *
     * @param id  ID hrĂˇÄŤe
     * @param dto novĂ© hodnoty hrĂˇÄŤe
     * @return aktualizovanĂ˝ hrĂˇÄŤ ve formÄ› {@link PlayerDTO}
     * @throws PlayerNotFoundException       pokud hrĂˇÄŤ neexistuje
     * @throws DuplicateNameSurnameException pokud novĂˇ kombinace jmĂ©no + pĹ™Ă­jmenĂ­ koliduje
     *                                       s jinĂ˝m hrĂˇÄŤem
     */
    @Override
    @Transactional
    public PlayerDTO updatePlayer(Long id, PlayerDTO dto) {
        PlayerEntity existing = findPlayerOrThrow(id);

        boolean nameChanged =
                !existing.getName().equals(dto.getName()) ||
                        !existing.getSurname().equals(dto.getSurname());

        if (nameChanged) {
            ensureUniqueNameSurname(dto.getName(), dto.getSurname(), id);
        }

        existing.setName(dto.getName());
        existing.setSurname(dto.getSurname());
        existing.setNickname(dto.getNickname());
        existing.setPhoneNumber(dto.getPhoneNumber());
        existing.setType(dto.getType());
        existing.setTeam(dto.getTeam());
        if (dto.getPlayerStatus() != null) {
            existing.setPlayerStatus(dto.getPlayerStatus());
        }

        PlayerEntity saved = playerRepository.save(existing);
        notifyPlayer(saved, NotificationType.PLAYER_UPDATED, saved);

        return playerMapper.toDTO(saved);
    }
    // TODO - Nebude probĂ­hat mazĂˇnĂ­ hrĂˇÄŤe - bude nastaven statut ARCHIVED
    /**
     * SmaĹľe hrĂˇÄŤe podle ID.
     *
     * Po smazĂˇnĂ­ je odeslĂˇna notifikace {@link NotificationType#PLAYER_DELETED}.
     *
     * @param id ID hrĂˇÄŤe
     * @return {@link SuccessResponseDTO} s potvrzujĂ­cĂ­ zprĂˇvou
     * @throws PlayerNotFoundException pokud hrĂˇÄŤ neexistuje
     */
    @Override
    @Transactional
    public SuccessResponseDTO deletePlayer(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);

        if (isDemoMode) {
            throw new DemoModeOperationNotAllowedException(
                    "HrĂˇÄŤ nebude smazĂˇn. Aplikace bÄ›ĹľĂ­ v DEMO reĹľimu."
            );
        }

        playerRepository.delete(player);

        String message = "HrĂˇÄŤ " + player.getFullName() + " byl ĂşspÄ›ĹˇnÄ› smazĂˇn";
        notifyPlayer(player, NotificationType.PLAYER_DELETED, player);

        return buildSuccessResponse(message, id);
    }

   // STATUS â€“ APPROVE / REJECT
    /**
     * SchvĂˇlĂ­ hrĂˇÄŤe a nastavĂ­ mu status {@link PlayerStatus#APPROVED}.
     *
     * Pokud je hrĂˇÄŤ jiĹľ schvĂˇlen, vyhodĂ­ se vĂ˝jimka
     * {@link InvalidPlayerStatusException}. Po schvĂˇlenĂ­ se odeĹˇle
     * notifikace {@link NotificationType#PLAYER_APPROVED}.
     *
     * @param id ID hrĂˇÄŤe
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     */
    @Override
    @Transactional
    public SuccessResponseDTO approvePlayer(Long id) {
        return changePlayerStatus(
                id,
                PlayerStatus.APPROVED,
                PlayerStatus.APPROVED,
                NotificationType.PLAYER_APPROVED,
                "BE - HrĂˇÄŤ uĹľ je schvĂˇlen.",
                "HrĂˇÄŤ %s byl ĂşspÄ›ĹˇnÄ› aktivovĂˇn"
        );
    }
    /**
     * ZamĂ­tne hrĂˇÄŤe a nastavĂ­ mu status {@link PlayerStatus#REJECTED}.
     *
     * Pokud je hrĂˇÄŤ jiĹľ zamĂ­tnut, vyhodĂ­ se vĂ˝jimka
     * {@link InvalidPlayerStatusException}. Po zamĂ­tnutĂ­ se odeĹˇle
     * notifikace {@link NotificationType#PLAYER_REJECTED}.
     *
     * @param id ID hrĂˇÄŤe
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     */
    @Override
    @Transactional
    public SuccessResponseDTO rejectPlayer(Long id) {
        return changePlayerStatus(
                id,
                REJECTED,
                REJECTED,
                NotificationType.PLAYER_REJECTED,
                "BE - HrĂˇÄŤ uĹľ je zamĂ­tnut.",
                "HrĂˇÄŤ %s byl ĂşspÄ›ĹˇnÄ› zamĂ­tnut"
        );
    }

    /**
     * ZmÄ›nĂ­ pĹ™iĹ™azenĂ©ho uĹľivatele k hrĂˇÄŤi a odeĹˇle notifikace
     * o zmÄ›nÄ› vazby hrĂˇÄŤe a uĹľivatele.
     *
     * PĹ™i pokusu pĹ™evĂ©st hrĂˇÄŤe na stejnĂ©ho uĹľivatele se vyhodĂ­
     * {@link InvalidChangePlayerUserException}.
     *
     * @param id        ID hrĂˇÄŤe
     * @param newUserId ID novĂ©ho uĹľivatele
     */
    @Transactional
    public void changePlayerUser(Long id, Long newUserId) {
        PlayerEntity player = findPlayerOrThrow(id);
        AppUserEntity newUser = findUserOrThrow(newUserId);
        AppUserEntity oldUser = player.getUser();

        if (oldUser != null && oldUser.getId().equals(newUserId)) {
            throw new InvalidChangePlayerUserException();
        }
        player.setUser(newUser);
        PlayerEntity saved = playerRepository.save(player);

        notifyPlayer(saved, NotificationType.PLAYER_CHANGE_USER, newUser);
        notifyUser(newUser, NotificationType.PLAYER_CHANGE_USER, player);
    }
    // READ
   /**
     * VrĂˇtĂ­ vĹˇechny hrĂˇÄŤe v systĂ©mu.
     *
     * @return seznam hrĂˇÄŤĹŻ ve formÄ› {@link PlayerDTO}
     */
    @Override
    public List<PlayerDTO> getAllPlayers() {
        return playerRepository.findAll().stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    /**
     * VrĂˇtĂ­ hrĂˇÄŤe podle ID.
     *
     * @param id ID hrĂˇÄŤe
     * @return {@link PlayerDTO} odpovĂ­dajĂ­cĂ­ hrĂˇÄŤi
     * @throws PlayerNotFoundException pokud hrĂˇÄŤ s danĂ˝m ID neexistuje
     */
    @Override
    public PlayerDTO getPlayerById(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);
        return playerMapper.toDTO(player);
    }

    /**
     * VrĂˇtĂ­ vĹˇechny hrĂˇÄŤe pĹ™iĹ™azenĂ© uĹľivateli s danĂ˝m emailem.
     *
     * HrĂˇÄŤi jsou vrĂˇceni v poĹ™adĂ­ podle ID vzestupnÄ›.
     *
     * @param email email uĹľivatele
     * @return seznam hrĂˇÄŤĹŻ ve formÄ› {@link PlayerDTO}
     */
    @Override
    public List<PlayerDTO> getPlayersByUser(String email) {
        return playerRepository.findByUser_EmailOrderByIdAsc(email).stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    // CURRENT PLAYER â€“ SESSION

    /**
     * NastavĂ­ aktuĂˇlnĂ­ho hrĂˇÄŤe pro danĂ©ho uĹľivatele.
     *
     * Nejprve se ovÄ›Ĺ™Ă­, Ĺľe hrĂˇÄŤ existuje a patĹ™Ă­ danĂ©mu uĹľivateli
     * (podle emailu). PotĂ© se jeho ID pĹ™edĂˇ do
     * {@link CurrentPlayerService#setCurrentPlayerId(Long)}.
     *
     * @param userEmail email pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @param playerId  ID hrĂˇÄŤe, kterĂ˝ mĂˇ bĂ˝t nastaven jako aktuĂˇlnĂ­
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     * @throws PlayerNotFoundException        pokud hrĂˇÄŤ neexistuje
     * @throws ForbiddenPlayerAccessException pokud hrĂˇÄŤ nepatĹ™Ă­ danĂ©mu uĹľivateli
     */
    @Override
    public SuccessResponseDTO setCurrentPlayerForUser(String userEmail, Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        assertPlayerBelongsToUser(player, userEmail);

        currentPlayerService.setCurrentPlayerId(playerId);

        String message = "BE - AktuĂˇlnĂ­ hrĂˇÄŤ nastaven na ID: " + playerId;
        return buildSuccessResponse(message, playerId);
    }

    /**
     * Automaticky vybere aktuĂˇlnĂ­ho hrĂˇÄŤe pro uĹľivatele podle
     * nastavenĂ­ v AppUserSettings (playerSelectionMode).
     *
     * ReĹľimy:
     * - FIRST_PLAYER: vĹľdy se vybere prvnĂ­ hrĂˇÄŤ podle ID,
     * - ALWAYS_CHOOSE: automaticky se vybere pouze v pĹ™Ă­padÄ›,
     *   Ĺľe mĂˇ uĹľivatel prĂˇvÄ› jednoho schvĂˇlenĂ©ho hrĂˇÄŤe.
     *
     * @param userEmail email uĹľivatele
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     */
    @Override
    public SuccessResponseDTO autoSelectCurrentPlayerForUser(String userEmail) {

        var userSettingsDto = appUserSettingsService.getSettingsForUser(userEmail);

        PlayerSelectionMode mode = PlayerSelectionMode.FIRST_PLAYER;
        if (userSettingsDto.getPlayerSelectionMode() != null) {
            mode = PlayerSelectionMode.valueOf(userSettingsDto.getPlayerSelectionMode());
        }

        switch (mode) {
            case FIRST_PLAYER:
                return autoSelectFirstPlayer(userEmail);
            case ALWAYS_CHOOSE:
                return autoSelectIfSinglePlayer(userEmail);
            default:
                return autoSelectFirstPlayer(userEmail);
        }
    }

    /**
     * PomocnĂˇ metoda pro reĹľim FIRST_PLAYER.
     *
     * Najde prvnĂ­ho hrĂˇÄŤe uĹľivatele (podle ID) a nastavĂ­ ho
     * jako aktuĂˇlnĂ­ho hrĂˇÄŤe v {@link CurrentPlayerService}.
     * Pokud uĹľivatel nemĂˇ ĹľĂˇdnĂ©ho hrĂˇÄŤe nebo hrĂˇÄŤ nenĂ­ schvĂˇlen,
     * vyhodĂ­ se vĂ˝jimka.
     *
     * @param userEmail email uĹľivatele
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     */
    private SuccessResponseDTO autoSelectFirstPlayer(String userEmail) {
        List<PlayerEntity> players = playerRepository.findByUser_EmailOrderByIdAsc(userEmail);

        if (players.isEmpty()) {
            currentPlayerService.clear();
            throw new PlayerNotFoundException(
                    "BE - UĹľivatel nemĂˇ pĹ™iĹ™azenĂ©ho ĹľĂˇdnĂ©ho hrĂˇÄŤe. Nelze automaticky vybrat.",
                    userEmail
            );
        }

        PlayerEntity firstPlayer = players.get(0);
        if (firstPlayer.getPlayerStatus() != APPROVED) {
            throw new InvalidPlayerStatusException(
                    "BE - Nelze zvolit hrĂˇÄŤe, kterĂ˝ nenĂ­ schvĂˇlen administrĂˇtorem."
            );
        }

        currentPlayerService.setCurrentPlayerId(firstPlayer.getId());
        String message = "BE - Automaticky byl vybrĂˇn prvnĂ­ hrĂˇÄŤ: " + firstPlayer.getFullName();
        return buildSuccessResponse(message, firstPlayer.getId());
    }

    /**
     * PomocnĂˇ metoda pro reĹľim ALWAYS_CHOOSE.
     *
     * Pokud mĂˇ uĹľivatel prĂˇvÄ› jednoho schvĂˇlenĂ©ho hrĂˇÄŤe, tento hrĂˇÄŤ
     * se nastavĂ­ jako aktuĂˇlnĂ­. V ostatnĂ­ch pĹ™Ă­padech se current player
     * vyÄŤistĂ­ a oÄŤekĂˇvĂˇ se ruÄŤnĂ­ vĂ˝bÄ›r na frontendu.
     *
     * @param userEmail email uĹľivatele
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     */
    private SuccessResponseDTO autoSelectIfSinglePlayer(String userEmail) {
        List<PlayerEntity> players = playerRepository
                .findByUser_EmailOrderByIdAsc(userEmail).stream()
                .filter(p -> p.getPlayerStatus() == APPROVED)
                .toList();

        if (players.isEmpty()) {
            currentPlayerService.clear();

            throw new PlayerNotFoundException(
                    "BE - UĹľivatel nemĂˇ pĹ™iĹ™azenĂ©ho ĹľĂˇdnĂ©ho hrĂˇÄŤe schvĂˇlenĂ©ho AdministrĂˇtorem. Nelze automaticky vybrat.",
                    userEmail
            );
        }
        if (players.size() == 1) {
            PlayerEntity onlyPlayer = players.get(0);

            currentPlayerService.setCurrentPlayerId(onlyPlayer.getId());

            String message = "BE - Byl vybrĂˇn jedinĂ˝ schvĂˇlenĂ˝ hrĂˇÄŤ: " + onlyPlayer.getFullName();
            return buildSuccessResponse(message, onlyPlayer.getId());
        }

        currentPlayerService.clear();

        StringBuilder sb = new StringBuilder();
        for (PlayerEntity player : players) {
            sb.append(players.indexOf(player) + 1);
            sb.append(". - ");
            sb.append(player.getFullName());
            sb.append(" / ");
        }
        String message = "BE - UĹľivatel mĂˇ vĂ­ce hrĂˇÄŤĹŻ a musĂ­ je vybrat manuĂˇlnÄ› dle nastavenĂ­: " + sb;
        return buildSuccessResponse(message, 0L);
    }

    // PRIVATE HELPERY â€“ ENTITY / DUPLICITY

    /**
     * Najde hrĂˇÄŤe podle ID nebo vyhodĂ­ {@link PlayerNotFoundException}.
     *
     * @param id ID hrĂˇÄŤe
     * @return entita hrĂˇÄŤe
     */
    private PlayerEntity findPlayerOrThrow(Long id) {
        return playerRepository.findById(id)
                .orElseThrow(() -> new PlayerNotFoundException(id));
    }

    /**
     * Najde uĹľivatele podle ID nebo vyhodĂ­ {@link UserNotFoundException}.
     *
     * @param id ID uĹľivatele
     * @return entita uĹľivatele
     */
    private AppUserEntity findUserOrThrow(Long id) {
        return appUserRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException(id));
    }

    /**
     * ZajistĂ­ unikĂˇtnost kombinace jmĂ©no + pĹ™Ă­jmenĂ­.
     *
     * PĹ™i vytvĂˇĹ™enĂ­ novĂ©ho hrĂˇÄŤe se oÄŤekĂˇvĂˇ ignoreId null.
     * PĹ™i aktualizaci se ignoruje hrĂˇÄŤ se stejnĂ˝m ID, aby nebyl
     * povaĹľovĂˇn za duplicitnĂ­ho sĂˇm se sebou.
     *
     * @param name     jmĂ©no hrĂˇÄŤe
     * @param surname  pĹ™Ă­jmenĂ­ hrĂˇÄŤe
     * @param ignoreId ID hrĂˇÄŤe, kterĂ˝ mĂˇ bĂ˝t ignorovĂˇn, nebo null
     */
    private void ensureUniqueNameSurname(String name, String surname, Long ignoreId) {
        Optional<PlayerEntity> duplicateOpt = playerRepository.findByNameAndSurname(name, surname);

        if (duplicateOpt.isPresent()) {
            PlayerEntity duplicate = duplicateOpt.get();

            if (ignoreId == null || !duplicate.getId().equals(ignoreId)) {
                throw new DuplicateNameSurnameException(name, surname);
            }
        }
    }

    /**
     * OvÄ›Ĺ™Ă­, Ĺľe hrĂˇÄŤ patĹ™Ă­ danĂ©mu uĹľivateli (podle emailu).
     *
     * Pokud hrĂˇÄŤ uĹľivateli nepatĹ™Ă­, vyhodĂ­ se {@link ForbiddenPlayerAccessException}.
     *
     * @param player    hrĂˇÄŤ
     * @param userEmail email uĹľivatele
     */
    private void assertPlayerBelongsToUser(PlayerEntity player, String userEmail) {
        if (player.getUser() == null ||
                player.getUser().getEmail() == null ||
                !player.getUser().getEmail().equals(userEmail)) {

            throw new ForbiddenPlayerAccessException(player.getId());
        }
    }

    /**
     * VytvoĹ™Ă­ standardizovanou ĂşspÄ›Ĺˇnou odpovÄ›ÄŹ {@link SuccessResponseDTO}
     * s danou zprĂˇvou a ID.
     *
     * @param message textovĂˇ zprĂˇva
     * @param id      ID entity, kterĂ© se operace tĂ˝kala
     * @return ĂşspÄ›ĹˇnĂˇ odpovÄ›ÄŹ
     */
    private SuccessResponseDTO buildSuccessResponse(String message, Long id) {
        return new SuccessResponseDTO(
                message,
                id,
                LocalDateTime.now().toString()
        );
    }

    /**
     * ObecnĂˇ pomocnĂˇ metoda pro zmÄ›nu statusu hrĂˇÄŤe (approve/reject).
     *
     * OvÄ›Ĺ™Ă­ se, Ĺľe hrĂˇÄŤ jiĹľ nenĂ­ v cĂ­lovĂ©m stavu, pĹ™Ă­padnÄ› se nastavĂ­
     * vĂ˝chozĂ­ nastavenĂ­ pro hrĂˇÄŤe pĹ™i schvĂˇlenĂ­. Po uloĹľenĂ­ se odeĹˇle
     * notifikace podle novĂ©ho statusu.
     *
     * @param id                     ID hrĂˇÄŤe
     * @param targetStatus           cĂ­lovĂ˝ status
     * @param alreadyStatus          status, kterĂ˝ znamenĂˇ â€žuĹľ je v tomto stavuâ€ś
     * @param notificationType       typ notifikace (pĹ™Ă­padnÄ› pĹ™epsanĂ˝ podle statusu)
     * @param alreadyMessage         zprĂˇva pro pĹ™Ă­pad, Ĺľe je hrĂˇÄŤ jiĹľ v cĂ­lovĂ©m stavu
     * @param successMessageTemplate Ĺˇablona ĂşspÄ›ĹˇnĂ© zprĂˇvy
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     */
    private SuccessResponseDTO changePlayerStatus(Long id,
                                                  PlayerStatus targetStatus,
                                                  PlayerStatus alreadyStatus,
                                                  NotificationType notificationType,
                                                  String alreadyMessage,
                                                  String successMessageTemplate) {

        PlayerEntity player = findPlayerOrThrow(id);

        if (player.getPlayerStatus() == alreadyStatus) {
            throw new InvalidPlayerStatusException(alreadyMessage);
        }

        player.setPlayerStatus(targetStatus);

        if (targetStatus == APPROVED && player.getSettings() == null) {
            PlayerSettingsEntity settings =
                    playerSettingsService.createDefaultSettingsForPlayer(player);
            player.setSettings(settings);
        }
        PlayerEntity saved = playerRepository.save(player);

        notificationType = resolveNotificationType(targetStatus);
        if (notificationType != null) {
            notifyPlayer(saved, notificationType, saved);
        }

        String message = String.format(successMessageTemplate, saved.getFullName());
        return buildSuccessResponse(message, id);
    }

    // PRIVĂTNĂŤ HELPERY â€“ NOTIFIKACE

    private void notifyPlayer(PlayerEntity player, NotificationType type, Object context) {
        notificationService.notifyPlayer(player, type, context);
    }

    private void notifyUser(AppUserEntity user, NotificationType type, Object context) {
        notificationService.notifyUser(user, type, context);
    }

    /**
     * PĹ™evede status hrĂˇÄŤe na typ notifikace.
     *
     * Pokud se pro zadanĂ˝ status notifikace neposĂ­lĂˇ,
     * vracĂ­ se null. Status PENDING se zde nevyuĹľĂ­vĂˇ,
     * protoĹľe notifikace pĹ™i vytvoĹ™enĂ­ hrĂˇÄŤe jsou Ĺ™eĹˇeny jinde.
     *
     * @param newStatus novĂ˝ status hrĂˇÄŤe
     * @return odpovĂ­dajĂ­cĂ­ {@link NotificationType} nebo null
     */
    private NotificationType resolveNotificationType(PlayerStatus newStatus) {
        return switch (newStatus) {
            case APPROVED -> NotificationType.PLAYER_APPROVED;
            case REJECTED -> NotificationType.MATCH_REGISTRATION_CANCELED;
            default -> null;
        };
    }

}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerSettingsService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerSettingsEntity;
import cz.phsoft.hokej.models.dto.PlayerSettingsDTO;

/**
 * Service rozhranĂ­ pro prĂˇci s nastavenĂ­m hrĂˇÄŤe ({@link PlayerSettingsEntity}).
 *
 * OdpovÄ›dnosti:
 * - poskytovat pĹ™Ă­stup k nastavenĂ­ konkrĂ©tnĂ­ho hrĂˇÄŤe,
 * - vytvĂˇĹ™et vĂ˝chozĂ­ nastavenĂ­ hrĂˇÄŤe,
 * - aktualizovat existujĂ­cĂ­ nastavenĂ­ hrĂˇÄŤe na zĂˇkladÄ› DTO.
 *
 * Architektura:
 * - pracuje s {@link PlayerSettingsDTO} jako pĹ™enosovĂ˝m objektem mezi backendem a frontendem,
 * - nezajiĹˇĹĄuje autorizaci ani kontrolu vlastnictvĂ­ hrĂˇÄŤe,
 *   tyto kontroly se provĂˇdÄ›jĂ­ v controlleru nebo ve vyĹˇĹˇĂ­ servisnĂ­ vrstvÄ›.
 */
public interface PlayerSettingsService {

    /**
     * VrĂˇtĂ­ nastavenĂ­ pro hrĂˇÄŤe podle jeho ID.
     *
     * Pokud nastavenĂ­ jeĹˇtÄ› neexistuje, vytvoĹ™Ă­ se z vĂ˝chozĂ­ch hodnot
     * a uloĹľĂ­ se pro danĂ©ho hrĂˇÄŤe. TĂ­m se zajiĹˇĹĄuje, Ĺľe volajĂ­cĂ­ vĹľdy
     * obdrĹľĂ­ platnĂ© nastavenĂ­.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return nastavenĂ­ hrĂˇÄŤe ve formÄ› {@link PlayerSettingsDTO}
     */
    PlayerSettingsDTO getSettingsForPlayer(Long playerId);

    /**
     * Aktualizuje nastavenĂ­ pro hrĂˇÄŤe podle jeho ID.
     *
     * Pokud hrĂˇÄŤ jeĹˇtÄ› nemĂˇ nastavenĂ­, vytvoĹ™Ă­ se vĂ˝chozĂ­ nastavenĂ­
     * a nĂˇslednÄ› se na nÄ›j aplikujĂ­ hodnoty z DTO.
     *
     * @param playerId ID hrĂˇÄŤe
     * @param dto      novĂ© hodnoty nastavenĂ­
     * @return aktualizovanĂ© nastavenĂ­ ve formÄ› {@link PlayerSettingsDTO}
     */
    PlayerSettingsDTO updateSettingsForPlayer(Long playerId, PlayerSettingsDTO dto);

    /**
     * VytvoĹ™Ă­ vĂ˝chozĂ­ nastavenĂ­ pro hrĂˇÄŤe.
     *
     * Metoda pouze vytvĂˇĹ™Ă­ instanci {@link PlayerSettingsEntity}
     * s nastavovanĂ˝mi default hodnotami. UloĹľenĂ­ do databĂˇze
     * je odpovÄ›dnostĂ­ volajĂ­cĂ­ho kĂłdu.
     *
     * @param player hrĂˇÄŤ, ke kterĂ©mu budou defaultnĂ­ hodnoty pĹ™iĹ™azeny
     * @return novĂˇ instance {@link PlayerSettingsEntity} s vĂ˝chozĂ­m nastavenĂ­m
     */
    PlayerSettingsEntity createDefaultSettingsForPlayer(PlayerEntity player);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerSettingsServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerSettingsEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.data.repositories.PlayerSettingsRepository;
import cz.phsoft.hokej.models.dto.PlayerSettingsDTO;
import cz.phsoft.hokej.models.mappers.PlayerSettingsMapper;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

/**
 * Implementace sluĹľby pro prĂˇci s nastavenĂ­m hrĂˇÄŤe ({@link PlayerSettingsEntity}).
 *
 * OdpovÄ›dnosti:
 * - naÄŤĂ­tĂˇnĂ­ nastavenĂ­ hrĂˇÄŤe podle jeho ID,
 * - vytvĂˇĹ™enĂ­ vĂ˝chozĂ­ho nastavenĂ­ pro hrĂˇÄŤe, pokud jeĹˇtÄ› neexistuje,
 * - aktualizace existujĂ­cĂ­ho nastavenĂ­ podle {@link PlayerSettingsDTO}.
 *
 * Tato tĹ™Ă­da:
 * - neĹ™eĹˇĂ­ autorizaci ani ovÄ›Ĺ™ovĂˇnĂ­ vlastnictvĂ­ hrĂˇÄŤe (Ĺ™eĹˇĂ­ controller),
 * - neodesĂ­lĂˇ notifikace, pouze spravuje data v databĂˇzi,
 * - spolupracuje s:
 *   - {@link PlayerRepository} pro ovÄ›Ĺ™enĂ­ existence hrĂˇÄŤe,
 *   - {@link PlayerSettingsRepository} pro prĂˇci s nastavenĂ­m,
 *   - {@link PlayerSettingsMapper} pro mapovĂˇnĂ­ mezi entitou a DTO.
 */
@Service
@Transactional
public class PlayerSettingsServiceImpl implements PlayerSettingsService {

    private final PlayerRepository playerRepository;
    private final PlayerSettingsRepository playerSettingsRepository;
    private final PlayerSettingsMapper mapper;

    public PlayerSettingsServiceImpl(PlayerRepository playerRepository,
                                     PlayerSettingsRepository playerSettingsRepository,
                                     PlayerSettingsMapper mapper) {
        this.playerRepository = playerRepository;
        this.playerSettingsRepository = playerSettingsRepository;
        this.mapper = mapper;
    }

    /**
     * VrĂˇtĂ­ nastavenĂ­ pro hrĂˇÄŤe podle jeho ID.
     *
     * Postup:
     * - ovÄ›Ĺ™Ă­ se existence hrĂˇÄŤe,
     * - pokusĂ­ se naÄŤĂ­st existujĂ­cĂ­ nastavenĂ­ hrĂˇÄŤe,
     * - pokud neexistuje ĹľĂˇdnĂ˝ zĂˇznam, vytvoĹ™Ă­ se vĂ˝chozĂ­ nastavenĂ­
     *   pomocĂ­ {@link #createDefaultSettingsForPlayer(PlayerEntity)} a uloĹľĂ­ se,
     * - vĂ˝sledek se namapuje na {@link PlayerSettingsDTO}.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return nastavenĂ­ hrĂˇÄŤe ve formÄ› {@link PlayerSettingsDTO}
     * @throws PlayerNotFoundException pokud hrĂˇÄŤ neexistuje
     */
    @Override
    public PlayerSettingsDTO getSettingsForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        Optional<PlayerSettingsEntity> existingOpt =
                playerSettingsRepository.findByPlayer(player);

        PlayerSettingsEntity settings = existingOpt.orElseGet(() -> {
            PlayerSettingsEntity created = createDefaultSettingsForPlayer(player);
            return playerSettingsRepository.save(created);
        });

        return mapper.toDTO(settings);
    }

    /**
     * Aktualizuje nastavenĂ­ hrĂˇÄŤe podle jeho ID.
     *
     * Postup:
     * - ovÄ›Ĺ™Ă­ se existence hrĂˇÄŤe,
     * - naÄŤte se existujĂ­cĂ­ nastavenĂ­ hrĂˇÄŤe, nebo se vytvoĹ™Ă­ novĂ© vĂ˝chozĂ­,
     * - na entitu se aplikujĂ­ hodnoty z {@link PlayerSettingsDTO},
     * - zajiĹˇĹĄuje se navĂˇzĂˇnĂ­ na hrĂˇÄŤe (settings.setPlayer),
     * - entita se uloĹľĂ­ a navrĂˇtĂ­ se ve formÄ› DTO.
     *
     * @param playerId ID hrĂˇÄŤe
     * @param dto      novĂ© hodnoty nastavenĂ­
     * @return aktualizovanĂ© nastavenĂ­ ve formÄ› {@link PlayerSettingsDTO}
     * @throws PlayerNotFoundException pokud hrĂˇÄŤ neexistuje
     */
    @Override
    public PlayerSettingsDTO updateSettingsForPlayer(Long playerId, PlayerSettingsDTO dto) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        PlayerSettingsEntity settings = playerSettingsRepository.findByPlayer(player)
                .orElseGet(() -> createDefaultSettingsForPlayer(player));

        mapper.updateEntityFromDTO(dto, settings);

        // pro jistotu se zajiĹˇĹĄuje navĂˇzĂˇnĂ­ na hrĂˇÄŤe
        settings.setPlayer(player);

        PlayerSettingsEntity saved = playerSettingsRepository.save(settings);

        return mapper.toDTO(saved);
    }

    // =========================
    // HELPER METODY
    // =========================

    /**
     * Najde hrĂˇÄŤe podle ID nebo vyhodĂ­ {@link PlayerNotFoundException}.
     *
     * Metoda centralizuje prĂˇci s {@link PlayerRepository} a
     * zjednoduĹˇuje obsluhu chyb pĹ™i neexistujĂ­cĂ­m hrĂˇÄŤi.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return entita hrĂˇÄŤe
     * @throws PlayerNotFoundException pokud hrĂˇÄŤ s danĂ˝m ID neexistuje
     */
    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    /**
     * VytvoĹ™Ă­ vĂ˝chozĂ­ nastavenĂ­ pro danĂ©ho hrĂˇÄŤe.
     *
     * VĂ˝chozĂ­ chovĂˇnĂ­:
     * - kontaktnĂ­ email a telefon jsou ponechĂˇny prĂˇzdnĂ© (null),
     * - emailovĂ© notifikace:
     *   - notifyOnRegistration = true,
     *   - notifyOnExcuse = true,
     *   - notifyOnMatchChange = true,
     *   - notifyOnMatchCancel = true,
     *   - notifyOnPayment = false,
     * - pĹ™ipomĂ­nky:
     *   - notifyReminders = true,
     *   - reminderHoursBefore = 24.
     *
     * Default hodnoty odpovĂ­dajĂ­ pĹŻvodnĂ­ logice, kterĂˇ byla dĹ™Ă­ve
     * uloĹľena pĹ™Ă­mo v entitÄ› {@link PlayerEntity} (emailEnabled, smsEnabled)
     * a nynĂ­ je pĹ™esunuta do dedikovanĂ© entity {@link PlayerSettingsEntity}.
     *
     * Metoda pouze vracĂ­ neinicializovanou entitu, uloĹľenĂ­ do databĂˇze
     * provĂˇdĂ­ volajĂ­cĂ­ kĂłd.
     *
     * @param player hrĂˇÄŤ, pro kterĂ©ho se vĂ˝chozĂ­ nastavenĂ­ vytvĂˇĹ™Ă­
     * @return novĂˇ instance {@link PlayerSettingsEntity} s vĂ˝chozĂ­m nastavenĂ­m
     */
    @Override
    public PlayerSettingsEntity createDefaultSettingsForPlayer(PlayerEntity player) {
        PlayerSettingsEntity settings = new PlayerSettingsEntity();
        settings.setPlayer(player);

        // explicitnÄ› nastavenĂ© default hodnoty

        settings.setContactEmail(null);
        settings.setContactPhone(null);

        // pĹŻvodnĂ­ logika z PlayerEntity.emailEnabled / smsEnabled pĹ™esunuta do nastavenĂ­ hrĂˇÄŤe
        settings.setEmailEnabled(true);
        settings.setSmsEnabled(true);
        settings.setNotifyOnRegistration(true);
        settings.setNotifyOnExcuse(true);
        settings.setNotifyOnMatchChange(true);
        settings.setNotifyOnMatchCancel(true);
        settings.setNotifyOnPayment(false);

        settings.setNotifyReminders(false);
        settings.setReminderHoursBefore(24);

        return settings;
    }

}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerStatsService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.PlayerStatsDTO;

/**
 * Service rozhranĂ­ pro poskytovĂˇnĂ­ statistik hrĂˇÄŤe.
 *
 * SlouĹľĂ­ k zapouzdĹ™enĂ­ business logiky vĂ˝poÄŤtu statistik hrĂˇÄŤe
 * v rĂˇmci aktuĂˇlnĂ­ sezĂłny. Implementace je odpovÄ›dnĂˇ za naÄŤtenĂ­
 * relevantnĂ­ch zĂˇpasĹŻ, vyhodnocenĂ­ aktivity hrĂˇÄŤe a agregaci
 * registraÄŤnĂ­ch statusĹŻ do souhrnnĂ© podoby.
 *
 * Toto rozhranĂ­ je urÄŤeno pro pouĹľitĂ­ v aplikaÄŤnĂ­ vrstvÄ›
 * (napĹ™Ă­klad z controlleru) a oddÄ›luje kontrakt od konkrĂ©tnĂ­
 * implementace vĂ˝poÄŤtu.
 */
public interface PlayerStatsService {

    /**
     * VracĂ­ statistiku hrĂˇÄŤe za aktuĂˇlnĂ­ sezĂłnu.
     *
     * Statistika zahrnuje celkovĂ˝ poÄŤet odehranĂ˝ch zĂˇpasĹŻ sezĂłny
     * a poÄŤty zĂˇpasĹŻ rozdÄ›lenĂ© podle registraÄŤnĂ­ho statusu hrĂˇÄŤe.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, pro kterĂ©ho se statistika poÄŤĂ­tĂˇ.
     * @return DatovĂ˝ pĹ™enosovĂ˝ objekt obsahujĂ­cĂ­ souhrnnĂ© statistiky hrĂˇÄŤe.
     */
    PlayerStatsDTO getPlayerStats(Long playerId);

}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerStatsServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerStatsDTO;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Service vrstva pro vĂ˝poÄŤet statistik hrĂˇÄŤe v rĂˇmci aktuĂˇlnĂ­ sezĂłny.
 *
 * ZajiĹˇĹĄuje vĂ˝bÄ›r odehranĂ˝ch zĂˇpasĹŻ aktuĂˇlnĂ­ sezĂłny a jejich zĂşĹľenĂ­ podle
 * data vytvoĹ™enĂ­ hrĂˇÄŤe a jeho aktivity v danĂ©m termĂ­nu. NĂˇslednÄ› agreguje
 * registrace hrĂˇÄŤe do souhrnnĂ˝ch poÄŤtĹŻ podle statusu.
 *
 * TĹ™Ă­da koordinuje naÄŤtenĂ­ dat pĹ™es repository a deleguje dĂ­lÄŤĂ­ logiku
 * na souvisejĂ­cĂ­ sluĹľby (aktuĂˇlnĂ­ sezĂłna, aktivnĂ­ sezĂłna, obdobĂ­ neaktivity,
 * registrace zĂˇpasĹŻ).
 */
@Service
public class PlayerStatsServiceImpl implements PlayerStatsService {

    private final PlayerRepository playerRepository;
    private final MatchRepository matchRepository;
    private final CurrentSeasonService currentSeasonService;
    private final SeasonService seasonService;
    private final PlayerInactivityPeriodService playerInactivityPeriodService;
    private final MatchRegistrationService matchRegistrationService;

    /**
     * VytvĂˇĹ™Ă­ service pro vĂ˝poÄŤet statistik hrĂˇÄŤe.
     *
     * PouĹľĂ­vĂˇ se napojenĂ­ na repository pro naÄŤĂ­tĂˇnĂ­ hrĂˇÄŤĹŻ a zĂˇpasĹŻ a
     * na sluĹľby, kterĂ© poskytujĂ­ identifikĂˇtor aktuĂˇlnĂ­ sezĂłny, aktivnĂ­ sezĂłnu,
     * vyhodnocenĂ­ aktivity hrĂˇÄŤe v ÄŤase a registrace zĂˇpasĹŻ.
     *
     * @param playerRepository Repository pro prĂˇci s hrĂˇÄŤi.
     * @param matchRepository Repository pro prĂˇci se zĂˇpasy.
     * @param currentSeasonService Service poskytujĂ­cĂ­ identifikĂˇtor aktuĂˇlnĂ­ sezĂłny.
     * @param seasonService Service poskytujĂ­cĂ­ aktivnĂ­ sezĂłnu jako fallback.
     * @param playerInactivityPeriodService Service pro vyhodnocenĂ­ aktivity hrĂˇÄŤe v termĂ­nu zĂˇpasu.
     * @param matchRegistrationService Service pro naÄŤĂ­tĂˇnĂ­ registracĂ­ hrĂˇÄŤĹŻ na zĂˇpasy.
     */
    public PlayerStatsServiceImpl(PlayerRepository playerRepository,
                                  MatchRepository matchRepository,
                                  CurrentSeasonService currentSeasonService,
                                  SeasonService seasonService,
                                  PlayerInactivityPeriodService playerInactivityPeriodService,
                                  MatchRegistrationService matchRegistrationService) {
        this.playerRepository = playerRepository;
        this.matchRepository = matchRepository;
        this.currentSeasonService = currentSeasonService;
        this.seasonService = seasonService;
        this.playerInactivityPeriodService = playerInactivityPeriodService;
        this.matchRegistrationService = matchRegistrationService;
    }

    /**
     * VracĂ­ statistiky hrĂˇÄŤe pro odehranĂ© zĂˇpasy aktuĂˇlnĂ­ sezĂłny.
     *
     * Nejprve se naÄŤte hrĂˇÄŤ a datum jeho vytvoĹ™enĂ­. NĂˇslednÄ› se naÄŤtou
     * vĹˇechny odehranĂ© zĂˇpasy aktuĂˇlnĂ­ sezĂłny a spoÄŤĂ­tĂˇ se jejich celkovĂ˝ poÄŤet.
     * ZĂˇpasy se dĂˇle filtrujĂ­ tak, aby byly zahrnuty pouze zĂˇpasy po vytvoĹ™enĂ­ hrĂˇÄŤe
     * a pouze ty, ve kterĂ˝ch byl hrĂˇÄŤ v danĂ©m ÄŤase aktivnĂ­.
     *
     * Pokud pro hrĂˇÄŤe nejsou ĹľĂˇdnĂ© relevantnĂ­ zĂˇpasy, vracĂ­ se DTO s vyplnÄ›nĂ˝m
     * identifikĂˇtorem hrĂˇÄŤe a poÄŤtem zĂˇpasĹŻ v sezĂłnÄ› a ostatnĂ­ hodnoty zĹŻstĂˇvajĂ­ nulovĂ©.
     *
     * Pro relevantnĂ­ zĂˇpasy se naÄŤtou registrace a vytvoĹ™Ă­ se mapovĂˇnĂ­ matchId na status
     * pouze pro danĂ©ho hrĂˇÄŤe. Pro zĂˇpasy bez registrace se pouĹľije vĂ˝chozĂ­ status NO_RESPONSE.
     * Nakonec se agregovanĂ© poÄŤty pĹ™enesou do nĂˇvratovĂ©ho DTO.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, pro kterĂ©ho se statistiky poÄŤĂ­tajĂ­.
     * @return DTO obsahujĂ­cĂ­ souhrnnĂ© poÄŤty zĂˇpasĹŻ podle statusĹŻ a poÄŤet zĂˇpasĹŻ v sezĂłnÄ›.
     * @throws PlayerNotFoundException Pokud hrĂˇÄŤ se zadanĂ˝m identifikĂˇtorem neexistuje.
     */
    @Override
    public PlayerStatsDTO getPlayerStats(Long playerId) {
        PlayerEntity player = getPlayerOrThrow(playerId);
        LocalDateTime playerCreatedDate = player.getTimestamp();

        List<MatchEntity> pastMatchesInSeason = findPastMatchesForCurrentSeason();
        int allMatchesInCurrentSeason = pastMatchesInSeason.size();

        List<MatchEntity> availableMatches =
                pastMatchesInSeason.stream()
                        .filter(match -> match.getDateTime().isAfter(playerCreatedDate))
                        .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                        .toList();

        int allMatchesInSeasonForPlayer = availableMatches.size();

        PlayerStatsDTO statsDTO = new PlayerStatsDTO();
        statsDTO.setPlayerId(playerId);
        statsDTO.setAllMatchesInSeason(allMatchesInCurrentSeason);
        statsDTO.setAllMatchesInSeasonForPlayer(allMatchesInSeasonForPlayer);
        statsDTO.setHomeTeam(player.getTeam());

        // vĹľdy pĹ™ipravĂ­me mapu se vĹˇemi tĂ˝my (aĹĄ je vĂ˝stup stabilnĂ­ pro FE)
        EnumMap<Team, Integer> registeredByTeam = new EnumMap<>(Team.class);
        for (Team t : Team.values()) {
            registeredByTeam.put(t, 0);
        }

        if (availableMatches.isEmpty()) {
            statsDTO.setRegisteredByTeam(registeredByTeam);
            return statsDTO;
        }

        List<Long> matchIds = availableMatches.stream()
                .map(MatchEntity::getId)
                .toList();

        List<MatchRegistrationDTO> allRegistrations =
                matchRegistrationService.getRegistrationsForMatches(matchIds);

        Map<Long, PlayerMatchStatus> playerStatusByMatchId = allRegistrations.stream()
                .filter(r -> playerId.equals(r.getPlayerId()))
                .collect(Collectors.toMap(
                        MatchRegistrationDTO::getMatchId,
                        MatchRegistrationDTO::getStatus,
                        (a, b) -> a
                ));

        Map<Long, Team> playerTeamByMatchId = allRegistrations.stream()
                .filter(r -> playerId.equals(r.getPlayerId()))
                .collect(Collectors.toMap(
                        MatchRegistrationDTO::getMatchId,
                        MatchRegistrationDTO::getTeam,
                        (a, b) -> a
                ));

        EnumMap<PlayerMatchStatus, Integer> counts = new EnumMap<>(PlayerMatchStatus.class);

        for (MatchEntity match : availableMatches) {
            PlayerMatchStatus status = playerStatusByMatchId.getOrDefault(
                    match.getId(),
                    PlayerMatchStatus.NO_RESPONSE
            );

            counts.merge(status, 1, Integer::sum);

            // jen REGISTERED a jen podle team z registrace
            if (status == PlayerMatchStatus.REGISTERED) {
                Team team = playerTeamByMatchId.get(match.getId());
                if (team != null) {
                    registeredByTeam.merge(team, 1, Integer::sum);
                }
            }
        }

        statsDTO.setRegistered(counts.getOrDefault(PlayerMatchStatus.REGISTERED, 0));
        statsDTO.setUnregistered(counts.getOrDefault(PlayerMatchStatus.UNREGISTERED, 0));
        statsDTO.setExcused(counts.getOrDefault(PlayerMatchStatus.EXCUSED, 0));
        statsDTO.setSubstituted(counts.getOrDefault(PlayerMatchStatus.SUBSTITUTE, 0));
        statsDTO.setReserved(counts.getOrDefault(PlayerMatchStatus.RESERVED, 0));
        statsDTO.setNoResponse(counts.getOrDefault(PlayerMatchStatus.NO_RESPONSE, 0));
        statsDTO.setNoExcused(counts.getOrDefault(PlayerMatchStatus.NO_EXCUSED, 0));

        // stabilnĂ­ mapa pro FE (obsahuje vĹˇechny Team.values())
        statsDTO.setRegisteredByTeam(registeredByTeam);

        return statsDTO;
    }

    /**
     * NaÄŤĂ­tĂˇ odehranĂ© zĂˇpasy aktuĂˇlnĂ­ sezĂłny.
     *
     * ZĂˇpasy se vybĂ­rajĂ­ podle identifikĂˇtoru sezĂłny a data zĂˇpasu menĹˇĂ­ho neĹľ aktuĂˇlnĂ­ ÄŤas.
     * VĂ˝sledek se Ĺ™adĂ­ sestupnÄ› podle data zĂˇpasu.
     *
     * @return Seznam odehranĂ˝ch zĂˇpasĹŻ aktuĂˇlnĂ­ sezĂłny.
     */
    private List<MatchEntity> findPastMatchesForCurrentSeason() {
        return matchRepository.findBySeasonIdAndDateTimeBeforeOrderByDateTimeDesc(
                getCurrentSeasonIdOrActive(),
                now()
        );
    }

    /**
     * VracĂ­ hrĂˇÄŤe podle identifikĂˇtoru nebo vyhazuje vĂ˝jimku, pokud neexistuje.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe.
     * @return Entita hrĂˇÄŤe.
     * @throws PlayerNotFoundException Pokud hrĂˇÄŤ se zadanĂ˝m identifikĂˇtorem neexistuje.
     */
    private PlayerEntity getPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    /**
     * UrÄŤuje identifikĂˇtor sezĂłny, pro kterou se majĂ­ poÄŤĂ­tat statistiky.
     *
     * PrimĂˇrnÄ› se pouĹľĂ­vĂˇ identifikĂˇtor aktuĂˇlnĂ­ sezĂłny poskytnutĂ˝ sluĹľbou.
     * Pokud nenĂ­ dostupnĂ˝, pouĹľije se identifikĂˇtor aktivnĂ­ sezĂłny.
     *
     * @return IdentifikĂˇtor sezĂłny pouĹľitĂ˝ pro vĂ˝bÄ›r zĂˇpasĹŻ.
     */
    private Long getCurrentSeasonIdOrActive() {
        Long id = currentSeasonService.getCurrentSeasonIdOrDefault();
        if (id != null) {
            return id;
        }
        return seasonService.getActiveSeason().getId();
    }

    /**
     * VracĂ­ aktuĂˇlnĂ­ ÄŤas pouĹľĂ­vanĂ˝ pro porovnĂˇnĂ­ termĂ­nu zĂˇpasĹŻ.
     *
     * @return AktuĂˇlnĂ­ ÄŤas.
     */
    private LocalDateTime now() {
        return LocalDateTime.now();
    }

    /**
     * Vyhodnocuje, zda byl hrĂˇÄŤ aktivnĂ­ v dobÄ› konĂˇnĂ­ zĂˇpasu.
     *
     * VĂ˝sledek se deleguje na sluĹľbu spravujĂ­cĂ­ obdobĂ­ neaktivity hrĂˇÄŤe.
     *
     * @param player HrĂˇÄŤ, pro kterĂ©ho se aktivita vyhodnocuje.
     * @param dateTime TermĂ­n zĂˇpasu.
     * @return True, pokud byl hrĂˇÄŤ v danĂ©m termĂ­nu aktivnĂ­.
     */
    private boolean isPlayerActiveForMatch(PlayerEntity player, LocalDateTime dateTime) {
        return playerInactivityPeriodService.isActive(player, dateTime);
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\SeasonHistoryService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.SeasonHistoryDTO;

import java.util.List;

/**
 * Service rozhranĂ­ pouĹľĂ­vanĂ© pro poskytovĂˇnĂ­ historickĂ˝ch dat sezĂłny.
 *
 * RozhranĂ­ definuje kontrakt pro naÄŤĂ­tĂˇnĂ­ pĹ™ehledovĂ˝ch nebo statistickĂ˝ch ĂşdajĹŻ
 * vztahujĂ­cĂ­ch se ke konkrĂ©tnĂ­ sezĂłnÄ›. Implementace je odpovÄ›dnĂˇ za sestavenĂ­
 * historickĂ˝ch dat z pĹ™Ă­sluĹˇnĂ˝ch entit a jejich pĹ™evod do DTO vrstvy.
 *
 * Vrstva service zajiĹˇĹĄuje business logiku a agregace dat. Controller vrstva
 * vyuĹľĂ­vĂˇ toto rozhranĂ­ pro zpĹ™Ă­stupnÄ›nĂ­ historie sezĂłny klientovi aplikace.
 */
public interface SeasonHistoryService {

    /**
     * VracĂ­ historickĂˇ data pro zadanou sezĂłnu.
     *
     * Implementace naÄŤĂ­tĂˇ potĹ™ebnĂˇ data pro danou sezĂłnu,
     * provĂˇdĂ­ agregace nebo vĂ˝poÄŤty podle business pravidel
     * a vĂ˝sledek pĹ™evĂˇdĂ­ do seznamu {@link SeasonHistoryDTO}.
     *
     * @param seasonId IdentifikĂˇtor sezĂłny, pro kterou se historie naÄŤĂ­tĂˇ.
     * @return Seznam historickĂ˝ch zĂˇznamĹŻ sezĂłny ve formÄ› DTO.
     */
    List<SeasonHistoryDTO> getHistoryForSeason(Long seasonId);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\SeasonHistoryServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.repositories.SeasonHistoryRepository;
import cz.phsoft.hokej.models.dto.SeasonHistoryDTO;
import cz.phsoft.hokej.models.mappers.SeasonHistoryMapper;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * Implementace service vrstvy pouĹľĂ­vanĂˇ pro poskytovĂˇnĂ­ historickĂ˝ch dat sezĂłny.
 *
 * TĹ™Ă­da zajiĹˇĹĄuje naÄŤtenĂ­ zĂˇznamĹŻ historie sezĂłny z repository vrstvy a jejich pĹ™evod do DTO.
 * NaÄŤĂ­tĂˇnĂ­ dat se deleguje do {@link SeasonHistoryRepository} a mapovĂˇnĂ­ entit na DTO se deleguje
 * do {@link SeasonHistoryMapper}.
 *
 * Implementace neposkytuje zĂˇpisovou logiku a slouĹľĂ­ pouze pro ÄŤtenĂ­ a prezentaci historie sezĂłny
 * vyĹˇĹˇĂ­m vrstvĂˇm aplikace, typicky controller vrstvÄ›.
 */
@Service
public class SeasonHistoryServiceImpl implements SeasonHistoryService {

    private final SeasonHistoryRepository repository;
    private final SeasonHistoryMapper mapper;

    public SeasonHistoryServiceImpl(
            SeasonHistoryRepository repository,
            SeasonHistoryMapper mapper
    ) {
        this.repository = repository;
        this.mapper = mapper;
    }

    /**
     * VracĂ­ historickĂˇ data pro zadanou sezĂłnu seĹ™azenĂˇ od nejnovÄ›jĹˇĂ­ zmÄ›ny.
     *
     * Data se naÄŤĂ­tajĂ­ z repository vrstvy filtrovĂˇnĂ­m podle identifikĂˇtoru sezĂłny.
     * VĂ˝sledek se pĹ™evĂˇdĂ­ do {@link SeasonHistoryDTO} pomocĂ­ mapper vrstvy.
     *
     * @param seasonId IdentifikĂˇtor sezĂłny, pro kterou se historie naÄŤĂ­tĂˇ.
     * @return Seznam historickĂ˝ch zĂˇznamĹŻ sezĂłny ve formÄ› DTO seĹ™azenĂ˝ sestupnÄ› podle ÄŤasu zmÄ›ny.
     */
    @Override
    public List<SeasonHistoryDTO> getHistoryForSeason(Long seasonId) {
        return mapper.toDTOList(
                repository.findBySeasonIdOrderByChangedAtDesc(seasonId)
        );
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\SeasonService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.SeasonEntity;
import cz.phsoft.hokej.models.dto.SeasonDTO;

import java.util.List;

/**
 * RozhranĂ­ pro sprĂˇvu sezĂłn v aplikaci.
 *
 * OdpovÄ›dnosti:
 * - definovat kontrakt pro prĂˇci se sezĂłnami jako ÄŤasovĂ˝m rĂˇmcem pro zĂˇpasy a statistiky,
 * - poskytovat operace pro vytvoĹ™enĂ­, Ăşpravu a naÄŤtenĂ­ sezĂłn,
 * - urÄŤovat aktivnĂ­ sezĂłnu, kterĂˇ se pouĹľĂ­vĂˇ v ostatnĂ­ch sluĹľbĂˇch (napĹ™. MatchServiceImpl).
 *
 * Architektura:
 * - vÄ›tĹˇina operacĂ­ pracuje s {@link SeasonDTO} jako pĹ™enosovĂ˝m objektem,
 * - metoda {@link #getActiveSeason()} vracĂ­ entitu {@link SeasonEntity}
 *   pro internĂ­ business logiku v jinĂ˝ch sluĹľbĂˇch.
 */
public interface SeasonService {

    /**
     * VytvoĹ™Ă­ novou sezĂłnu.
     *
     * OdpovÄ›dnost implementace:
     * - validovat datumovĂ© rozmezĂ­ sezĂłny,
     * - zajistit, aby se obdobĂ­ sezĂłny nepĹ™ekrĂ˝valo s jinĂ˝mi sezĂłnami.
     *
     * @param season data novĂ© sezĂłny
     * @return vytvoĹ™enĂˇ sezĂłna ve formÄ› {@link SeasonDTO}
     */
    SeasonDTO createSeason(SeasonDTO season);

    /**
     * Aktualizuje existujĂ­cĂ­ sezĂłnu.
     *
     * Implementace typicky:
     * - ovÄ›Ĺ™uje existenci sezĂłny,
     * - validuje datumovĂ© rozmezĂ­ a pĹ™ekryvy,
     * - aplikuje zmÄ›ny z DTO do entity.
     *
     * @param id     ID sezĂłny, kterĂˇ mĂˇ bĂ˝t aktualizovĂˇna
     * @param season novĂ© hodnoty sezĂłny
     * @return aktualizovanĂˇ sezĂłna ve formÄ› {@link SeasonDTO}
     */
    SeasonDTO updateSeason(Long id, SeasonDTO season);

    /**
     * VrĂˇtĂ­ aktuĂˇlnÄ› aktivnĂ­ sezĂłnu.
     *
     * AktivnĂ­ sezĂłna pĹ™edstavuje ÄŤasovĂ˝ rĂˇmec, ve kterĂ©m se povaĹľujĂ­
     * zĂˇpasy a jejich statistiky za â€žplatnĂ©â€ś. Hodnota se pouĹľĂ­vĂˇ
     * v dalĹˇĂ­ch sluĹľbĂˇch, napĹ™Ă­klad v {@code MatchServiceImpl}.
     *
     * @return aktivnĂ­ sezĂłna jako entita {@link SeasonEntity}
     */
    SeasonEntity getActiveSeason();

    /**
     * VrĂˇtĂ­ seznam vĹˇech sezĂłn v systĂ©mu.
     *
     * Metoda se typicky pouĹľĂ­vĂˇ v administrĂˇtorskĂ˝ch pĹ™ehledech
     * a v UI pro sprĂˇvu sezĂłn.
     *
     * @return seznam vĹˇech sezĂłn ve formÄ› {@link SeasonDTO}
     */
    List<SeasonDTO> getAllSeasons();

    /**
     * NastavĂ­ zadanou sezĂłnu jako aktivnĂ­.
     *
     * Implementace zajiĹˇĹĄuje, Ĺľe v systĂ©mu existuje
     * vĹľdy nejvĂ˝Ĺˇe jedna aktivnĂ­ sezĂłna.
     *
     * @param seasonId ID sezĂłny, kterĂˇ mĂˇ bĂ˝t nastavena jako aktivnĂ­
     */
    void setActiveSeason(Long seasonId);

    /**
     * VrĂˇtĂ­ aktivnĂ­ sezĂłnu ve formÄ› {@link SeasonDTO} nebo null,
     * pokud ĹľĂˇdnĂˇ aktivnĂ­ sezĂłna nenĂ­ nastavena.
     *
     * Metoda se pouĹľĂ­vĂˇ tam, kde je absence aktivnĂ­ sezĂłny
     * platnĂ˝m a oÄŤekĂˇvanĂ˝m stavem.
     *
     * @return aktivnĂ­ sezĂłna nebo null
     */
    SeasonDTO getActiveSeasonOrNull();

    /**
     * VrĂˇtĂ­ sezĂłnu podle jejĂ­ho ID.
     *
     * PouĹľĂ­vĂˇ se v administrĂˇtorskĂ© ÄŤĂˇsti a internĂ­ logice,
     * kde je potĹ™eba pracovat s konkrĂ©tnĂ­ sezĂłnou.
     *
     * @param id ID sezĂłny
     * @return sezĂłna ve formÄ› {@link SeasonDTO}
     */
    SeasonDTO getSeasonById(Long id);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\SeasonServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.SeasonEntity;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.SeasonRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.models.dto.SeasonDTO;
import cz.phsoft.hokej.models.mappers.SeasonMapper;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;

import java.time.LocalDate;
import java.util.List;

/**
 * Implementace service vrstvy pouĹľĂ­vanĂˇ pro sprĂˇvu sezĂłn.
 *
 * TĹ™Ă­da zajiĹˇĹĄuje vytvĂˇĹ™enĂ­ a Ăşpravy sezĂłn vÄŤetnÄ› validace datumovĂ©ho rozsahu, kontroly pĹ™ekryvĹŻ a kontroly duplicity nĂˇzvu.
 * SouÄŤasnÄ› se zajiĹˇĹĄuje sprĂˇva aktivnĂ­ sezĂłny tak, aby byl v systĂ©mu v jeden okamĹľik aktivnĂ­ prĂˇvÄ› jeden zĂˇznam.
 *
 * NaÄŤĂ­tĂˇnĂ­ a uklĂˇdĂˇnĂ­ dat se deleguje do {@link SeasonRepository} a pĹ™evod mezi entitou a DTO se deleguje do {@link SeasonMapper}.
 * IdentifikĂˇtor autora vytvoĹ™enĂ­ sezĂłny se odvozuje z bezpeÄŤnostnĂ­ho kontextu a dohledĂˇvĂˇ se pĹ™es {@link AppUserRepository}.
 *
 * TĹ™Ă­da neĹ™eĹˇĂ­ autorizaci endpointĹŻ, protoĹľe kontrola oprĂˇvnÄ›nĂ­ se pĹ™edpoklĂˇdĂˇ v controller vrstvÄ›.
 * ZĂˇroveĹ se zde neodesĂ­lajĂ­ notifikace a Ĺ™eĹˇĂ­ se pouze konzistence domĂ©novĂ©ho stavu sezĂłn.
 */
@Service
public class SeasonServiceImpl implements SeasonService {

    private final SeasonRepository seasonRepository;
    private final SeasonMapper mapper;
    private final AppUserRepository appUserRepository;

    public SeasonServiceImpl(SeasonRepository seasonRepository,
                             SeasonMapper mapper,
                             AppUserRepository appUserRepository) {
        this.seasonRepository = seasonRepository;
        this.mapper = mapper;
        this.appUserRepository = appUserRepository;
    }

    // CREATE

    /**
     * VytvĂˇĹ™Ă­ novou sezĂłnu.
     *
     * PĹ™ed uloĹľenĂ­m se provĂˇdĂ­ validace datumovĂ©ho rozmezĂ­, kontrola pĹ™ekryvu s existujĂ­cĂ­mi sezĂłnami a kontrola duplicity nĂˇzvu.
     * NĂˇslednÄ› se DTO pĹ™evede na entitu a uloĹľĂ­ se pĹ™es repository vrstvu. Do entity se doplnĂ­ identifikĂˇtor uĹľivatele,
     * kterĂ˝ sezĂłnu vytvoĹ™il, pokud je moĹľnĂ© jej odvodit z autentizace.
     *
     * Po uloĹľenĂ­ se vynucuje invariant aktivnĂ­ sezĂłny. Pokud je novĂˇ sezĂłna oznaÄŤena jako aktivnĂ­, nastavĂ­ se jako jedinĂˇ aktivnĂ­.
     * Pokud aktivnĂ­ sezĂłna v systĂ©mu neexistuje, nastavĂ­ se vytvoĹ™enĂˇ sezĂłna jako aktivnĂ­ automaticky.
     *
     * @param seasonDTO VstupnĂ­ data sezĂłny.
     * @return VytvoĹ™enĂˇ sezĂłna ve formÄ› {@link SeasonDTO}.
     * @throws InvalidSeasonPeriodDateException Pokud jsou neplatnĂˇ data od a do.
     * @throws SeasonPeriodOverlapException Pokud se sezĂłna pĹ™ekrĂ˝vĂˇ s existujĂ­cĂ­ sezĂłnou.
     * @throws DuplicateSeasonNameException Pokud jiĹľ existuje sezĂłna se stejnĂ˝m nĂˇzvem.
     */
    @Override
    @Transactional
    public SeasonDTO createSeason(SeasonDTO seasonDTO) {
        validateDates(seasonDTO, null);
        checkSeasonName(seasonDTO, null);

        SeasonEntity entity = mapper.toEntity(seasonDTO);

        // *** NOVĂ‰ *** â€“ nastavĂ­me ID uĹľivatele, kterĂ˝ sezĂłnu vytvoĹ™il
        Long currentUserId = getCurrentUserIdOrNull();
        entity.setCreatedByUserId(currentUserId);

        SeasonEntity saved = seasonRepository.save(entity);

        long activeCount = seasonRepository.countByActiveTrue();

        if (seasonDTO.isActive()) {
            setOnlyActiveSeason(saved.getId());
        } else if (activeCount == 0) {
            setOnlyActiveSeason(saved.getId());
        }

        return mapper.toDTO(saved);
    }

    // UPDATE

    /**
     * Aktualizuje existujĂ­cĂ­ sezĂłnu.
     *
     * Nejprve se ovÄ›Ĺ™Ă­ existence sezĂłny podle identifikĂˇtoru. PotĂ© se zvaliduje datumovĂ© rozmezĂ­ a pĹ™ekryvy s ostatnĂ­mi sezĂłnami
     * s tĂ­m, Ĺľe upravovanĂˇ sezĂłna se pĹ™i kontrole pĹ™ekryvĹŻ ignoruje. SouÄŤasnÄ› se kontroluje duplicita nĂˇzvu sezĂłny.
     *
     * PĹ™i pokusu o deaktivaci aktivnĂ­ sezĂłny se ovÄ›Ĺ™uje, Ĺľe v systĂ©mu zĹŻstane alespoĹ jedna aktivnĂ­ sezĂłna.
     * NĂˇslednÄ› se zmÄ›ny z DTO promĂ­tnou do entity pomocĂ­ mapper vrstvy a sezĂłna se uloĹľĂ­ pĹ™es repository vrstvu.
     *
     * Pokud se sezĂłna stane novÄ› aktivnĂ­, nastavĂ­ se jako jedinĂˇ aktivnĂ­ sezĂłna a ostatnĂ­ sezĂłny se deaktivujĂ­.
     *
     * @param id IdentifikĂˇtor upravovanĂ© sezĂłny.
     * @param seasonDTO NovĂ© hodnoty sezĂłny.
     * @return AktualizovanĂˇ sezĂłna ve formÄ› {@link SeasonDTO}.
     * @throws SeasonNotFoundException Pokud sezĂłna s danĂ˝m ID neexistuje.
     * @throws InvalidSeasonPeriodDateException Pokud jsou neplatnĂˇ data od a do.
     * @throws SeasonPeriodOverlapException Pokud se sezĂłna pĹ™ekrĂ˝vĂˇ s jinou sezĂłnou.
     * @throws InvalidSeasonStateException Pokud se pokouĹˇĂ­ deaktivovat jedinĂˇ aktivnĂ­ sezĂłna.
     * @throws DuplicateSeasonNameException Pokud jiĹľ existuje sezĂłna se stejnĂ˝m nĂˇzvem.
     */
    @Override
    @Transactional
    public SeasonDTO updateSeason(Long id, SeasonDTO seasonDTO) {
        SeasonEntity existing = seasonRepository.findById(id)
                .orElseThrow(() -> new SeasonNotFoundException(id));

        validateDates(seasonDTO, id);
        checkSeasonName(seasonDTO, id);

        boolean wasActive = existing.isActive();
        boolean willBeActive = seasonDTO.isActive();

        if (wasActive && !willBeActive) {
            long activeCount = seasonRepository.countByActiveTrue();
            if (activeCount <= 1) {
                throw new InvalidSeasonStateException(
                        "BE - Nelze deaktivovat jedinou aktivnĂ­ sezĂłnu. " +
                                "Nejprve nastav jinou sezĂłnu jako aktivnĂ­."
                );
            }
        }

        mapper.updateEntityFromDTO(seasonDTO, existing);
        SeasonEntity saved = seasonRepository.save(existing);

        if (!wasActive && saved.isActive()) {
            setOnlyActiveSeason(saved.getId());
        }

        return mapper.toDTO(saved);
    }

    // AKTIVNĂŤ SEZĂ“NA

    /**
     * VracĂ­ aktuĂˇlnÄ› aktivnĂ­ sezĂłnu jako entitu.
     *
     * Metoda se pouĹľĂ­vĂˇ v service vrstvÄ› jako zdroj pravdy pro aktuĂˇlnĂ­ sezĂłnu, typicky pro filtrovĂˇnĂ­ zĂˇpasĹŻ nebo dalĹˇĂ­ch dat.
     * NaÄŤtenĂ­ se deleguje do {@link SeasonRepository}. Pokud aktivnĂ­ sezĂłna nenĂ­ nastavena, vyhazuje se {@link SeasonNotFoundException}.
     *
     * @return AktuĂˇlnÄ› aktivnĂ­ sezĂłna jako {@link SeasonEntity}.
     * @throws SeasonNotFoundException Pokud nenĂ­ nastavena ĹľĂˇdnĂˇ aktivnĂ­ sezĂłna.
     */
    @Override
    public SeasonEntity getActiveSeason() {
        return seasonRepository.findByActiveTrue()
                .orElseThrow(() -> new SeasonNotFoundException(
                        "BE - NenĂ­ nastavena ĹľĂˇdnĂˇ aktivnĂ­ sezĂłna."
                ));
    }

    /**
     * VracĂ­ aktuĂˇlnÄ› aktivnĂ­ sezĂłnu ve formÄ› DTO nebo null.
     *
     * Metoda se pouĹľĂ­vĂˇ v mĂ­stech, kde je absence aktivnĂ­ sezĂłny akceptovatelnĂˇ a nemĂˇ bĂ˝t povaĹľovĂˇna za chybovĂ˝ stav.
     * NaÄŤtenĂ­ se deleguje do {@link SeasonRepository} a mapovĂˇnĂ­ se deleguje do {@link SeasonMapper}.
     *
     * @return AktivnĂ­ sezĂłna ve formÄ› {@link SeasonDTO}, nebo null pokud aktivnĂ­ sezĂłna neexistuje.
     */
    @Override
    public SeasonDTO getActiveSeasonOrNull() {
        return seasonRepository.findByActiveTrue()
                .map(mapper::toDTO)
                .orElse(null);
    }

    /**
     * VracĂ­ sezĂłnu podle identifikĂˇtoru ve formÄ› DTO.
     *
     * SezĂłna se naÄŤĂ­tĂˇ z repository vrstvy. Pokud sezĂłna neexistuje, vyhazuje se {@link SeasonNotFoundException}.
     * MapovĂˇnĂ­ entity na DTO se deleguje do {@link SeasonMapper}.
     *
     * @param id IdentifikĂˇtor sezĂłny.
     * @return SezĂłna ve formÄ› {@link SeasonDTO}.
     * @throws SeasonNotFoundException Pokud sezĂłna s danĂ˝m ID neexistuje.
     */
    @Override
    public SeasonDTO getSeasonById(Long id) {
        SeasonEntity entity = seasonRepository.findById(id)
                .orElseThrow(() -> new SeasonNotFoundException(id));
        return mapper.toDTO(entity);
    }

    // SEZNAM VĹ ECH SEZĂ“N

    /**
     * VracĂ­ vĹˇechny sezĂłny seĹ™azenĂ© podle zaÄŤĂˇtku vzestupnÄ›.
     *
     * NaÄŤtenĂ­ se deleguje do {@link SeasonRepository} a mapovĂˇnĂ­ na DTO se deleguje do {@link SeasonMapper}.
     * Metoda se pouĹľĂ­vĂˇ pro administrativnĂ­ pĹ™ehledy a pro zobrazenĂ­ seznamu sezĂłn v uĹľivatelskĂ©m rozhranĂ­.
     *
     * @return Seznam vĹˇech sezĂłn ve formÄ› {@link SeasonDTO}.
     */
    @Override
    public List<SeasonDTO> getAllSeasons() {
        return seasonRepository.findAllByOrderByStartDateAsc()
                .stream()
                .map(mapper::toDTO)
                .toList();
    }

    // NASTAVENĂŤ AKTIVNĂŤ SEZĂ“NY

    /**
     * Nastavuje konkrĂ©tnĂ­ sezĂłnu jako aktivnĂ­.
     *
     * Nejprve se ovÄ›Ĺ™uje existence sezĂłny podle identifikĂˇtoru. NĂˇslednÄ› se provede nastavenĂ­ sezĂłny jako jedinĂ© aktivnĂ­
     * pomocĂ­ internĂ­ metody {@link #setOnlyActiveSeason(Long)}, kterĂˇ souÄŤasnÄ› deaktivuje vĹˇechny ostatnĂ­ sezĂłny.
     *
     * @param seasonId IdentifikĂˇtor sezĂłny, kterĂˇ mĂˇ bĂ˝t nastavena jako aktivnĂ­.
     * @throws SeasonNotFoundException Pokud sezĂłna s danĂ˝m ID neexistuje.
     */
    @Override
    @Transactional
    public void setActiveSeason(Long seasonId) {
        SeasonEntity toActivate = seasonRepository.findById(seasonId)
                .orElseThrow(() -> new SeasonNotFoundException(seasonId));

        setOnlyActiveSeason(toActivate.getId());
    }

    // PRIVĂTNĂŤ VALIDACE DAT

    /**
     * Validuje datumovĂ© rozmezĂ­ sezĂłny a kontroluje pĹ™ekryv s ostatnĂ­mi sezĂłnami.
     *
     * Kontroluje se, Ĺľe datum zaÄŤĂˇtku a konce nenĂ­ null, Ĺľe datum zaÄŤĂˇtku pĹ™edchĂˇzĂ­ datu konce a Ĺľe rozsah sezĂłny
     * nenĂ­ v pĹ™ekryvu s jinou sezĂłnou. PĹ™i aktualizaci se z kontroly pĹ™ekryvu vynechĂˇvĂˇ sezĂłna s identifikĂˇtorem
     * currentSeasonId.
     *
     * @param seasonDTO DTO s daty sezĂłny.
     * @param currentSeasonId IdentifikĂˇtor aktuĂˇlnĂ­ sezĂłny pĹ™i aktualizaci, nebo null pĹ™i vytvĂˇĹ™enĂ­.
     * @throws InvalidSeasonPeriodDateException Pokud jsou data neplatnĂˇ.
     * @throws SeasonPeriodOverlapException Pokud se sezĂłna pĹ™ekrĂ˝vĂˇ s jinou sezĂłnou.
     */
    private void validateDates(SeasonDTO seasonDTO, Long currentSeasonId) {
        LocalDate start = seasonDTO.getStartDate();
        LocalDate end = seasonDTO.getEndDate();

        if (start == null || end == null) {
            throw new InvalidSeasonPeriodDateException("BE - Datum od a do nesmĂ­ bĂ˝t null.");
        }
        if (!start.isBefore(end)) {
            throw new InvalidSeasonPeriodDateException("BE - Datum 'od' musĂ­ bĂ˝t pĹ™ed 'do'.");
        }

        boolean overlaps;
        if (currentSeasonId == null) {
            overlaps = seasonRepository
                    .existsByStartDateLessThanEqualAndEndDateGreaterThanEqual(end, start);
        } else {
            overlaps = seasonRepository
                    .existsByStartDateLessThanEqualAndEndDateGreaterThanEqualAndIdNot(
                            end,
                            start,
                            currentSeasonId
                    );
        }

        if (overlaps) {
            throw new SeasonPeriodOverlapException("BE - SezĂłna se pĹ™ekrĂ˝vĂˇ s existujĂ­cĂ­ sezĂłnou.");
        }
    }

    /**
     * Validuje nĂˇzev sezĂłny kontrolou duplicity vĹŻÄŤi ostatnĂ­m sezĂłnĂˇm.
     *
     * PĹ™i vytvĂˇĹ™enĂ­ se ovÄ›Ĺ™uje existence nĂˇzvu vĹŻÄŤi vĹˇem sezĂłnĂˇm. PĹ™i aktualizaci se kontrola provĂˇdĂ­ vĹŻÄŤi vĹˇem sezĂłnĂˇm
     * s tĂ­m, Ĺľe sezĂłna s identifikĂˇtorem currentSeasonId se z kontroly vynechĂˇvĂˇ.
     *
     * @param seasonDTO DTO s daty sezĂłny.
     * @param currentSeasonId IdentifikĂˇtor aktuĂˇlnĂ­ sezĂłny pĹ™i aktualizaci, nebo null pĹ™i vytvĂˇĹ™enĂ­.
     * @throws DuplicateSeasonNameException Pokud jiĹľ existuje sezĂłna se stejnĂ˝m nĂˇzvem.
     */
    private void checkSeasonName(SeasonDTO seasonDTO, Long currentSeasonId) {
        String seasonName = seasonDTO.getName().trim();

        boolean existSeasonName;
        if (currentSeasonId == null) {
            existSeasonName = seasonRepository.existsByName(seasonName);
        } else {
            existSeasonName = seasonRepository.existsByNameAndIdNot(seasonName, currentSeasonId);
        }

        if (existSeasonName) {
            throw new DuplicateSeasonNameException(seasonName);
        }
    }

    // PRIVĂTNĂŤ POMOCNĂ METODA

    /**
     * Nastavuje zadanou sezĂłnu jako jedinou aktivnĂ­.
     *
     * VĹˇechny sezĂłny se naÄŤtou z repository vrstvy a nĂˇslednÄ› se u sezĂłny se zadanĂ˝m identifikĂˇtorem nastavĂ­ active na true,
     * zatĂ­mco u vĹˇech ostatnĂ­ch sezĂłn se active nastavĂ­ na false. ZmÄ›ny se uloĹľĂ­ hromadnÄ› pĹ™es {@link SeasonRepository}.
     * TĂ­m se vynucuje invariant, Ĺľe v systĂ©mu existuje v jeden okamĹľik prĂˇvÄ› jedna aktivnĂ­ sezĂłna.
     *
     * @param activeSeasonId IdentifikĂˇtor sezĂłny, kterĂˇ mĂˇ bĂ˝t nastavena jako jedinĂˇ aktivnĂ­.
     */
    private void setOnlyActiveSeason(Long activeSeasonId) {
        List<SeasonEntity> all = seasonRepository.findAll();
        for (SeasonEntity season : all) {
            season.setActive(season.getId().equals(activeSeasonId));
        }
        seasonRepository.saveAll(all);
    }

    /**
     * VracĂ­ identifikĂˇtor aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele nebo null, pokud nenĂ­ moĹľnĂ© uĹľivatele urÄŤit.
     *
     * IdentifikĂˇtor se odvozuje z autentizace v bezpeÄŤnostnĂ­m kontextu. Jako klĂ­ÄŤ se pouĹľĂ­vĂˇ e-mail uĹľivatele
     * a dohledĂˇnĂ­ se provĂˇdĂ­ pĹ™es {@link AppUserRepository}. Pokud autentizace neexistuje, uĹľivatel nenĂ­ pĹ™ihlĂˇĹˇen
     * nebo zĂˇznam uĹľivatele nelze dohledat, vracĂ­ se null.
     *
     * @return IdentifikĂˇtor aktuĂˇlnĂ­ho uĹľivatele, nebo null pokud jej nelze urÄŤit.
     */
    private Long getCurrentUserIdOrNull() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth == null || !auth.isAuthenticated()) {
            return null;
        }

        String email = auth.getName();
        return appUserRepository.findByEmail(email)
                .map(AppUserEntity::getId)
                .orElse(null);
    }
}
