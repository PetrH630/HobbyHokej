Balíček (složka): services
Cesta: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services

Seznam souborů:
AppUserHistoryService.java
AppUserHistoryServiceImpl.java
AppUserService.java
AppUserServiceImpl.java
AppUserSettingsService.java
AppUserSettingsServiceImpl.java
CurrentPlayerService.java
CurrentPlayerServiceImpl.java
CurrentSeasonService.java
CurrentSeasonServiceImpl.java
MatchRegistrationCommandService.java
MatchRegistrationCommandServiceImpl.java
MatchRegistrationHistoryService.java
MatchRegistrationHistoryServiceImpl.java
MatchRegistrationQueryService.java
MatchRegistrationQueryServiceImpl.java
MatchRegistrationService.java
MatchRegistrationServiceImpl.java
MatchService.java
MatchServiceImpl.java
NotificationDecision.java
package-info.java
PlayerHistoryService.java
PlayerHistoryServiceImpl.java
PlayerInactivityPeriodService.java
PlayerInactivityPeriodServiceImpl.java
PlayerService.java
PlayerServiceImpl.java
PlayerSettingsService.java
PlayerSettingsServiceImpl.java
PlayerStatsService.java
PlayerStatsServiceImpl.java
SeasonHistoryService.java
SeasonHistoryServiceImpl.java
SeasonService.java
SeasonServiceImpl.java


-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserHistoryService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.user.dto.AppUserHistoryDTO;

import java.util.List;

/**
 * ServisnĂ­ rozhranĂ­ pro prĂˇci s historiĂ­ uĹľivatelskĂ˝ch ĂşÄŤtĹŻ.
 *
 * SlouĹľĂ­ k naÄŤĂ­tĂˇnĂ­ historickĂ˝ch zĂˇznamĹŻ uĹľivatele
 * pro auditnĂ­ a pĹ™ehledovĂ© ĂşÄŤely. HistorickĂ© zĂˇznamy
 * jsou typicky vytvĂˇĹ™eny databĂˇzovĂ˝mi triggery a
 * nĂˇslednÄ› pĹ™evĂˇdÄ›ny na DTO objekty pomocĂ­ mapperu.
 *
 * RozhranĂ­ je implementovĂˇno servisnĂ­ tĹ™Ă­dou,
 * kterĂˇ zajiĹˇĹĄuje komunikaci s repozitĂˇĹ™em
 * a pĹ™evod entit na DTO.
 */
public interface AppUserHistoryService {

    /**
     * VrĂˇtĂ­ historii zmÄ›n uĹľivatele podle jeho e-mailovĂ© adresy.
     *
     * @param email e-mailovĂˇ adresa uĹľivatele
     * @return seznam historickĂ˝ch zĂˇznamĹŻ uĹľivatele
     */
    List<AppUserHistoryDTO> getHistoryForUser(String email);

    /**
     * VrĂˇtĂ­ historii zmÄ›n uĹľivatele podle jeho identifikĂˇtoru.
     *
     * @param id identifikĂˇtor uĹľivatele
     * @return seznam historickĂ˝ch zĂˇznamĹŻ uĹľivatele
     */
    List<AppUserHistoryDTO> getHistoryForUser(Long id);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserHistoryServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.user.repositories.AppUserHistoryRepository;
import cz.phsoft.hokej.user.dto.AppUserHistoryDTO;
import cz.phsoft.hokej.user.mappers.AppUserHistoryMapper;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * Implementace servisnĂ­ vrstvy pro prĂˇci s historiĂ­ uĹľivatelskĂ˝ch ĂşÄŤtĹŻ.
 *
 * ZajiĹˇĹĄuje naÄŤĂ­tĂˇnĂ­ historickĂ˝ch zĂˇznamĹŻ uĹľivatele z databĂˇze
 * prostĹ™ednictvĂ­m repozitĂˇĹ™e a jejich pĹ™evod na DTO objekty
 * pomocĂ­ mapperu.
 *
 * TĹ™Ă­da neprovĂˇdĂ­ ĹľĂˇdnĂ© zĂˇpisy do databĂˇze. HistorickĂ© zĂˇznamy
 * jsou vytvĂˇĹ™eny databĂˇzovĂ˝mi triggery a tato sluĹľba slouĹľĂ­
 * vĂ˝hradnÄ› pro ÄŤtecĂ­ a auditnĂ­ ĂşÄŤely.
 */
@Service
public class AppUserHistoryServiceImpl implements AppUserHistoryService {

    private final AppUserHistoryRepository repository;
    private final AppUserHistoryMapper mapper;

    /**
     * VytvoĹ™Ă­ instanci servisnĂ­ tĹ™Ă­dy.
     *
     * @param repository repozitĂˇĹ™ pro pĹ™Ă­stup k historickĂ˝m zĂˇznamĹŻm uĹľivatelĹŻ
     * @param mapper mapper pro pĹ™evod entit na DTO objekty
     */
    public AppUserHistoryServiceImpl(
            AppUserHistoryRepository repository,
            AppUserHistoryMapper mapper
    ) {
        this.repository = repository;
        this.mapper = mapper;
    }

    /**
     * VrĂˇtĂ­ historii zmÄ›n uĹľivatele podle jeho e-mailovĂ© adresy.
     *
     * ZĂˇznamy jsou naÄŤteny z databĂˇze v sestupnĂ©m poĹ™adĂ­
     * podle ÄŤasu zmÄ›ny a nĂˇslednÄ› pĹ™evedeny na DTO objekty.
     *
     * @param email e-mailovĂˇ adresa uĹľivatele
     * @return seznam historickĂ˝ch zĂˇznamĹŻ uĹľivatele
     */
    @Override
    public List<AppUserHistoryDTO> getHistoryForUser(String email) {
        return mapper.toDTOList(
                repository.findByEmailOrderByChangedAtDesc(email)
        );
    }

    /**
     * VrĂˇtĂ­ historii zmÄ›n uĹľivatele podle jeho identifikĂˇtoru.
     *
     * ZĂˇznamy jsou naÄŤteny z databĂˇze v sestupnĂ©m poĹ™adĂ­
     * podle ÄŤasu zmÄ›ny a nĂˇslednÄ› pĹ™evedeny na DTO objekty.
     *
     * @param id identifikĂˇtor uĹľivatele
     * @return seznam historickĂ˝ch zĂˇznamĹŻ uĹľivatele
     */
    @Override
    public List<AppUserHistoryDTO> getHistoryForUser(Long id) {
        return mapper.toDTOList(
                repository.findByUserIdOrderByChangedAtDesc(id)
        );
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.user.dto.AppUserDTO;
import cz.phsoft.hokej.user.dto.ForgottenPasswordResetDTO;
import cz.phsoft.hokej.user.dto.RegisterUserDTO;

import java.util.List;

/**
 * RozhranĂ­ pro sprĂˇvu uĹľivatelskĂ˝ch ĂşÄŤtĹŻ aplikace.
 *
 * Definuje se smlouva pro registraci uĹľivatelĹŻ, zmÄ›nu a reset hesla,
 * aktivaci nebo deaktivaci ĂşÄŤtĹŻ a ÄŤtenĂ­ seznamĹŻ uĹľivatelĹŻ. RozhranĂ­
 * se pouĹľĂ­vĂˇ v controller vrstvĂˇch a v dalĹˇĂ­ch service tĹ™Ă­dĂˇch.
 *
 * Implementace pracuje s DTO objekty a zajiĹˇĹĄuje napojenĂ­
 * na perzistenÄŤnĂ­ vrstvu (repozitĂˇĹ™e) a notifikaÄŤnĂ­ mechanismy.
 */
public interface AppUserService {

    /**
     * Zaregistruje novĂ©ho uĹľivatele do systĂ©mu.
     *
     * ProvĂˇdĂ­ se kontrola jedineÄŤnosti emailu, shody hesla a jeho potvrzenĂ­
     * a dalĹˇĂ­ validaÄŤnĂ­ pravidla. NovĂ˝ ĂşÄŤet se typicky zaklĂˇdĂˇ jako neaktivnĂ­
     * a jeho aktivace se dokonÄŤuje pĹ™es aktivaÄŤnĂ­ odkaz.
     *
     * @param registerUserDTO registraÄŤnĂ­ data novĂ©ho uĹľivatele
     */
    void register(RegisterUserDTO registerUserDTO);

    /**
     * Aktualizuje Ăşdaje uĹľivatele podle emailu.
     *
     * PouĹľĂ­vĂˇ se pro zmÄ›ny bÄ›ĹľnĂ˝ch ĂşdajĹŻ (jmĂ©no, pĹ™Ă­jmenĂ­, email).
     * BezpeÄŤnost a oprĂˇvnÄ›nĂ­ se kontrolujĂ­ v controller vrstvÄ›.
     *
     * @param email email uĹľivatele, kterĂ˝ mĂˇ bĂ˝t aktualizovĂˇn
     * @param dto   novĂ© hodnoty uĹľivatelskĂ˝ch ĂşdajĹŻ
     */
    void updateUser(String email, AppUserDTO dto);

    /**
     * VracĂ­ aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele podle emailu.
     *
     * Metoda se pouĹľĂ­vĂˇ zejmĂ©na v kontextu endpointĹŻ typu "/me".
     *
     * @param email email pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @return DTO reprezentace aktuĂˇlnĂ­ho uĹľivatele
     */
    AppUserDTO getCurrentUser(String email);

    /**
     * VracĂ­ seznam vĹˇech uĹľivatelĹŻ v systĂ©mu.
     *
     * Typicky se pouĹľĂ­vĂˇ v administrĂˇtorskĂ©m rozhranĂ­
     * pro sprĂˇvu uĹľivatelĹŻ.
     *
     * @return seznam uĹľivatelĹŻ ve formÄ› DTO
     */
    List<AppUserDTO> getAllUsers();

    /**
     * VracĂ­ uĹľivatele podle ID.
     *
     * PouĹľĂ­vĂˇ se v administraci, kde je potĹ™eba pracovat
     * s konkrĂ©tnĂ­m ĂşÄŤtem podle jeho identifikĂˇtoru.
     *
     * @param userId ID uĹľivatele
     * @return uĹľivatel ve formÄ› DTO
     */
    AppUserDTO getUserById(Long userId);

    /**
     * ZmÄ›nĂ­ heslo uĹľivatele.
     *
     * OvÄ›Ĺ™uje se sprĂˇvnost pĹŻvodnĂ­ho hesla, shoda novĂ©ho hesla
     * a jeho potvrzenĂ­ a pĹ™Ă­padnĂ© bezpeÄŤnostnĂ­ poĹľadavky.
     *
     * @param email              email uĹľivatele
     * @param oldPassword        pĹŻvodnĂ­ heslo
     * @param newPassword        novĂ© heslo
     * @param newPasswordConfirm potvrzenĂ­ novĂ©ho hesla
     */
    void changePassword(
            String email,
            String oldPassword,
            String newPassword,
            String newPasswordConfirm
    );

    /**
     * Resetuje heslo uĹľivatele na vĂ˝chozĂ­ hodnotu.
     *
     * Operace se typicky pouĹľĂ­vĂˇ v administraci, kde se Ĺ™eĹˇĂ­
     * problĂ©my s pĹ™ihlĂˇĹˇenĂ­m. KonkrĂ©tnĂ­ politika bezpeÄŤnĂ©ho
     * zachĂˇzenĂ­ s takovĂ˝m heslem se Ĺ™eĹˇĂ­ v aplikaÄŤnĂ­ logice.
     *
     * @param userId ID uĹľivatele, jehoĹľ heslo mĂˇ bĂ˝t resetovĂˇno
     */
    void resetPassword(Long userId);

    /**
     * Aktivuje uĹľivatelskĂ˝ ĂşÄŤet na zĂˇkladÄ› aktivaÄŤnĂ­ho tokenu.
     *
     * Metoda se pouĹľĂ­vĂˇ po registraci uĹľivatele, kdy je odkaz
     * zaslĂˇn v aktivaÄŤnĂ­m emailu. PĹ™i ĂşspÄ›chu se ĂşÄŤet oznaÄŤĂ­
     * jako povolenĂ˝ k pĹ™ihlĂˇĹˇenĂ­.
     *
     * @param token aktivaÄŤnĂ­ token
     * @return true, pokud byla aktivace ĂşspÄ›ĹˇnĂˇ, jinak false
     */
    boolean activateUser(String token);

    /**
     * Aktivuje uĹľivatelskĂ˝ ĂşÄŤet v administraci.
     *
     * Aktivace se provĂˇdĂ­ bez pouĹľitĂ­ aktivaÄŤnĂ­ho tokenu,
     * typicky v situaci, kdy mĂˇ uĹľivatel technickĂ˝ problĂ©m
     * s aktivaÄŤnĂ­m emailem.
     *
     * @param id ID uĹľivatele
     */
    void activateUserByAdmin(Long id);

    /**
     * Deaktivuje uĹľivatelskĂ˝ ĂşÄŤet v administraci.
     *
     * ĂšÄŤet se ponechĂˇ v databĂˇzi, ale uĹľivatel se nemĹŻĹľe
     * doÄŤasnÄ› pĹ™ihlĂˇsit do aplikace.
     *
     * @param id ID uĹľivatele
     */
    void deactivateUserByAdmin(Long id);

    /**
     * VytvoĹ™Ă­ poĹľadavek na reset zapomenutĂ©ho hesla.
     *
     * Pro danĂ˝ email se vygeneruje resetovacĂ­ token a odeĹˇle
     * se odpovĂ­dajĂ­cĂ­ notifikace (napĹ™Ă­klad email s odkazem
     * na formulĂˇĹ™ pro nastavenĂ­ novĂ©ho hesla).
     *
     * @param email email uĹľivatele
     */
    void requestForgottenPasswordReset(String email);

    /**
     * VracĂ­ email uĹľivatele pro zadanĂ˝ resetovacĂ­ token.
     *
     * Metoda se pouĹľĂ­vĂˇ pĹ™i naÄŤĂ­tĂˇnĂ­ formulĂˇĹ™e pro nastavenĂ­
     * novĂ©ho hesla, aby se ovÄ›Ĺ™ilo, ke kterĂ©mu ĂşÄŤtu token patĹ™Ă­.
     *
     * @param token resetovacĂ­ token
     * @return email uĹľivatele
     */
    String getForgottenPasswordResetEmail(String token);

    /**
     * NastavĂ­ novĂ© heslo na zĂˇkladÄ› tokenu pro zapomenutĂ© heslo.
     *
     * Token se ovÄ›Ĺ™Ă­, zkontroluje se shoda hesla a jeho potvrzenĂ­
     * a potĂ© se heslo uloĹľĂ­ v zahashovanĂ© podobÄ›.
     *
     * @param dto data pro reset zapomenutĂ©ho hesla
     */
    void forgottenPasswordReset(ForgottenPasswordResetDTO dto);

    void onSuccessfulLogin(String email);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.user.entities.AppUserEntity;
import cz.phsoft.hokej.user.entities.EmailVerificationTokenEntity;
import cz.phsoft.hokej.user.entities.ForgottenPasswordResetTokenEntity;
import cz.phsoft.hokej.notifications.enums.NotificationType;
import cz.phsoft.hokej.user.enums.Role;
import cz.phsoft.hokej.user.repositories.AppUserRepository;
import cz.phsoft.hokej.user.repositories.EmailVerificationTokenRepository;
import cz.phsoft.hokej.user.repositories.ForgottenPasswordResetTokenRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.user.dto.AppUserDTO;
import cz.phsoft.hokej.user.dto.ForgottenPasswordResetDTO;
import cz.phsoft.hokej.user.dto.RegisterUserDTO;
import cz.phsoft.hokej.user.mappers.AppUserMapper;
import cz.phsoft.hokej.models.services.email.EmailService;
import cz.phsoft.hokej.notifications.services.ForgottenPasswordResetContext;
import cz.phsoft.hokej.notifications.services.NotificationService;
import cz.phsoft.hokej.notifications.services.UserActivationContext;
import cz.phsoft.hokej.models.services.demo.DemoModeGuard;
import jakarta.transaction.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

import java.time.Clock;
import java.time.Instant;

/**
 * Implementace servisnĂ­ vrstvy pro sprĂˇvu aplikaÄŤnĂ­ch uĹľivatelskĂ˝ch ĂşÄŤtĹŻ.
 *
 * ZajiĹˇĹĄuje registraci uĹľivatele, aktivaci a deaktivaci ĂşÄŤtu,
 * zmÄ›nu a reset hesla a aktualizaci zĂˇkladnĂ­ch ĂşdajĹŻ.
 * SouÄŤĂˇstĂ­ odpovÄ›dnosti je bezpeÄŤnĂ© uloĹľenĂ­ hesel pomocĂ­ BCrypt
 * a sprĂˇva ovÄ›Ĺ™ovacĂ­ch a resetovacĂ­ch tokenĹŻ.
 *
 * Notifikace o udĂˇlostech jsou odesĂ­lĂˇny prostĹ™ednictvĂ­m NotificationService.
 * Autentizace a autorizace jsou Ĺ™eĹˇeny v rĂˇmci Spring Security
 * a nejsou souÄŤĂˇstĂ­ odpovÄ›dnosti tĂ©to tĹ™Ă­dy.
 */
@Service
public class AppUserServiceImpl implements AppUserService {

    @Value("${app.frontend-base-url}")
    private String frontendBasUrl;
    @Value("${app.demo-mode:false}")
    private boolean isDemoMode;

    private static final Logger log = LoggerFactory.getLogger(AppUserServiceImpl.class);

    /**
     * VĂ˝chozĂ­ heslo pouĹľĂ­vanĂ© pĹ™i resetu ĂşÄŤtu administrĂˇtorem.
     */
    private static final String DEFAULT_RESET_PASSWORD = "Player123";

    /**
     * ZĂˇkladnĂ­ URL aplikace pouĹľĂ­vanĂˇ pro sestavenĂ­ odkazĹŻ
     * v aktivaÄŤnĂ­ch a resetovacĂ­ch notifikacĂ­ch.
     */
    @Value("${app.base-url}")
    private String baseUrl;

    private final AppUserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final AppUserMapper appUserMapper;
    private final EmailService emailService;
    private final EmailVerificationTokenRepository tokenRepository;
    private final AppUserSettingsService appUserSettingsService;
    private final NotificationService notificationService;
    private final ForgottenPasswordResetTokenRepository forgottenPasswordResetTokenRepository;
    private final DemoModeGuard demoModeGuard;
    private final Clock clock;

    /**
     * VytvoĹ™Ă­ instanci servisnĂ­ tĹ™Ă­dy.
     *
     * ZĂˇvislosti jsou pĹ™edĂˇny pomocĂ­ konstruktoru a jsou pouĹľĂ­vĂˇny
     * pro prĂˇci s databĂˇzĂ­, mapovĂˇnĂ­ dat a odesĂ­lĂˇnĂ­ notifikacĂ­.
     *
     * @param userRepository repozitĂˇĹ™ pro prĂˇci s uĹľivatelskĂ˝mi ĂşÄŤty
     * @param passwordEncoder encoder pro hashovĂˇnĂ­ a ovÄ›Ĺ™enĂ­ hesel
     * @param appUserMapper mapper pro pĹ™evod mezi entitami a DTO
     * @param emailService servis pro odesĂ­lĂˇnĂ­ e-mailĹŻ
     * @param tokenRepository repozitĂˇĹ™ pro ovÄ›Ĺ™ovacĂ­ tokeny
     * @param appUserSettingsService servis pro sprĂˇvu uĹľivatelskĂ˝ch nastavenĂ­
     * @param notificationService servis pro odesĂ­lĂˇnĂ­ notifikacĂ­
     * @param forgottenPasswordResetTokenRepository repozitĂˇĹ™ pro resetovacĂ­ tokeny
     */
    public AppUserServiceImpl(AppUserRepository userRepository,
                              PasswordEncoder passwordEncoder,
                              AppUserMapper appUserMapper,
                              EmailService emailService,
                              EmailVerificationTokenRepository tokenRepository,
                              AppUserSettingsService appUserSettingsService,
                              NotificationService notificationService,
                              ForgottenPasswordResetTokenRepository forgottenPasswordResetTokenRepository,
                              DemoModeGuard demoModeGuard,
                              Clock clock) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
        this.appUserMapper = appUserMapper;
        this.emailService = emailService;
        this.tokenRepository = tokenRepository;
        this.appUserSettingsService = appUserSettingsService;
        this.notificationService = notificationService;
        this.forgottenPasswordResetTokenRepository = forgottenPasswordResetTokenRepository;
        this.demoModeGuard = demoModeGuard;
        this.clock = clock;
    }

    /**
     * Zaregistruje novĂ©ho uĹľivatele.
     *
     * PĹ™ed vytvoĹ™enĂ­m ĂşÄŤtu se ovÄ›Ĺ™uje shoda zadanĂ˝ch hesel
     * a jedineÄŤnost e-mailovĂ© adresy. ĂšÄŤet je vytvoĹ™en jako neaktivnĂ­,
     * je vygenerovĂˇn ovÄ›Ĺ™ovacĂ­ token a je odeslĂˇna notifikace
     * obsahujĂ­cĂ­ aktivaÄŤnĂ­ odkaz.
     *
     * @param dto registraÄŤnĂ­ Ăşdaje uĹľivatele
     */
    @Override
    @Transactional
    public void register(RegisterUserDTO dto) {
        ensurePasswordsMatch(dto.getPassword(), dto.getPasswordConfirm(), null);
        ensureEmailNotUsed(dto.getEmail(), null);

        AppUserEntity user = createUserFromRegisterDto(dto);
        AppUserEntity savedUser = userRepository.save(user);

        EmailVerificationTokenEntity verificationToken =
                createVerificationToken(savedUser);

        String activationLink = buildActivationLink(verificationToken);
        log.info("AktivaÄŤnĂ­ odkaz pro {}: {}", user.getEmail(), activationLink);

        notificationService.notifyUser(
                savedUser,
                NotificationType.USER_CREATED,
                new UserActivationContext(savedUser, activationLink)
        );
    }

    /**
     * Aktivuje uĹľivatelskĂ˝ ĂşÄŤet na zĂˇkladÄ› ovÄ›Ĺ™ovacĂ­ho tokenu.
     *
     * Token je vyhledĂˇn a je ovÄ›Ĺ™ena jeho platnost. Pokud je token neplatnĂ˝
     * nebo expirovanĂ˝, je vrĂˇcena hodnota false. PĹ™i ĂşspÄ›ĹˇnĂ© aktivaci
     * je ĂşÄŤet povolen a v pĹ™Ă­padÄ› chybÄ›jĂ­cĂ­ konfigurace jsou vytvoĹ™ena
     * vĂ˝chozĂ­ uĹľivatelskĂˇ nastavenĂ­. PouĹľitĂ˝ token je odstranÄ›n.
     *
     * Po ĂşspÄ›ĹˇnĂ© aktivaci je odeslĂˇna notifikace o aktivaci ĂşÄŤtu.
     *
     * @param token aktivaÄŤnĂ­ token
     * @return true, pokud byla aktivace provedena, jinak false
     */
    @Override
    @Transactional
    public boolean activateUser(String token) {
        EmailVerificationTokenEntity verificationToken =
                tokenRepository.findByToken(token).orElse(null);

        if (verificationToken == null ||
                verificationToken.getExpiresAt().isBefore(LocalDateTime.now())) {
            return false;
        }

        AppUserEntity user = verificationToken.getUser();
        boolean newlyActivated = false;

        if (!user.isEnabled()) {
            user.setEnabled(true);
            newlyActivated = true;

            if (user.getSettings() == null) {
                appUserSettingsService.createDefaultSettingsForUser(user);
            }
            userRepository.save(user);
        }

        tokenRepository.delete(verificationToken);

        if (newlyActivated) {
            notifyUser(user, NotificationType.USER_ACTIVATED);
        }
        return true;
    }

    /**
     * Aktivuje uĹľivatelskĂ˝ ĂşÄŤet v administraci.
     *
     * OvÄ›Ĺ™uje se, zda se nejednĂˇ o administrĂˇtorskĂ˝ ĂşÄŤet a zda ĂşÄŤet jiĹľ nenĂ­ aktivnĂ­.
     * PĹ™i ĂşspÄ›ĹˇnĂ© aktivaci jsou pĹ™Ă­padnĂˇ chybÄ›jĂ­cĂ­ uĹľivatelskĂˇ nastavenĂ­ vytvoĹ™ena
     * a vĹˇechny ovÄ›Ĺ™ovacĂ­ tokeny uĹľivatele jsou odstranÄ›ny.
     *
     * Po ĂşspÄ›ĹˇnĂ© aktivaci je odeslĂˇna notifikace o aktivaci ĂşÄŤtu.
     *
     * @param id identifikĂˇtor uĹľivatele
     */
    @Override
    public void activateUserByAdmin(Long id) {
        AppUserEntity user = findUserByIdOrThrow(id);

        if (user.getRole() == Role.ROLE_ADMIN) {
            throw new InvalidAdminActivateDeactivateException(
                    "BE - AdministrĂˇtorskĂ˝ ĂşÄŤet nelze deaktivovat"
            );
        }

        if (user.isEnabled()) {
            throw new InvalidUserActivationException(
                    "BE - Aktivace ĂşÄŤtu jiĹľ byla provedena"
            );
        }
        boolean newlyActivated = false;

        if (!user.isEnabled()) {
            user.setEnabled(true);
            newlyActivated = true;

            if (user.getSettings() == null) {
                appUserSettingsService.createDefaultSettingsForUser(user);
            }

            userRepository.save(user);
        }

        tokenRepository.deleteByUser(user);

        if (newlyActivated) {
            notifyUser(user, NotificationType.USER_ACTIVATED);
        }
    }

    /**
     * Aktualizuje zĂˇkladnĂ­ Ăşdaje uĹľivatele podle e-mailovĂ© adresy.
     *
     * PĹ™i zmÄ›nÄ› e-mailu se ovÄ›Ĺ™uje, Ĺľe novĂˇ e-mailovĂˇ adresa nenĂ­ pouĹľĂ­vĂˇna
     * jinĂ˝m ĂşÄŤtem. V demo reĹľimu je operace pĹ™ed zĂˇpisem do databĂˇze zakĂˇzĂˇna.
     * Po ĂşspÄ›ĹˇnĂ© aktualizaci je odeslĂˇna notifikace o zmÄ›nÄ› ĂşdajĹŻ.
     *
     * @param email e-mailovĂˇ adresa aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @param dto aktualizovanĂˇ data ĂşÄŤtu
     */
    @Override
    @Transactional
    public void updateUser(String email, AppUserDTO dto) {
        AppUserEntity user = findUserByEmailOrThrow(email);

        if (!user.getEmail().equals(dto.getEmail())) {
            ensureEmailNotUsed(dto.getEmail(), user.getId());
        }

        demoModeGuard.write(
                user.getId(),
                "UĹľivatel, kterĂ˝ byl vytvoĹ™en aplikacĂ­, nebude zmÄ›nÄ›n. " +
                        "Aplikace bÄ›ĹľĂ­ v DEMO reĹľimu. ZmÄ›ny budou skuteÄŤnÄ› provedeny " +
                        "pouze u vĂˇmi vytvoĹ™enĂ˝ch uĹľivatelĹŻ."
        );

        user.setName(dto.getName());
        user.setSurname(dto.getSurname());
        user.setEmail(dto.getEmail());

        userRepository.save(user);
        notifyUser(user, NotificationType.USER_UPDATED);
    }

    /**
     * VrĂˇtĂ­ detail aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * UĹľivatel je vyhledĂˇn podle e-mailovĂ© adresy a je pĹ™eveden na DTO.
     *
     * @param email e-mailovĂˇ adresa uĹľivatele
     * @return DTO reprezentace uĹľivatele
     */
    @Override
    public AppUserDTO getCurrentUser(String email) {
        AppUserEntity user = findUserByEmailOrThrow(email);
        return appUserMapper.toDTO(user);
    }

    /**
     * VrĂˇtĂ­ seznam vĹˇech uĹľivatelĹŻ systĂ©mu.
     *
     * ZĂˇznamy jsou naÄŤteny z databĂˇze a jsou mapovĂˇny na DTO.
     * Metoda se pouĹľĂ­vĂˇ v administraci pro pĹ™ehled a sprĂˇvu ĂşÄŤtĹŻ.
     *
     * @return seznam uĹľivatelĹŻ ve formÄ› DTO
     */
    @Override
    public List<AppUserDTO> getAllUsers() {
        return userRepository.findAll().stream()
                .map(appUserMapper::toDTO)
                .toList();
    }

    /**
     * ZmÄ›nĂ­ heslo aktuĂˇlnĂ­ho uĹľivatele.
     *
     * OvÄ›Ĺ™uje se shoda novĂ©ho hesla a jeho potvrzenĂ­ a nĂˇslednÄ› se ovÄ›Ĺ™uje
     * pĹŻvodnĂ­ heslo. V demo reĹľimu je operace pĹ™ed zĂˇpisem do databĂˇze zakĂˇzĂˇna.
     * Po ĂşspÄ›ĹˇnĂ© zmÄ›nÄ› hesla je odeslĂˇna notifikace.
     *
     * @param email e-mailovĂˇ adresa uĹľivatele
     * @param oldPassword pĹŻvodnĂ­ heslo
     * @param newPassword novĂ© heslo
     * @param newPasswordConfirm potvrzenĂ­ novĂ©ho hesla
     */
    @Override
    @Transactional
    public void changePassword(String email,
                               String oldPassword,
                               String newPassword,
                               String newPasswordConfirm) {

        ensurePasswordsMatch(
                newPassword,
                newPasswordConfirm,
                "BE - NovĂ© heslo a potvrzenĂ­ novĂ©ho hesla se neshodujĂ­"
        );

        AppUserEntity user = findUserByEmailOrThrow(email);

        if (!passwordEncoder.matches(oldPassword, user.getPassword())) {
            throw new InvalidOldPasswordException();
        }

        demoModeGuard.write(
                user.getId(),
                "Heslo u uĹľivatele, kterĂ˝ byl vytvoĹ™en aplikacĂ­, nebude zmÄ›nÄ›no. " +
                        "Aplikace bÄ›ĹľĂ­ v DEMO reĹľimu. ZmÄ›na hesla bude skuteÄŤnÄ› provedena " +
                        "pouze u vĂˇmi vytvoĹ™enĂ˝ch uĹľivatelĹŻ."
        );

        user.setPassword(passwordEncoder.encode(newPassword));
        userRepository.save(user);

        notifyUser(user, NotificationType.USER_CHANGE_PASSWORD);
    }

    /**
     * Resetuje heslo uĹľivatele na vĂ˝chozĂ­ hodnotu.
     *
     * Metoda se pouĹľĂ­vĂˇ v administraci pĹ™i ruÄŤnĂ­m resetu hesla.
     * V demo reĹľimu je operace pĹ™ed zĂˇpisem do databĂˇze zakĂˇzĂˇna.
     * Po ĂşspÄ›ĹˇnĂ©m resetu je odeslĂˇna notifikace.
     *
     * @param userId identifikĂˇtor uĹľivatele
     */
    @Override
    @Transactional
    public void resetPassword(Long userId) {
        AppUserEntity user = findUserByIdOrThrow(userId);

        if (isDemoMode) {
            throw new DemoModeOperationNotAllowedException(
                    "Heslo nebude resetovĂˇno. Aplikace bÄ›ĹľĂ­ v DEMO reĹľimu."
            );
        }

        user.setPassword(passwordEncoder.encode(DEFAULT_RESET_PASSWORD));
        userRepository.save(user);

        notifyUser(user, NotificationType.PASSWORD_RESET);
    }

    /**
     * Deaktivuje uĹľivatelskĂ˝ ĂşÄŤet v administraci.
     *
     * OvÄ›Ĺ™uje se, zda se nejednĂˇ o administrĂˇtorskĂ˝ ĂşÄŤet a zda ĂşÄŤet jiĹľ nenĂ­ deaktivovanĂ˝.
     * Po ĂşspÄ›ĹˇnĂ© deaktivaci je odeslĂˇna notifikace o deaktivaci ĂşÄŤtu.
     *
     * @param id identifikĂˇtor uĹľivatele
     */
    @Override
    public void deactivateUserByAdmin(Long id) {
        AppUserEntity user = findUserByIdOrThrow(id);

        if (user.getRole() == Role.ROLE_ADMIN) {
            throw new InvalidAdminActivateDeactivateException(
                    "BE - AdministrĂˇtorskĂ˝ ĂşÄŤet nelze deaktivovat"
            );
        }

        if (!user.isEnabled()) {
            throw new InvalidUserActivationException(
                    "BE - Deaktivace ĂşÄŤtu jiĹľ byla provedena"
            );
        }

        demoModeGuard.write(
                user.getId(),
                "UĹľivatel, kterĂ˝ byl vytvoĹ™en aplikacĂ­, nebude deaktivovĂˇn. " +
                        "Aplikace bÄ›ĹľĂ­ v DEMO reĹľimu. Deaktivace bude skuteÄŤnÄ› provedena " +
                        "pouze u vĂˇmi vytvoĹ™enĂ˝ch uĹľivatelĹŻ."
        );

        user.setEnabled(false);
        userRepository.save(user);

        notifyUser(user, NotificationType.USER_DEACTIVATED);
    }


    /**
     * VrĂˇtĂ­ uĹľivatele podle identifikĂˇtoru ve formÄ› DTO.
     *
     * Metoda se pouĹľĂ­vĂˇ v administraci pĹ™i zobrazenĂ­ detailu ĂşÄŤtu.
     *
     * @param id identifikĂˇtor uĹľivatele
     * @return DTO reprezentace uĹľivatele
     */
    public AppUserDTO getUserById(Long id) {
        AppUserEntity user = findUserByIdOrThrow(id);
        return appUserMapper.toDTO(user);
    }

    /**
     * VytvoĹ™Ă­ poĹľadavek na reset zapomenutĂ©ho hesla.
     *
     * Pokud uĹľivatel pro danĂ˝ e-mail neexistuje, nenĂ­ vyhozena chyba
     * a metoda se ukonÄŤĂ­, aby nebylo moĹľnĂ© odvodit existenci ĂşÄŤtu.
     * PĹ™ed vygenerovĂˇnĂ­m novĂ©ho tokenu jsou odstranÄ›ny pĹ™Ă­padnĂ© starĂ© tokeny.
     * NĂˇslednÄ› je odeslĂˇna notifikace obsahujĂ­cĂ­ odkaz pro nastavenĂ­ novĂ©ho hesla.
     *
     * @param email e-mailovĂˇ adresa uĹľivatele
     */
    @Override
    @Transactional
    public void requestForgottenPasswordReset(String email) {
        AppUserEntity user = userRepository.findByEmail(email)
                .orElse(null);

        if (user == null) {
            log.info("PoĹľadavek na forgotten password reset pro neexistujĂ­cĂ­ email: {}", email);
            return;
        }

        forgottenPasswordResetTokenRepository.deleteByUser(user);

        ForgottenPasswordResetTokenEntity forgottenPasswordToken = createResetPasswordToken(user);
        String resetPasswordlink = buildResetPasswordlink(forgottenPasswordToken);

        log.info("Odkaz pro reset hesla {}: {}", user.getEmail(), resetPasswordlink);

        notifyUser(
                user,
                NotificationType.FORGOTTEN_PASSWORD_RESET_REQUEST,
                new ForgottenPasswordResetContext(user, resetPasswordlink)
        );
    }

    /**
     * VrĂˇtĂ­ e-mailovou adresu uĹľivatele svĂˇzanou se zadanĂ˝m resetovacĂ­m tokenem.
     *
     * Token je vyhledĂˇn a je ovÄ›Ĺ™ena jeho platnost. Metoda se pouĹľĂ­vĂˇ
     * pĹ™i naÄŤĂ­tĂˇnĂ­ formulĂˇĹ™e pro zadĂˇnĂ­ novĂ©ho hesla.
     *
     * @param token resetovacĂ­ token
     * @return e-mailovĂˇ adresa uĹľivatele
     */
    @Override
    @Transactional
    public String getForgottenPasswordResetEmail(String token) {
        ForgottenPasswordResetTokenEntity resetToken =
                forgottenPasswordResetTokenRepository.findByToken(token)
                        .orElseThrow(InvalidResetTokenException::new);

        if (resetToken.getExpiresAt().isBefore(LocalDateTime.now())) {
            throw new InvalidResetTokenException("BE - Reset token expiroval.");
        }

        return resetToken.getUser().getEmail();
    }

    /**
     * NastavĂ­ novĂ© heslo na zĂˇkladÄ› resetovacĂ­ho tokenu.
     *
     * OvÄ›Ĺ™uje se shoda novĂ©ho hesla a jeho potvrzenĂ­ a platnost tokenu.
     * NovĂ© heslo je uloĹľeno v zahashovanĂ© podobÄ› a pouĹľitĂ˝ token je odstranÄ›n.
     * Po ĂşspÄ›ĹˇnĂ©m dokonÄŤenĂ­ je odeslĂˇna notifikace o dokonÄŤenĂ©m resetu hesla.
     *
     * @param dto data pro reset zapomenutĂ©ho hesla
     */
    @Override
    @Transactional
    public void forgottenPasswordReset(ForgottenPasswordResetDTO dto) {
        ensurePasswordsMatch(
                dto.getNewPassword(),
                dto.getNewPasswordConfirm(),
                "BE - NovĂ© heslo a potvrzenĂ­ novĂ©ho hesla se neshodujĂ­"
        );

        ForgottenPasswordResetTokenEntity resetToken =
                forgottenPasswordResetTokenRepository.findByToken(dto.getToken())
                        .orElseThrow(InvalidResetTokenException::new);

        if (resetToken.getExpiresAt().isBefore(LocalDateTime.now())) {
            throw new InvalidResetTokenException("BE - Reset token expiroval.");
        }

        AppUserEntity user = resetToken.getUser();


        demoModeGuard.writeWithFinalize(
                user.getId(),
                "Heslo u uĹľivatele, kterĂ˝ byl vytvoĹ™en aplikacĂ­, nebude ve skuteÄŤnosti resetovĂˇno. " +
                        "Aplikace bÄ›ĹľĂ­ v DEMO reĹľimu. Reset a zmÄ›na zapomenutĂ©ho hesla bude skuteÄŤnÄ› provedena " +
                        "pouze u vĂˇmi vytvoĹ™enĂ˝ch uĹľivatelĹŻ.",
                () -> {
                    user.setPassword(passwordEncoder.encode(dto.getNewPassword()));
                    userRepository.save(user);
                    forgottenPasswordResetTokenRepository.delete(resetToken);
                    notifyUser(user, NotificationType.FORGOTTEN_PASSWORD_RESET_COMPLETED);
                },
                () -> {
                    forgottenPasswordResetTokenRepository.delete(resetToken);
                    notifyUser(user, NotificationType.FORGOTTEN_PASSWORD_RESET_COMPLETED);
                }
        );
    }

    /**
     * Aktualizuje ÄŤasovĂˇ razĂ­tka pĹ™ihlĂˇĹˇenĂ­ uĹľivatele.
     *
     * PĹ™i ĂşspÄ›ĹˇnĂ©m pĹ™ihlĂˇĹˇenĂ­ se pĹŻvodnĂ­ hodnota currentLoginAt
     * uloĹľĂ­ do lastLoginAt a currentLoginAt se nastavĂ­ na aktuĂˇlnĂ­ ÄŤas.
     * Metoda se pouĹľĂ­vĂˇ v bezpeÄŤnostnĂ­ vrstvÄ› po ĂşspÄ›ĹˇnĂ© autentizaci.
     *
     * @param email e-mailovĂˇ adresa pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     */
    @Transactional
    public void onSuccessfulLogin(String email) {
        AppUserEntity user = findUserByEmailOrThrow(email);

        Instant now = Instant.now(clock);

        user.setLastLoginAt(user.getCurrentLoginAt());
        user.setCurrentLoginAt(now);

        userRepository.save(user);

        log.info("AktualizovĂˇna pĹ™ihlĂˇĹˇenĂ­ uĹľivatele {}: lastLoginAt={}, currentLoginAt={}",
                email, user.getLastLoginAt(), user.getCurrentLoginAt());
    }

    // ==================================================
    // HELPER METODY
    // ==================================================

    private String buildActivationLink(EmailVerificationTokenEntity token) {
        return frontendBasUrl + "/verify?token=" + token.getToken();
    }

    private String buildResetPasswordlink(ForgottenPasswordResetTokenEntity token) {
        return baseUrl + "/api/auth/reset-password?token=" + token.getToken();
    }

    private AppUserEntity findUserByEmailOrThrow(String email) {
        return userRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException(email));
    }

    private AppUserEntity findUserByIdOrThrow(Long id) {
        return userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException(id));
    }

    /**
     * OvÄ›Ĺ™Ă­ shodu hesla a jeho potvrzenĂ­.
     *
     * Pokud se hodnoty neshodujĂ­, je vyhozena vĂ˝jimka PasswordsDoNotMatchException.
     * Pokud je pĹ™edĂˇn vlastnĂ­ text, je pouĹľit jako chybovĂˇ zprĂˇva vĂ˝jimky.
     *
     * @param password heslo
     * @param confirm potvrzenĂ­ hesla
     * @param customMessage volitelnĂˇ vlastnĂ­ chybovĂˇ zprĂˇva
     */
    private void ensurePasswordsMatch(String password,
                                      String confirm,
                                      String customMessage) {
        if (password == null || confirm == null || !password.equals(confirm)) {
            if (customMessage == null) {
                throw new PasswordsDoNotMatchException();
            }
            throw new PasswordsDoNotMatchException(customMessage);
        }
    }

    /**
     * OvÄ›Ĺ™Ă­, Ĺľe e-mailovĂˇ adresa nenĂ­ pouĹľĂ­vĂˇna jinĂ˝m uĹľivatelem.
     *
     * PĹ™i registraci je currentUserId null. PĹ™i aktualizaci ĂşÄŤtu se kontroluje,
     * zda pĹ™Ă­padnÄ› nalezenĂ˝ uĹľivatel nenĂ­ totoĹľnĂ˝ s aktualizovanĂ˝m ĂşÄŤtem.
     *
     * @param email e-mailovĂˇ adresa urÄŤenĂˇ ke kontrole
     * @param currentUserId identifikĂˇtor aktuĂˇlnĂ­ho uĹľivatele nebo null pĹ™i registraci
     */
    private void ensureEmailNotUsed(String email, Long currentUserId) {
        userRepository.findByEmail(email).ifPresent(existing -> {
            if (currentUserId == null || !existing.getId().equals(currentUserId)) {
                throw new UserAlreadyExistsException(
                        "BE - UĹľivatel s tĂ­mto emailem jiĹľ existuje"
                );
            }
        });
    }

    /**
     * VytvoĹ™Ă­ novĂ©ho uĹľivatele na zĂˇkladÄ› registraÄŤnĂ­ho DTO.
     *
     * Heslo je uloĹľeno v zahashovanĂ© podobÄ›. ĂšÄŤet je vytvoĹ™en jako neaktivnĂ­
     * a je mu nastavena vĂ˝chozĂ­ role ROLE_PLAYER.
     *
     * @param dto registraÄŤnĂ­ data
     * @return novĂˇ entita uĹľivatele pĹ™ipravenĂˇ k uloĹľenĂ­
     */
    private AppUserEntity createUserFromRegisterDto(RegisterUserDTO dto) {
        AppUserEntity user = appUserMapper.fromRegisterDto(dto);
        user.setPassword(passwordEncoder.encode(dto.getPassword()));
        user.setRole(Role.ROLE_PLAYER);
        user.setEnabled(false);
        return user;
    }

    /**
     * VytvoĹ™Ă­ a uloĹľĂ­ ovÄ›Ĺ™ovacĂ­ token pro aktivaci ĂşÄŤtu.
     *
     * Token mĂˇ omezenou platnost a je pouĹľĂ­vĂˇn pĹ™i aktivaci ĂşÄŤtu pĹ™es odkaz.
     *
     * @param user uĹľivatel, pro kterĂ©ho se token vytvĂˇĹ™Ă­
     * @return uloĹľenĂ˝ ovÄ›Ĺ™ovacĂ­ token
     */
    private EmailVerificationTokenEntity createVerificationToken(AppUserEntity user) {
        EmailVerificationTokenEntity token = new EmailVerificationTokenEntity();
        token.setToken(UUID.randomUUID().toString());
        token.setUser(user);
        token.setExpiresAt(LocalDateTime.now().plusHours(24));
        return tokenRepository.save(token);
    }

    /**
     * VytvoĹ™Ă­ a uloĹľĂ­ resetovacĂ­ token pro proces resetu zapomenutĂ©ho hesla.
     *
     * Token mĂˇ omezenou platnost a je pouĹľĂ­vĂˇn pro autorizaci nastavenĂ­ novĂ©ho hesla.
     *
     * @param user uĹľivatel, pro kterĂ©ho se token vytvĂˇĹ™Ă­
     * @return uloĹľenĂ˝ resetovacĂ­ token
     */
    private ForgottenPasswordResetTokenEntity createResetPasswordToken(AppUserEntity user) {
        ForgottenPasswordResetTokenEntity token = new ForgottenPasswordResetTokenEntity();
        token.setToken(UUID.randomUUID().toString());
        token.setUser(user);
        token.setExpiresAt(LocalDateTime.now().plusHours(1));
        return forgottenPasswordResetTokenRepository.save(token);
    }

    /**
     * OdeĹˇle notifikaci uĹľivateli bez kontextu.
     *
     * VolĂˇnĂ­ je delegovĂˇno do NotificationService.
     *
     * @param user uĹľivatel, kterĂ©mu se notifikace odesĂ­lĂˇ
     * @param type typ notifikace
     */
    private void notifyUser(AppUserEntity user, NotificationType type) {
        notificationService.notifyUser(user, type, null);
    }

    /**
     * OdeĹˇle notifikaci uĹľivateli s volitelnĂ˝m kontextem.
     *
     * VolĂˇnĂ­ je delegovĂˇno do NotificationService.
     *
     * @param user uĹľivatel, kterĂ©mu se notifikace odesĂ­lĂˇ
     * @param type typ notifikace
     * @param context kontextovĂˇ data pro Ĺˇablonu notifikace
     */
    private void notifyUser(AppUserEntity user, NotificationType type, Object context) {
        notificationService.notifyUser(user, type, context);
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserSettingsService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.user.entities.AppUserEntity;
import cz.phsoft.hokej.user.entities.AppUserSettingsEntity;
import cz.phsoft.hokej.user.dto.AppUserSettingsDTO;

/**
 * Service se pouĹľĂ­vĂˇ pro prĂˇci s uĹľivatelskĂ˝m nastavenĂ­m.
 *
 * OdpovÄ›dnostĂ­ je zĂ­skĂˇvĂˇnĂ­, vytvĂˇĹ™enĂ­ a aktualizace nastavenĂ­
 * v kontextu uĹľivatelskĂ©ho ĂşÄŤtu, nikoli v kontextu hrĂˇÄŤe.
 * V tĂ©to vrstvÄ› se pouĹľĂ­vĂˇ typ AppUserSettingsDTO, aby byla
 * oddÄ›lena prezentaÄŤnĂ­ vrstva od perzistentnĂ­ch entit.
 */
public interface AppUserSettingsService {

    /**
     * VrĂˇtĂ­ nastavenĂ­ pro uĹľivatele identifikovanĂ©ho e-mailem.
     * Pokud nastavenĂ­ neexistuje, vytvoĹ™Ă­ se novĂ˝ zĂˇznam
     * s vĂ˝chozĂ­mi hodnotami a uloĹľĂ­ se k danĂ©mu uĹľivateli.
     *
     * Metoda se typicky pouĹľĂ­vĂˇ v controlleru pro naÄŤtenĂ­
     * dat do formulĂˇĹ™e na frontendu.
     *
     * @param userEmail e-mail uĹľivatele, kterĂ˝ slouĹľĂ­ jako unikĂˇtnĂ­ login
     * @return nastavenĂ­ uĹľivatele pĹ™evedenĂ© do AppUserSettingsDTO
     */
    AppUserSettingsDTO getSettingsForUser(String userEmail);

    /**
     * Aktualizuje nastavenĂ­ pro uĹľivatele identifikovanĂ©ho e-mailem.
     * Pokud uĹľivatel nemĂˇ dosud ĹľĂˇdnĂ© nastavenĂ­, vytvoĹ™Ă­ se nejprve
     * vĂ˝chozĂ­ zĂˇznam a potĂ© se na nÄ›j aplikujĂ­ hodnoty z DTO.
     *
     * Metoda se obvykle volĂˇ z controlleru po odeslĂˇnĂ­ formulĂˇĹ™e
     * s uĹľivatelskĂ˝mi preferencemi.
     *
     * @param userEmail e-mail uĹľivatele, pro kterĂ©ho se nastavenĂ­ aktualizuje
     * @param dto novĂ© hodnoty nastavenĂ­ z frontendu
     * @return aktuĂˇlnĂ­ stav nastavenĂ­ po uloĹľenĂ­ v podobÄ› AppUserSettingsDTO
     */
    AppUserSettingsDTO updateSettingsForUser(String userEmail, AppUserSettingsDTO dto);

    /**
     * VytvoĹ™Ă­ vĂ˝chozĂ­ nastavenĂ­ pro danĂ©ho uĹľivatele.
     *
     * Metoda se pouĹľĂ­vĂˇ internÄ› pĹ™i prvnĂ­m pĹ™Ă­stupu k nastavenĂ­,
     * kdy neexistuje ĹľĂˇdnĂ˝ zĂˇznam v tabulce s nastavenĂ­m.
     * VĂ˝chozĂ­ hodnoty se nastavĂ­ tak, aby byla aplikace pouĹľitelnĂˇ
     * i bez ruÄŤnĂ­ho nastavenĂ­.
     *
     * @param user entita uĹľivatele, ke kterĂ© se nastavenĂ­ navĂˇĹľe
     * @return novÄ› vytvoĹ™enĂˇ entita AppUserSettingsEntity s vĂ˝chozĂ­mi hodnotami
     */
    AppUserSettingsEntity createDefaultSettingsForUser(AppUserEntity user);

}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserSettingsServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.user.entities.AppUserEntity;
import cz.phsoft.hokej.user.entities.AppUserSettingsEntity;
import cz.phsoft.hokej.notifications.enums.GlobalNotificationLevel;
import cz.phsoft.hokej.user.enums.LandingPage;
import cz.phsoft.hokej.user.enums.PlayerSelectionMode;
import cz.phsoft.hokej.user.repositories.AppUserSettingsRepository;
import cz.phsoft.hokej.user.repositories.AppUserRepository;
import cz.phsoft.hokej.user.exceptions.UserNotFoundException;
import cz.phsoft.hokej.user.dto.AppUserSettingsDTO;
import cz.phsoft.hokej.user.mappers.AppUserSettingsMapper;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

/**
 * Implementace service pro prĂˇci s uĹľivatelskĂ˝m nastavenĂ­m.
 *
 * OdpovÄ›dnostĂ­ je vyhledĂˇvĂˇnĂ­ uĹľivatele podle e-mailu,
 * zĂ­skĂˇvĂˇnĂ­ nebo vytvĂˇĹ™enĂ­ odpovĂ­dajĂ­cĂ­ho AppUserSettingsEntity
 * a mapovĂˇnĂ­ na AppUserSettingsDTO. V rĂˇmci tĂ©to tĹ™Ă­dy se udrĹľuje
 * vazba mezi nastavenĂ­m a uĹľivatelskĂ˝m ĂşÄŤtem.
 *
 * TĹ™Ă­da pĹ™edstavuje transakÄŤnĂ­ hranici pro operace s uĹľivatelskĂ˝m
 * nastavenĂ­m. Validace vstupĹŻ z HTTP vrstvy a autorizace se Ĺ™eĹˇĂ­
 * v controllerech a bezpeÄŤnostnĂ­ vrstvÄ›.
 */
@Service
@Transactional
public class AppUserSettingsServiceImpl implements AppUserSettingsService {

    private final AppUserRepository appUserRepository;
    private final AppUserSettingsRepository appUserSettingsRepository;
    private final AppUserSettingsMapper mapper;

    /**
     * VytvoĹ™Ă­ instanci service s repository a mapperem.
     *
     * Repository se pouĹľĂ­vajĂ­ pro prĂˇci s entitami AppUserEntity
     * a AppUserSettingsEntity. Mapper zajiĹˇĹĄuje pĹ™evod mezi entitou
     * a AppUserSettingsDTO pro komunikaci s frontendem.
     *
     * @param appUserRepository repository pro uĹľivatelskĂ© ĂşÄŤty
     * @param appUserSettingsRepository repository pro uĹľivatelskĂˇ nastavenĂ­
     * @param mapper mapper pro pĹ™evod mezi entitou a DTO
     */
    public AppUserSettingsServiceImpl(AppUserRepository appUserRepository,
                                      AppUserSettingsRepository appUserSettingsRepository,
                                      AppUserSettingsMapper mapper) {
        this.appUserRepository = appUserRepository;
        this.appUserSettingsRepository = appUserSettingsRepository;
        this.mapper = mapper;
    }

    /**
     * NaÄŤte nastavenĂ­ pro uĹľivatele identifikovanĂ©ho e-mailem.
     *
     * Pokud nastavenĂ­ neexistuje, vytvoĹ™Ă­ se novĂˇ entita s vĂ˝chozĂ­mi
     * hodnotami pomocĂ­ metody createDefaultSettingsForUser a uloĹľĂ­ se.
     * VolajĂ­cĂ­ ÄŤĂˇst aplikace tak vĹľdy obdrĹľĂ­ validnĂ­ nastavenĂ­.
     *
     * @param userEmail e-mail uĹľivatele, pro kterĂ©ho se nastavenĂ­ naÄŤĂ­tĂˇ
     * @return AppUserSettingsDTO s aktuĂˇlnĂ­m nastavenĂ­m uĹľivatele
     * @throws UserNotFoundException pokud uĹľivatel s danĂ˝m e-mailem neexistuje
     */
    @Override
    public AppUserSettingsDTO getSettingsForUser(String userEmail) {
        AppUserEntity user = findUserByEmailOrThrow(userEmail);

        Optional<AppUserSettingsEntity> existingOpt = appUserSettingsRepository.findByUser(user);

        AppUserSettingsEntity settings = existingOpt.orElseGet(() -> {
            AppUserSettingsEntity created = createDefaultSettingsForUser(user);
            return appUserSettingsRepository.save(created);
        });

        return mapper.toDTO(settings);
    }

    /**
     * Aktualizuje nastavenĂ­ pro uĹľivatele identifikovanĂ©ho e-mailem.
     *
     * Pokud uĹľivatel ĹľĂˇdnĂ© nastavenĂ­ nemĂˇ, vytvoĹ™Ă­ se novĂˇ entita
     * s vĂ˝chozĂ­mi hodnotami a nĂˇslednÄ› se do nĂ­ aplikujĂ­ hodnoty
     * z pĹ™edanĂ©ho DTO. Je zajiĹˇtÄ›no, Ĺľe nastavenĂ­ je navĂˇzĂˇno
     * na sprĂˇvnĂ©ho uĹľivatele.
     *
     * @param userEmail e-mail uĹľivatele, pro kterĂ©ho se nastavenĂ­ aktualizuje
     * @param dto novĂ© hodnoty nastavenĂ­ z frontendu
     * @return AppUserSettingsDTO reprezentujĂ­cĂ­ uloĹľenĂ© nastavenĂ­
     * @throws UserNotFoundException pokud uĹľivatel s danĂ˝m e-mailem neexistuje
     */
    @Override
    public AppUserSettingsDTO updateSettingsForUser(String userEmail, AppUserSettingsDTO dto) {
        AppUserEntity user = findUserByEmailOrThrow(userEmail);

        AppUserSettingsEntity settings = appUserSettingsRepository.findByUser(user)
                .orElseGet(() -> createDefaultSettingsForUser(user));

        mapper.updateEntityFromDTO(dto, settings);

        settings.setUser(user);

        AppUserSettingsEntity saved = appUserSettingsRepository.save(settings);

        return mapper.toDTO(saved);
    }

    // =========================================
    // Helper metody
    // =========================================

    /**
     * Najde uĹľivatele podle e-mailu nebo vyhodĂ­ vĂ˝jimku.
     *
     * Metoda centralizuje logiku pro vyhledĂˇvĂˇnĂ­ uĹľivatele v databĂˇzi.
     *
     * @param email e-mail hledanĂ©ho uĹľivatele
     * @return entita AppUserEntity, pokud byla nalezena
     * @throws UserNotFoundException pokud uĹľivatel s danĂ˝m e-mailem neexistuje
     */
    private AppUserEntity findUserByEmailOrThrow(String email) {
        return appUserRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException(email));
    }

    /**
     * VytvoĹ™Ă­ vĂ˝chozĂ­ nastavenĂ­ pro danĂ©ho uĹľivatele.
     *
     * VĂ˝chozĂ­ hodnoty jsou nastaveny explicitnÄ›, aby byly
     * snadno dohledatelnĂ© na jednom mĂ­stÄ›. Metoda se pouĹľĂ­vĂˇ
     * pĹ™i prvnĂ­m naÄŤtenĂ­ nastavenĂ­ nebo pĹ™i zaklĂˇdĂˇnĂ­ novĂ©ho ĂşÄŤtu.
     *
     * @param user entita uĹľivatele, ke kterĂ© se nastavenĂ­ navĂˇĹľe
     * @return entita AppUserSettingsEntity s vĂ˝chozĂ­mi hodnotami
     */
    @Override
    public AppUserSettingsEntity createDefaultSettingsForUser(AppUserEntity user) {
        AppUserSettingsEntity settings = new AppUserSettingsEntity();
        settings.setUser(user);

        settings.setPlayerSelectionMode(PlayerSelectionMode.FIRST_PLAYER);
        settings.setGlobalNotificationLevel(GlobalNotificationLevel.ALL);
        settings.setManagerNotificationLevel(GlobalNotificationLevel.ALL);
        settings.setCopyAllPlayerNotificationsToUserEmail(false);
        settings.setReceiveNotificationsForPlayersWithOwnEmail(false);
        settings.setEmailDigestEnabled(false);
        settings.setEmailDigestTime(null);
        settings.setUiLanguage("cs");
        settings.setTimezone("Europe/Prague");
        settings.setDefaultLandingPage(LandingPage.DASHBOARD);

        appUserSettingsRepository.save(settings);

        return settings;
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\CurrentPlayerService.java
-----
package cz.phsoft.hokej.models.services;

/**
 * RozhranĂ­ se pouĹľĂ­vĂˇ pro sprĂˇvu aktuĂˇlnÄ› zvolenĂ©ho hrĂˇÄŤe pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
 *
 * UĹľivatel mĹŻĹľe mĂ­t v systĂ©mu vĂ­ce hrĂˇÄŤĹŻ, ale vÄ›tĹˇina aplikaÄŤnĂ­ch operacĂ­
 * (registrace na zĂˇpasy, pĹ™ehledy, statistiky) pracuje vĹľdy s jednĂ­m
 * jednoznaÄŤnÄ› urÄŤenĂ˝m hrĂˇÄŤem. RozhranĂ­ definuje jednotnĂ˝ kontrakt
 * pro prĂˇci s tĂ­mto kontextem napĹ™Ă­ÄŤ aplikacĂ­.
 *
 * RozhranĂ­ oddÄ›luje prĂˇci s uĹľivatelskĂ˝m kontextem od business logiky.
 * KonkrĂ©tnĂ­ implementace obvykle uklĂˇdĂˇ identifikĂˇtor hrĂˇÄŤe do uĹľivatelskĂ©
 * session. OvÄ›Ĺ™enĂ­ existence a stavu hrĂˇÄŤe je odpovÄ›dnostĂ­ implementace.
 */
public interface CurrentPlayerService {

    /**
     * VrĂˇtĂ­ identifikĂˇtor aktuĂˇlnÄ› zvolenĂ©ho hrĂˇÄŤe.
     *
     * @return ID hrĂˇÄŤe nebo null, pokud aktuĂˇlnĂ­ hrĂˇÄŤ nenĂ­ nastaven
     */
    Long getCurrentPlayerId();

    /**
     * NastavĂ­ aktuĂˇlnĂ­ho hrĂˇÄŤe v uĹľivatelskĂ©m kontextu.
     *
     * Metoda slouĹľĂ­ ke zmÄ›nÄ› kontextu pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * na konkrĂ©tnĂ­ho hrĂˇÄŤe. Implementace je odpovÄ›dnĂˇ za to,
     * aby byl zvolen pouze platnĂ˝ hrĂˇÄŤ v odpovĂ­dajĂ­cĂ­m stavu.
     *
     * @param playerId ID hrĂˇÄŤe, kterĂ˝ mĂˇ bĂ˝t nastaven jako aktuĂˇlnĂ­
     */
    void setCurrentPlayerId(Long playerId);

    /**
     * OvÄ›Ĺ™Ă­, Ĺľe je aktuĂˇlnĂ­ hrĂˇÄŤ nastaven.
     *
     * Metoda se pouĹľĂ­vĂˇ pĹ™ed operacemi, kterĂ© vyĹľadujĂ­ kontext
     * aktuĂˇlnÄ› zvolenĂ©ho hrĂˇÄŤe. Pokud hrĂˇÄŤ nenĂ­ zvolen, je vyhozena vĂ˝jimka.
     *
     * @throws RuntimeException pokud aktuĂˇlnĂ­ hrĂˇÄŤ nenĂ­ nastaven
     */
    void requireCurrentPlayer();

    /**
     * OdstranĂ­ informaci o aktuĂˇlnĂ­m hrĂˇÄŤi z uĹľivatelskĂ©ho kontextu.
     *
     * Metoda se pouĹľĂ­vĂˇ zejmĂ©na pĹ™i odhlĂˇĹˇenĂ­ uĹľivatele nebo pĹ™i
     * explicitnĂ­m resetu uĹľivatelskĂ©ho kontextu.
     */
    void clear();
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\CurrentPlayerServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.player.entities.PlayerEntity;
import cz.phsoft.hokej.player.enums.PlayerStatus;
import cz.phsoft.hokej.player.repositories.PlayerRepository;
import cz.phsoft.hokej.player.exceptions.CurrentPlayerNotSelectedException;
import cz.phsoft.hokej.player.exceptions.InvalidPlayerStatusException;
import cz.phsoft.hokej.player.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.security.SessionKeys;
import cz.phsoft.hokej.security.impersonation.ImpersonationContext;
import jakarta.servlet.http.HttpSession;
import org.springframework.stereotype.Service;

/**
 * Implementace rozhranĂ­ CurrentPlayerService.
 *
 * TĹ™Ă­da spravuje identifikĂˇtor aktuĂˇlnÄ› zvolenĂ©ho hrĂˇÄŤe v HTTP session
 * pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele. V session se uklĂˇdĂˇ pouze ID hrĂˇÄŤe, nikoli
 * celĂˇ entita.
 *
 * Pokud je aktivnĂ­ reĹľim zastoupenĂ­ administrĂˇtorem, je jako aktuĂˇlnĂ­ hrĂˇÄŤ
 * vracen hrĂˇÄŤ urÄŤenĂ˝ v impersonaÄŤnĂ­m kontextu. V takovĂ©m pĹ™Ă­padÄ› se hodnota
 * v session nepouĹľĂ­vĂˇ a zĹŻstĂˇvĂˇ beze zmÄ›ny.
 *
 * PomocĂ­ PlayerRepository se ovÄ›Ĺ™uje, zda hrĂˇÄŤ existuje a zda je ve stavu
 * vhodnĂ©m pro pouĹľitĂ­ v aplikaci.
 *
 * TĹ™Ă­da neĹ™eĹˇĂ­ oprĂˇvnÄ›nĂ­ uĹľivatele k danĂ©mu hrĂˇÄŤi ani business logiku
 * zĂˇpasĹŻ a registracĂ­. Tyto oblasti jsou pokryty jinĂ˝mi service tĹ™Ă­dami.
 */
@Service
public class CurrentPlayerServiceImpl implements CurrentPlayerService {

    /**
     * HTTP session vĂˇzanĂˇ na pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     * SlouĹľĂ­ k uchovĂˇnĂ­ identifikĂˇtoru aktuĂˇlnĂ­ho hrĂˇÄŤe.
     */
    private final HttpSession session;

    /**
     * Repository pro prĂˇci s entitami hrĂˇÄŤĹŻ.
     * PouĹľĂ­vĂˇ se k ovÄ›Ĺ™enĂ­ existence hrĂˇÄŤe a jeho aktuĂˇlnĂ­ho stavu.
     */
    private final PlayerRepository playerRepository;

    public CurrentPlayerServiceImpl(HttpSession session,
                                    PlayerRepository playerRepository) {
        this.session = session;
        this.playerRepository = playerRepository;
    }

    /**
     * VrĂˇtĂ­ identifikĂˇtor aktuĂˇlnĂ­ho hrĂˇÄŤe.
     *
     * Pokud je aktivnĂ­ reĹľim zastoupenĂ­, je vrĂˇcen identifikĂˇtor impersonovanĂ©ho
     * hrĂˇÄŤe. V opaÄŤnĂ©m pĹ™Ă­padÄ› je vrĂˇcen identifikĂˇtor uloĹľenĂ˝ v HTTP session.
     *
     * @return ID hrĂˇÄŤe nebo null, pokud aktuĂˇlnĂ­ hrĂˇÄŤ jeĹˇtÄ› nebyl zvolen
     */
    @Override
    public Long getCurrentPlayerId() {
        Long impersonatedPlayerId = ImpersonationContext.getImpersonatedPlayerId();
        if (impersonatedPlayerId != null) {
            return impersonatedPlayerId;
        }
        return (Long) session.getAttribute(SessionKeys.CURRENT_PLAYER_ID);
    }

    /**
     * NastavĂ­ aktuĂˇlnĂ­ho hrĂˇÄŤe do HTTP session.
     *
     * PĹ™ed uloĹľenĂ­m do session se ovÄ›Ĺ™Ă­, Ĺľe hrĂˇÄŤ existuje
     * a Ĺľe je ve stavu PlayerStatus.APPROVED. Pokud nÄ›kterĂˇ
     * z podmĂ­nek nenĂ­ splnÄ›na, je vyhozena vĂ˝jimka.
     *
     * ReĹľim zastoupenĂ­ tuto operaci nemÄ›nĂ­. ZvolenĂ˝ hrĂˇÄŤ se uklĂˇdĂˇ
     * do session a pouĹľĂ­vĂˇ se pĹ™i bÄ›ĹľnĂ©m reĹľimu bez impersonace.
     *
     * @param playerId ID hrĂˇÄŤe, kterĂ˝ mĂˇ bĂ˝t nastaven jako aktuĂˇlnĂ­
     * @throws PlayerNotFoundException pokud hrĂˇÄŤ s danĂ˝m ID neexistuje
     * @throws InvalidPlayerStatusException pokud hrĂˇÄŤ nenĂ­ ve schvĂˇlenĂ©m stavu
     */
    @Override
    public void setCurrentPlayerId(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        validatePlayerSelectable(player);

        session.setAttribute(SessionKeys.CURRENT_PLAYER_ID, playerId);
    }

    /**
     * OvÄ›Ĺ™Ă­, Ĺľe je aktuĂˇlnĂ­ hrĂˇÄŤ nastaven.
     *
     * Metoda se pouĹľĂ­vĂˇ pĹ™ed operacemi, kterĂ© vyĹľadujĂ­ kontext
     * aktuĂˇlnĂ­ho hrĂˇÄŤe, napĹ™Ă­klad pĹ™ed registracĂ­ na zĂˇpas
     * nebo pĹ™i volĂˇnĂ­ endpointĹŻ pracujĂ­cĂ­ch s â€ž/meâ€ś.
     *
     * Pokud je aktivnĂ­ reĹľim zastoupenĂ­, je podmĂ­nka povaĹľovĂˇna
     * za splnÄ›nou, protoĹľe aktuĂˇlnĂ­ hrĂˇÄŤ je urÄŤen impersonaÄŤnĂ­m kontextem.
     *
     * @throws CurrentPlayerNotSelectedException pokud aktuĂˇlnĂ­ hrĂˇÄŤ nenĂ­ nastaven
     */
    @Override
    public void requireCurrentPlayer() {
        Long currentPlayerId = getCurrentPlayerId();
        if (currentPlayerId == null) {
            throw new CurrentPlayerNotSelectedException();
        }
    }

    /**
     * OdstranĂ­ informaci o aktuĂˇlnĂ­m hrĂˇÄŤi z HTTP session.
     *
     * Metoda se pouĹľĂ­vĂˇ pĹ™i odhlĂˇĹˇenĂ­ uĹľivatele nebo pĹ™i resetu
     * uĹľivatelskĂ©ho kontextu, kdy jiĹľ nemĂˇ bĂ˝t vazba na konkrĂ©tnĂ­ho hrĂˇÄŤe.
     *
     * ReĹľim zastoupenĂ­ se neuklĂˇdĂˇ do session a jeho vyÄŤiĹˇtÄ›nĂ­ se Ĺ™eĹˇĂ­
     * na Ăşrovni request filtru.
     */
    @Override
    public void clear() {
        session.removeAttribute(SessionKeys.CURRENT_PLAYER_ID);
    }

    // ==================================================
    // Helper metody
    // ==================================================

    /**
     * Najde hrĂˇÄŤe podle ID nebo vyhodĂ­ vĂ˝jimku.
     *
     * @param playerId ID hledanĂ©ho hrĂˇÄŤe
     * @return entita PlayerEntity odpovĂ­dajĂ­cĂ­ zadanĂ©mu ID
     * @throws PlayerNotFoundException pokud hrĂˇÄŤ s danĂ˝m ID neexistuje
     */
    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    /**
     * OvÄ›Ĺ™Ă­, zda mĹŻĹľe bĂ˝t hrĂˇÄŤ zvolen jako aktuĂˇlnĂ­.
     *
     * V souÄŤasnĂ© dobÄ› je povolen pouze stav PlayerStatus.APPROVED.
     * OstatnĂ­ stavy jsou povaĹľovĂˇny za neplatnĂ© pro pouĹľitĂ­
     * v kontextu pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * @param player entita hrĂˇÄŤe, kterĂˇ mĂˇ bĂ˝t ovÄ›Ĺ™ena
     * @throws InvalidPlayerStatusException pokud hrĂˇÄŤ nenĂ­ ve schvĂˇlenĂ©m stavu
     */
    private void validatePlayerSelectable(PlayerEntity player) {
        if (player.getPlayerStatus() != PlayerStatus.APPROVED) {
            throw new InvalidPlayerStatusException(
                    "BE - Nelze zvolit hrĂˇÄŤe, kterĂ˝ nenĂ­ schvĂˇlen administrĂˇtorem."
            );
        }
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\CurrentSeasonService.java
-----
package cz.phsoft.hokej.models.services;

/**
 * RozhranĂ­ se pouĹľĂ­vĂˇ pro sprĂˇvu aktuĂˇlnÄ› zvolenĂ© sezĂłny
 * v kontextu pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
 *
 * SezĂłna slouĹľĂ­ jako globĂˇlnĂ­ kontextovĂ˝ filtr pro vÄ›tĹˇinu
 * aplikaÄŤnĂ­ch operacĂ­, jako jsou zĂˇpasy, statistiky a pĹ™ehledy.
 * UĹľivatel mĹŻĹľe pracovat buÄŹ s automaticky zvolenou aktivnĂ­ sezĂłnou,
 * nebo si mĹŻĹľe sezĂłnu explicitnÄ› vybrat.
 *
 * RozhranĂ­ definuje jednotnĂ˝ kontrakt pro prĂˇci s aktuĂˇlnĂ­ sezĂłnou
 * a oddÄ›luje prĂˇci se session od business logiky sprĂˇvy sezĂłn.
 */
public interface CurrentSeasonService {

    /**
     * VrĂˇtĂ­ identifikĂˇtor aktuĂˇlnÄ› pouĹľĂ­vanĂ© sezĂłny.
     *
     * Pokud je v session uloĹľena sezĂłna, kterou si uĹľivatel
     * explicitnÄ› zvolil, vrĂˇtĂ­ se tato hodnota.
     * Pokud sezĂłna nastavena nenĂ­ nebo nebyla zvolena vÄ›domÄ›,
     * pouĹľije se globĂˇlnÄ› aktivnĂ­ sezĂłna definovanĂˇ v systĂ©mu.
     *
     * PĹ™i pouĹľitĂ­ globĂˇlnÄ› aktivnĂ­ sezĂłny se jejĂ­ identifikĂˇtor
     * uloĹľĂ­ do session jako automaticky zvolenĂ˝.
     *
     * @return ID aktuĂˇlnĂ­ sezĂłny nebo null, pokud neexistuje ĹľĂˇdnĂˇ aktivnĂ­ sezĂłna
     */
    Long getCurrentSeasonIdOrDefault();

    /**
     * NastavĂ­ sezĂłnu jako aktuĂˇlnĂ­ pro pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * Metoda se pouĹľĂ­vĂˇ v okamĹľiku, kdy si uĹľivatel sezĂłnu
     * explicitnÄ› vybere. ZvolenĂˇ sezĂłna je uloĹľena do session
     * jako uĹľivatelskĂˇ volba.
     *
     * @param seasonId ID sezĂłny, kterĂˇ mĂˇ bĂ˝t nastavena jako aktuĂˇlnĂ­
     */
    void setCurrentSeasonId(Long seasonId);

    /**
     * OdstranĂ­ informaci o aktuĂˇlnĂ­ sezĂłnÄ› z uĹľivatelskĂ©ho kontextu.
     *
     * Metoda se pouĹľĂ­vĂˇ zejmĂ©na pĹ™i odhlĂˇĹˇenĂ­ uĹľivatele
     * nebo pĹ™i resetu session.
     */
    void clearCurrentSeason();
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\CurrentSeasonServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.season.dto.SeasonDTO;
import jakarta.servlet.http.HttpSession;
import org.springframework.stereotype.Service;

/**
 * Implementace rozhranĂ­ CurrentSeasonService.
 *
 * TĹ™Ă­da spravuje identifikĂˇtor aktuĂˇlnÄ› zvolenĂ© sezĂłny
 * v HTTP session pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
 * RozliĹˇuje se, zda byla sezĂłna zvolena explicitnÄ› uĹľivatelem,
 * nebo byla nastavena automaticky na zĂˇkladÄ› globĂˇlnÄ› aktivnĂ­ sezĂłny.
 *
 * SprĂˇva samotnĂ˝ch sezĂłn a jejich ĹľivotnĂ­ho cyklu nenĂ­
 * odpovÄ›dnostĂ­ tĂ©to tĹ™Ă­dy a je Ĺ™eĹˇena v SeasonService.
 */
@Service
public class CurrentSeasonServiceImpl implements CurrentSeasonService {

    /**
     * NĂˇzev session atributu pro uloĹľenĂ­ ID aktuĂˇlnĂ­ sezĂłny.
     */
    private static final String CURRENT_SEASON_SESSION_ATTR = "CURRENT_SEASON_ID";

    /**
     * Session atribut urÄŤujĂ­cĂ­, zda byla sezĂłna zvolena uĹľivatelem.
     *
     * Hodnota true znaÄŤĂ­ explicitnĂ­ uĹľivatelskou volbu.
     * Hodnota false nebo null znaÄŤĂ­ automatickĂ© nastavenĂ­.
     */
    private static final String CURRENT_SEASON_CUSTOM_ATTR = "CURRENT_SEASON_CUSTOM";

    /**
     * HTTP session pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     */
    private final HttpSession session;

    /**
     * Service poskytujĂ­cĂ­ informace o sezĂłnĂˇch.
     *
     * PouĹľĂ­vĂˇ se k zĂ­skĂˇnĂ­ globĂˇlnÄ› aktivnĂ­ sezĂłny.
     */
    private final SeasonService seasonService;

    public CurrentSeasonServiceImpl(HttpSession session,
                                    SeasonService seasonService) {
        this.session = session;
        this.seasonService = seasonService;
    }

    /**
     * VrĂˇtĂ­ identifikĂˇtor aktuĂˇlnĂ­ sezĂłny podle stanovenĂ© priority.
     *
     * Nejprve se zohlednĂ­ sezĂłna explicitnÄ› zvolenĂˇ uĹľivatelem.
     * Pokud takovĂˇ volba neexistuje, pouĹľije se globĂˇlnÄ› aktivnĂ­ sezĂłna.
     * PĹ™i automatickĂ©m nastavenĂ­ se identifikĂˇtor sezĂłny uloĹľĂ­ do session.
     *
     * @return ID aktuĂˇlnĂ­ sezĂłny nebo null, pokud nenĂ­ k dispozici ĹľĂˇdnĂˇ aktivnĂ­ sezĂłna
     */
    @Override
    public Long getCurrentSeasonIdOrDefault() {
        Object value = session.getAttribute(CURRENT_SEASON_SESSION_ATTR);
        Boolean custom = (Boolean) session.getAttribute(CURRENT_SEASON_CUSTOM_ATTR);

        if (Boolean.TRUE.equals(custom) && value != null) {
            return toLong(value);
        }

        SeasonDTO active = seasonService.getActiveSeasonOrNull();
        if (active != null) {
            Long id = active.getId();
            session.setAttribute(CURRENT_SEASON_SESSION_ATTR, id);
            session.setAttribute(CURRENT_SEASON_CUSTOM_ATTR, Boolean.FALSE);
            return id;
        }

        return null;
    }

    /**
     * NastavĂ­ sezĂłnu jako aktuĂˇlnĂ­ pro pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * SezĂłna je uloĹľena do session a oznaÄŤena jako
     * explicitnĂ­ uĹľivatelskĂˇ volba.
     *
     * @param seasonId ID sezĂłny, kterĂˇ mĂˇ bĂ˝t nastavena
     */
    @Override
    public void setCurrentSeasonId(Long seasonId) {
        session.setAttribute(CURRENT_SEASON_SESSION_ATTR, seasonId);
        session.setAttribute(CURRENT_SEASON_CUSTOM_ATTR, Boolean.TRUE);
    }

    /**
     * OdstranĂ­ informaci o aktuĂˇlnĂ­ sezĂłnÄ› z HTTP session.
     *
     * Metoda se pouĹľĂ­vĂˇ pĹ™i odhlĂˇĹˇenĂ­ uĹľivatele
     * nebo pĹ™i resetu uĹľivatelskĂ©ho kontextu.
     */
    @Override
    public void clearCurrentSeason() {
        session.removeAttribute(CURRENT_SEASON_SESSION_ATTR);
        session.removeAttribute(CURRENT_SEASON_CUSTOM_ATTR);
    }

    /**
     * ZajistĂ­ bezpeÄŤnĂ˝ pĹ™evod hodnoty ze session na typ Long.
     *
     * Metoda slouĹľĂ­ jako ochrana proti rozdĂ­lnĂ˝m typĹŻm hodnot,
     * kterĂ© mĹŻĹľe servlet container vrĂˇtit.
     *
     * @param value hodnota naÄŤtenĂˇ ze session
     * @return hodnota pĹ™evedenĂˇ na Long
     */
    private Long toLong(Object value) {
        if (value instanceof Long l) return l;
        if (value instanceof Integer i) return i.longValue();
        return Long.valueOf(value.toString());
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationCommandService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.registration.enums.ExcuseReason;
import cz.phsoft.hokej.registration.enums.PlayerMatchStatus;
import cz.phsoft.hokej.player.enums.PlayerPosition;
import cz.phsoft.hokej.player.enums.Team;
import cz.phsoft.hokej.registration.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.registration.dto.MatchRegistrationRequest;

/**
 * Service vrstva pro pĹ™Ă­kazovĂ© operace nad registracemi hrĂˇÄŤĹŻ na zĂˇpasy.
 *
 * RozhranĂ­ se pouĹľĂ­vĂˇ pro zmÄ›ny stavu registracĂ­, zmÄ›ny tĂ˝mu a pozic,
 * pĹ™epoÄŤet kapacity pĹ™i zmÄ›nÄ› poÄŤtu hrĂˇÄŤĹŻ a pro hromadnĂ© odesĂ­lĂˇnĂ­ SMS.
 *
 * NeĹ™eĹˇĂ­ ÄŤtecĂ­ operace nad registracemi (ty zĹŻstĂˇvajĂ­ v {@link MatchRegistrationService}).
 */
public interface MatchRegistrationCommandService {

    /**
     * VytvĂˇĹ™Ă­ nebo aktualizuje registraci hrĂˇÄŤe na zĂˇpas.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe.
     * @param request  PoĹľadavek na zmÄ›nu registrace.
     * @return UloĹľenĂˇ registrace pĹ™evedenĂˇ do DTO.
     */
    MatchRegistrationDTO upsertRegistration(Long playerId, MatchRegistrationRequest request);

    /**
     * Nastavuje registraci hrĂˇÄŤe do stavu NO_EXCUSED.
     *
     * @param matchId   IdentifikĂˇtor zĂˇpasu.
     * @param playerId  IdentifikĂˇtor hrĂˇÄŤe.
     * @param adminNote PoznĂˇmka administrĂˇtora.
     * @return AktualizovanĂˇ registrace pĹ™evedenĂˇ do DTO.
     */
    MatchRegistrationDTO markNoExcused(Long matchId, Long playerId, String adminNote);

    /**
     * RuĹˇĂ­ stav NO_EXCUSED a nastavuje registraci do stavu EXCUSED.
     *
     * @param matchId      IdentifikĂˇtor zĂˇpasu.
     * @param playerId     IdentifikĂˇtor hrĂˇÄŤe.
     * @param excuseReason DĹŻvod omluvy.
     * @param excuseNote   PoznĂˇmka omluvy.
     * @return AktualizovanĂˇ registrace pĹ™evedenĂˇ do DTO.
     */
    MatchRegistrationDTO cancelNoExcused(Long matchId,
                                         Long playerId,
                                         ExcuseReason excuseReason,
                                         String excuseNote);

    /**
     * MÄ›nĂ­ tĂ˝m hrĂˇÄŤe v rĂˇmci registrace na zĂˇpas.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe.
     * @param matchId  IdentifikĂˇtor zĂˇpasu.
     * @return AktualizovanĂˇ registrace pĹ™evedenĂˇ do DTO.
     */
    MatchRegistrationDTO changeRegistrationTeam(Long playerId, Long matchId);

    /**
     * MÄ›nĂ­ pozici hrĂˇÄŤe v rĂˇmci konkrĂ©tnĂ­ho zĂˇpasu.
     *
     * @param playerId        IdentifikĂˇtor hrĂˇÄŤe.
     * @param matchId         IdentifikĂˇtor zĂˇpasu.
     * @param positionInMatch CĂ­lovĂˇ pozice v zĂˇpase.
     * @return AktualizovanĂˇ registrace pĹ™evedenĂˇ do DTO.
     */
    MatchRegistrationDTO changeRegistrationPosition(Long playerId,
                                                    Long matchId,
                                                    PlayerPosition positionInMatch);

    /**
     * ProvĂˇdĂ­ administrĂˇtorskou zmÄ›nu stavu registrace.
     *
     * @param matchId  IdentifikĂˇtor zĂˇpasu.
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe.
     * @param status   CĂ­lovĂ˝ stav registrace.
     * @return AktualizovanĂˇ registrace pĹ™evedenĂˇ do DTO.
     */
    MatchRegistrationDTO updateStatus(Long matchId,
                                      Long playerId,
                                      PlayerMatchStatus status);

    /**
     * PĹ™epoÄŤĂ­tĂˇvĂˇ stavy REGISTERED a RESERVED podle aktuĂˇlnĂ­ kapacity zĂˇpasu.
     *
     * @param matchId IdentifikĂˇtor zĂˇpasu.
     */
    void recalcStatusesForMatch(Long matchId);

    /**
     * PovyĹˇuje kandidĂˇty ze stavu RESERVED do stavu REGISTERED
     * pĹ™i navĂ˝ĹˇenĂ­ kapacity zĂˇpasu.
     *
     * @param matchId       IdentifikĂˇtor zĂˇpasu.
     * @param freedTeam     TĂ˝m, ve kterĂ©m se mĂ­sto uvolnilo (nebo preferovanĂ˝ tĂ˝m).
     * @param freedPosition Pozice, kterĂˇ se uvolnila (nebo null).
     * @param slotsCount    PoÄŤet novĂ˝ch mĂ­st, kterĂˇ se majĂ­ obsadit.
     */
    void promoteReservedCandidatesForCapacityIncrease(Long matchId,
                                                      Team freedTeam,
                                                      PlayerPosition freedPosition,
                                                      int slotsCount);

    /**
     * OdesĂ­lĂˇ SMS zprĂˇvu vĹˇem hrĂˇÄŤĹŻm ve stavu REGISTERED,
     * kteĹ™Ă­ majĂ­ povolenĂ© SMS notifikace.
     *
     * @param matchId IdentifikĂˇtor zĂˇpasu.
     */
    void sendSmsToRegisteredPlayers(Long matchId);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationCommandServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.match.entities.MatchEntity;
import cz.phsoft.hokej.registration.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.player.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.*;
import cz.phsoft.hokej.registration.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.match.repositories.MatchRepository;
import cz.phsoft.hokej.player.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.match.enums.MatchMode;
import cz.phsoft.hokej.registration.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.registration.dto.MatchRegistrationRequest;
import cz.phsoft.hokej.registration.mappers.MatchRegistrationMapper;
import cz.phsoft.hokej.notifications.services.NotificationService;
import cz.phsoft.hokej.models.services.sms.SmsMessageBuilder;
import cz.phsoft.hokej.models.services.sms.SmsService;
import jakarta.transaction.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

/**
 * Implementace pĹ™Ă­kazovĂ© service vrstvy pro sprĂˇvu registracĂ­ hrĂˇÄŤĹŻ na zĂˇpasy.
 *
 * Tato tĹ™Ă­da zajiĹˇĹĄuje veĹˇkerĂ© zmÄ›ny stavĹŻ registracĂ­, zmÄ›ny tĂ˝mĹŻ a pozic,
 * pĹ™epoÄŤet kapacity zĂˇpasu pĹ™i zmÄ›nÄ› poÄŤtu hrĂˇÄŤĹŻ a hromadnĂ© odesĂ­lĂˇnĂ­ SMS.
 *
 * TĹ™Ă­da obsahuje business logiku registracĂ­ a souvisejĂ­cĂ­ch pravidel.
 * NeĹ™eĹˇĂ­ ÄŤtecĂ­ operace nad registracemi, kterĂ© zĹŻstĂˇvajĂ­ v {@link MatchRegistrationService}.
 */
@Service
public class MatchRegistrationCommandServiceImpl implements MatchRegistrationCommandService {

    private static final Logger log = LoggerFactory.getLogger(MatchRegistrationCommandServiceImpl.class);

    private final MatchRegistrationRepository registrationRepository;
    private final MatchRepository matchRepository;
    private final PlayerRepository playerRepository;
    private final MatchRegistrationMapper matchRegistrationMapper;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;
    private final NotificationService notificationService;

    public MatchRegistrationCommandServiceImpl(
            MatchRegistrationRepository registrationRepository,
            MatchRepository matchRepository,
            PlayerRepository playerRepository,
            MatchRegistrationMapper matchRegistrationMapper,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder,
            NotificationService notificationService
    ) {
        this.registrationRepository = registrationRepository;
        this.matchRepository = matchRepository;
        this.playerRepository = playerRepository;
        this.matchRegistrationMapper = matchRegistrationMapper;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
        this.notificationService = notificationService;
    }

    // ==========================================
    // HLAVNĂŤ METODA â€“ UPSERT REGISTRACE HRĂÄŚE
    // ==========================================

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional
    public MatchRegistrationDTO upsertRegistration(Long playerId, MatchRegistrationRequest request) {

        MatchEntity match = getMatchOrThrow(request.getMatchId());
        PlayerEntity player = getPlayerOrThrow(playerId);

        // OvÄ›Ĺ™enĂ­, Ĺľe zĂˇpas patĹ™Ă­ do aktivnĂ­ sezĂłny.
        assertMatchInActiveSeason(match);

        // OvÄ›Ĺ™enĂ­ oprĂˇvnÄ›nĂ­ hrĂˇÄŤe mÄ›nit registraci v ÄŤase.
        assertPlayerCanModifyMatch(match);

        MatchRegistrationEntity registration =
                getRegistrationOrNull(playerId, request.getMatchId());

        if (registration == null && !request.isUnregister()) {
            registration = new MatchRegistrationEntity();
            registration.setMatch(match);
            registration.setPlayer(player);
        }

        PlayerMatchStatus originalStatus =
                (registration != null) ? registration.getStatus() : null;

        PlayerMatchStatus newStatus;

        if (request.isUnregister()) {
            newStatus = handleUnregister(request, playerId, registration);
        } else if (request.getExcuseReason() != null) {
            newStatus = handleExcuse(request, match, player, registration);
        } else {
            newStatus = handleRegisterOrReserveOrSubstitute(request, match, player, registration);
        }

        applyRequestDetails(registration, request);

        registration.setStatus(newStatus);
        registration.setTimestamp(now());
        registration.setCreatedBy("user");

        registration = registrationRepository.save(registration);

        // Po odhlĂˇĹˇenĂ­ ze stavu REGISTERED se provede pokus o povĂ˝ĹˇenĂ­
        // nejvhodnÄ›jĹˇĂ­ho kandidĂˇta ze stavu RESERVED.
        if (request.isUnregister() && originalStatus == PlayerMatchStatus.REGISTERED) {
            promoteReservedCandidateAfterUnregister(match, registration);
        }

        NotificationType notificationType = resolveNotificationType(newStatus);
        if (notificationType != null) {
            notifyPlayer(player, notificationType, registration);
        }

        return matchRegistrationMapper.toDTO(registration);
    }

    // ==========================================
    // OMLUVY A NO_EXCUSED
    // ==========================================

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional
    public MatchRegistrationDTO markNoExcused(Long matchId,
                                              Long playerId,
                                              String adminNote) {

        MatchEntity match = getMatchOrThrow(matchId);
        PlayerEntity player = getPlayerOrThrow(playerId);

        if (match.getDateTime().isAfter(now())) {
            throw new InvalidPlayerStatusException(
                    "BE - Status NO_EXCUSED lze nastavit pouze u jiĹľ probÄ›hlĂ©ho zĂˇpasu."
            );
        }

        MatchRegistrationEntity registration = getRegistrationOrThrow(playerId, matchId);

        if (registration.getStatus() != PlayerMatchStatus.REGISTERED) {
            throw new InvalidPlayerStatusException(
                    "BE - Status NO_EXCUSED lze nastavit pouze z registrace REGISTERED."
            );
        }

        registration.setExcuseReason(null);
        registration.setExcuseNote(null);

        if (adminNote == null || adminNote.isBlank()) {
            registration.setAdminNote("Nedostavil se bez omluvy");
        } else {
            registration.setAdminNote(adminNote);
        }

        MatchRegistrationEntity updated =
                updateRegistrationStatus(
                        registration,
                        PlayerMatchStatus.NO_EXCUSED,
                        "admin",
                        true
                );

        PlayerMatchStatus newStatus = PlayerMatchStatus.NO_EXCUSED;

        NotificationType notificationType = resolveNotificationType(newStatus);
        if (notificationType != null) {
            notifyPlayer(player, notificationType, updated);
        }

        return matchRegistrationMapper.toDTO(updated);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional
    public MatchRegistrationDTO cancelNoExcused(Long matchId,
                                                Long playerId,
                                                ExcuseReason excuseReason,
                                                String excuseNote) {

        MatchEntity match = getMatchOrThrow(matchId);
        getPlayerOrThrow(playerId);

        if (match.getDateTime().isAfter(now())) {
            throw new InvalidPlayerStatusException(
                    "BE - Status EXCUSED po NO-EXCUSED lze nastavit pouze u jiĹľ probÄ›hlĂ©ho zĂˇpasu."
            );
        }

        MatchRegistrationEntity registration = getRegistrationOrThrow(playerId, matchId);

        if (registration.getStatus() != PlayerMatchStatus.NO_EXCUSED) {
            throw new InvalidPlayerStatusException(
                    "BE - Status EXCUSED (zruĹˇenĂ­ neomluvenĂ­) lze nastavit pouze u hrĂˇÄŤe se statutem NO_EXCUSED."
            );
        }

        registration.setExcuseReason(excuseReason != null ? excuseReason : ExcuseReason.JINE);
        registration.setAdminNote(null);
        if (excuseNote == null || excuseNote.isBlank()) {
            registration.setExcuseNote("Opravdu nemohl");
        } else {
            registration.setExcuseNote(excuseNote);
        }

        MatchRegistrationEntity updated =
                updateRegistrationStatus(
                        registration,
                        PlayerMatchStatus.EXCUSED,
                        "manager",
                        true
                );

        return matchRegistrationMapper.toDTO(updated);
    }

    // ==========================================
    // ZMÄšNY TĂťMU A POZICE
    // ==========================================

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional
    public MatchRegistrationDTO changeRegistrationTeam(Long playerId,
                                                       Long matchId) {

        MatchEntity match = getMatchOrThrow(matchId);
        PlayerEntity player = getPlayerOrThrow(playerId);

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth != null) {
            log.debug("changeRegistrationTeam â€“ current user: {}", auth.getName());
            log.debug("changeRegistrationTeam â€“ authorities: {}", auth.getAuthorities());
        } else {
            log.debug("changeRegistrationTeam â€“ no authenticated user");
        }

        if (match.getDateTime().isBefore(now()) && isCurrentUserPlayer()) {
            throw new InvalidMatchDateTimeException(
                    "BE - Team lze zmÄ›nit pouze u zĂˇpasĹŻ, kterĂ© teprve budou."
            );
        }

        MatchRegistrationEntity registration = getRegistrationOrThrow(playerId, matchId);
        Team oldTeam = registration.getTeam();

        if (registration.getStatus() != PlayerMatchStatus.REGISTERED) {
            throw new InvalidPlayerStatusException(
                    "BE - Team lze zmÄ›nit pouze z registrace REGISTERED."
            );
        }

        PlayerMatchStatus newStatus = PlayerMatchStatus.REGISTERED;
        Team newTeam = oldTeam.opposite();

        registration.setTeam(newTeam);

        registration = registrationRepository.save(registration);
        NotificationType notificationType = resolveNotificationType(newStatus);
        if (notificationType != null) {
            notifyPlayer(player, notificationType, registration);
        }
        return matchRegistrationMapper.toDTO(registration);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional
    public MatchRegistrationDTO changeRegistrationPosition(Long playerId,
                                                           Long matchId,
                                                           PlayerPosition positionInMatch) {

        MatchEntity match = getMatchOrThrow(matchId);
        PlayerEntity player = getPlayerOrThrow(playerId);

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth != null) {
            log.debug("changeRegistrationPosition â€“ current user: {}", auth.getName());
            log.debug("changeRegistrationPosition â€“ authorities: {}", auth.getAuthorities());
        } else {
            log.debug("changeRegistrationPosition â€“ no authenticated user");
        }

        if (match.getDateTime().isBefore(now()) && isCurrentUserPlayer()) {
            throw new InvalidMatchDateTimeException(
                    "BE - Pozici lze zmÄ›nit pouze u zĂˇpasĹŻ, kterĂ© teprve budou."
            );
        }

        MatchRegistrationEntity registration = getRegistrationOrThrow(playerId, matchId);

        if (registration.getStatus() == PlayerMatchStatus.UNREGISTERED
                || registration.getStatus() == PlayerMatchStatus.NO_EXCUSED
                || registration.getStatus() == PlayerMatchStatus.EXCUSED) {
            throw new InvalidPlayerStatusException(
                    "BE - Pozici lze mÄ›nit pouze u aktivnĂ­ch registracĂ­ (REGISTERED, RESERVED, SUBSTITUTE)."
            );
        }

        registration.setPositionInMatch(positionInMatch);

        registration = registrationRepository.save(registration);

        return matchRegistrationMapper.toDTO(registration);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional
    public MatchRegistrationDTO updateStatus(Long matchId,
                                             Long playerId,
                                             PlayerMatchStatus status) {

        getMatchOrThrow(matchId);
        getPlayerOrThrow(playerId);

        if (status == PlayerMatchStatus.NO_EXCUSED) {
            throw new InvalidPlayerStatusException(
                    "BE - Status NO_EXCUSED musĂ­ bĂ˝t nastaven pĹ™es speciĂˇlnĂ­ endpoint / logiku."
            );
        }

        MatchRegistrationEntity registration = getRegistrationOrThrow(playerId, matchId);

        MatchRegistrationEntity updated =
                updateRegistrationStatus(registration, status, "admin", true);

        return matchRegistrationMapper.toDTO(updated);
    }

    // ==========================================
    // PĹEPOÄŚET KAPACITY
    // ==========================================

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional
    public void recalcStatusesForMatch(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);
        Integer maxPlayersObj = match.getMaxPlayers();

        if (maxPlayersObj == null || maxPlayersObj <= 0) {
            return;
        }

        int maxPlayers = maxPlayersObj;

        // Kolik slotĹŻ se rezervuje pro brankĂˇĹ™e v rĂˇmci maxPlayers.
        int goalieSlots = getGoalieSlotsForMatch(match);
        if (goalieSlots < 0) {
            goalieSlots = 0;
        }
        if (goalieSlots > maxPlayers) {
            goalieSlots = maxPlayers;
        }

        int skaterCapacity = maxPlayers - goalieSlots;

        // VĹˇichni aktuĂˇlnÄ› REGISTERED, seĹ™azenĂ­ podle ÄŤasu registrace.
        List<MatchRegistrationEntity> allRegistered = registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .sorted((a, b) -> a.getTimestamp().compareTo(b.getTimestamp()))
                .toList();

        // RozdÄ›lenĂ­ na brankĂˇĹ™e a hrĂˇÄŤe v poli.
        List<MatchRegistrationEntity> goalies = allRegistered.stream()
                .filter(this::isGoalieRegistration)
                .toList();

        List<MatchRegistrationEntity> skaters = allRegistered.stream()
                .filter(r -> !isGoalieRegistration(r))
                .toList();

        int registeredGoalies = goalies.size();
        int registeredSkaters = skaters.size();

        // Pokud celkovĂ˝ poÄŤet hrĂˇÄŤĹŻ nepĹ™esahuje kapacitu a poÄŤet hrĂˇÄŤĹŻ v poli
        // nepĹ™esahuje skaterCapacity, nenĂ­ tĹ™eba nic mÄ›nit.
        if (registeredGoalies + registeredSkaters <= maxPlayers
                && registeredSkaters <= skaterCapacity) {
            return;
        }

        // 1) BrankĂˇĹ™i â€“ ponechajĂ­ se REGISTERED pouze do vĂ˝Ĺˇe goalieSlots,
        //    pĹ™Ă­padnĂ­ dalĹˇĂ­ brankĂˇĹ™i se pĹ™esunou do RESERVED.
        int allowedGoalies = Math.min(goalieSlots, maxPlayers);
        int keptGoalies = 0;

        for (MatchRegistrationEntity goalieReg : goalies) {
            if (keptGoalies < allowedGoalies) {
                updateRegistrationStatus(goalieReg, PlayerMatchStatus.REGISTERED, "system", false);
                keptGoalies++;
            } else {
                updateRegistrationStatus(goalieReg, PlayerMatchStatus.RESERVED, "system", false);
            }
        }

        // 2) HrĂˇÄŤi v poli â€“ pĹ™epoÄŤet jen nad skaters s kapacitou skaterCapacity.
        if (registeredSkaters <= skaterCapacity) {
            return;
        }

        int desiredTotal = skaterCapacity;

        // AktuĂˇlnĂ­ rozloĹľenĂ­ hrĂˇÄŤĹŻ v poli â€“ vyuĹľĂ­vĂˇ se pĹ™i rozhodovĂˇnĂ­,
        // kterĂ˝ tĂ˝m dostane pĹ™Ă­padnĂ© "lichĂ©" extra mĂ­sto.
        long currentDark = skaters.stream()
                .filter(r -> r.getTeam() == Team.DARK)
                .count();
        long currentLight = skaters.stream()
                .filter(r -> r.getTeam() == Team.LIGHT)
                .count();

        int targetDark;
        int targetLight;

        if (desiredTotal % 2 == 0) {
            // RovnomÄ›rnĂ© rozdÄ›lenĂ­.
            targetDark = desiredTotal / 2;
            targetLight = desiredTotal / 2;
        } else {
            // LichĂ˝ poÄŤet â€“ jeden tĂ˝m mĂˇ o 1 vĂ­ce, upĹ™ednostnĂ­ se aktuĂˇlnÄ› vÄ›tĹˇĂ­ tĂ˝m.
            if (currentDark >= currentLight) {
                targetDark = desiredTotal / 2 + 1;
                targetLight = desiredTotal - targetDark;
            } else {
                targetLight = desiredTotal / 2 + 1;
                targetDark = desiredTotal - targetLight;
            }
        }

        int dark = 0;
        int light = 0;

        for (MatchRegistrationEntity reg : skaters) {
            Team team = reg.getTeam();
            boolean movable = canAutoMoveTeam(reg); // VyuĹľitĂ­ PlayerSettings.isPossibleMoveToAnotherTeam().

            // HrĂˇÄŤ bez pĹ™iĹ™azenĂ©ho tĂ˝mu â€“ pĹ™iĹ™adĂ­ se tam, kde je volno.
            if (team == null) {
                if (dark < targetDark) {
                    reg.setTeam(Team.DARK);
                    updateRegistrationStatus(reg, PlayerMatchStatus.REGISTERED, "system", false);
                    dark++;
                } else if (light < targetLight) {
                    reg.setTeam(Team.LIGHT);
                    updateRegistrationStatus(reg, PlayerMatchStatus.REGISTERED, "system", false);
                    light++;
                } else {
                    updateRegistrationStatus(reg, PlayerMatchStatus.RESERVED, "system", false);
                }
                continue;
            }

            if (team == Team.DARK) {
                if (!movable) {
                    if (dark < targetDark) {
                        updateRegistrationStatus(reg, PlayerMatchStatus.REGISTERED, "system", false);
                        dark++;
                    } else {
                        updateRegistrationStatus(reg, PlayerMatchStatus.RESERVED, "system", false);
                    }
                } else {
                    if (dark < targetDark) {
                        updateRegistrationStatus(reg, PlayerMatchStatus.REGISTERED, "system", false);
                        dark++;
                    } else if (light < targetLight) {
                        reg.setTeam(Team.LIGHT);
                        updateRegistrationStatus(reg, PlayerMatchStatus.REGISTERED, "system", false);
                        light++;
                    } else {
                        updateRegistrationStatus(reg, PlayerMatchStatus.RESERVED, "system", false);
                    }
                }
            } else if (team == Team.LIGHT) {
                if (!movable) {
                    if (light < targetLight) {
                        updateRegistrationStatus(reg, PlayerMatchStatus.REGISTERED, "system", false);
                        light++;
                    } else {
                        updateRegistrationStatus(reg, PlayerMatchStatus.RESERVED, "system", false);
                    }
                } else {
                    if (light < targetLight) {
                        updateRegistrationStatus(reg, PlayerMatchStatus.REGISTERED, "system", false);
                        light++;
                    } else if (dark < targetDark) {
                        reg.setTeam(Team.DARK);
                        updateRegistrationStatus(reg, PlayerMatchStatus.REGISTERED, "system", false);
                        dark++;
                    } else {
                        updateRegistrationStatus(reg, PlayerMatchStatus.RESERVED, "system", false);
                    }
                }
            } else {
                // NeznĂˇmĂ˝ tĂ˝m â€“ konzervativnÄ› do RESERVED.
                updateRegistrationStatus(reg, PlayerMatchStatus.RESERVED, "system", false);
            }
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional
    public void promoteReservedCandidatesForCapacityIncrease(Long matchId,
                                                             Team freedTeam,
                                                             PlayerPosition freedPosition,
                                                             int slotsCount) {

        if (slotsCount <= 0) {
            return;
        }

        MatchEntity match = getMatchOrThrow(matchId);

        long registeredCount = registrationRepository
                .countByMatchIdAndStatus(matchId, PlayerMatchStatus.REGISTERED);

        int maxPlayers = match.getMaxPlayers();

        int remainingSlotsToFill = Math.min(slotsCount, maxPlayers - (int) registeredCount);
        if (remainingSlotsToFill <= 0) {
            return;
        }

        List<MatchRegistrationEntity> reserved = registrationRepository
                .findByMatchIdAndStatus(matchId, PlayerMatchStatus.RESERVED)
                .stream()
                .sorted((a, b) -> a.getTimestamp().compareTo(b.getTimestamp()))
                .toList();

        for (MatchRegistrationEntity candidate : reserved) {
            if (remainingSlotsToFill <= 0) {
                break;
            }

            boolean promoted = tryPromoteCandidateToFreedSlot(
                    candidate,
                    freedTeam,
                    freedPosition
            );

            if (promoted) {
                remainingSlotsToFill--;
            }
        }
    }

    // SMS â€“ HROMADNĂ‰ ODESĂŤLĂNĂŤ

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional
    public void sendSmsToRegisteredPlayers(Long matchId) {
        registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .forEach(r -> {
                    PlayerEntity player = r.getPlayer();
                    if (player == null) {
                        return;
                    }

                    var settings = player.getSettings();
                    if (settings == null || !settings.isSmsEnabled()) {
                        return;
                    }

                    sendSms(r, smsMessageBuilder.buildMessageFinal(r));
                });
    }
    // PRIVĂTNĂŤ METODY


    private PlayerMatchStatus handleRegisterOrReserveOrSubstitute(
            MatchRegistrationRequest request,
            MatchEntity match,
            PlayerEntity player,
            MatchRegistrationEntity registration
    ) {
        PlayerMatchStatus currentStatus =
                (registration != null) ? registration.getStatus() : null;

        boolean isAlreadyRegistered = currentStatus == PlayerMatchStatus.REGISTERED;

        if (isAlreadyRegistered) {
            throw new DuplicateRegistrationException(request.getMatchId(), player.getId());
        }

        // Registrace jako nĂˇhradnĂ­k (SUBSTITUTE) â€“ hrĂˇÄŤ je oznaÄŤen jako â€žmoĹľnĂˇâ€ś
        // a neblokuje kapacitu ani poĹ™adĂ­.
        if (request.isSubstitute()) {
            if (currentStatus == PlayerMatchStatus.SUBSTITUTE) {
                throw new DuplicateRegistrationException(
                        request.getMatchId(),
                        player.getId(),
                        "HrĂˇÄŤ jiĹľ mĂˇ zaregistrovĂˇno - moĹľnĂˇ"
                );
            }

            clearExcuseIfNeeded(registration);
            return PlayerMatchStatus.SUBSTITUTE;
        }

        PlayerMatchStatus newStatus =
                isSlotAvailable(match) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;

        clearExcuseIfNeeded(registration);
        return newStatus;
    }

    private PlayerMatchStatus handleUnregister(
            MatchRegistrationRequest request,
            Long playerId,
            MatchRegistrationEntity registration
    ) {
        boolean isAllowedUnregisterStatus =
                registration != null
                        && (registration.getStatus() == PlayerMatchStatus.REGISTERED
                        || registration.getStatus() == PlayerMatchStatus.RESERVED);

        if (!isAllowedUnregisterStatus) {
            throw new RegistrationNotFoundException(request.getMatchId(), playerId);
        }

        registration.setExcuseReason(request.getExcuseReason());
        registration.setExcuseNote(request.getExcuseNote());

        return PlayerMatchStatus.UNREGISTERED;
    }

    private PlayerMatchStatus handleExcuse(
            MatchRegistrationRequest request,
            MatchEntity match,
            PlayerEntity player,
            MatchRegistrationEntity registration
    ) {
        boolean isNoResponseOrSubstitute =
                (registration == null
                        || registration.getStatus() == null
                        || registration.getStatus() == PlayerMatchStatus.SUBSTITUTE
                        || registration.getStatus() == PlayerMatchStatus.NO_EXCUSED);

        if (!isNoResponseOrSubstitute) {
            throw new DuplicateRegistrationException(
                    request.getMatchId(),
                    player.getId(),
                    "BE - Omluva je moĹľnĂˇ pouze pokud hrĂˇÄŤ dosud nereagoval na zĂˇpas, nebo byl nĂˇhradnĂ­k."
            );
        }

        registration.setExcuseReason(request.getExcuseReason());
        registration.setExcuseNote(request.getExcuseNote());

        return PlayerMatchStatus.EXCUSED;
    }

    private void applyRequestDetails(MatchRegistrationEntity registration,
                                     MatchRegistrationRequest request) {

        if (request.getTeam() != null) {
            registration.setTeam(request.getTeam());
        }

        if (request.getAdminNote() != null) {
            registration.setAdminNote(request.getAdminNote());
        }

        if (request.getExcuseReason() != null) {
            registration.setExcuseReason(request.getExcuseReason());
        }

        if (request.getExcuseNote() != null) {
            registration.setExcuseNote(request.getExcuseNote());
        }

        if (request.getPositionInMatch() != null) {
            registration.setPositionInMatch(request.getPositionInMatch());
        }
    }

    private void clearExcuseIfNeeded(MatchRegistrationEntity registration) {
        if (registration == null) {
            return;
        }
        if (registration.getExcuseReason() != null || registration.getExcuseNote() != null) {
            registration.setExcuseReason(null);
            registration.setExcuseNote(null);
        }
    }

    private void promoteReservedCandidateAfterUnregister(MatchEntity match,
                                                         MatchRegistrationEntity canceledRegistration) {

        if (match == null || canceledRegistration == null) {
            return;
        }

        Team freedTeam = canceledRegistration.getTeam();
        PlayerPosition freedPosition = canceledRegistration.getPositionInMatch();

        List<MatchRegistrationEntity> reserved = registrationRepository
                .findByMatchIdAndStatus(match.getId(), PlayerMatchStatus.RESERVED)
                .stream()
                .sorted((a, b) -> a.getTimestamp().compareTo(b.getTimestamp()))
                .toList();

        for (MatchRegistrationEntity candidate : reserved) {
            if (tryPromoteCandidateToFreedSlot(candidate, freedTeam, freedPosition)) {
                log.debug(
                        "promoteReservedCandidateAfterUnregister: matchId={}, candidateId={}, freedTeam={}, freedPosition={}",
                        match.getId(),
                        candidate.getId(),
                        freedTeam,
                        freedPosition
                );
                break;
            }
        }
    }

    private boolean tryPromoteCandidateToFreedSlot(MatchRegistrationEntity candidate,
                                                   Team freedTeam,
                                                   PlayerPosition freedPosition) {

        if (candidate == null || candidate.getPlayer() == null) {
            return false;
        }

        PlayerEntity player = candidate.getPlayer();
        var settings = player.getSettings();

        boolean canMoveTeam =
                settings != null && settings.isPossibleMoveToAnotherTeam();
        boolean canChangePosition =
                settings != null && settings.isPossibleChangePlayerPosition();

        Team currentTeam = candidate.getTeam();
        PlayerPosition currentPositionInMatch = candidate.getPositionInMatch();
        PlayerPosition primaryPosition = player.getPrimaryPosition();

        PlayerPosition effectiveCurrentPosition =
                (currentPositionInMatch != null) ? currentPositionInMatch : primaryPosition;

        // 1) VyhodnocenĂ­ cĂ­lovĂ©ho tĂ˝mu.
        Team targetTeam;
        if (freedTeam == null || currentTeam == freedTeam) {
            targetTeam = currentTeam;
        } else {
            if (!canMoveTeam) {
                return false;
            }
            targetTeam = freedTeam;
        }

        // 2) VyhodnocenĂ­ cĂ­lovĂ© pozice s ohledem na GOALIE a zmÄ›nu Ĺ™ady.
        PlayerPosition targetPosition = resolveTargetPosition(
                effectiveCurrentPosition,
                freedPosition,
                canChangePosition
        );

        if (targetPosition == null) {
            return false;
        }

        candidate.setTeam(targetTeam);
        candidate.setPositionInMatch(targetPosition);

        MatchRegistrationEntity updated =
                updateRegistrationStatus(candidate, PlayerMatchStatus.REGISTERED, "system", false);

        NotificationType type = resolveNotificationType(PlayerMatchStatus.REGISTERED);
        if (type != null) {
            notifyPlayer(player, type, updated);
        }

        return true;
    }

    private PlayerPosition resolveTargetPosition(PlayerPosition currentPosition,
                                                 PlayerPosition freedPosition,
                                                 boolean canChangePosition) {

        if (freedPosition == null) {
            return currentPosition;
        }

        // GOALIE â€“ speciĂˇlnĂ­ pravidlo: pouze kandidĂˇt, kterĂ˝ je jiĹľ veden jako GOALIE.
        if (freedPosition == PlayerPosition.GOALIE) {
            if (currentPosition == PlayerPosition.GOALIE) {
                return PlayerPosition.GOALIE;
            }
            return null;
        }

        // KandidĂˇt s ANY (nezĂˇleĹľĂ­) â€“ mĹŻĹľe obsadit libovolnou ne-brankĂˇĹ™skou pozici.
        if (currentPosition == null || currentPosition == PlayerPosition.ANY) {
            return freedPosition;
        }

        // StejnĂˇ pozice = vĹľdy povoleno.
        if (currentPosition == freedPosition) {
            return currentPosition;
        }

        boolean currentIsDefense = isDefensePosition(currentPosition);
        boolean freedIsDefense = isDefensePosition(freedPosition);
        boolean currentIsForward = isForwardPosition(currentPosition);
        boolean freedIsForward = isForwardPosition(freedPosition);

        boolean sameLine =
                (currentIsDefense && freedIsDefense) ||
                        (currentIsForward && freedIsForward);

        if (sameLine) {
            // ZmÄ›na v rĂˇmci obrany nebo Ăştoku je povolena vĹľdy.
            return freedPosition;
        }

        boolean crossLine =
                (currentIsDefense && freedIsForward) ||
                        (currentIsForward && freedIsDefense);

        if (crossLine) {
            // PĹ™echod mezi obranou a Ăştokem pouze pokud to hrĂˇÄŤ povolil v nastavenĂ­.
            if (!canChangePosition) {
                return null;
            }
            return freedPosition;
        }

        return null;
    }

    private boolean isGoalieRegistration(MatchRegistrationEntity registration) {
        if (registration == null || registration.getPlayer() == null) {
            return false;
        }

        PlayerPosition position = registration.getPositionInMatch();
        if (position == null) {
            position = registration.getPlayer().getPrimaryPosition();
        }

        return position == PlayerPosition.GOALIE;
    }

    private int getGoalieSlotsForMatch(MatchEntity match) {
        MatchMode mode = match.getMatchMode();
        if (mode == null) {
            return 0;
        }
        return switch (mode) {
            case THREE_ON_THREE_WITH_GOALIE -> 2;
            case FOUR_ON_FOUR_WITH_GOALIE -> 2;
            case FIVE_ON_FIVE_WITH_GOALIE -> 2;
            default -> 0;
        };
    }

    private boolean isDefensePosition(PlayerPosition position) {
        return position != null && position.isDefense();
    }

    private boolean isForwardPosition(PlayerPosition position) {
        return position != null && position.isForward();
    }

    private boolean canAutoMoveTeam(MatchRegistrationEntity registration) {
        if (registration == null || registration.getPlayer() == null) {
            return false;
        }

        PlayerEntity player = registration.getPlayer();
        var settings = player.getSettings();
        if (settings == null) {
            return false;
        }

        return settings.isPossibleMoveToAnotherTeam();
    }

    private void notifyPlayer(PlayerEntity player, NotificationType type, Object context) {
        notificationService.notifyPlayer(player, type, context);
    }

    private MatchEntity getMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }

    private PlayerEntity getPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    private MatchRegistrationEntity getRegistrationOrNull(Long playerId, Long matchId) {
        return registrationRepository
                .findByPlayerIdAndMatchId(playerId, matchId)
                .orElse(null);
    }

    private MatchRegistrationEntity getRegistrationOrThrow(Long playerId, Long matchId) {
        return registrationRepository
                .findByPlayerIdAndMatchId(playerId, matchId)
                .orElseThrow(() -> new RegistrationNotFoundException(matchId, playerId));
    }

    private boolean isSlotAvailable(MatchEntity match) {
        long registeredCount = registrationRepository
                .countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);
        return registeredCount < match.getMaxPlayers();
    }

    private void sendSms(MatchRegistrationEntity registration, String message) {
        if (registration == null || registration.getPlayer() == null) {
            return;
        }

        PlayerEntity player = registration.getPlayer();
        var settings = player.getSettings();

        String phone = null;
        if (settings != null && settings.getContactPhone() != null && !settings.getContactPhone().isBlank()) {
            phone = settings.getContactPhone();
        } else if (player.getPhoneNumber() != null && !player.getPhoneNumber().isBlank()) {
            phone = player.getPhoneNumber();
        }

        if (phone == null || phone.isBlank()) {
            log.debug("sendSms: hrĂˇÄŤ {} nemĂˇ ĹľĂˇdnĂ© telefonnĂ­ ÄŤĂ­slo â€“ SMS se nepoĹˇle", player.getId());
            return;
        }

        try {
            smsService.sendSms(phone, message);
        } catch (Exception e) {
            log.error(
                    "Chyba pĹ™i odesĂ­lĂˇnĂ­ SMS pro registraci {}: {}",
                    registration.getId(),
                    e.getMessage(),
                    e
            );
        }
    }

    private MatchRegistrationEntity updateRegistrationStatus(
            MatchRegistrationEntity registration,
            PlayerMatchStatus status,
            String updatedBy,
            boolean updateTimestamp
    ) {
        registration.setStatus(status);
        registration.setCreatedBy(updatedBy);
        if (updateTimestamp) {
            registration.setTimestamp(LocalDateTime.now());
        }
        return registrationRepository.saveAndFlush(registration);
    }

    private NotificationType resolveNotificationType(PlayerMatchStatus newStatus) {
        return switch (newStatus) {
            case REGISTERED -> NotificationType.MATCH_REGISTRATION_CREATED;
            case UNREGISTERED -> NotificationType.MATCH_REGISTRATION_CANCELED;
            case EXCUSED -> NotificationType.PLAYER_EXCUSED;
            case RESERVED -> NotificationType.MATCH_REGISTRATION_RESERVED;
            case NO_RESPONSE -> NotificationType.MATCH_REGISTRATION_NO_RESPONSE;
            case SUBSTITUTE -> NotificationType.MATCH_REGISTRATION_SUBSTITUTE;
            case NO_EXCUSED -> NotificationType.PLAYER_NO_EXCUSED;
            default -> null;
        };
    }

    private LocalDateTime now() {
        return LocalDateTime.now();
    }

    private void assertMatchInActiveSeason(MatchEntity match) {
        if (match.getSeason() == null || !match.getSeason().isActive()) {
            throw new InvalidSeasonStateException(
                    "BE - Registrace lze mÄ›nit pouze u zĂˇpasĹŻ v aktivnĂ­ sezĂłnÄ›."
            );
        }
    }

    private void assertPlayerCanModifyMatch(MatchEntity match) {
        if (!isCurrentUserPlayer()) {
            return;
        }

        if (!isMatchEditableForPlayer(match)) {
            throw new InvalidPlayerStatusException(
                    "BE - HrĂˇÄŤ mĹŻĹľe mÄ›nit registraci pouze do 30 minut po zaÄŤĂˇtku zĂˇpasu."
            );
        }
    }

    private boolean isMatchEditableForPlayer(MatchEntity match) {
        LocalDateTime editLimit = match.getDateTime().plusMinutes(30);
        return now().isBefore(editLimit);
    }

    private boolean isCurrentUserPlayer() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth == null) {
            return false;
        }

        return auth.getAuthorities().stream()
                .anyMatch(a -> "ROLE_PLAYER".equals(a.getAuthority()));
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationHistoryService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.registration.dto.MatchRegistrationHistoryDTO;

import java.util.List;

/**
 * Service se pouĹľĂ­vĂˇ pro prĂˇci s historickĂ˝mi (auditnĂ­mi) zĂˇznamy
 * registracĂ­ hrĂˇÄŤĹŻ k zĂˇpasĹŻm.
 *
 * Tato service je ÄŤistÄ› pro ÄŤtenĂ­. Pracuje s historickĂ˝mi daty,
 * neprovĂˇdĂ­ ĹľĂˇdnĂ© zmÄ›ny v databĂˇzi a neobsahuje vlastnĂ­ business logiku.
 * SlouĹľĂ­ k oddÄ›lenĂ­ auditnĂ­ch dotazĹŻ od hlavnĂ­ logiky registracĂ­.
 *
 * TypickĂ˝m pouĹľitĂ­m je zobrazenĂ­ historie zmÄ›n registrace
 * aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho hrĂˇÄŤe nebo provĂˇdÄ›nĂ­ administrativnĂ­ho auditu
 * registracĂ­ konkrĂ©tnĂ­ho hrĂˇÄŤe k danĂ©mu zĂˇpasu.
 */
public interface MatchRegistrationHistoryService {

    /**
     * VrĂˇtĂ­ historii vĹˇech zmÄ›n registrace aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho hrĂˇÄŤe
     * pro zadanĂ˝ zĂˇpas.
     *
     * Metoda pracuje s kontextem aktuĂˇlnĂ­ho hrĂˇÄŤe
     * a vracĂ­ pouze zĂˇznamy, kterĂ© se k tomuto hrĂˇÄŤi vztahujĂ­.
     * Historie je seĹ™azena sestupnÄ› podle ÄŤasu zmÄ›ny, takĹľe
     * nejnovÄ›jĹˇĂ­ zmÄ›na je na prvnĂ­m mĂ­stÄ›.
     *
     * @param matchId ID zĂˇpasu, ke kterĂ©mu se historie naÄŤĂ­tĂˇ
     * @return seznam historickĂ˝ch zĂˇznamĹŻ registrace hrĂˇÄŤe k zĂˇpasu
     */
    List<MatchRegistrationHistoryDTO> getHistoryForCurrentPlayerAndMatch(Long matchId);

    /**
     * VrĂˇtĂ­ historii vĹˇech zmÄ›n registrace zadanĂ©ho hrĂˇÄŤe
     * k danĂ©mu zĂˇpasu.
     *
     * Metoda se pouĹľĂ­vĂˇ zejmĂ©na pro administrativnĂ­ a auditnĂ­ ĂşÄŤely,
     * napĹ™Ă­klad pĹ™i kontrole zĂˇsahĹŻ do registracĂ­ hrĂˇÄŤĹŻ
     * nebo pĹ™i Ĺ™eĹˇenĂ­ sporĹŻ a reklamacĂ­.
     * Historie je seĹ™azena sestupnÄ› podle ÄŤasu zmÄ›ny.
     *
     * @param matchId  ID zĂˇpasu
     * @param playerId ID hrĂˇÄŤe
     * @return seznam historickĂ˝ch zĂˇznamĹŻ registrace hrĂˇÄŤe k zĂˇpasu
     */
    List<MatchRegistrationHistoryDTO> getHistoryForPlayerAndMatch(Long matchId, Long playerId);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationHistoryServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.match.entities.MatchEntity;
import cz.phsoft.hokej.registration.repositories.MatchRegistrationHistoryRepository;
import cz.phsoft.hokej.match.repositories.MatchRepository;
import cz.phsoft.hokej.match.exceptions.MatchNotFoundException;
import cz.phsoft.hokej.registration.dto.MatchRegistrationHistoryDTO;
import cz.phsoft.hokej.registration.mappers.MatchRegistrationHistoryMapper;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * Implementace rozhranĂ­ MatchRegistrationHistoryService.
 *
 * TĹ™Ă­da zajiĹˇĹĄuje naÄŤĂ­tĂˇnĂ­ historickĂ˝ch zĂˇznamĹŻ registracĂ­ hrĂˇÄŤĹŻ
 * k zĂˇpasĹŻm z databĂˇze a jejich pĹ™evod do DTO. OdpovÄ›dnostĂ­ je
 * ovÄ›Ĺ™enĂ­ existence zĂˇpasu, provedenĂ­ dotazu do historie a mapovĂˇnĂ­
 * vĂ˝sledkĹŻ do podoby vhodnĂ© pro controller a frontend.
 *
 * TĹ™Ă­da neprovĂˇdĂ­ ĹľĂˇdnĂ© zmÄ›ny stavu systĂ©mu. SlouĹľĂ­ jako read-only
 * vrstva nad auditnĂ­mi daty a nenahrazuje hlavnĂ­ logiku registracĂ­.
 */
@Service
public class MatchRegistrationHistoryServiceImpl implements MatchRegistrationHistoryService {

    /**
     * Repository pro ÄŤtenĂ­ historickĂ˝ch zĂˇznamĹŻ registracĂ­.
     */
    private final MatchRegistrationHistoryRepository historyRepository;

    /**
     * Mapper pro pĹ™evod historickĂ˝ch entit do DTO.
     */
    private final MatchRegistrationHistoryMapper historyMapper;

    /**
     * Service pro prĂˇci s aktuĂˇlnÄ› zvolenĂ˝m hrĂˇÄŤem.
     *
     * PouĹľĂ­vĂˇ se pĹ™i naÄŤĂ­tĂˇnĂ­ historie pro pĹ™ihlĂˇĹˇenĂ©ho hrĂˇÄŤe.
     */
    private final CurrentPlayerService currentPlayerService;

    /**
     * Repository pro prĂˇci se zĂˇpasy.
     *
     * PouĹľĂ­vĂˇ se k ovÄ›Ĺ™enĂ­, Ĺľe poĹľadovanĂ˝ zĂˇpas existuje.
     */
    private final MatchRepository matchRepository;

    public MatchRegistrationHistoryServiceImpl(
            MatchRegistrationHistoryRepository historyRepository,
            MatchRegistrationHistoryMapper historyMapper,
            CurrentPlayerService currentPlayerService,
            MatchRepository matchRepository
    ) {
        this.historyRepository = historyRepository;
        this.historyMapper = historyMapper;
        this.currentPlayerService = currentPlayerService;
        this.matchRepository = matchRepository;
    }

    /**
     * NaÄŤte historii registracĂ­ aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho hrĂˇÄŤe pro danĂ˝ zĂˇpas.
     *
     * Nejprve se ovÄ›Ĺ™Ă­, Ĺľe zĂˇpas existuje. PotĂ© se ovÄ›Ĺ™Ă­,
     * Ĺľe je nastaven aktuĂˇlnĂ­ hrĂˇÄŤ, a zĂ­skĂˇ se jeho identifikĂˇtor.
     * NĂˇslednÄ› se naÄŤtou auditnĂ­ zĂˇznamy pro kombinaci danĂ©ho zĂˇpasu
     * a aktuĂˇlnĂ­ho hrĂˇÄŤe. VĂ˝sledky jsou mapovĂˇny do DTO.
     *
     * @param matchId ID zĂˇpasu
     * @return seznam historickĂ˝ch zĂˇznamĹŻ registrace aktuĂˇlnĂ­ho hrĂˇÄŤe k zĂˇpasu
     * @throws MatchNotFoundException pokud zĂˇpas s danĂ˝m ID neexistuje
     */
    @Override
    public List<MatchRegistrationHistoryDTO> getHistoryForCurrentPlayerAndMatch(Long matchId) {
        MatchEntity match = matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));

        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        var history = historyRepository
                .findByMatchIdAndPlayerIdOrderByChangedAtDesc(match.getId(), currentPlayerId);

        return historyMapper.toDTOList(history);
    }

    /**
     * NaÄŤte historii registracĂ­ zadanĂ©ho hrĂˇÄŤe pro danĂ˝ zĂˇpas.
     *
     * Metoda je vhodnĂˇ pro administrativnĂ­ a auditnĂ­ endpointy,
     * kde se nepracuje s kontextem aktuĂˇlnĂ­ho hrĂˇÄŤe, ale s konkrĂ©tnĂ­m
     * hrĂˇÄŤem urÄŤenĂ˝m parametrem. Nejprve se ovÄ›Ĺ™Ă­ existence zĂˇpasu,
     * potĂ© se naÄŤtou odpovĂ­dajĂ­cĂ­ historickĂ© zĂˇznamy a pĹ™evedou se do DTO.
     *
     * @param matchId  ID zĂˇpasu
     * @param playerId ID hrĂˇÄŤe
     * @return seznam historickĂ˝ch zĂˇznamĹŻ registrace hrĂˇÄŤe k zĂˇpasu
     * @throws MatchNotFoundException pokud zĂˇpas s danĂ˝m ID neexistuje
     */
    @Override
    public List<MatchRegistrationHistoryDTO> getHistoryForPlayerAndMatch(Long matchId, Long playerId) {
        MatchEntity match = matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));

        var history = historyRepository
                .findByMatchIdAndPlayerIdOrderByChangedAtDesc(match.getId(), playerId);

        return historyMapper.toDTOList(history);
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationQueryService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.registration.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.player.dto.PlayerDTO;

import java.util.List;

/**
 * Service vrstva pro ÄŤtecĂ­ operace nad registracemi hrĂˇÄŤĹŻ.
 *
 * Poskytuje pĹ™ehledy registracĂ­ a hrĂˇÄŤĹŻ podle zĂˇpasĹŻ a sezĂłny.
 */
public interface MatchRegistrationQueryService {

    List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId);

    List<MatchRegistrationDTO> getRegistrationsForMatches(List<Long> matchIds);

    List<MatchRegistrationDTO> getAllRegistrations();

    List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId);

    List<PlayerDTO> getNoResponsePlayers(Long matchId);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationQueryServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.match.entities.MatchEntity;
import cz.phsoft.hokej.registration.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.player.entities.PlayerEntity;
import cz.phsoft.hokej.registration.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.match.repositories.MatchRepository;
import cz.phsoft.hokej.player.repositories.PlayerRepository;
import cz.phsoft.hokej.match.exceptions.MatchNotFoundException;
import cz.phsoft.hokej.registration.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.player.dto.PlayerDTO;
import cz.phsoft.hokej.registration.mappers.MatchRegistrationMapper;
import cz.phsoft.hokej.player.mappers.PlayerMapper;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class MatchRegistrationQueryServiceImpl implements MatchRegistrationQueryService{
    private final MatchRegistrationRepository registrationRepository;
    private final MatchRepository matchRepository;
    private final PlayerRepository playerRepository;
    private final MatchRegistrationMapper matchRegistrationMapper;
    private final PlayerMapper playerMapper;
    private final SeasonService seasonService;
    private final CurrentSeasonService currentSeasonService;

    public MatchRegistrationQueryServiceImpl(
            MatchRegistrationRepository registrationRepository,
            MatchRepository matchRepository,
            PlayerRepository playerRepository,
            MatchRegistrationMapper matchRegistrationMapper,
            PlayerMapper playerMapper,
            SeasonService seasonService,
            CurrentSeasonService currentSeasonService
    ) {
        this.registrationRepository = registrationRepository;
        this.matchRepository = matchRepository;
        this.playerRepository = playerRepository;
        this.matchRegistrationMapper = matchRegistrationMapper;
        this.playerMapper = playerMapper;
        this.seasonService = seasonService;
        this.currentSeasonService = currentSeasonService;
    }

    /**
     * VracĂ­ registrace pro danĂ˝ zĂˇpas omezenĂ© na aktuĂˇlnÄ› vybranou sezĂłnu.
     *
     * Pokud zĂˇpas nepatĹ™Ă­ do aktuĂˇlnÄ› vybranĂ© sezĂłny, vracĂ­ se prĂˇzdnĂ˝ seznam.
     *
     * @param matchId IdentifikĂˇtor zĂˇpasu, pro kterĂ˝ se registrace naÄŤĂ­tajĂ­.
     * @return Seznam registracĂ­ pĹ™evedenĂ˝ch do DTO pro danĂ˝ zĂˇpas v rĂˇmci aktuĂˇlnĂ­ sezĂłny.
     */
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);

        if (!isMatchInCurrentSeason(match)) {
            return List.of();
        }

        return matchRegistrationMapper.toDTOList(
                registrationRepository.findByMatchId(matchId)
        );
    }

    /**
     * VracĂ­ registrace pro zadanou sadu zĂˇpasĹŻ omezenĂ© na aktuĂˇlnÄ› vybranou sezĂłnu.
     *
     * Pokud je seznam identifikĂˇtorĹŻ zĂˇpasĹŻ null nebo prĂˇzdnĂ˝, vracĂ­ se prĂˇzdnĂ˝ seznam.
     *
     * @param matchIds Seznam identifikĂˇtorĹŻ zĂˇpasĹŻ.
     * @return Seznam registracĂ­ pĹ™evedenĂ˝ch do DTO pro zadanĂ© zĂˇpasy
     * v rĂˇmci aktuĂˇlnĂ­ sezĂłny.
     */
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatches(List<Long> matchIds) {
        if (matchIds == null || matchIds.isEmpty()) {
            return List.of();
        }

        List<MatchRegistrationEntity> regsInSeason = registrationRepository
                .findByMatchIdIn(matchIds).stream()
                .filter(this::isRegistrationInCurrentSeason)
                .toList();

        return matchRegistrationMapper.toDTOList(regsInSeason);
    }

    /**
     * VracĂ­ vĹˇechny registrace v systĂ©mu omezenĂ© na aktuĂˇlnÄ› vybranou sezĂłnu.
     *
     * @return Seznam vĹˇech registracĂ­ pĹ™evedenĂ˝ch do DTO v rĂˇmci aktuĂˇlnĂ­ sezĂłny.
     */
    @Override
    public List<MatchRegistrationDTO> getAllRegistrations() {
        List<MatchRegistrationEntity> regsInSeason = registrationRepository
                .findAll().stream()
                .filter(this::isRegistrationInCurrentSeason)
                .toList();

        return matchRegistrationMapper.toDTOList(regsInSeason);
    }

    /**
     * VracĂ­ registrace zadanĂ©ho hrĂˇÄŤe omezenĂ© na aktuĂˇlnÄ› vybranou sezĂłnu.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe.
     * @return Seznam registracĂ­ hrĂˇÄŤe pĹ™evedenĂ˝ch do DTO v rĂˇmci aktuĂˇlnĂ­ sezĂłny.
     */
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId) {
        List<MatchRegistrationEntity> regsInSeason = registrationRepository
                .findByPlayerId(playerId).stream()
                .filter(this::isRegistrationInCurrentSeason)
                .toList();

        return matchRegistrationMapper.toDTOList(regsInSeason);
    }

    /**
     * VracĂ­ hrĂˇÄŤe, kteĹ™Ă­ na danĂ˝ zĂˇpas nijak nereagovali.
     *
     * Pokud zĂˇpas nepatĹ™Ă­ do aktuĂˇlnÄ› vybranĂ© sezĂłny, vracĂ­ se prĂˇzdnĂ˝ seznam.
     *
     * @param matchId IdentifikĂˇtor zĂˇpasu.
     * @return Seznam hrĂˇÄŤĹŻ bez reakce pĹ™evedenĂ˝ch do DTO v rĂˇmci aktuĂˇlnĂ­ sezĂłny.
     */
    @Override
    public List<PlayerDTO> getNoResponsePlayers(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);

        if (!isMatchInCurrentSeason(match)) {
            return List.of();
        }

        Set<Long> respondedIds = getRespondedPlayerIds(matchId);

        List<PlayerEntity> noResponsePlayers = playerRepository.findAll().stream()
                .filter(p -> !respondedIds.contains(p.getId()))
                .toList();

        return noResponsePlayers.stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    /**
     * NaÄŤĂ­tĂˇ zĂˇpas podle identifikĂˇtoru nebo vyhazuje vĂ˝jimku pĹ™i neexistenci.
     *
     * @param matchId IdentifikĂˇtor zĂˇpasu.
     * @return NaÄŤtenĂˇ entita zĂˇpasu.
     */
    private MatchEntity getMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }

    /**
     * Vyhodnocuje, zda zĂˇpas patĹ™Ă­ do aktuĂˇlnÄ› vybranĂ© sezĂłny.
     *
     * @param match ZĂˇpas, kterĂ˝ se mĂˇ vyhodnotit.
     * @return True, pokud zĂˇpas patĹ™Ă­ do aktuĂˇlnĂ­ sezĂłny, jinak false.
     */
    private boolean isMatchInCurrentSeason(MatchEntity match) {
        if (match == null || match.getSeason() == null) {
            return false;
        }
        Long seasonId = getCurrentSeasonIdOrActive();
        return seasonId.equals(match.getSeason().getId());
    }

    /**
     * Vyhodnocuje, zda registrace patĹ™Ă­ k zĂˇpasu v aktuĂˇlnÄ› vybranĂ© sezĂłnÄ›.
     *
     * @param registration Registrace, kterĂˇ se mĂˇ vyhodnotit.
     * @return True, pokud registrace patĹ™Ă­ do aktuĂˇlnĂ­ sezĂłny, jinak false.
     */
    private boolean isRegistrationInCurrentSeason(MatchRegistrationEntity registration) {
        if (registration == null) {
            return false;
        }
        return isMatchInCurrentSeason(registration.getMatch());
    }

    /**
     * VracĂ­ identifikĂˇtor sezĂłny pouĹľĂ­vanĂ© pro filtrovĂˇnĂ­ registracĂ­.
     *
     * @return IdentifikĂˇtor aktuĂˇlnĂ­ nebo aktivnĂ­ sezĂłny.
     */
    private Long getCurrentSeasonIdOrActive() {
        Long id = currentSeasonService.getCurrentSeasonIdOrDefault();
        if (id != null) {
            return id;
        }
        return seasonService.getActiveSeason().getId();
    }

    /**
     * VracĂ­ mnoĹľinu identifikĂˇtorĹŻ hrĂˇÄŤĹŻ, kteĹ™Ă­ majĂ­ k zĂˇpasu uloĹľenou
     * registraci v jakĂ©mkoliv stavu.
     *
     * @param matchId IdentifikĂˇtor zĂˇpasu.
     * @return MnoĹľina identifikĂˇtorĹŻ hrĂˇÄŤĹŻ, kteĹ™Ă­ na zĂˇpas reagovali.
     */
    private Set<Long> getRespondedPlayerIds(Long matchId) {
        return registrationRepository.findByMatchId(matchId).stream()
                .map(r -> r.getPlayer().getId())
                .collect(Collectors.toSet());
    }

}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.registration.enums.ExcuseReason;
import cz.phsoft.hokej.registration.enums.PlayerMatchStatus;
import cz.phsoft.hokej.player.enums.PlayerPosition;
import cz.phsoft.hokej.player.enums.Team;
import cz.phsoft.hokej.registration.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.player.dto.PlayerDTO;
import cz.phsoft.hokej.registration.dto.MatchRegistrationRequest;

import java.util.List;

/**
 * RozhranĂ­ se pouĹľĂ­vĂˇ pro sprĂˇvu registracĂ­ hrĂˇÄŤĹŻ na zĂˇpasy.
 * <p>
 * Definuje kontrakt pro prĂˇci s ĂşÄŤastĂ­ hrĂˇÄŤĹŻ na zĂˇpasech
 * z pohledu business logiky aplikace. Poskytuje operace pro
 * vytvoĹ™enĂ­ nebo zmÄ›nu registrace, zĂ­skĂˇvĂˇnĂ­ pĹ™ehledĹŻ a
 * administrativnĂ­ zĂˇsahy do stavĹŻ registracĂ­.
 * <p>
 * RozhranĂ­ pracuje s DTO objekty a oddÄ›luje business logiku
 * od persistence vrstvy. Implementace je odpovÄ›dnĂˇ za validace
 * a pĹ™echody stavĹŻ registracĂ­.
 */
public interface MatchRegistrationService {

    /**
     * VytvoĹ™Ă­ nebo aktualizuje registraci hrĂˇÄŤe na zĂˇpas.
     * <p>
     * Metoda slouĹľĂ­ jako jednotnĂ˝ vstupnĂ­ bod pro reakci hrĂˇÄŤe
     * na zĂˇpas. Registrace se podle potĹ™eby vytvoĹ™Ă­ nebo upravĂ­.
     * Implementace zajiĹˇĹĄuje validaci vstupnĂ­ch dat, kontrolu
     * povolenĂ˝ch pĹ™echodĹŻ stavĹŻ a uloĹľenĂ­ vĂ˝slednĂ© registrace.
     * <p>
     * TypickĂ˝m scĂ©nĂˇĹ™em je pĹ™ihlĂˇĹˇenĂ­ hrĂˇÄŤe k zĂˇpasu, odhlĂˇĹˇenĂ­
     * nebo omluva z ĂşÄŤasti.
     *
     * @param playerId ID hrĂˇÄŤe, kterĂ˝ reaguje na zĂˇpas
     * @param request  poĹľadavek obsahujĂ­cĂ­ data o registraci
     * @return DTO reprezentace vĂ˝slednĂ©ho stavu registrace
     */
    MatchRegistrationDTO upsertRegistration(
            Long playerId,
            MatchRegistrationRequest request
    );

    /**
     * VrĂˇtĂ­ seznam registracĂ­ pro konkrĂ©tnĂ­ zĂˇpas.
     *
     * @param matchId ID zĂˇpasu
     * @return seznam registracĂ­ hrĂˇÄŤĹŻ k danĂ©mu zĂˇpasu
     */
    List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId);

    /**
     * VrĂˇtĂ­ seznam registracĂ­ pro vĂ­ce zĂˇpasĹŻ.
     * <p>
     * Metoda se typicky pouĹľĂ­vĂˇ pro hromadnĂ© pĹ™ehledy
     * nebo statistiky pĹ™es vĂ­ce zĂˇpasĹŻ.
     *
     * @param matchIds seznam ID zĂˇpasĹŻ
     * @return seznam registracĂ­ pro zadanĂ© zĂˇpasy
     */
    List<MatchRegistrationDTO> getRegistrationsForMatches(List<Long> matchIds);

    /**
     * VrĂˇtĂ­ vĹˇechny registrace v systĂ©mu omezenĂ©
     * na relevantnĂ­ sezĂłnu podle implementace.
     * <p>
     * Metoda se pouĹľĂ­vĂˇ zejmĂ©na pro administrĂˇtorskĂ© pĹ™ehledy.
     *
     * @return seznam vĹˇech registracĂ­
     */
    List<MatchRegistrationDTO> getAllRegistrations();

    /**
     * VrĂˇtĂ­ seznam registracĂ­ konkrĂ©tnĂ­ho hrĂˇÄŤe.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return seznam registracĂ­ danĂ©ho hrĂˇÄŤe
     */
    List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId);

    /**
     * VrĂˇtĂ­ seznam hrĂˇÄŤĹŻ, kteĹ™Ă­ dosud nereagovali na danĂ˝ zĂˇpas.
     * <p>
     * Metoda se pouĹľĂ­vĂˇ napĹ™Ă­klad pro pĹ™ipomĂ­nkovĂ© notifikace
     * nebo pro pĹ™ehledy nevyĹ™eĹˇenĂ© ĂşÄŤasti.
     *
     * @param matchId ID zĂˇpasu
     * @return seznam hrĂˇÄŤĹŻ bez reakce na zĂˇpas
     */
    List<PlayerDTO> getNoResponsePlayers(Long matchId);

    /**
     * PĹ™epoÄŤĂ­tĂˇ stavy registracĂ­ pro danĂ˝ zĂˇpas.
     * <p>
     * Metoda slouĹľĂ­ k zajiĹˇtÄ›nĂ­ konzistence stavĹŻ registrovanĂ˝ch
     * a rezervnĂ­ch hrĂˇÄŤĹŻ podle kapacity zĂˇpasu, typicky po zmÄ›nĂˇch
     * provedenĂ˝ch administrĂˇtorem.
     *
     * @param matchId ID zĂˇpasu
     */
    void recalcStatusesForMatch(Long matchId);

    /**
     * ZmÄ›nĂ­ stav registrace hrĂˇÄŤe na zĂˇpas.
     * <p>
     * Metoda se pouĹľĂ­vĂˇ pĹ™evĂˇĹľnÄ› v administrĂˇtorskĂ©m kontextu,
     * kde je nutnĂ© ruÄŤnÄ› upravit stav registrace. NastavenĂ­
     * stavu NO_EXCUSED mĂˇ vlastnĂ­ logiku a Ĺ™eĹˇĂ­ se samostatnÄ›.
     *
     * @param matchId  ID zĂˇpasu
     * @param playerId ID hrĂˇÄŤe
     * @param status   novĂ˝ stav registrace
     * @return DTO reprezentace aktualizovanĂ© registrace
     */
    MatchRegistrationDTO updateStatus(
            Long matchId,
            Long playerId,
            PlayerMatchStatus status
    );

    /**
     * OznaÄŤĂ­ hrĂˇÄŤe jako neomluvenĂ©ho pro konkrĂ©tnĂ­ zĂˇpas.
     * <p>
     * Metoda se pouĹľĂ­vĂˇ v administrĂˇtorskĂ©m kontextu po vyhodnocenĂ­
     * ĂşÄŤasti na zĂˇpase. PĹŻvodnĂ­ omluva se odstranĂ­ a registrace
     * se nastavĂ­ do stavu NO_EXCUSED vÄŤetnÄ› poznĂˇmky administrĂˇtora.
     *
     * @param matchId   ID zĂˇpasu
     * @param playerId  ID hrĂˇÄŤe
     * @param adminNote poznĂˇmka administrĂˇtora
     * @return DTO reprezentace aktualizovanĂ© registrace
     */
    MatchRegistrationDTO markNoExcused(
            Long matchId,
            Long playerId,
            String adminNote
    );

    MatchRegistrationDTO cancelNoExcused(Long matchId,
                                         Long playerId,
                                         ExcuseReason excuseReason,
                                         String excuseNote);



    MatchRegistrationDTO changeRegistrationTeam(Long matchId,
                                                Long playerId);

    MatchRegistrationDTO changeRegistrationPosition(Long playerId,
                                                    Long matchId,
                                                    PlayerPosition positionInMatch);

    void promoteReservedCandidatesForCapacityIncrease(Long matchId,
                                                      Team freedTeam,
                                                      PlayerPosition freedPosition,
                                                      int slotsCount);

}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.registration.enums.ExcuseReason;
import cz.phsoft.hokej.registration.enums.PlayerMatchStatus;
import cz.phsoft.hokej.player.enums.PlayerPosition;
import cz.phsoft.hokej.player.enums.Team;
import cz.phsoft.hokej.registration.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.player.dto.PlayerDTO;
import cz.phsoft.hokej.registration.dto.MatchRegistrationRequest;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * Service vrstva pro orchestraci nad registracemi hrĂˇÄŤĹŻ na zĂˇpasy.
 *
 * PĹ™Ă­kazovĂ© (write) operace jsou delegovĂˇny do {@link MatchRegistrationCommandService}.
 * ÄŚtecĂ­ operace jsou delegovĂˇny do {@link MatchRegistrationQueryService}.
 *
 * SlouĹľĂ­ jako jednotnĂ© rozhranĂ­ pro kontrolery, kterĂ© tak nemusĂ­ znĂˇt
 * rozdÄ›lenĂ­ na command/query sluĹľby.
 */
@Service
public class MatchRegistrationServiceImpl implements MatchRegistrationService {

    private final MatchRegistrationCommandService commandService;
    private final MatchRegistrationQueryService matchRegistrationQueryService;

    public MatchRegistrationServiceImpl(
            MatchRegistrationCommandService commandService,
            MatchRegistrationQueryService matchRegistrationQueryService
    ) {
        this.commandService = commandService;
        this.matchRegistrationQueryService = matchRegistrationQueryService;
    }

    // ==========================================
    // PĹĂŤKAZOVĂ‰ OPERACE â€“ DELEGACE DO COMMAND SERVICE
    // ==========================================

    @Override
    @Transactional
    public MatchRegistrationDTO upsertRegistration(Long playerId, MatchRegistrationRequest request) {
        return commandService.upsertRegistration(playerId, request);
    }

    @Override
    @Transactional
    public MatchRegistrationDTO markNoExcused(Long matchId,
                                              Long playerId,
                                              String adminNote) {
        return commandService.markNoExcused(matchId, playerId, adminNote);
    }

    @Override
    @Transactional
    public MatchRegistrationDTO cancelNoExcused(Long matchId,
                                                Long playerId,
                                                ExcuseReason excuseReason,
                                                String excuseNote) {
        return commandService.cancelNoExcused(matchId, playerId, excuseReason, excuseNote);
    }

    @Override
    @Transactional
    public MatchRegistrationDTO changeRegistrationTeam(Long playerId,
                                                       Long matchId) {
        return commandService.changeRegistrationTeam(playerId, matchId);
    }

    @Override
    @Transactional
    public MatchRegistrationDTO changeRegistrationPosition(Long playerId,
                                                           Long matchId,
                                                           PlayerPosition positionInMatch) {
        return commandService.changeRegistrationPosition(playerId, matchId, positionInMatch);
    }

    @Override
    @Transactional
    public MatchRegistrationDTO updateStatus(Long matchId,
                                             Long playerId,
                                             PlayerMatchStatus status) {
        return commandService.updateStatus(matchId, playerId, status);
    }

    @Override
    @Transactional
    public void recalcStatusesForMatch(Long matchId) {
        commandService.recalcStatusesForMatch(matchId);
    }

    @Override
    @Transactional
    public void promoteReservedCandidatesForCapacityIncrease(Long matchId,
                                                             Team freedTeam,
                                                             PlayerPosition freedPosition,
                                                             int slotsCount) {
        commandService.promoteReservedCandidatesForCapacityIncrease(
                matchId,
                freedTeam,
                freedPosition,
                slotsCount
        );
    }

    @Transactional
    public void sendSmsToRegisteredPlayers(Long matchId) {
        commandService.sendSmsToRegisteredPlayers(matchId);
    }

    // ======================================
    // ÄŚTECĂŤ OPERACE â€“ DELEGACE DO QUERY SERVICE
    // ======================================

    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId) {
        return matchRegistrationQueryService.getRegistrationsForMatch(matchId);
    }

    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatches(List<Long> matchIds) {
        return matchRegistrationQueryService.getRegistrationsForMatches(matchIds);
    }

    @Override
    public List<MatchRegistrationDTO> getAllRegistrations() {
        return matchRegistrationQueryService.getAllRegistrations();
    }

    @Override
    public List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId) {
        return matchRegistrationQueryService.getRegistrationsForPlayer(playerId);
    }

    @Override
    public List<PlayerDTO> getNoResponsePlayers(Long matchId) {
        return matchRegistrationQueryService.getNoResponsePlayers(matchId);
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.match.dto.MatchDTO;
import cz.phsoft.hokej.match.dto.MatchDetailDTO;
import cz.phsoft.hokej.match.dto.MatchOverviewDTO;
import cz.phsoft.hokej.match.enums.MatchCancelReason;
import cz.phsoft.hokej.models.dto.*;

import java.util.List;

/**
 * RozhranĂ­ se pouĹľĂ­vĂˇ pro sprĂˇvu zĂˇpasĹŻ v aplikaci.
 *
 * Definuje kontrakt pro prĂˇci se zĂˇpasy z pohledu business logiky.
 * ZajiĹˇĹĄuje vytvĂˇĹ™enĂ­, Ăşpravy, mazĂˇnĂ­ zĂˇpasĹŻ, zĂ­skĂˇvĂˇnĂ­ pĹ™ehledĹŻ
 * a prĂˇci s dostupnostĂ­ zĂˇpasĹŻ pro konkrĂ©tnĂ­ho hrĂˇÄŤe.
 *
 * RozhranĂ­ je navrĹľeno tak, aby oddÄ›lovalo business logiku
 * od persistence vrstvy a poskytovalo jednotnĂ˝ vstupnĂ­ bod
 * pro controllery a napĹ™. plĂˇnovaÄŤe (scheduler).
 */
public interface MatchService {

    /**
     * VrĂˇtĂ­ seznam vĹˇech zĂˇpasĹŻ v systĂ©mu.
     *
     * Metoda se typicky pouĹľĂ­vĂˇ pro administrĂˇtorskĂ© pĹ™ehledy
     * nebo pro globĂˇlnĂ­ seznam zĂˇpasĹŻ v rĂˇmci vybranĂ© sezĂłny.
     *
     * @return seznam vĹˇech zĂˇpasĹŻ ve formÄ› {@link MatchDTO}
     */
    List<MatchDTO> getAllMatches();

    /**
     * VrĂˇtĂ­ seznam vĹˇech nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ.
     *
     * Za nadchĂˇzejĂ­cĂ­ zĂˇpasy se povaĹľujĂ­ ty, kterĂ© majĂ­
     * datum a ÄŤas v budoucnosti podle internÄ› zvolenĂ˝ch pravidel.
     *
     * @return seznam nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ
     */
    List<MatchDTO> getUpcomingMatches();

    /**
     * VrĂˇtĂ­ seznam vĹˇech jiĹľ odehranĂ˝ch zĂˇpasĹŻ.
     *
     * ZĂˇpasy jsou obvykle Ĺ™azenĂ© od nejnovÄ›jĹˇĂ­ho po nejstarĹˇĂ­.
     *
     * @return seznam minulĂ˝ch zĂˇpasĹŻ
     */
    List<MatchDTO> getPastMatches();

    /**
     * VrĂˇtĂ­ nejbliĹľĹˇĂ­ nadchĂˇzejĂ­cĂ­ zĂˇpas.
     *
     * Metoda se pouĹľĂ­vĂˇ napĹ™Ă­klad pro zobrazenĂ­
     * â€ždalĹˇĂ­ho zĂˇpasuâ€ś na dashboardu nebo
     * pro potĹ™eby notifikacĂ­.
     *
     * @return nejbliĹľĹˇĂ­ nadchĂˇzejĂ­cĂ­ zĂˇpas nebo {@code null},
     * pokud ĹľĂˇdnĂ˝ neexistuje
     */
    MatchDTO getNextMatch();

    /**
     * VrĂˇtĂ­ zĂˇkladnĂ­ informace o zĂˇpasu podle jeho ID.
     *
     * @param id ID zĂˇpasu
     * @return zĂˇpas ve formÄ› {@link MatchDTO}
     */
    MatchDTO getMatchById(Long id);

    /**
     * VytvoĹ™Ă­ novĂ˝ zĂˇpas.
     *
     * Metoda je typicky dostupnĂˇ pouze pro administrĂˇtory
     * nebo manaĹľery. Implementace zajiĹˇĹĄuje validaci
     * data v rĂˇmci aktivnĂ­ sezĂłny a pĹ™iĹ™azenĂ­ sezĂłny k zĂˇpasu.
     *
     * @param dto data novĂ©ho zĂˇpasu
     * @return vytvoĹ™enĂ˝ zĂˇpas
     */
    MatchDTO createMatch(MatchDTO dto);

    /**
     * Aktualizuje existujĂ­cĂ­ zĂˇpas.
     *
     * Implementace je odpovÄ›dnĂˇ za naÄŤtenĂ­ stĂˇvajĂ­cĂ­ho zĂˇpasu,
     * pĹ™enesenĂ­ zmÄ›n z DTO, validaci a uloĹľenĂ­ vĂ˝slednĂ©ho stavu.
     *
     * @param id  ID zĂˇpasu, kterĂ˝ mĂˇ bĂ˝t upraven
     * @param dto novĂ© hodnoty pro zĂˇpas
     * @return aktualizovanĂ˝ zĂˇpas
     */
    MatchDTO updateMatch(Long id, MatchDTO dto);

    /**
     * SmaĹľe zĂˇpas podle ID.
     *
     * Metoda typicky vracĂ­ standardizovanou odpovÄ›ÄŹ
     * s informacĂ­ o ĂşspÄ›chu operace.
     *
     * @param id ID zĂˇpasu, kterĂ˝ mĂˇ bĂ˝t smazĂˇn
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     */
    SuccessResponseDTO deleteMatch(Long id);

    /**
     * VrĂˇtĂ­ detailnĂ­ informace o zĂˇpasu.
     *
     * Oproti metodÄ› {@link #getMatchById(Long)} mĹŻĹľe detail
     * obsahovat rozĹˇĂ­Ĺ™enĂˇ data, napĹ™Ă­klad statistiky,
     * seznamy hrĂˇÄŤĹŻ v jednotlivĂ˝ch stavech nebo agregovanĂ© Ăşdaje.
     *
     * @param id ID zĂˇpasu
     * @return detail zĂˇpasu
     */
    MatchDetailDTO getMatchDetail(Long id);

    /**
     * VrĂˇtĂ­ seznam zĂˇpasĹŻ, na kterĂ© se danĂ˝ hrĂˇÄŤ mĹŻĹľe registrovat.
     *
     * Implementace obvykle filtruje pouze nadchĂˇzejĂ­cĂ­ zĂˇpasy,
     * kontroluje kapacitu a respektuje pravidla sezĂłny
     * a pĹ™Ă­padnĂˇ dalĹˇĂ­ business omezenĂ­.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return seznam dostupnĂ˝ch zĂˇpasĹŻ pro hrĂˇÄŤe
     */
    List<MatchDTO> getAvailableMatchesForPlayer(Long playerId);

    /**
     * VrĂˇtĂ­ nadchĂˇzejĂ­cĂ­ zĂˇpasy pro konkrĂ©tnĂ­ho hrĂˇÄŤe.
     *
     * Metoda mĹŻĹľe zohledĹovat, zda je hrĂˇÄŤ registrovanĂ˝,
     * pĹ™Ă­padnÄ› dalĹˇĂ­ business pravidla. VĂ˝sledek je
     * urÄŤen pro podrobnÄ›jĹˇĂ­ zobrazenĂ­ seznamu zĂˇpasĹŻ.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return seznam nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ pro danĂ©ho hrĂˇÄŤe
     */
    List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId);

    /**
     * Najde ID hrĂˇÄŤe podle e-mailu uĹľivatele.
     *
     * Metoda se pouĹľĂ­vĂˇ jako pomocnĂ˝ nĂˇstroj v situaci,
     * kdy je k dispozici e-mail pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * a je potĹ™eba zjistit navĂˇzanĂ©ho hrĂˇÄŤe.
     *
     * @param email e-mail uĹľivatele
     * @return ID hrĂˇÄŤe nebo {@code null}, pokud neexistuje
     */
    Long getPlayerIdByEmail(String email);

    /**
     * VrĂˇtĂ­ pĹ™ehled nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ pro hrĂˇÄŤe.
     *
     * PĹ™ehled slouĹľĂ­ pro zobrazenĂ­ na dashboardu
     * nebo v jednoduchĂ˝ch seznamech, kde se zobrazujĂ­
     * zĂˇkladnĂ­ informace o zĂˇpasech vÄŤetnÄ› stavu
     * danĂ©ho hrĂˇÄŤe.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return pĹ™ehled nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ pro danĂ©ho hrĂˇÄŤe
     */
    List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId);

    /**
     * VrĂˇtĂ­ pĹ™ehled vĹˇech odehranĂ˝ch zĂˇpasĹŻ pro hrĂˇÄŤe.
     *
     * Metoda se pouĹľĂ­vĂˇ pro statistiky, historii ĂşÄŤasti
     * a pĹ™ehled minulĂ˝ch zĂˇpasĹŻ danĂ©ho hrĂˇÄŤe v rĂˇmci sezĂłny.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return pĹ™ehled vĹˇech odehranĂ˝ch zĂˇpasĹŻ pro danĂ©ho hrĂˇÄŤe
     */
    List<MatchOverviewDTO> getAllPassedMatchesForPlayer(Long playerId);

    /**
     * ZruĹˇĂ­ zĂˇpas a nastavĂ­ dĹŻvod zruĹˇenĂ­.
     *
     * ZĂˇpas je oznaÄŤen jako zruĹˇenĂ˝ vÄŤetnÄ› uvedenĂ©ho dĹŻvodu.
     * Implementace mĹŻĹľe navazovat dalĹˇĂ­ logiku, napĹ™Ă­klad
     * odeslĂˇnĂ­ notifikacĂ­ hrĂˇÄŤĹŻm.
     *
     * @param matchId ID zĂˇpasu
     * @param reason  dĹŻvod zruĹˇenĂ­
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     */
    SuccessResponseDTO cancelMatch(Long matchId, MatchCancelReason reason);

    /**
     * ObnovĂ­ dĹ™Ă­ve zruĹˇenĂ˝ zĂˇpas.
     *
     * ZĂˇpas se vracĂ­ do stavu, kdy je opÄ›t platnĂ˝ a mĹŻĹľe se konat,
     * pokud jsou splnÄ›ny ostatnĂ­ podmĂ­nky (datum, kapacita a podobnÄ›).
     *
     * @param matchId ID zĂˇpasu
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     */
    SuccessResponseDTO unCancelMatch(Long matchId);

}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\MatchServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.match.entities.MatchEntity;
import cz.phsoft.hokej.registration.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.player.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.*;
import cz.phsoft.hokej.user.repositories.AppUserRepository;
import cz.phsoft.hokej.registration.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.match.repositories.MatchRepository;
import cz.phsoft.hokej.player.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.match.dto.MatchDTO;
import cz.phsoft.hokej.match.dto.MatchDetailDTO;
import cz.phsoft.hokej.match.dto.MatchOverviewDTO;
import cz.phsoft.hokej.match.enums.MatchCancelReason;
import cz.phsoft.hokej.match.enums.MatchMode;
import cz.phsoft.hokej.match.enums.MatchStatus;
import cz.phsoft.hokej.match.services.MatchCapacityService;
import cz.phsoft.hokej.match.util.MatchModeLayoutUtil;
import cz.phsoft.hokej.models.dto.*;
import cz.phsoft.hokej.match.mappers.MatchMapper;
import cz.phsoft.hokej.player.mappers.PlayerMapper;
import cz.phsoft.hokej.notifications.services.NotificationService;
import cz.phsoft.hokej.notifications.services.MatchTimeChangeContext;
import jakarta.transaction.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import cz.phsoft.hokej.user.entities.AppUserEntity;
import cz.phsoft.hokej.registration.enums.PlayerPositionCategory;

import java.time.Clock;
import java.time.LocalDateTime;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

//TODO KOMENTĂĹE - PROSTĂ‰
/**
 * Implementace service vrstvy, kterĂˇ se pouĹľĂ­vĂˇ pro prĂˇci se zĂˇpasy.
 *
 * V tĂ©to tĹ™Ă­dÄ› se zajiĹˇĹĄujĂ­ CRUD operace nad zĂˇpasy v rĂˇmci sezĂłn, filtrovĂˇnĂ­ nadchĂˇzejĂ­cĂ­ch a probÄ›hlĂ˝ch zĂˇpasĹŻ,
 * sestavenĂ­ detailu zĂˇpasu vÄŤetnÄ› agregovanĂ˝ch statistik a zpracovĂˇnĂ­ zmÄ›n stavu zĂˇpasu, jako je zruĹˇenĂ­ nebo obnova.
 *
 * SouÄŤĂˇstĂ­ odpovÄ›dnosti je takĂ© doplnÄ›nĂ­ ÄŤĂ­slovĂˇnĂ­ zĂˇpasĹŻ v sezĂłnÄ› a spouĹˇtÄ›nĂ­ notifikacĂ­ hrĂˇÄŤĹŻm pĹ™i vybranĂ˝ch zmÄ›nĂˇch,
 * zejmĂ©na pĹ™i zmÄ›nÄ› termĂ­nu, zruĹˇenĂ­ nebo obnovenĂ­ zĂˇpasu. Notifikace se delegujĂ­ do {@link NotificationService}.
 *
 * TĹ™Ă­da neĹ™eĹˇĂ­ detailnĂ­ stavovĂ© pĹ™echody registracĂ­ hrĂˇÄŤĹŻ na zĂˇpasy, kterĂ© jsou spravovĂˇny v {@link MatchRegistrationService}.
 * VĂ˝bÄ›r aktuĂˇlnĂ­ho hrĂˇÄŤe se zajiĹˇĹĄuje ve {@link CurrentPlayerService} a v controller vrstvÄ›.
 */
@Service
public class MatchServiceImpl implements MatchService {

    @Value("${app.demo-mode:false}")
    private boolean isDemoMode;

    private static final Logger logger = LoggerFactory.getLogger(MatchServiceImpl.class);

    private static final String ROLE_ADMIN = "ROLE_ADMIN";
    private static final String ROLE_MANAGER = "ROLE_MANAGER";

    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository matchRegistrationRepository;
    private final MatchMapper matchMapper;
    private final MatchRegistrationService registrationService;
    private final MatchRegistrationCommandService registrationCommandService;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodService playerInactivityPeriodService;
    private final PlayerMapper playerMapper;
    private final CurrentPlayerService currentPlayerService;
    private final SeasonService seasonService;
    private final CurrentSeasonService currentSeasonService;
    private final NotificationService notificationService;
    private final AppUserRepository appUserRepository;
    private final Clock clock;
    private final MatchCapacityService matchCapacityService;

    public MatchServiceImpl(
            MatchRepository matchRepository,
            MatchRegistrationRepository matchRegistrationRepository,
            MatchMapper matchMapper,
            MatchRegistrationService registrationService,
            MatchRegistrationCommandService registrationCommandService,
            PlayerRepository playerRepository,
            PlayerInactivityPeriodService playerInactivityPeriodService,
            PlayerMapper playerMapper,
            CurrentPlayerService currentPlayerService,
            SeasonService seasonService,
            CurrentSeasonService currentSeasonService,
            NotificationService notificationService,
            AppUserRepository appUserRepository,
            Clock clock,
            MatchCapacityService matchCapacityService
    ) {
        this.matchRepository = matchRepository;
        this.matchRegistrationRepository = matchRegistrationRepository;
        this.matchMapper = matchMapper;
        this.registrationService = registrationService;
        this.registrationCommandService = registrationCommandService;
        this.playerRepository = playerRepository;
        this.playerInactivityPeriodService = playerInactivityPeriodService;
        this.playerMapper = playerMapper;
        this.currentPlayerService = currentPlayerService;
        this.seasonService = seasonService;
        this.currentSeasonService = currentSeasonService;
        this.notificationService = notificationService;
        this.appUserRepository = appUserRepository;
        this.clock = clock;
        this.matchCapacityService = matchCapacityService;
    }

    // ======================
    // ZĂKLADNĂŤ SEZNAMY ZĂPASĹ®
    // ======================

    /**
     * VracĂ­ vĹˇechny zĂˇpasy v rĂˇmci aktuĂˇlnÄ› pouĹľĂ­vanĂ© sezĂłny.
     *
     * ZĂˇpasy se naÄŤĂ­tajĂ­ z repository vrstvy, seĹ™adĂ­ se podle data a ÄŤasu vzestupnÄ› a nĂˇslednÄ› se doplnĂ­ poĹ™adovĂ© ÄŤĂ­slo
     * zĂˇpasu v sezĂłnÄ›. MapovĂˇnĂ­ entit na DTO se deleguje do {@link MatchMapper}.
     *
     * @return Seznam zĂˇpasĹŻ aktuĂˇlnĂ­ sezĂłny pĹ™evedenĂ˝ch do DTO vÄŤetnÄ› poĹ™adovĂ©ho ÄŤĂ­sla.
     */
    @Override
    public List<MatchDTO> getAllMatches() {
        Long seasonId = getCurrentSeasonIdOrActive();
        List<MatchEntity> matches =
                matchRepository.findAllBySeasonIdOrderByDateTimeAsc(seasonId);

        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);
        return assignMatchNumbers(matches, matchMapper::toDTO, matchNumberMap);
    }

    /**
     * VracĂ­ vĹˇechny nadchĂˇzejĂ­cĂ­ zĂˇpasy v aktuĂˇlnĂ­ sezĂłnÄ›.
     *
     * ZĂˇpasy se filtrujĂ­ na zĂˇkladÄ› data a ÄŤasu vÄ›tĹˇĂ­ho neĹľ aktuĂˇlnĂ­ okamĹľik, seĹ™adĂ­ se podle data vzestupnÄ›
     * a doplnĂ­ se poĹ™adovĂ© ÄŤĂ­slo zĂˇpasu v sezĂłnÄ›.
     *
     * @return Seznam nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ pĹ™evedenĂ˝ch do DTO vÄŤetnÄ› poĹ™adovĂ©ho ÄŤĂ­sla.
     */
    @Override
    public List<MatchDTO> getUpcomingMatches() {
        Long seasonId = getCurrentSeasonIdOrActive();
        List<MatchEntity> upcomingMatches = findUpcomingMatchesForCurrentSeason();

        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);
        return assignMatchNumbers(upcomingMatches, matchMapper::toDTO, matchNumberMap);
    }

    /**
     * VracĂ­ vĹˇechny probÄ›hlĂ© zĂˇpasy v aktuĂˇlnĂ­ sezĂłnÄ›.
     *
     * ZĂˇpasy se filtrujĂ­ na zĂˇkladÄ› data a ÄŤasu menĹˇĂ­ho neĹľ aktuĂˇlnĂ­ okamĹľik, seĹ™adĂ­ se podle data sestupnÄ›
     * a doplnĂ­ se poĹ™adovĂ© ÄŤĂ­slo zĂˇpasu v sezĂłnÄ›.
     *
     * @return Seznam probÄ›hlĂ˝ch zĂˇpasĹŻ pĹ™evedenĂ˝ch do DTO vÄŤetnÄ› poĹ™adovĂ©ho ÄŤĂ­sla.
     */
    @Override
    public List<MatchDTO> getPastMatches() {
        Long seasonId = getCurrentSeasonIdOrActive();
        List<MatchEntity> pastMatches = findPastMatchesForCurrentSeason();

        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);
        return assignMatchNumbers(pastMatches, matchMapper::toDTO, matchNumberMap);
    }

    /**
     * VracĂ­ nejbliĹľĹˇĂ­ nadchĂˇzejĂ­cĂ­ zĂˇpas v aktuĂˇlnĂ­ sezĂłnÄ›.
     *
     * Pokud ĹľĂˇdnĂ˝ nadchĂˇzejĂ­cĂ­ zĂˇpas neexistuje, vracĂ­ se null.
     *
     * @return NejbliĹľĹˇĂ­ nadchĂˇzejĂ­cĂ­ zĂˇpas pĹ™evedenĂ˝ do DTO, nebo null pokud ĹľĂˇdnĂ˝ neexistuje.
     */
    @Override
    public MatchDTO getNextMatch() {
        return findUpcomingMatchesForCurrentSeason()
                .stream()
                .findFirst()
                .map(matchMapper::toDTO)
                .orElse(null);
    }

    /**
     * VracĂ­ zĂˇkladnĂ­ informace o zĂˇpasu podle identifikĂˇtoru.
     *
     * ZĂˇpas se naÄŤĂ­tĂˇ z repository vrstvy a mapuje se do DTO. PĹ™i neexistenci zĂˇpasu se vyhazuje
     * {@link MatchNotFoundException}.
     *
     * @param id IdentifikĂˇtor zĂˇpasu.
     * @return ZĂˇpas pĹ™evedenĂ˝ do {@link MatchDTO}.
     */
    @Override
    public MatchDTO getMatchById(Long id) {
        return matchMapper.toDTO(findMatchOrThrow(id));
    }

    /**
     * VytvĂˇĹ™Ă­ novĂ˝ zĂˇpas v aktivnĂ­ sezĂłnÄ›.
     *
     * DTO se mapuje na entitu, ovÄ›Ĺ™Ă­ se, Ĺľe datum zĂˇpasu spadĂˇ do obdobĂ­ aktivnĂ­ sezĂłny, a k zĂˇpasu se pĹ™iĹ™adĂ­
     * aktivnĂ­ sezĂłna. IdentifikĂˇtor autora vytvoĹ™enĂ­ a poslednĂ­ Ăşpravy se nastavĂ­ na aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele,
     * pokud je dostupnĂ˝. UloĹľenĂ­ se provĂˇdĂ­ pĹ™es repository vrstvu.
     *
     * @param dto DTO obsahujĂ­cĂ­ data vytvĂˇĹ™enĂ©ho zĂˇpasu.
     * @return VytvoĹ™enĂ˝ zĂˇpas pĹ™evedenĂ˝ do DTO.
     */
    @Override
    public MatchDTO createMatch(MatchDTO dto) {
        MatchEntity entity = matchMapper.toEntity(dto);
        validateMatchDateInActiveSeason(entity.getDateTime());

        entity.setSeason(seasonService.getActiveSeason());

        Long currentUserId = getCurrentUserIdOrNull();
        entity.setCreatedByUserId(currentUserId);
        entity.setLastModifiedByUserId(currentUserId);

        return matchMapper.toDTO(matchRepository.save(entity));
    }

    /**
     * Aktualizuje existujĂ­cĂ­ zĂˇpas podle identifikĂˇtoru.
     *
     * ZĂˇpas se naÄŤte z repository vrstvy a vyhodnotĂ­ se oprĂˇvnÄ›nĂ­ podle role uĹľivatele. UĹľivatel bez role ADMIN
     * nebo MANAGER mĹŻĹľe upravovat pouze zĂˇpasy patĹ™Ă­cĂ­ do aktivnĂ­ sezĂłny a souÄŤasnÄ› se ovÄ›Ĺ™uje, Ĺľe datum zĂˇpasu
     * zĹŻstĂˇvĂˇ v obdobĂ­ aktivnĂ­ sezĂłny. NĂˇslednÄ› se pĹ™enesou zmÄ›ny z DTO do entity a zĂˇpas se uloĹľĂ­.
     *
     * Pokud se zmÄ›nĂ­ kapacita zĂˇpasu, pĹ™epoÄŤĂ­tajĂ­ se stavy registracĂ­ pĹ™es {@link MatchCapacityService}.
     * Pokud se zmÄ›nĂ­ termĂ­n zĂˇpasu, odeĹˇlou se notifikace o zmÄ›nÄ› termĂ­nu pĹ™es {@link NotificationService}.
     * PĹ™i zmÄ›nÄ› vybranĂ˝ch vlastnostĂ­ se nastavĂ­ stav zĂˇpasu na UPDATED.
     *
     * @param id  IdentifikĂˇtor upravovanĂ©ho zĂˇpasu.
     * @param dto DTO obsahujĂ­cĂ­ novĂˇ data zĂˇpasu.
     * @return AktualizovanĂ˝ zĂˇpas pĹ™evedenĂ˝ do DTO.
     * @throws InvalidMatchStatusException    Pokud uĹľivatel bez role ADMIN nebo MANAGER upravuje zĂˇpas mimo aktivnĂ­ sezĂłnu.
     * @throws InvalidMatchDateTimeException  Pokud by po ĂşpravÄ› zĂˇpas spadl do minulosti.
     */
    @Override
    public MatchDTO updateMatch(Long id, MatchDTO dto) {
        MatchEntity entity = findMatchOrThrow(id);

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        boolean isAdminOrManager = hasAdminOrManagerRole(auth);

        if (!isAdminOrManager) {
            Long activeSeasonId = seasonService.getActiveSeason().getId();
            if (!entity.getSeason().getId().equals(activeSeasonId)) {
                throw new InvalidMatchStatusException(
                        id, " - ZĂˇpas nepatĹ™Ă­ do aktuĂˇlnĂ­ sezĂłny, nelze ho upravit."
                );
            }
        }

        Integer oldMaxPlayers = entity.getMaxPlayers();
        LocalDateTime oldDateTime = entity.getDateTime();
        String oldLocation = entity.getLocation();
        Integer oldPrice = entity.getPrice();
        MatchMode oldMatchMode = entity.getMatchMode();   // sledujeme zmÄ›nu reĹľimu

        matchMapper.updateEntity(dto, entity);
        logger.info("UPDATE matchId={}, oldMode={}, newModeAfterMap={}",
                id, oldMatchMode, entity.getMatchMode());

        Long currentUserId = getCurrentUserIdOrNull();
        entity.setLastModifiedByUserId(currentUserId);

        if (!isAdminOrManager) {
            validateMatchDateInActiveSeason(entity.getDateTime());
        }

        if (entity.getDateTime() != null
                && entity.getDateTime().isBefore(LocalDateTime.now())) {
            throw new InvalidMatchDateTimeException("ZĂˇpas by jiĹľ byl minulostĂ­");
        }

        boolean maxPlayersChanged =
                !java.util.Objects.equals(entity.getMaxPlayers(), oldMaxPlayers);

        boolean dateTimeChanged =
                !java.util.Objects.equals(entity.getDateTime(), oldDateTime);

        boolean locationChanged =
                !java.util.Objects.equals(entity.getLocation(), oldLocation);

        boolean priceChanged =
                !java.util.Objects.equals(entity.getPrice(), oldPrice);

        boolean matchModeChanged =
                !java.util.Objects.equals(entity.getMatchMode(), oldMatchMode);

        if (maxPlayersChanged || dateTimeChanged || locationChanged || priceChanged || matchModeChanged) {
            entity.setMatchStatus(MatchStatus.UPDATED);
        }

        MatchEntity saved = matchRepository.save(entity);

        // Pokud se zmÄ›nil hernĂ­ systĂ©m, upravĂ­ se pozice hrĂˇÄŤĹŻ v registracĂ­ch.
        if (matchModeChanged) {
            adjustPlayerPositionsForMatchModeChange(saved, oldMatchMode);
        }

        // KapacitnĂ­ logika se deleguje do specializovanĂ© sluĹľby.
        if (maxPlayersChanged) {
            matchCapacityService.handleCapacityChange(saved, oldMaxPlayers);
        }

        // ZmÄ›na termĂ­nu â€“ notifikace hrĂˇÄŤĹŻm o zmÄ›nÄ› ÄŤasu zĂˇpasu.
        if (dateTimeChanged) {
            MatchTimeChangeContext ctx = new MatchTimeChangeContext(saved, oldDateTime);
            notifyPlayersAboutMatchChanges(ctx, MatchStatus.UPDATED);
        }

        return matchMapper.toDTO(saved);
    }

    /**
     * OdstraĹuje zĂˇpas podle identifikĂˇtoru.
     *
     * ZĂˇpas se naÄŤĂ­tĂˇ z repository vrstvy a pĹ™i neexistenci se vyhazuje {@link MatchNotFoundException}.
     * V demo reĹľimu se operace blokuje a vyhazuje se {@link DemoModeOperationNotAllowedException}.
     * PĹ™i ĂşspÄ›ĹˇnĂ©m odstranÄ›nĂ­ se vracĂ­ standardizovanĂˇ odpovÄ›ÄŹ s potvrzenĂ­m a ÄŤasovou znĂˇmkou.
     *
     * @param id IdentifikĂˇtor odstraĹovanĂ©ho zĂˇpasu.
     * @return StandardizovanĂˇ odpovÄ›ÄŹ o ĂşspÄ›ĹˇnĂ©m odstranÄ›nĂ­.
     */
    @Override
    public SuccessResponseDTO deleteMatch(Long id) {
        MatchEntity match = findMatchOrThrow(id);

        if (isDemoMode) {
            throw new DemoModeOperationNotAllowedException(
                    "ZĂˇpas nebude odstranÄ›n. Aplikace bÄ›ĹľĂ­ v DEMO reĹľimu."
            );
        }

        matchRepository.delete(match);

        return new SuccessResponseDTO(
                "BE - ZĂˇpas " + match.getId() + match.getDateTime() + " byl ĂşspÄ›ĹˇnÄ› smazĂˇn",
                id,
                LocalDateTime.now().toString()
        );
    }

    /**
     * RuĹˇĂ­ zĂˇpas a uklĂˇdĂˇ dĹŻvod zruĹˇenĂ­.
     *
     * Pokud je zĂˇpas jiĹľ zruĹˇen, vyhazuje se {@link InvalidMatchStatusException}. PĹ™i ĂşspÄ›ĹˇnĂ©m zruĹˇenĂ­ se nastavĂ­ stav
     * CANCELED, uloĹľĂ­ se dĹŻvod zruĹˇenĂ­ a aktualizuje se identifikĂˇtor uĹľivatele, kterĂ˝ zmÄ›nu provedl. NĂˇslednÄ› se odeĹˇlou
     * notifikace registrovanĂ˝m hrĂˇÄŤĹŻm o zruĹˇenĂ­ zĂˇpasu pĹ™es {@link NotificationService}.
     *
     * @param matchId IdentifikĂˇtor ruĹˇenĂ©ho zĂˇpasu.
     * @param reason DĹŻvod zruĹˇenĂ­ zĂˇpasu.
     * @return StandardizovanĂˇ odpovÄ›ÄŹ o ĂşspÄ›ĹˇnĂ©m zruĹˇenĂ­.
     */
    @Override
    @Transactional
    public SuccessResponseDTO cancelMatch(Long matchId, MatchCancelReason reason) {
        MatchEntity match = findMatchOrThrow(matchId);
        String message = " je jiĹľ zruĹˇen";

        if (match.getMatchStatus() == MatchStatus.CANCELED) {
            throw new InvalidMatchStatusException(matchId, message);
        }

        match.setMatchStatus(MatchStatus.CANCELED);
        match.setCancelReason(reason);

        Long currentUserId = getCurrentUserIdOrNull();
        match.setLastModifiedByUserId(currentUserId);

        MatchEntity saved = matchRepository.save(match);
        notifyPlayersAboutMatchChanges(saved, MatchStatus.CANCELED);

        return new SuccessResponseDTO(
                "BE - ZĂˇpas " + match.getId() + match.getDateTime() + " byl ĂşspÄ›ĹˇnÄ› zruĹˇen",
                match.getId(),
                LocalDateTime.now().toString()
        );
    }

    /**
     * Obnovuje dĹ™Ă­ve zruĹˇenĂ˝ zĂˇpas.
     *
     * Pokud zĂˇpas nenĂ­ ve stavu CANCELED, vyhazuje se {@link InvalidMatchStatusException}. PĹ™i ĂşspÄ›ĹˇnĂ© obnovÄ› se odstranĂ­
     * dĹŻvod zruĹˇenĂ­, nastavĂ­ se stav UNCANCELED a aktualizuje se identifikĂˇtor uĹľivatele, kterĂ˝ zmÄ›nu provedl. NĂˇslednÄ› se
     * odeĹˇlou notifikace registrovanĂ˝m hrĂˇÄŤĹŻm o obnovenĂ­ zĂˇpasu pĹ™es {@link NotificationService}.
     *
     * @param matchId IdentifikĂˇtor obnovovanĂ©ho zĂˇpasu.
     * @return StandardizovanĂˇ odpovÄ›ÄŹ o ĂşspÄ›ĹˇnĂ© obnovÄ›.
     */
    @Override
    @Transactional
    public SuccessResponseDTO unCancelMatch(Long matchId) {
        MatchEntity match = findMatchOrThrow(matchId);
        String message = " jeĹˇtÄ› nebyl zruĹˇen";

        if (match.getMatchStatus() != MatchStatus.CANCELED) {
            throw new InvalidMatchStatusException(matchId, message);
        }

        match.setMatchStatus(MatchStatus.UNCANCELED);
        match.setCancelReason(null);

        Long currentUserId = getCurrentUserIdOrNull();
        match.setLastModifiedByUserId(currentUserId);

        MatchEntity saved = matchRepository.save(match);
        notifyPlayersAboutMatchChanges(saved, MatchStatus.UNCANCELED);

        return new SuccessResponseDTO(
                "BE - ZĂˇpas " + match.getId() + match.getDateTime() + " byl ĂşspÄ›ĹˇnÄ› obnoven",
                match.getId(),
                LocalDateTime.now().toString()
        );
    }

    // ======================
    // DETAIL ZĂPASU
    // ======================

    /**
     * VracĂ­ detail zĂˇpasu ve formÄ› {@link MatchDetailDTO}.
     *
     * Nejprve se naÄŤte zĂˇpas a vyhodnotĂ­ se pĹ™Ă­stupovĂˇ pravidla dle role uĹľivatele a jeho navĂˇzanĂ˝ch hrĂˇÄŤĹŻ.
     * NĂˇslednÄ› se sestavĂ­ detailnĂ­ DTO vÄŤetnÄ› agregovanĂ˝ch statistik a seskupenĂ­ hrĂˇÄŤĹŻ podle stavĹŻ registracĂ­.
     * Do vĂ˝sledku se doplnĂ­ stav aktuĂˇlnÄ› zvolenĂ©ho hrĂˇÄŤe, pĹ™Ă­padnĂ© informace o omluvÄ›, stav zĂˇpasu a dĹŻvod zruĹˇenĂ­.
     * Pokud je zĂˇpas souÄŤĂˇstĂ­ sezĂłny, doplnĂ­ se takĂ© poĹ™adovĂ© ÄŤĂ­slo zĂˇpasu v sezĂłnÄ›.
     *
     * @param id IdentifikĂˇtor zĂˇpasu.
     * @return Detail zĂˇpasu ve formÄ› {@link MatchDetailDTO}.
     */
    @Override
    public MatchDetailDTO getMatchDetail(Long id) {
        MatchEntity match = findMatchOrThrow(id);

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        boolean isAdminOrManager = hasAdminOrManagerRole(auth);

        checkAccessForPlayer(match, auth);

        MatchDetailDTO dto = collectPlayerStatus(match, isAdminOrManager);

        Long currentPlayerId = null;
        try {
            currentPlayerId = currentPlayerService.getCurrentPlayerId();
        } catch (Exception e) {
            logger.debug("Nebyl nalezen currentPlayerId pro match detail {}", id);
        }

        PlayerMatchStatus playerMatchStatus = resolveStatusForPlayer(dto, currentPlayerId);
        dto.setPlayerMatchStatus(playerMatchStatus);

        if (currentPlayerId != null) {
            matchRegistrationRepository.findByPlayerIdAndMatchId(currentPlayerId, match.getId())
                    .ifPresent(reg -> {
                        dto.setExcuseReason(reg.getExcuseReason());
                        dto.setExcuseNote(reg.getExcuseNote());
                    });
        } else {
            dto.setExcuseReason(null);
            dto.setExcuseNote(null);
        }

        dto.setMatchStatus(match.getMatchStatus());
        dto.setCancelReason(match.getCancelReason());
        dto.setMatchMode(match.getMatchMode());   // doplnÄ›nĂ­ reĹľimu zĂˇpasu do detailu

        if (match.getSeason() != null && match.getSeason().getId() != null) {
            Long seasonId = match.getSeason().getId();
            Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);
            Integer number = matchNumberMap.get(match.getId());
            dto.setMatchNumber(number);
            dto.setSeasonId(seasonId);           // doplnÄ›nĂ­ ID sezĂłny do detailu
        }

        return dto;
    }

    /**
     * OvÄ›Ĺ™uje, zda mĂˇ aktuĂˇlnĂ­ uĹľivatel pĹ™Ă­stup k detailu zĂˇpasu.
     *
     * UĹľivatel musĂ­ bĂ˝t pĹ™ihlĂˇĹˇen. UĹľivatel s rolĂ­ ADMIN nebo MANAGER mĂˇ pĹ™Ă­stup vĹľdy.
     * UĹľivatel bez administrĂˇtorskĂ© role musĂ­ mĂ­t navĂˇzanĂ©ho alespoĹ jednoho hrĂˇÄŤe a souÄŤasnÄ› platĂ­ omezenĂ­ podle toho,
     * zda jde o nadchĂˇzejĂ­cĂ­ nebo probÄ›hlĂ˝ zĂˇpas v rĂˇmci aktuĂˇlnĂ­ sezĂłny.
     *
     * Pro nadchĂˇzejĂ­cĂ­ zĂˇpas se ovÄ›Ĺ™uje, Ĺľe uĹľivatel mĂˇ alespoĹ jednoho aktivnĂ­ho hrĂˇÄŤe pro termĂ­n zĂˇpasu.
     * Pro probÄ›hlĂ˝ zĂˇpas se ovÄ›Ĺ™uje, Ĺľe nÄ›kterĂ˝ z hrĂˇÄŤĹŻ uĹľivatele byl v zĂˇpase registrovĂˇn ve stavu REGISTERED.
     *
     * @param match ZĂˇpas, ke kterĂ©mu se pĹ™Ă­stup vyhodnocuje.
     * @param auth AktuĂˇlnĂ­ autentizace z bezpeÄŤnostnĂ­ho kontextu.
     */
    private void checkAccessForPlayer(MatchEntity match, Authentication auth) {
        if (auth == null || !auth.isAuthenticated()) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - MusĂ­te bĂ˝t pĹ™ihlĂˇĹˇen."
            );
        }

        boolean isAdminOrManager = hasAdminOrManagerRole(auth);
        if (isAdminOrManager) {
            return;
        }

        Long currentSeasonId = getCurrentSeasonIdOrActive();
        if (match.getSeason() == null || !match.getSeason().getId().equals(currentSeasonId)) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - K detailu zĂˇpasu z jinĂ© sezĂłny nemĂˇte pĹ™Ă­stup."
            );
        }

        Object principal = auth.getPrincipal();
        if (!(principal instanceof org.springframework.security.core.userdetails.UserDetails userDetails)) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - NemĂˇte pĹ™Ă­stup k detailu tohoto zĂˇpasu."
            );
        }

        List<PlayerEntity> ownedPlayers =
                playerRepository.findByUser_EmailOrderByIdAsc(userDetails.getUsername());

        if (ownedPlayers.isEmpty()) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - NemĂˇte pĹ™iĹ™azenĂ©ho ĹľĂˇdnĂ©ho hrĂˇÄŤe."
            );
        }

        LocalDateTime now = now();
        boolean isPastOrNow = !match.getDateTime().isAfter(now);
        List<Long> ownedPlayerIds = ownedPlayers.stream()
                .map(PlayerEntity::getId)
                .toList();

        List<MatchRegistrationDTO> registrations =
                registrationService.getRegistrationsForMatch(match.getId());

        if (!isPastOrNow) {
            boolean hasActivePlayerForMatch = ownedPlayers.stream()
                    .anyMatch(p -> isPlayerActiveForMatch(p, match.getDateTime()));

            if (!hasActivePlayerForMatch) {
                throw new org.springframework.security.access.AccessDeniedException(
                        "BE - NemĂˇte aktivnĂ­ho hrĂˇÄŤe pro tento zĂˇpas."
                );
            }
            return;
        }

        boolean wasRegistered = registrations.stream()
                .anyMatch(r ->
                        r.getStatus() == PlayerMatchStatus.REGISTERED
                                && ownedPlayerIds.contains(r.getPlayerId())
                );

        if (!wasRegistered) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - K tomuto uplynulĂ©mu zĂˇpasu nemĂˇte oprĂˇvnÄ›nĂ­ (nejste mezi registrovanĂ˝mi hrĂˇÄŤi)."
            );
        }
    }

    /**
     * Sestavuje {@link MatchDetailDTO} pro danĂ˝ zĂˇpas.
     *
     * V rĂˇmci sestavenĂ­ se naÄŤtou registrace k zĂˇpasu, hrĂˇÄŤi se seskupĂ­ podle stavĹŻ registracĂ­ a spoÄŤĂ­tajĂ­ se agregovanĂ©
     * hodnoty, zejmĂ©na poÄŤty hrĂˇÄŤĹŻ v jednotlivĂ˝ch stavech, volnĂˇ mĂ­sta a cena na registrovanĂ©ho hrĂˇÄŤe.
     *
     * Seznam hrĂˇÄŤĹŻ bez reakce se do vĂ˝sledku doplĹuje pouze pro role ADMIN a MANAGER.
     *
     * @param match ZĂˇpas, pro kterĂ˝ se detail sestavuje.
     * @param isAdminOrManager PĹ™Ă­znak urÄŤujĂ­cĂ­, zda mĂˇ uĹľivatel oprĂˇvnÄ›nĂ­ pro administrĂˇtorskĂ˝ pohled.
     * @return Detail zĂˇpasu sestavenĂ˝ do DTO.
     */
    private MatchDetailDTO collectPlayerStatus(MatchEntity match, boolean isAdminOrManager) {
        List<MatchRegistrationDTO> registrations =
                registrationService.getRegistrationsForMatch(match.getId());

        var statusToPlayersMap = registrations.stream()
                .map(r -> playerRepository.findById(r.getPlayerId())
                        .map(playerMapper::toDTO)
                        .map(dto -> new AbstractMap.SimpleEntry<>(r.getStatus(), dto))
                )
                .filter(Optional::isPresent)
                .map(Optional::get)
                .collect(Collectors.groupingBy(
                        java.util.Map.Entry::getKey,
                        Collectors.mapping(java.util.Map.Entry::getValue, Collectors.toList())
                ));

        List<PlayerDTO> noResponsePlayers =
                registrationService.getNoResponsePlayers(match.getId());
        List<PlayerDTO> registeredDarkPlayers = getRegisteredPlayersForTeam(registrations, Team.DARK);
        List<PlayerDTO> registeredLightPlayers = getRegisteredPlayersForTeam(registrations, Team.LIGHT);

        int inGamePlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()).size();

        int inGamePlayersDark =
                (int) registrations.stream()
                        .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                        .filter(r -> r.getTeam() == Team.DARK)
                        .count();

        int inGamePlayersLight =
                (int) registrations.stream()
                        .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                        .filter(r -> r.getTeam() == Team.LIGHT)
                        .count();

        int substitutePlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.SUBSTITUTE, List.of()).size();

        int outGamePlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()).size()
                        + statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()).size()
                        + statusToPlayersMap.getOrDefault(PlayerMatchStatus.NO_EXCUSED, List.of()).size();

        int waitingPlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()).size();

        int noExcusedPlayersSum =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.NO_EXCUSED, List.of()).size();

        int noActionPlayers = noResponsePlayers.size();

        int remainingSlots = match.getMaxPlayers() - inGamePlayers;
        double pricePerRegistered = inGamePlayers > 0
                ? match.getPrice() / (double) inGamePlayers
                : match.getPrice();

        MatchDetailDTO dto = new MatchDetailDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setLocation(match.getLocation());
        dto.setDescription(match.getDescription());
        dto.setPrice(match.getPrice());
        dto.setMaxPlayers(match.getMaxPlayers());
        dto.setInGamePlayers(inGamePlayers);
        dto.setInGamePlayersDark(inGamePlayersDark);
        dto.setInGamePlayersLight(inGamePlayersLight);
        dto.setSubstitutePlayers(substitutePlayers);
        dto.setOutGamePlayers(outGamePlayers);
        dto.setWaitingPlayers(waitingPlayers);
        dto.setNoExcusedPlayersSum(noExcusedPlayersSum);
        dto.setNoActionPlayers(noActionPlayers);
        dto.setPricePerRegisteredPlayer(pricePerRegistered);
        dto.setRemainingSlots(remainingSlots);

        dto.setRegisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()));
        dto.setReservedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()));
        dto.setUnregisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()));
        dto.setExcusedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()));
        dto.setSubstitutedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.SUBSTITUTE, List.of()));
        dto.setNoExcusedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.NO_EXCUSED, List.of()));

        dto.setNoResponsePlayers(isAdminOrManager ? noResponsePlayers : null);
        dto.setRegisteredDarkPlayers(registeredDarkPlayers);
        dto.setRegisteredLightPlayers(registeredLightPlayers);
        dto.setRegistrations(registrations);

        return dto;
    }

    /**
     * Sestavuje seznam hrĂˇÄŤĹŻ registrovanĂ˝ch do konkrĂ©tnĂ­ho tĂ˝mu.
     *
     * Seznam se sestavuje pouze ze stavu REGISTERED a pouĹľĂ­vĂˇ se pro rychlĂ© zobrazenĂ­ sloĹľenĂ­ tĂ˝mĹŻ v detailu zĂˇpasu.
     * NaÄŤĂ­tĂˇnĂ­ hrĂˇÄŤĹŻ se provĂˇdĂ­ pĹ™es repository vrstvu a pĹ™evod do DTO se deleguje do {@link PlayerMapper}.
     *
     * @param registrations Registrace zĂˇpasu, ze kterĂ˝ch se hrĂˇÄŤi vyhodnocujĂ­.
     * @param team TĂ˝m, pro kterĂ˝ se hrĂˇÄŤi filtrujĂ­.
     * @return Seznam hrĂˇÄŤĹŻ registrovanĂ˝ch v danĂ©m tĂ˝mu pĹ™evedenĂ˝ch do DTO.
     */
    private List<PlayerDTO> getRegisteredPlayersForTeam(List<MatchRegistrationDTO> registrations, Team team) {
        return registrations.stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .filter(r -> r.getTeam() == team)
                .map(MatchRegistrationDTO::getPlayerId)
                .distinct()
                .map(playerRepository::findById)
                .flatMap(Optional::stream)
                .map(playerMapper::toDTO)
                .toList();
    }

    /**
     * Odvozuje stav konkrĂ©tnĂ­ho hrĂˇÄŤe z detailu zĂˇpasu.
     *
     * Stav se vyhodnocuje na zĂˇkladÄ› pĹ™Ă­tomnosti hrĂˇÄŤe v seznamech seskupenĂ˝ch podle stavu registrace.
     * Pokud hrĂˇÄŤ nenĂ­ nalezen v ĹľĂˇdnĂ© kategorii, vracĂ­ se NO_RESPONSE.
     *
     * @param dto Detail zĂˇpasu obsahujĂ­cĂ­ seskupenĂ© seznamy hrĂˇÄŤĹŻ.
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, pro kterĂ©ho se stav vyhodnocuje.
     * @return Stav hrĂˇÄŤe vĹŻÄŤi zĂˇpasu.
     */
    private PlayerMatchStatus resolveStatusForPlayer(MatchDetailDTO dto, Long playerId) {
        if (dto == null || playerId == null) {
            return PlayerMatchStatus.NO_RESPONSE;
        }

        if (isIn(dto.getRegisteredPlayers(), playerId)) {
            return PlayerMatchStatus.REGISTERED;
        }
        if (isIn(dto.getReservedPlayers(), playerId)) {
            return PlayerMatchStatus.RESERVED;
        }
        if (isIn(dto.getExcusedPlayers(), playerId)) {
            return PlayerMatchStatus.EXCUSED;
        }
        if (isIn(dto.getSubstitutedPlayers(), playerId)) {
            return PlayerMatchStatus.SUBSTITUTE;
        }
        if (isIn(dto.getUnregisteredPlayers(), playerId)) {
            return PlayerMatchStatus.UNREGISTERED;
        }
        if (isIn(dto.getNoExcusedPlayers(), playerId)) {
            return PlayerMatchStatus.NO_EXCUSED;
        }

        return PlayerMatchStatus.NO_RESPONSE;
    }

    /**
     * Vyhodnocuje pĹ™Ă­tomnost hrĂˇÄŤe v seznamu hrĂˇÄŤĹŻ podle identifikĂˇtoru.
     *
     * @param players Seznam hrĂˇÄŤĹŻ, ve kterĂ©m se vyhledĂˇvĂˇ.
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, kterĂ˝ se v seznamu ovÄ›Ĺ™uje.
     * @return True, pokud je hrĂˇÄŤ v seznamu pĹ™Ă­tomen, jinak false.
     */
    private boolean isIn(List<PlayerDTO> players, Long playerId) {
        return players != null
                && players.stream().anyMatch(p -> p.getId().equals(playerId));
    }

    // ======================
    // DALĹ ĂŤ PUBLIC METODY
    // ======================

    /**
     * VracĂ­ zĂˇpasy, ve kterĂ˝ch mĹŻĹľe danĂ˝ hrĂˇÄŤ potenciĂˇlnÄ› hrĂˇt.
     *
     * ZĂˇpasy se naÄŤĂ­tajĂ­ napĹ™Ă­ÄŤ vĹˇemi sezĂłnami a nĂˇslednÄ› se filtrujĂ­ podle aktivity hrĂˇÄŤe v termĂ­nu zĂˇpasu.
     * VyhodnocenĂ­ aktivity se deleguje do {@link PlayerInactivityPeriodService}.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, pro kterĂ©ho se dostupnĂ© zĂˇpasy vyhodnocujĂ­.
     * @return Seznam zĂˇpasĹŻ, pro kterĂ© je hrĂˇÄŤ v termĂ­nu aktivnĂ­, pĹ™evedenĂ˝ch do DTO.
     */
    @Override
    public List<MatchDTO> getAvailableMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        return matchRepository.findAll().stream()
                .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                .map(matchMapper::toDTO)
                .toList();
    }

    /**
     * VyhledĂˇvĂˇ identifikĂˇtor hrĂˇÄŤe podle e-mailu uĹľivatele.
     *
     * HrĂˇÄŤ se naÄŤĂ­tĂˇ pĹ™es repository vrstvu. Pokud uĹľivatel nemĂˇ ĹľĂˇdnĂ©ho hrĂˇÄŤe, vyhazuje se {@link PlayerNotFoundException}.
     *
     * @param email E-mail uĹľivatele, pro kterĂ˝ se hrĂˇÄŤ vyhledĂˇvĂˇ.
     * @return IdentifikĂˇtor hrĂˇÄŤe navĂˇzanĂ©ho na uĹľivatele.
     */
    @Override
    public Long getPlayerIdByEmail(String email) {
        return playerRepository.findByUserEmail(email)
                .map(PlayerEntity::getId)
                .orElseThrow(() -> new PlayerNotFoundException(email));
    }

    /**
     * VracĂ­ pĹ™ehled nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ pro konkrĂ©tnĂ­ho hrĂˇÄŤe.
     *
     * NadchĂˇzejĂ­cĂ­ zĂˇpasy se naÄŤtou pro aktuĂˇlnĂ­ sezĂłnu a omezĂ­ se podle typu hrĂˇÄŤe. NĂˇslednÄ› se filtrujĂ­ pouze ty zĂˇpasy,
     * pro kterĂ© je hrĂˇÄŤ v termĂ­nu aktivnĂ­. Do vĂ˝stupu se doplnĂ­ stav hrĂˇÄŤe v zĂˇpase a poĹ™adovĂ© ÄŤĂ­slo zĂˇpasu v sezĂłnÄ›.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, pro kterĂ©ho se pĹ™ehled sestavuje.
     * @return Seznam pĹ™ehledĹŻ zĂˇpasĹŻ pĹ™evedenĂ˝ch do {@link MatchOverviewDTO}.
     */
    @Override
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        List<MatchEntity> upcomingAll = findUpcomingMatchesForCurrentSeason();
        List<MatchEntity> limited = limitMatchesByPlayerType(upcomingAll, type);

        List<MatchEntity> activeMatches = limited.stream()
                .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                .toList();

        Long seasonId = getCurrentSeasonIdOrActive();
        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);

        return assignMatchNumbers(
                activeMatches,
                match -> toOverviewDTO(match, playerId),
                matchNumberMap
        );
    }

    /**
     * VracĂ­ seznam nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ pro konkrĂ©tnĂ­ho hrĂˇÄŤe.
     *
     * NadchĂˇzejĂ­cĂ­ zĂˇpasy se naÄŤtou pro aktuĂˇlnĂ­ sezĂłnu, omezĂ­ se podle typu hrĂˇÄŤe a nĂˇslednÄ› se filtrujĂ­ pouze ty zĂˇpasy,
     * pro kterĂ© je hrĂˇÄŤ v termĂ­nu aktivnĂ­. Do vĂ˝stupu se doplnĂ­ poĹ™adovĂ© ÄŤĂ­slo zĂˇpasu v sezĂłnÄ›.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, pro kterĂ©ho se zĂˇpasy naÄŤĂ­tajĂ­.
     * @return Seznam nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ pĹ™evedenĂ˝ch do {@link MatchDTO}.
     */
    @Override
    public List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        List<MatchEntity> upcomingAll = findUpcomingMatchesForCurrentSeason();
        List<MatchEntity> limited = limitMatchesByPlayerType(upcomingAll, type);

        List<MatchEntity> activeMatches = limited.stream()
                .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                .toList();

        Long seasonId = getCurrentSeasonIdOrActive();
        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);

        return assignMatchNumbers(activeMatches, matchMapper::toDTO, matchNumberMap);
    }

    /**
     * VracĂ­ pĹ™ehled probÄ›hlĂ˝ch zĂˇpasĹŻ aktuĂˇlnĂ­ sezĂłny, kterĂ˝ch se hrĂˇÄŤ mohl ĂşÄŤastnit.
     *
     * ZĂˇpasy se filtrujĂ­ podle data vytvoĹ™enĂ­ hrĂˇÄŤe a podle aktivity hrĂˇÄŤe v termĂ­nu zĂˇpasu. Pro vybranou sadu zĂˇpasĹŻ
     * se hromadnÄ› naÄŤtou registrace a pro kaĹľdĂ˝ zĂˇpas se odvodĂ­ stav hrĂˇÄŤe. Do vĂ˝stupu se doplnĂ­ poĹ™adovĂ© ÄŤĂ­slo zĂˇpasu
     * v sezĂłnÄ›.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, pro kterĂ©ho se pĹ™ehled sestavuje.
     * @return Seznam pĹ™ehledĹŻ probÄ›hlĂ˝ch zĂˇpasĹŻ pĹ™evedenĂ˝ch do {@link MatchOverviewDTO}.
     */
    @Override
    public List<MatchOverviewDTO> getAllPassedMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        LocalDateTime playerCreatedDate = player.getTimestamp();

        List<MatchEntity> availableMatches =
                findPastMatchesForCurrentSeason().stream()
                        .filter(match -> match.getDateTime().isAfter(playerCreatedDate))
                        .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                        .toList();

        if (availableMatches.isEmpty()) {
            return List.of();
        }

        List<Long> matchIds = availableMatches.stream()
                .map(MatchEntity::getId)
                .toList();

        List<MatchRegistrationDTO> allRegistrations =
                registrationService.getRegistrationsForMatches(matchIds);

        var statusMap = allRegistrations.stream()
                .collect(Collectors.groupingBy(
                        MatchRegistrationDTO::getMatchId,
                        Collectors.toMap(
                                MatchRegistrationDTO::getPlayerId,
                                MatchRegistrationDTO::getStatus,
                                (a, b) -> a
                        )
                ));

        List<MatchOverviewDTO> overviews = availableMatches.stream()
                .map(match -> {
                    MatchOverviewDTO overview = toOverviewDTO(match);
                    PlayerMatchStatus playerMatchStatus = Optional.ofNullable(statusMap.get(match.getId()))
                            .map(m -> normalizePlayerStatus(m.get(playerId)))
                            .orElse(PlayerMatchStatus.NO_RESPONSE);
                    overview.setPlayerMatchStatus(playerMatchStatus);
                    return overview;
                })
                .toList();

        Long seasonId = getCurrentSeasonIdOrActive();
        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);

        overviews.forEach(o -> o.setMatchNumber(matchNumberMap.get(o.getId())));

        return overviews;
    }

    /**
     * NaÄŤĂ­tĂˇ hrĂˇÄŤe podle identifikĂˇtoru nebo vyhazuje vĂ˝jimku pĹ™i neexistenci.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe.
     * @return NaÄŤtenĂˇ entita hrĂˇÄŤe.
     */
    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    /**
     * NaÄŤĂ­tĂˇ zĂˇpas podle identifikĂˇtoru nebo vyhazuje vĂ˝jimku pĹ™i neexistenci.
     *
     * @param matchId IdentifikĂˇtor zĂˇpasu.
     * @return NaÄŤtenĂˇ entita zĂˇpasu.
     */
    private MatchEntity findMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }

    /**
     * NaÄŤĂ­tĂˇ registraci hrĂˇÄŤe k zĂˇpasu nebo vyhazuje vĂ˝jimku pĹ™i neexistenci.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe.
     * @param matchId IdentifikĂˇtor zĂˇpasu.
     * @return NaÄŤtenĂˇ entita registrace.
     */
    private MatchRegistrationEntity findMatchRegistrationOrThrow(Long playerId, Long matchId) {
        return matchRegistrationRepository.findByPlayerIdAndMatchId(playerId, matchId)
                .orElseThrow(() -> new MatchRegistrationNotFoundException(playerId, matchId));
    }

    /**
     * VracĂ­ aktuĂˇlnĂ­ ÄŤas.
     *
     * Metoda se pouĹľĂ­vĂˇ pro sjednocenĂ­ pĹ™Ă­stupu k ÄŤasu a pro usnadnÄ›nĂ­ testovĂˇnĂ­.
     *
     * @return AktuĂˇlnĂ­ ÄŤas jako LocalDateTime.
     */
    private LocalDateTime now() {
        return LocalDateTime.now();
    }

    // ======================
    // POMOCNĂ‰ METODY â€“ DTO MAPOVĂNĂŤ
    // ======================

    /**
     * Sestavuje zĂˇkladnĂ­ {@link MatchOverviewDTO} pro danĂ˝ zĂˇpas.
     *
     * DTO obsahuje zĂˇkladnĂ­ informace o zĂˇpasu a poÄŤet hrĂˇÄŤĹŻ se stavem REGISTERED vÄŤetnÄ› vypoÄŤtenĂ© ceny na registrovanĂ©ho
     * hrĂˇÄŤe. NaÄŤtenĂ­ registracĂ­ se deleguje do {@link MatchRegistrationService}.
     *
     * @param match ZĂˇpas, pro kterĂ˝ se pĹ™ehled sestavuje.
     * @return PĹ™ehled zĂˇpasu pĹ™evedenĂ˝ do {@link MatchOverviewDTO}.
     */
    private MatchOverviewDTO toOverviewDTO(MatchEntity match) {
        MatchOverviewDTO dto = new MatchOverviewDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setLocation(match.getLocation());
        dto.setDescription(match.getDescription());
        dto.setPrice(match.getPrice());
        dto.setMaxPlayers(match.getMaxPlayers());

        int inGamePlayers = registrationService.getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .mapToInt(r -> 1)
                .sum();
        dto.setInGamePlayers(inGamePlayers);

        double pricePerPlayer = inGamePlayers > 0 && match.getPrice() != null
                ? match.getPrice() / (double) inGamePlayers
                : match.getPrice();
        dto.setPricePerRegisteredPlayer(pricePerPlayer);

        // doplnÄ›nĂ­ stavu zĂˇpasu, reĹľimu a sezĂłny pro pĹ™ehled
        dto.setMatchStatus(match.getMatchStatus());
        dto.setCancelReason(match.getCancelReason());
        dto.setMatchMode(match.getMatchMode());

        if (match.getSeason() != null && match.getSeason().getId() != null) {
            dto.setSeasonId(match.getSeason().getId());
        }

        return dto;
    }

    /**
     * Sestavuje {@link MatchOverviewDTO} pro danĂ˝ zĂˇpas v kontextu konkrĂ©tnĂ­ho hrĂˇÄŤe.
     *
     * K zĂˇkladnĂ­m ĂşdajĹŻm o zĂˇpasu se doplnĂ­ stav hrĂˇÄŤe v zĂˇpase odvozenĂ˝ z registracĂ­. Pokud registrace hrĂˇÄŤe neexistuje,
     * pouĹľije se stav NO_RESPONSE.
     *
     * @param match ZĂˇpas, pro kterĂ˝ se pĹ™ehled sestavuje.
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, jehoĹľ stav se do pĹ™ehledu doplĹuje.
     * @return PĹ™ehled zĂˇpasu pĹ™evedenĂ˝ do {@link MatchOverviewDTO} vÄŤetnÄ› stavu hrĂˇÄŤe.
     */
    private MatchOverviewDTO toOverviewDTO(MatchEntity match, Long playerId) {
        MatchOverviewDTO dto = toOverviewDTO(match);

        PlayerMatchStatus playerMatchStatus = registrationService
                .getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getPlayerId().equals(playerId))
                .map(MatchRegistrationDTO::getStatus)
                .findFirst()
                .map(this::normalizePlayerStatus)
                .orElse(PlayerMatchStatus.NO_RESPONSE);

        dto.setPlayerMatchStatus(playerMatchStatus);
        return dto;
    }

    // ======================
    // DALĹ ĂŤ POMOCNĂ‰ METODY
    // ======================

    /**
     * Vyhodnocuje, zda mĂˇ uĹľivatel roli ADMIN nebo MANAGER.
     *
     * @param auth AktuĂˇlnĂ­ autentizace z bezpeÄŤnostnĂ­ho kontextu.
     * @return True, pokud mĂˇ uĹľivatel jednu z administrĂˇtorskĂ˝ch rolĂ­, jinak false.
     */
    private boolean hasAdminOrManagerRole(Authentication auth) {
        if (auth == null) {
            return false;
        }
        return auth.getAuthorities().stream()
                .anyMatch(a ->
                        ROLE_ADMIN.equals(a.getAuthority()) ||
                                ROLE_MANAGER.equals(a.getAuthority())
                );
    }

    /**
     * NaÄŤĂ­tĂˇ vĹˇechny nadchĂˇzejĂ­cĂ­ zĂˇpasy v aktuĂˇlnĂ­ sezĂłnÄ›.
     *
     * ZĂˇpasy se vybĂ­rajĂ­ podle data a ÄŤasu vÄ›tĹˇĂ­ho neĹľ aktuĂˇlnĂ­ okamĹľik a Ĺ™adĂ­ se vzestupnÄ› podle data.
     *
     * @return Seznam nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ v aktuĂˇlnĂ­ sezĂłnÄ›.
     */
    private List<MatchEntity> findUpcomingMatchesForCurrentSeason() {
        return matchRepository.findBySeasonIdAndDateTimeAfterOrderByDateTimeAsc(
                getCurrentSeasonIdOrActive(),
                now()
        );
    }

    /**
     * NaÄŤĂ­tĂˇ vĹˇechny probÄ›hlĂ© zĂˇpasy v aktuĂˇlnĂ­ sezĂłnÄ›.
     *
     * ZĂˇpasy se vybĂ­rajĂ­ podle data a ÄŤasu menĹˇĂ­ho neĹľ aktuĂˇlnĂ­ okamĹľik a Ĺ™adĂ­ se sestupnÄ› podle data.
     *
     * @return Seznam probÄ›hlĂ˝ch zĂˇpasĹŻ v aktuĂˇlnĂ­ sezĂłnÄ›.
     */
    private List<MatchEntity> findPastMatchesForCurrentSeason() {
        return matchRepository.findBySeasonIdAndDateTimeBeforeOrderByDateTimeDesc(
                getCurrentSeasonIdOrActive(),
                now()
        );
    }

    /**
     * Omezuje poÄŤet nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ podle typu hrĂˇÄŤe.
     *
     * Pro typ VIP se vracĂ­ tĹ™i nejbliĹľĹˇĂ­ zĂˇpasy, pro STANDARD dva nejbliĹľĹˇĂ­ zĂˇpasy a pro BASIC jeden nejbliĹľĹˇĂ­ zĂˇpas.
     *
     * @param upcomingAll Seznam vĹˇech nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ.
     * @param type Typ hrĂˇÄŤe.
     * @return OmezenĂ˝ seznam zĂˇpasĹŻ podle pravidel typu hrĂˇÄŤe.
     */
    private List<MatchEntity> limitMatchesByPlayerType(List<MatchEntity> upcomingAll, PlayerType type) {
        if (upcomingAll == null || upcomingAll.isEmpty()) {
            return List.of();
        }

        return switch (type) {
            case VIP -> upcomingAll.stream().limit(3).toList();
            case STANDARD -> upcomingAll.stream().limit(2).toList();
            case BASIC -> List.of(upcomingAll.get(0));
        };
    }

    /**
     * Vyhodnocuje, zda je hrĂˇÄŤ aktivnĂ­ pro termĂ­n zĂˇpasu.
     *
     * VyhodnocenĂ­ aktivity se deleguje do {@link PlayerInactivityPeriodService}.
     *
     * @param player HrĂˇÄŤ, jehoĹľ aktivita se vyhodnocuje.
     * @param dateTime TermĂ­n zĂˇpasu.
     * @return True, pokud je hrĂˇÄŤ v termĂ­nu zĂˇpasu aktivnĂ­, jinak false.
     */
    private boolean isPlayerActiveForMatch(PlayerEntity player, LocalDateTime dateTime) {
        return playerInactivityPeriodService.isActive(player, dateTime);
    }

    /**
     * Normalizuje stav registrace hrĂˇÄŤe pro pouĹľitĂ­ v pĹ™ehledech.
     *
     * Pokud je stav null nebo je neznĂˇmĂ˝, vracĂ­ se NO_RESPONSE. PodporovanĂ© stavy se vracejĂ­ beze zmÄ›ny.
     *
     * @param status Stav registrace hrĂˇÄŤe.
     * @return NormalizovanĂ˝ stav registrace pro pouĹľitĂ­ v pĹ™ehledech.
     */
    private PlayerMatchStatus normalizePlayerStatus(PlayerMatchStatus status) {
        if (status == null) {
            return PlayerMatchStatus.NO_RESPONSE;
        }

        return switch (status) {
            case REGISTERED,
                 UNREGISTERED,
                 EXCUSED,
                 SUBSTITUTE,
                 RESERVED,
                 NO_EXCUSED -> status;
            default -> PlayerMatchStatus.NO_RESPONSE;
        };
    }

    /**
     * OvÄ›Ĺ™uje, Ĺľe datum zĂˇpasu spadĂˇ do obdobĂ­ aktivnĂ­ sezĂłny.
     *
     * Kontrola se pouĹľĂ­vĂˇ pĹ™i vytvĂˇĹ™enĂ­ a ĂşpravÄ› zĂˇpasu pro uĹľivatele bez administrĂˇtorskĂ© role. PĹ™i poruĹˇenĂ­ obdobĂ­
     * aktivnĂ­ sezĂłny se vyhazuje {@link InvalidSeasonPeriodDateException}.
     *
     * @param dateTime TermĂ­n zĂˇpasu, kterĂ˝ se ovÄ›Ĺ™uje.
     */
    private void validateMatchDateInActiveSeason(LocalDateTime dateTime) {
        var activeSeason = seasonService.getActiveSeason();
        var date = dateTime.toLocalDate();

        if (date.isBefore(activeSeason.getStartDate()) ||
                date.isAfter(activeSeason.getEndDate())) {

            throw new InvalidSeasonPeriodDateException(
                    "BE - Datum zĂˇpasu musĂ­ bĂ˝t v rozmezĂ­ aktivnĂ­ sezĂłny (" +
                            activeSeason.getStartDate() + " - " + activeSeason.getEndDate() + ")."
            );
        }
    }

    /**
     * VracĂ­ identifikĂˇtor sezĂłny, kterĂˇ se pouĹľije pro prĂˇci se zĂˇpasy.
     *
     * PrimĂˇrnÄ› se pouĹľĂ­vĂˇ sezĂłna uloĹľenĂˇ v {@link CurrentSeasonService}. Pokud nenĂ­ k dispozici, pouĹľije se globĂˇlnÄ›
     * aktivnĂ­ sezĂłna ze {@link SeasonService}.
     *
     * @return IdentifikĂˇtor aktuĂˇlnĂ­ nebo aktivnĂ­ sezĂłny.
     */
    private Long getCurrentSeasonIdOrActive() {
        Long id = currentSeasonService.getCurrentSeasonIdOrDefault();
        if (id != null) {
            return id;
        }
        return seasonService.getActiveSeason().getId();
    }

    /**
     * DoplĹuje poĹ™adovĂ© ÄŤĂ­slo zĂˇpasu v sezĂłnÄ› do DTO vĂ˝stupu.
     *
     * PoĹ™adovĂ© ÄŤĂ­slo se doplĹuje na zĂˇkladÄ› mapy matchId na poĹ™adĂ­ v sezĂłnÄ›. MapovĂˇnĂ­ entity na DTO se pĹ™edĂˇvĂˇ
     * jako funkce, aby bylo moĹľnĂ© metodu pouĹľĂ­t pro rĹŻznĂ© DTO implementujĂ­cĂ­ {@link NumberedMatchDTO}.
     *
     * @param matches Seznam zĂˇpasĹŻ, kterĂ© se mapujĂ­ do DTO.
     * @param mapper Funkce pro mapovĂˇnĂ­ {@link MatchEntity} na DTO.
     * @param matchNumberMap Mapa matchId na poĹ™adovĂ© ÄŤĂ­slo v sezĂłnÄ›.
     * @return Seznam DTO s doplnÄ›nĂ˝m poĹ™adovĂ˝m ÄŤĂ­slem.
     * @param <D> Typ DTO implementujĂ­cĂ­ {@link NumberedMatchDTO}.
     */
    private <D extends NumberedMatchDTO> List<D> assignMatchNumbers(
            List<MatchEntity> matches,
            Function<MatchEntity, D> mapper,
            Map<Long, Integer> matchNumberMap
    ) {
        return matches.stream()
                .map(entity -> {
                    D dto = mapper.apply(entity);
                    Integer number = matchNumberMap.get(entity.getId());
                    dto.setMatchNumber(number);
                    return dto;
                })
                .toList();
    }

    /**
     * Sestavuje mapu matchId na poĹ™adovĂ© ÄŤĂ­slo zĂˇpasu v sezĂłnÄ›.
     *
     * PoĹ™adĂ­ zĂˇpasĹŻ se odvozuje z data a ÄŤasu zĂˇpasu Ĺ™azenĂ©ho vzestupnÄ› v rĂˇmci sezĂłny.
     *
     * @param seasonId IdentifikĂˇtor sezĂłny, pro kterou se poĹ™adĂ­ sestavuje.
     * @return Mapa matchId na poĹ™adovĂ© ÄŤĂ­slo zĂˇpasu v sezĂłnÄ›.
     */
    private Map<Long, Integer> buildMatchNumberMapForSeason(Long seasonId) {
        List<MatchEntity> allMatchesInSeason =
                matchRepository.findAllBySeasonIdOrderByDateTimeAsc(seasonId);

        Map<Long, Integer> map = new HashMap<>();
        int counter = 1;
        for (MatchEntity m : allMatchesInSeason) {
            map.put(m.getId(), counter++);
        }
        return map;
    }

    /**
     * OdesĂ­lĂˇ notifikace hrĂˇÄŤĹŻm o zmÄ›nĂˇch souvisejĂ­cĂ­ch se zĂˇpasem.
     *
     * Kontext pĹ™edstavuje buÄŹ samotnĂ˝ zĂˇpas, nebo {@link MatchTimeChangeContext} v pĹ™Ă­padÄ› zmÄ›ny termĂ­nu. Na zĂˇkladÄ›
     * stavu zmÄ›ny zĂˇpasu se urÄŤĂ­ typ notifikace a notifikace se odesĂ­lajĂ­ hrĂˇÄŤĹŻm s registracĂ­ ve stavu REGISTERED,
     * RESERVED nebo SUBSTITUTE. OdeslĂˇnĂ­ se deleguje do {@link NotificationService}.
     *
     * @param context Kontext notifikace pouĹľitĂ˝ pro sestavenĂ­ obsahu zprĂˇvy.
     * @param matchStatus Stav zmÄ›ny zĂˇpasu, podle kterĂ©ho se urÄŤuje typ notifikace.
     */
    private void notifyPlayersAboutMatchChanges(Object context, MatchStatus matchStatus) {
        MatchEntity match;
        if (context instanceof MatchTimeChangeContext mtc) {
            match = mtc.match();
        } else if (context instanceof MatchEntity m) {
            match = m;
        } else {
            throw new IllegalArgumentException("NepodporovanĂ˝ typ contextu: " + context);
        }

        var registrations = matchRegistrationRepository.findByMatchId(match.getId());

        registrations.stream()
                .filter(reg -> reg.getStatus() == PlayerMatchStatus.REGISTERED
                        || reg.getStatus() == PlayerMatchStatus.RESERVED
                        || reg.getStatus() == PlayerMatchStatus.SUBSTITUTE)
                .forEach(reg -> {
                    PlayerEntity player = reg.getPlayer();

                    if (matchStatus == MatchStatus.UPDATED) {
                        notificationService.notifyPlayer(
                                player,
                                NotificationType.MATCH_TIME_CHANGED,
                                context
                        );
                    }

                    if (matchStatus == MatchStatus.CANCELED) {
                        notificationService.notifyPlayer(
                                player,
                                NotificationType.MATCH_CANCELED,
                                match
                        );
                        logger.info("CANCEL notify: matchId={}, regs={}",
                                match.getId(),
                                registrations.stream().map(r -> r.getStatus().name()).toList()
                        );
                    }

                    if (matchStatus == MatchStatus.UNCANCELED) {
                        notificationService.notifyPlayer(
                                player,
                                NotificationType.MATCH_UNCANCELED,
                                match
                        );
                    }
                });
    }

    /**
     * VracĂ­ identifikĂˇtor aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele, pokud je dostupnĂ˝.
     *
     * IdentifikĂˇtor se odvozuje z aktuĂˇlnĂ­ autentizace. Jako klĂ­ÄŤ se pouĹľĂ­vĂˇ e-mail uĹľivatele a dohledĂˇnĂ­ se provĂˇdĂ­
     * pĹ™es {@link AppUserRepository}. Pokud autentizace nenĂ­ dostupnĂˇ nebo uĹľivatel neexistuje, vracĂ­ se null.
     *
     * @return IdentifikĂˇtor aktuĂˇlnĂ­ho uĹľivatele, nebo null pokud uĹľivatele nelze urÄŤit.
     */
    private Long getCurrentUserIdOrNull() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth == null || !auth.isAuthenticated()) {
            return null;
        }

        String email = auth.getName();
        return appUserRepository.findByEmail(email)
                .map(AppUserEntity::getId)
                .orElse(null);
    }

    /**
     * Upravuje pozice hrĂˇÄŤĹŻ v registracĂ­ch pĹ™i zmÄ›nÄ› hernĂ­ho systĂ©mu zĂˇpasu.
     *
     * VyuĹľĂ­vĂˇ preferovanĂ© pozice hrĂˇÄŤe (primary / secondary) a nastavenĂ­
     * PlayerSettings (possibleChangePlayerPosition) pro rozhodnutĂ­, na jakĂ˝
     * post mĹŻĹľe bĂ˝t hrĂˇÄŤ pĹ™esunut. PĹ™esun probĂ­hĂˇ pouze u registracĂ­ ve
     * stavu REGISTERED nebo RESERVED.
     *
     * Pokud je pĹŻvodnĂ­ pozice platnĂˇ i v novĂ©m matchMode, ponechĂˇvĂˇ se beze zmÄ›ny.
     * Pokud jiĹľ novĂ˝ matchMode danĂ˝ post neobsahuje, hledĂˇ se nejbliĹľĹˇĂ­ vhodnĂˇ
     * pozice v rĂˇmci stejnĂ© kategorie (obrĂˇnce / ĂştoÄŤnĂ­k / brankĂˇĹ™). PĹ™echod
     * mezi kategoriemi je povolen pouze pokud to hrĂˇÄŤ v nastavenĂ­ povolil.
     *
     * @param match        ZĂˇpas po uloĹľenĂ­ novĂ©ho nastavenĂ­.
     * @param oldMatchMode PĹŻvodnĂ­ reĹľim zĂˇpasu pĹ™ed zmÄ›nou.
     */
    private void adjustPlayerPositionsForMatchModeChange(MatchEntity match, MatchMode oldMatchMode) {
        MatchMode newMode = match.getMatchMode();
        if (newMode == null || newMode == oldMatchMode) {
            return;
        }

        // PovolenĂ© pozice v novĂ©m reĹľimu (stejnĂ© pro oba tĂ˝my)
        List<PlayerPosition> icePositions = MatchModeLayoutUtil.getIcePositionsForMode(newMode);
        if (icePositions == null || icePositions.isEmpty()) {
            return;
        }
        Set<PlayerPosition> allowedPositions = new LinkedHashSet<>(icePositions);

        // Registrace pro danĂ˝ zĂˇpas â€“ budeme upravovat jen REGISTERED / RESERVED
        List<MatchRegistrationEntity> registrations =
                matchRegistrationRepository.findByMatchId(match.getId());
        if (registrations.isEmpty()) {
            return;
        }

        boolean changed = false;

        for (MatchRegistrationEntity reg : registrations) {
            PlayerMatchStatus status = reg.getStatus();
            if (status != PlayerMatchStatus.REGISTERED
                    && status != PlayerMatchStatus.RESERVED) {
                continue;
            }

            PlayerPosition currentPosition = reg.getPositionInMatch();
            if (currentPosition == null || currentPosition == PlayerPosition.ANY) {
                continue;
            }

            // Pokud je stĂˇvajĂ­cĂ­ pozice v novĂ©m reĹľimu platnĂˇ, nenĂ­ tĹ™eba nic mÄ›nit
            if (allowedPositions.contains(currentPosition)) {
                continue;
            }

            PlayerEntity player = reg.getPlayer();
            if (player == null) {
                continue;
            }

            var settings = player.getSettings();
            boolean canCrossCategory = settings != null && settings.isPossibleChangePlayerPosition();

            PlayerPosition primary = player.getPrimaryPosition();
            PlayerPosition secondary = player.getSecondaryPosition();

            PlayerPosition newPosition = resolvePositionForMatchModeChange(
                    currentPosition,
                    primary,
                    secondary,
                    allowedPositions,
                    canCrossCategory
            );

            if (newPosition != null && newPosition != currentPosition) {
                reg.setPositionInMatch(newPosition);
                changed = true;
            }
        }

        if (changed) {
            matchRegistrationRepository.saveAll(registrations);
        }
    }

    /**
     * Odvozuje novou pozici hrĂˇÄŤe pĹ™i zmÄ›nÄ› hernĂ­ho systĂ©mu.
     *
     * Pravidla:
     * - pokud je souÄŤasnĂˇ pozice podporovĂˇna novĂ˝m reĹľimem, nic se nemÄ›nĂ­ (vracĂ­ se null),
     * - pokud post v novĂ©m reĹľimu neexistuje, hledĂˇ se vhodnĂˇ alternativa:
     *   1) pokud v novĂ©m reĹľimu existuje alespoĹ jedna pozice stejnĂ© kategorie:
     *      - primĂˇrnĂ­ pozice hrĂˇÄŤe ve stejnĂ© kategorii,
     *      - sekundĂˇrnĂ­ pozice ve stejnĂ© kategorii,
     *      - libovolnĂˇ jinĂˇ pozice ve stejnĂ© kategorii,
     *      - pĹ™echod do jinĂ© kategorie jen pokud to hrĂˇÄŤ povolil;
     *   2) pokud v novĂ©m reĹľimu neexistuje ĹľĂˇdnĂˇ pozice stejnĂ© kategorie (napĹ™. GOALIE):
     *      - primĂˇrnĂ­ pozice, pokud je v allowedPositions (bez ohledu na kategorii),
     *      - sekundĂˇrnĂ­ pozice, pokud je v allowedPositions,
     *      - libovolnĂˇ pozice z allowedPositions jako fallback.
     */
    private PlayerPosition resolvePositionForMatchModeChange(
            PlayerPosition currentPosition,
            PlayerPosition primary,
            PlayerPosition secondary,
            Set<PlayerPosition> allowedPositions,
            boolean canCrossCategory
    ) {
        if (currentPosition == null || currentPosition == PlayerPosition.ANY) {
            return null;
        }

        // StĂˇvajĂ­cĂ­ pozice je v novĂ©m reĹľimu podporovanĂˇ â€“ nenĂ­ dĹŻvod ji mÄ›nit
        if (allowedPositions.contains(currentPosition)) {
            return null;
        }

        PlayerPositionCategory currentCategory = getPositionCategory(currentPosition);
        if (currentCategory == null) {
            return null;
        }

        // ZjistĂ­me, jestli novĂˇ konfigurace vĹŻbec obsahuje nÄ›jakou pozici stejnĂ© kategorie
        boolean hasSameCategory = allowedPositions.stream()
                .anyMatch(p -> getPositionCategory(p) == currentCategory);

        // ============================
        // 1) KATEGORIE V NOVĂ‰M REĹ˝IMU EXISTUJE
        // ============================
        if (hasSameCategory) {
            // 1a) PrimĂˇrnĂ­ pozice ve stejnĂ© kategorii
            if (isCandidatePosition(primary, allowedPositions, currentCategory)) {
                return primary;
            }

            // 1b) SekundĂˇrnĂ­ pozice ve stejnĂ© kategorii
            if (isCandidatePosition(secondary, allowedPositions, currentCategory)) {
                return secondary;
            }

            // 1c) JakĂˇkoli jinĂˇ pozice ve stejnĂ© kategorii
            PlayerPosition sameCategoryTarget = allowedPositions.stream()
                    .filter(p -> getPositionCategory(p) == currentCategory)
                    .findFirst()
                    .orElse(null);

            if (sameCategoryTarget != null) {
                return sameCategoryTarget;
            }

            // 1d) PĹ™echod do jinĂ© kategorie pouze pokud to hrĂˇÄŤ v nastavenĂ­ povolil
            if (!canCrossCategory) {
                return null;
            }

            return allowedPositions.stream().findFirst().orElse(null);
        }

        // ============================
        // 2) KATEGORIE V NOVĂ‰M REĹ˝IMU VĹ®BEC NEEXISTUJE
        //    (napĹ™. GOALIE u THREE_ON_THREE_NO_GOALIE)
        // ============================

        // 2a) ZkusĂ­me primĂˇrnĂ­ pozici, pokud je v allowedPositions (bez ohledu na kategorii)
        if (primary != null && primary != PlayerPosition.ANY && allowedPositions.contains(primary)) {
            return primary;
        }

        // 2b) ZkusĂ­me sekundĂˇrnĂ­ pozici
        if (secondary != null && secondary != PlayerPosition.ANY && allowedPositions.contains(secondary)) {
            return secondary;
        }

        // 2c) Fallback â€“ libovolnĂˇ povolenĂˇ pozice v novĂ©m reĹľimu
        return allowedPositions.stream().findFirst().orElse(null);
    }

    /**
     * Vyhodnocuje, zda je kandidĂˇtnĂ­ pozice vhodnĂˇ pro pĹ™esun hrĂˇÄŤe.
     *
     * @param candidate         KandidĂˇtnĂ­ pozice.
     * @param allowedPositions  PovolenĂ© pozice v novĂ©m matchMode.
     * @param requiredCategory  PoĹľadovanĂˇ kategorie pozice.
     * @return True, pokud kandidĂˇt splĹuje podmĂ­nky, jinak false.
     */
    private boolean isCandidatePosition(
            PlayerPosition candidate,
            Set<PlayerPosition> allowedPositions,
            PlayerPositionCategory requiredCategory
    ) {
        if (candidate == null || candidate == PlayerPosition.ANY) {
            return false;
        }
        if (!allowedPositions.contains(candidate)) {
            return false;
        }
        PlayerPositionCategory cat = getPositionCategory(candidate);
        return cat == requiredCategory;
    }

    /**
     * Mapuje konkrĂ©tnĂ­ pozici hrĂˇÄŤe na logickou kategorii (brankĂˇĹ™ / obrĂˇnce / ĂştoÄŤnĂ­k).
     *
     * MapovĂˇnĂ­ je drĹľeno zde, aby bylo moĹľnĂ© logiku pouĹľĂ­t nezĂˇvisle
     * na internĂ­ implementaci enumu PlayerPosition.
     *
     * @param position Pozice hrĂˇÄŤe.
     * @return Kategorie pozice, nebo null pro ANY / neznĂˇmou hodnotu.
     */
    private PlayerPositionCategory getPositionCategory(PlayerPosition position) {
        if (position == null || position == PlayerPosition.ANY) {
            return null;
        }

        return switch (position) {
            case GOALIE -> PlayerPositionCategory.GOALIE;

            case DEFENSE,
                 DEFENSE_LEFT,
                 DEFENSE_RIGHT -> PlayerPositionCategory.DEFENSE;

            case CENTER,
                 WING_LEFT,
                 WING_RIGHT,
                 FORWARD -> PlayerPositionCategory.FORWARD;
            case ANY -> null;
        };
    }

}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\NotificationDecision.java
-----
package cz.phsoft.hokej.models.services;

/**
 * DatovĂ˝ objekt reprezentujĂ­cĂ­ vĂ˝sledek vyhodnocenĂ­
 * notifikaÄŤnĂ­ch preferencĂ­ pro konkrĂ©tnĂ­ udĂˇlost.
 *
 * SlouĹľĂ­ jako pĹ™enosovĂ˝ objekt mezi logikou vyhodnocenĂ­
 * notifikacĂ­ a konkrĂ©tnĂ­mi kanĂˇly odesĂ­lĂˇnĂ­ (email, SMS).
 *
 * Objekt jednoznaÄŤnÄ› urÄŤuje:
 * - zda mĂˇ bĂ˝t odeslĂˇn email uĹľivateli (AppUser),
 * - zda mĂˇ bĂ˝t odeslĂˇn email hrĂˇÄŤi na jeho vlastnĂ­ kontakt,
 * - zda mĂˇ bĂ˝t odeslĂˇna SMS hrĂˇÄŤi,
 * - jakĂ© konkrĂ©tnĂ­ kontaktnĂ­ Ăşdaje se majĂ­ pouĹľĂ­t.
 *
 * TĹ™Ă­da neĹ™eĹˇĂ­:
 * - samotnĂ© odesĂ­lĂˇnĂ­ notifikacĂ­,
 * - sestavenĂ­ obsahu zprĂˇv,
 * - validaci kontaktnĂ­ch ĂşdajĹŻ.
 *
 * PouĹľĂ­vĂˇ se typicky v NotificationService
 * jako vĂ˝sledek rozhodovacĂ­ logiky.
 */
public class NotificationDecision {

    // ==================================================
    // EMAIL â€“ UĹ˝IVATEL (AppUser)
    // ==================================================

    /**
     * UrÄŤuje, zda mĂˇ bĂ˝t odeslĂˇn email uĹľivateli (AppUser).
     *
     * Hodnota {@code true} znamenĂˇ, Ĺľe notifikace mĂˇ bĂ˝t
     * odeslĂˇna na email navĂˇzanĂ˝ na uĹľivatelskĂ˝ ĂşÄŤet.
     */
    private boolean sendEmailToUser;

    /**
     * EmailovĂˇ adresa uĹľivatele (AppUser.email),
     * na kterou mĂˇ bĂ˝t pĹ™Ă­padnĂˇ notifikace odeslĂˇna.
     */
    private String userEmail;

    /**
     * CelĂ© jmĂ©no uĹľivatele.
     *
     * PouĹľĂ­vĂˇ se zejmĂ©na pro personalizaci textu
     * emailovĂ© zprĂˇvy.
     */
    private String fullname;

    // ==================================================
    // EMAIL â€“ HRĂÄŚ
    // ==================================================

    /**
     * UrÄŤuje, zda mĂˇ bĂ˝t odeslĂˇn email pĹ™Ă­mo hrĂˇÄŤi.
     *
     * Email se odesĂ­lĂˇ na kontakt definovanĂ˝ v nastavenĂ­ hrĂˇÄŤe,
     * typicky {@code PlayerSettings.contactEmail}.
     */
    private boolean sendEmailToPlayer;

    /**
     * EmailovĂˇ adresa hrĂˇÄŤe.
     *
     * Hodnota obvykle pochĂˇzĂ­ z {@code PlayerSettings.contactEmail},
     * pĹ™Ă­padnÄ› mĹŻĹľe bĂ˝t pouĹľita nĂˇhradnĂ­ (fallback) hodnota
     * podle logiky vyhodnocenĂ­.
     */
    private String playerEmail;

    // ==================================================
    // SMS â€“ HRĂÄŚ
    // ==================================================

    /**
     * UrÄŤuje, zda mĂˇ bĂ˝t odeslĂˇna SMS hrĂˇÄŤi.
     *
     * Hodnota {@code true} znamenĂˇ, Ĺľe hrĂˇÄŤ mĂˇ povolenĂ©
     * SMS notifikace a je k dispozici platnĂ© telefonnĂ­ ÄŤĂ­slo.
     */
    private boolean sendSmsToPlayer;

    /**
     * TelefonnĂ­ ÄŤĂ­slo hrĂˇÄŤe.
     *
     * Hodnota obvykle pochĂˇzĂ­ z {@code PlayerSettings.contactPhone},
     * pĹ™Ă­padnÄ› se pouĹľije fallback hodnota uloĹľenĂˇ pĹ™Ă­mo u hrĂˇÄŤe.
     */
    private String playerPhone;

    // ==================================================
    // GETTERY / SETTERY
    // ==================================================

    public boolean isSendEmailToUser() {
        return sendEmailToUser;
    }

    public void setSendEmailToUser(boolean sendEmailToUser) {
        this.sendEmailToUser = sendEmailToUser;
    }

    public String getUserEmail() {
        return userEmail;
    }

    public void setUserEmail(String userEmail) {
        this.userEmail = userEmail;
    }

    public boolean isSendEmailToPlayer() {
        return sendEmailToPlayer;
    }

    public void setSendEmailToPlayer(boolean sendEmailToPlayer) {
        this.sendEmailToPlayer = sendEmailToPlayer;
    }

    public String getPlayerEmail() {
        return playerEmail;
    }

    public void setPlayerEmail(String playerEmail) {
        this.playerEmail = playerEmail;
    }

    public boolean isSendSmsToPlayer() {
        return sendSmsToPlayer;
    }

    public void setSendSmsToPlayer(boolean sendSmsToPlayer) {
        this.sendSmsToPlayer = sendSmsToPlayer;
    }

    public String getPlayerPhone() {
        return playerPhone;
    }

    public void setPlayerPhone(String playerPhone) {
        this.playerPhone = playerPhone;
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\package-info.java
-----
/**
 * Service vrstva aplikace.
 *
 * Obsahuje aplikaÄŤnĂ­ a business logiku systĂ©mu.
 *
 * ZajiĹˇĹĄuje:
 * - zpracovĂˇnĂ­ poĹľadavkĹŻ z controllerĹŻ,
 * - koordinaci prĂˇce mezi repozitĂˇĹ™i,
 * - rozhodovacĂ­ logiku a validace domĂ©novĂ˝ch pravidel,
 * - vyvolĂˇvĂˇnĂ­ notifikacĂ­ a dalĹˇĂ­ch vedlejĹˇĂ­ch procesĹŻ.
 *
 * Service vrstva:
 * - neĹ™eĹˇĂ­ HTTP ani prezentaci,
 * - pouĹľĂ­vĂˇ repository pro pĹ™Ă­stup k datĹŻm,
 * - pracuje s DTO objekty.
 */
package cz.phsoft.hokej.models.services;

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerHistoryService.java
-----
package cz.phsoft.hokej.models.services;


import cz.phsoft.hokej.player.dto.PlayerHistoryDTO;

import java.util.List;

/**
 * ServisnĂ­ rozhranĂ­ pro prĂˇci s historiĂ­ hrĂˇÄŤĹŻ.
 *
 * SlouĹľĂ­ pouze pro ÄŤtenĂ­ auditnĂ­ch zĂˇznamĹŻ.
 */
public interface PlayerHistoryService {

    /**
     * VrĂˇtĂ­ historii danĂ©ho hrĂˇÄŤe.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return seznam historickĂ˝ch zĂˇznamĹŻ od nejnovÄ›jĹˇĂ­ho po nejstarĹˇĂ­
     */
    List<PlayerHistoryDTO> getHistoryForPlayer(Long playerId);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerHistoryServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.player.repositories.PlayerHistoryRepository;
import cz.phsoft.hokej.player.dto.PlayerHistoryDTO;
import cz.phsoft.hokej.player.mappers.PlayerHistoryMapper;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * Implementace servisnĂ­ vrstvy pro prĂˇci s historiĂ­ hrĂˇÄŤĹŻ.
 *
 * NeprovĂˇdĂ­ ĹľĂˇdnĂ© zĂˇpisy do databĂˇze â€“ historickĂ© zĂˇznamy
 * jsou vytvĂˇĹ™eny databĂˇzovĂ˝mi triggery.
 */
@Service
public class PlayerHistoryServiceImpl
        implements PlayerHistoryService {

    private final PlayerHistoryRepository repository;
    private final PlayerHistoryMapper mapper;

    public PlayerHistoryServiceImpl(
            PlayerHistoryRepository repository,
            PlayerHistoryMapper mapper
    ) {
        this.repository = repository;
        this.mapper = mapper;
    }

    @Override
    public List<PlayerHistoryDTO> getHistoryForPlayer(Long playerId) {
        return mapper.toDTOList(
                repository.findByPlayerIdOrderByChangedAtDesc(playerId)
        );
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.player.entities.PlayerEntity;
import cz.phsoft.hokej.player.dto.PlayerInactivityPeriodDTO;

import java.time.LocalDateTime;
import java.util.List;

/**
 * RozhranĂ­ pro sprĂˇvu obdobĂ­ neaktivity hrĂˇÄŤĹŻ.
 *
 * Tato service definuje kontrakt pro prĂˇci s ÄŤasovĂ˝mi Ăşseky,
 * ve kterĂ˝ch je hrĂˇÄŤ povaĹľovĂˇn za neaktivnĂ­ho
 * (zranÄ›nĂ­, dovolenĂˇ, dlouhodobĂˇ absence a podobnĂ© situace).
 *
 * OdpovÄ›dnosti:
 * - eviduje obdobĂ­, kdy se hrĂˇÄŤ nemĹŻĹľe ĂşÄŤastnit zĂˇpasĹŻ,
 * - poskytuje pĹ™ehledy obdobĂ­ neaktivity pro konkrĂ©tnĂ­ho hrĂˇÄŤe i pro administraci,
 * - umoĹľĹuje ovÄ›Ĺ™enĂ­, zda je hrĂˇÄŤ v danĂ©m okamĹľiku aktivnĂ­.
 *
 * Tato service:
 * - pracuje s DTO {@link PlayerInactivityPeriodDTO}, nikoliv pĹ™Ă­mo s entitami,
 * - oddÄ›luje business logiku neaktivity od persistence vrstvy.
 *
 * Tato service neĹ™eĹˇĂ­:
 * - autorizaci a role uĹľivatelĹŻ,
 * - notifikace,
 * - UI logiku.
 */
public interface PlayerInactivityPeriodService {

    /**
     * VrĂˇtĂ­ seznam vĹˇech obdobĂ­ neaktivity v systĂ©mu.
     *
     * Typicky se pouĹľĂ­vĂˇ v administrĂˇtorskĂ˝ch pĹ™ehledech.
     *
     * @return seznam vĹˇech obdobĂ­ neaktivity ve formÄ› DTO
     */
    List<PlayerInactivityPeriodDTO> getAll();

    /**
     * VrĂˇtĂ­ obdobĂ­ neaktivity podle jeho ID.
     *
     * @param id ID obdobĂ­ neaktivity
     * @return obdobĂ­ neaktivity ve formÄ› DTO
     */
    PlayerInactivityPeriodDTO getById(Long id);

    /**
     * VrĂˇtĂ­ seznam obdobĂ­ neaktivity pro konkrĂ©tnĂ­ho hrĂˇÄŤe.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return seznam obdobĂ­ neaktivity danĂ©ho hrĂˇÄŤe
     */
    List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId);

    /**
     * VytvoĹ™Ă­ novĂ© obdobĂ­ neaktivity hrĂˇÄŤe.
     *
     * Implementace je zodpovÄ›dnĂˇ za:
     * - validaci ÄŤasovĂ©ho rozsahu (zaÄŤĂˇtek pĹ™ed koncem),
     * - kontrolu pĹ™ekryvĹŻ s existujĂ­cĂ­mi obdobĂ­mi neaktivity.
     *
     * @param dto data novĂ©ho obdobĂ­ neaktivity
     * @return vytvoĹ™enĂ© obdobĂ­ neaktivity ve formÄ› DTO
     */
    PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto);

    /**
     * Aktualizuje existujĂ­cĂ­ obdobĂ­ neaktivity.
     *
     * Implementace je zodpovÄ›dnĂˇ za:
     * - validaci ÄŤasovĂ©ho rozsahu,
     * - kontrolu pĹ™ekryvĹŻ s ostatnĂ­mi obdobĂ­mi neaktivity danĂ©ho hrĂˇÄŤe.
     *
     * @param id  ID obdobĂ­ neaktivity, kterĂ© mĂˇ bĂ˝t upraveno
     * @param dto novĂ© hodnoty obdobĂ­ neaktivity
     * @return aktualizovanĂ© obdobĂ­ neaktivity ve formÄ› DTO
     */
    PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto);

    /**
     * OdstranĂ­ obdobĂ­ neaktivity podle ID.
     *
     * @param id ID obdobĂ­ neaktivity, kterĂ© mĂˇ bĂ˝t smazĂˇno
     */
    void delete(Long id);

    /**
     * OvÄ›Ĺ™Ă­, zda je hrĂˇÄŤ v danĂ©m okamĹľiku aktivnĂ­.
     *
     * Metoda vracĂ­ informaci, zda se zadanĂ˝ ÄŤas
     * nenachĂˇzĂ­ v ĹľĂˇdnĂ©m z evidovanĂ˝ch obdobĂ­ neaktivity hrĂˇÄŤe.
     *
     * TypickĂ© pouĹľitĂ­:
     * - pĹ™i registraci hrĂˇÄŤe na zĂˇpas,
     * - pĹ™i validaci ĂşÄŤasti hrĂˇÄŤe v konkrĂ©tnĂ­m ÄŤase,
     * - pĹ™i filtrovĂˇnĂ­ dostupnĂ˝ch zĂˇpasĹŻ pro hrĂˇÄŤe.
     *
     * @param player   hrĂˇÄŤ, jehoĹľ aktivita se ovÄ›Ĺ™uje
     * @param dateTime ÄŤasovĂ˝ okamĹľik, pro kterĂ˝ se aktivita kontroluje
     * @return true, pokud je hrĂˇÄŤ v danĂ©m ÄŤase aktivnĂ­, jinak false
     */
    boolean isActive(PlayerEntity player, LocalDateTime dateTime);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.player.entities.PlayerEntity;
import cz.phsoft.hokej.player.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.player.repositories.PlayerInactivityPeriodRepository;
import cz.phsoft.hokej.player.repositories.PlayerRepository;
import cz.phsoft.hokej.player.exceptions.InactivityPeriodNotFoundException;
import cz.phsoft.hokej.player.exceptions.InactivityPeriodOverlapException;
import cz.phsoft.hokej.player.exceptions.InvalidInactivityPeriodDateException;
import cz.phsoft.hokej.player.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.player.dto.PlayerInactivityPeriodDTO;
import cz.phsoft.hokej.player.mappers.PlayerInactivityPeriodMapper;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

/**
 * Service implementace pro sprĂˇvu obdobĂ­ neaktivity hrĂˇÄŤĹŻ.
 *
 * ObchodnĂ­ vĂ˝znam:
 * - urÄŤuje, zda je hrĂˇÄŤ v danĂ©m ÄŤase aktivnĂ­ nebo neaktivnĂ­,
 * - poskytuje podklady pro rozhodovĂˇnĂ­, zda mĹŻĹľe bĂ˝t hrĂˇÄŤ
 *   zaĹ™azen do zĂˇpasu nebo mĂ­t pĹ™Ă­stup k urÄŤitĂ˝m funkcĂ­m.
 *
 * TypickĂ© pouĹľitĂ­:
 * - pĹ™i filtrovĂˇnĂ­ zĂˇpasĹŻ dostupnĂ˝ch pro hrĂˇÄŤe,
 * - v pĹ™Ă­stupovĂ© logice k detailu zĂˇpasu,
 * - pĹ™i registraci hrĂˇÄŤe na zĂˇpas.
 *
 * KlĂ­ÄŤovĂ© pravidlo:
 * - hrĂˇÄŤ nesmĂ­ mĂ­t pĹ™ekrĂ˝vajĂ­cĂ­ se obdobĂ­ neaktivity
 *   (pĹ™ekryv je povaĹľovĂˇn za chybu dat).
 *
 * Tato service:
 * - Ĺ™eĹˇĂ­ pouze domĂ©novĂˇ pravidla pro neaktivitu,
 * - neĹ™eĹˇĂ­ bezpeÄŤnost, role ani notifikace,
 * - vyuĹľĂ­vĂˇ mapper {@link PlayerInactivityPeriodMapper}
 *   pro pĹ™evod mezi entitami a DTO.
 */
@Service
public class PlayerInactivityPeriodServiceImpl implements PlayerInactivityPeriodService {

    private final PlayerInactivityPeriodRepository inactivityRepository;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodMapper mapper;

    public PlayerInactivityPeriodServiceImpl(
            PlayerInactivityPeriodRepository inactivityRepository,
            PlayerRepository playerRepository,
            PlayerInactivityPeriodMapper mapper
    ) {
        this.inactivityRepository = inactivityRepository;
        this.playerRepository = playerRepository;
        this.mapper = mapper;
    }

    // ======================
    // READ OPERACE
    // ======================

    /**
     * VrĂˇtĂ­ vĹˇechna obdobĂ­ neaktivity vĹˇech hrĂˇÄŤĹŻ.
     *
     * PouĹľĂ­vĂˇ se zejmĂ©na v administrĂˇtorskĂ˝ch pĹ™ehledech
     * nebo internĂ­ch reportech.
     *
     * @return seznam vĹˇech obdobĂ­ neaktivity ve formÄ› DTO
     */
    @Override
    public List<PlayerInactivityPeriodDTO> getAll() {
        return inactivityRepository.findAll().stream()
                .map(mapper::toDTO)
                .toList();
    }

    /**
     * VrĂˇtĂ­ konkrĂ©tnĂ­ obdobĂ­ neaktivity podle ID.
     *
     * @param id ID obdobĂ­ neaktivity
     * @return DTO reprezentace obdobĂ­ neaktivity
     * @throws InactivityPeriodNotFoundException pokud zĂˇznam neexistuje
     */
    @Override
    public PlayerInactivityPeriodDTO getById(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new InactivityPeriodNotFoundException(id));

        return mapper.toDTO(entity);
    }

    /**
     * VrĂˇtĂ­ vĹˇechna obdobĂ­ neaktivity konkrĂ©tnĂ­ho hrĂˇÄŤe,
     * seĹ™azenĂˇ podle zaÄŤĂˇtku neaktivity od nejstarĹˇĂ­ho.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return seznam obdobĂ­ neaktivity ve formÄ› DTO
     * @throws PlayerNotFoundException pokud hrĂˇÄŤ neexistuje
     */
    @Override
    public List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId) {
        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));

        return inactivityRepository.findByPlayerOrderByInactiveFromAsc(player).stream()
                .map(mapper::toDTO)
                .toList();
    }

    // ======================
    // CREATE
    // ======================

    /**
     * VytvoĹ™Ă­ novĂ© obdobĂ­ neaktivity hrĂˇÄŤe.
     *
     * PĹ™ed uloĹľenĂ­m se ovÄ›Ĺ™uje:
     * - existence hrĂˇÄŤe,
     * - platnost dat (od/do),
     * - nepĹ™ekrĂ˝vĂˇnĂ­ s jinĂ˝mi obdobĂ­mi neaktivity danĂ©ho hrĂˇÄŤe.
     *
     * @param dto data novĂ©ho obdobĂ­ neaktivity
     * @return novÄ› vytvoĹ™enĂ© obdobĂ­ neaktivity ve formÄ› DTO
     * @throws PlayerNotFoundException              pokud hrĂˇÄŤ neexistuje
     * @throws InvalidInactivityPeriodDateException pokud je rozsah dat neplatnĂ˝
     * @throws InactivityPeriodOverlapException     pokud se novĂ© obdobĂ­ pĹ™ekrĂ˝vĂˇ s existujĂ­cĂ­m
     */
    @Override
    @Transactional
    public PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto) {

        PlayerEntity player = playerRepository.findById(dto.getPlayerId())
                .orElseThrow(() -> new PlayerNotFoundException(dto.getPlayerId()));

        validateDates(dto);

        // kontrola pĹ™ekryvu existujĂ­cĂ­ch obdobĂ­ pro danĂ©ho hrĂˇÄŤe
        boolean overlaps = !inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        player,
                        dto.getInactiveFrom(),
                        dto.getInactiveTo()
                ).isEmpty();

        if (overlaps) {
            throw new InactivityPeriodOverlapException();
        }

        PlayerInactivityPeriodEntity entity = mapper.toEntity(dto, player);
        PlayerInactivityPeriodEntity saved = inactivityRepository.save(entity);

        return mapper.toDTO(saved);
    }

    // ======================
    // UPDATE
    // ======================

    /**
     * Aktualizuje existujĂ­cĂ­ obdobĂ­ neaktivity.
     *
     * Oproti vytvoĹ™enĂ­ novĂ©ho obdobĂ­ se pĹ™i kontrole pĹ™ekryvu
     * ignoruje aktuĂˇlnĂ­ zĂˇznam (aby nebyl povaĹľovĂˇn za kolizi sĂˇm se sebou).
     *
     * @param id  ID upravovanĂ©ho obdobĂ­
     * @param dto novĂ© hodnoty obdobĂ­ neaktivity
     * @return aktualizovanĂ© obdobĂ­ neaktivity ve formÄ› DTO
     * @throws InactivityPeriodNotFoundException     pokud zĂˇznam neexistuje
     * @throws InvalidInactivityPeriodDateException  pokud je rozsah dat neplatnĂ˝
     * @throws InactivityPeriodOverlapException      pokud se upravenĂ© obdobĂ­ pĹ™ekrĂ˝vĂˇ s jinĂ˝m
     */
    @Override
    @Transactional
    public PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto) {

        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new InactivityPeriodNotFoundException(id));

        validateDates(dto);

        // kontrola pĹ™ekryvu â€“ existujĂ­cĂ­ zĂˇznamy kromÄ› aktuĂˇlnĂ­ho ID
        boolean overlaps = inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        entity.getPlayer(),
                        dto.getInactiveFrom(),
                        dto.getInactiveTo()
                ).stream()
                .anyMatch(p -> !p.getId().equals(id));

        if (overlaps) {
            throw new InactivityPeriodOverlapException(
                    "BE - UpravenĂ© obdobĂ­ se pĹ™ekrĂ˝vĂˇ s jinĂ˝m obdobĂ­m neaktivity hrĂˇÄŤe."
            );
        }

        entity.setInactiveFrom(dto.getInactiveFrom());
        entity.setInactiveTo(dto.getInactiveTo());

        PlayerInactivityPeriodEntity saved = inactivityRepository.save(entity);

        return mapper.toDTO(saved);
    }

    // ======================
    // DELETE
    // ======================

    /**
     * SmaĹľe obdobĂ­ neaktivity podle ID.
     *
     * @param id ID obdobĂ­ neaktivity
     * @throws InactivityPeriodNotFoundException pokud zĂˇznam neexistuje
     */
    @Override
    @Transactional
    public void delete(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new InactivityPeriodNotFoundException(id));

        inactivityRepository.delete(entity);
    }

    // ======================
    // AKTIVITA HRĂÄŚE
    // ======================

    /**
     * OvÄ›Ĺ™Ă­, zda je hrĂˇÄŤ v danĂ©m ÄŤase aktivnĂ­.
     *
     * HrĂˇÄŤ je povaĹľovĂˇn za neaktivnĂ­ho, pokud existuje obdobĂ­ neaktivity,
     * kterĂ© danĂ˝ ÄŤasovĂ˝ okamĹľik zahrnuje. Metoda vracĂ­ negaci tĂ©to podmĂ­nky.
     *
     * TypickĂ© pouĹľitĂ­:
     * - v {@link MatchServiceImpl} pĹ™i filtrovĂˇnĂ­ dostupnĂ˝ch zĂˇpasĹŻ,
     * - v pĹ™Ă­stupovĂ© logice k detailu zĂˇpasu,
     * - pĹ™i posuzovĂˇnĂ­, zda mĂˇ hrĂˇÄŤ â€žnĂˇrokâ€ś na ĂşÄŤast v zĂˇpase.
     *
     * @param player   hrĂˇÄŤ, jehoĹľ aktivita se ovÄ›Ĺ™uje
     * @param dateTime ÄŤasovĂ˝ okamĹľik, pro kterĂ˝ se aktivita kontroluje
     * @return true, pokud hrĂˇÄŤ nenĂ­ v danĂ©m ÄŤase v ĹľĂˇdnĂ©m obdobĂ­ neaktivity, jinak false
     */
    @Override
    public boolean isActive(PlayerEntity player, LocalDateTime dateTime) {
        // pokud existuje zĂˇznam pokrĂ˝vajĂ­cĂ­ danĂ˝ ÄŤas â†’ hrĂˇÄŤ je neaktivnĂ­
        return !inactivityRepository
                .existsByPlayerAndInactiveFromLessThanEqualAndInactiveToGreaterThanEqual(
                        player,
                        dateTime,
                        dateTime
                );
    }

    // ======================
    // PRIVĂTNĂŤ VALIDACE
    // ======================

    /**
     * Validuje ÄŤasovĂ˝ rozsah obdobĂ­ neaktivity.
     *
     * Kontroluje se:
     * - Ĺľe datum od i do nenĂ­ null,
     * - Ĺľe datum od je pĹ™ed datem do.
     *
     * @param dto DTO s daty obdobĂ­ neaktivity
     * @throws InvalidInactivityPeriodDateException pĹ™i neplatnĂ©m rozsahu dat
     */
    private void validateDates(PlayerInactivityPeriodDTO dto) {
        if (dto.getInactiveFrom() == null || dto.getInactiveTo() == null) {
            throw new InvalidInactivityPeriodDateException(
                    "BE - Datum od a do nesmĂ­ bĂ˝t null."
            );
        }

        if (!dto.getInactiveFrom().isBefore(dto.getInactiveTo())) {
            throw new InvalidInactivityPeriodDateException(
                    "BE - Datum 'od' musĂ­ bĂ˝t pĹ™ed 'do'."
            );
        }
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.player.dto.PlayerDTO;
import cz.phsoft.hokej.shared.dto.SuccessResponseDTO;

import java.util.List;

/**
 * RozhranĂ­ pro sprĂˇvu hrĂˇÄŤĹŻ v aplikaci.
 *
 * RozhranĂ­ definuje kontrakt pro prĂˇci s hrĂˇÄŤi z pohledu business logiky,
 * vÄŤetnÄ› jejich vytvĂˇĹ™enĂ­, Ăşprav, schvalovĂˇnĂ­ a vazby na uĹľivatele.
 *
 * OdpovÄ›dnosti:
 * - sprĂˇva ĹľivotnĂ­ho cyklu hrĂˇÄŤĹŻ (vytvoĹ™enĂ­, Ăşprava, smazĂˇnĂ­),
 * - sprĂˇva vazby hrĂˇÄŤĹŻ na uĹľivatelskĂ© ĂşÄŤty,
 * - Ĺ™Ă­zenĂ­ stavu hrĂˇÄŤe (ÄŤekajĂ­cĂ­, schvĂˇlenĂ˝, zamĂ­tnutĂ˝),
 * - sprĂˇva â€žaktuĂˇlnĂ­ho hrĂˇÄŤeâ€ś v kontextu uĹľivatele.
 *
 * RozhranĂ­ se pouĹľĂ­vĂˇ:
 * - v controllerech pro hrĂˇÄŤe a administraci,
 * - v dalĹˇĂ­ch service tĹ™Ă­dĂˇch, kterĂ© potĹ™ebujĂ­ pracovat s hrĂˇÄŤi na DTO Ăşrovni.
 */
public interface PlayerService {

    /**
     * VrĂˇtĂ­ seznam vĹˇech hrĂˇÄŤĹŻ v systĂ©mu.
     *
     * Metoda se pouĹľĂ­vĂˇ typicky v administrĂˇtorskĂ˝ch pĹ™ehledech.
     *
     * @return seznam vĹˇech hrĂˇÄŤĹŻ ve formÄ› {@link PlayerDTO}
     */
    List<PlayerDTO> getAllPlayers();

    /**
     * VrĂˇtĂ­ hrĂˇÄŤe podle jeho ID.
     *
     * @param id ID hrĂˇÄŤe
     * @return hrĂˇÄŤ ve formÄ› {@link PlayerDTO}
     */
    PlayerDTO getPlayerById(Long id);

    /**
     * VytvoĹ™Ă­ novĂ©ho hrĂˇÄŤe bez explicitnĂ­ vazby na uĹľivatele.
     *
     * Typicky se pouĹľĂ­vĂˇ v administraci pro ruÄŤnĂ­ zaloĹľenĂ­ hrĂˇÄŤe.
     *
     * @param player data novĂ©ho hrĂˇÄŤe
     * @return vytvoĹ™enĂ˝ hrĂˇÄŤ ve formÄ› {@link PlayerDTO}
     */
    PlayerDTO createPlayer(PlayerDTO player);

    /**
     * VytvoĹ™Ă­ novĂ©ho hrĂˇÄŤe a pĹ™iĹ™adĂ­ jej ke konkrĂ©tnĂ­mu uĹľivateli.
     *
     * Metoda se pouĹľĂ­vĂˇ v pĹ™Ă­padech, kdy je hrĂˇÄŤ vytvĂˇĹ™en
     * v kontextu jiĹľ existujĂ­cĂ­ho uĹľivatelskĂ©ho ĂşÄŤtu.
     *
     * @param dto       data novĂ©ho hrĂˇÄŤe
     * @param userEmail email uĹľivatele, ke kterĂ©mu mĂˇ bĂ˝t hrĂˇÄŤ pĹ™iĹ™azen
     * @return vytvoĹ™enĂ˝ hrĂˇÄŤ ve formÄ› {@link PlayerDTO}
     */
    PlayerDTO createPlayerForUser(PlayerDTO dto, String userEmail);

    /**
     * Aktualizuje Ăşdaje existujĂ­cĂ­ho hrĂˇÄŤe.
     *
     * Metoda aktualizuje zĂˇkladnĂ­ identifikaÄŤnĂ­ a kontaktnĂ­ Ăşdaje
     * i parametry hrĂˇÄŤe (typ, tĂ˝m, status).
     *
     * @param id     ID hrĂˇÄŤe, kterĂ˝ mĂˇ bĂ˝t aktualizovĂˇn
     * @param player novĂ© hodnoty hrĂˇÄŤe
     * @return aktualizovanĂ˝ hrĂˇÄŤ ve formÄ› {@link PlayerDTO}
     */
    PlayerDTO updatePlayer(Long id, PlayerDTO player);

    /**
     * OdstranĂ­ hrĂˇÄŤe ze systĂ©mu.
     *
     * Typicky se pouĹľĂ­vĂˇ v administraci. NĂˇvratovĂˇ hodnota informuje
     * o ĂşspÄ›chu operace ve formÄ› {@link SuccessResponseDTO}.
     *
     * @param id ID hrĂˇÄŤe, kterĂ˝ mĂˇ bĂ˝t odstranÄ›n
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     */
    SuccessResponseDTO deletePlayer(Long id);

    /**
     * VrĂˇtĂ­ seznam hrĂˇÄŤĹŻ pĹ™iĹ™azenĂ˝ch ke konkrĂ©tnĂ­mu uĹľivateli.
     *
     * Metoda se pouĹľĂ­vĂˇ napĹ™Ă­klad pĹ™i zobrazenĂ­ hrĂˇÄŤĹŻ pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * @param email email uĹľivatele
     * @return seznam hrĂˇÄŤĹŻ danĂ©ho uĹľivatele ve formÄ› {@link PlayerDTO}
     */
    List<PlayerDTO> getPlayersByUser(String email);

    /**
     * SchvĂˇlĂ­ hrĂˇÄŤe.
     *
     * Po schvĂˇlenĂ­ je hrĂˇÄŤ povaĹľovĂˇn za aktivnĂ­ho
     * a mĹŻĹľe se ĂşÄŤastnit zĂˇpasĹŻ podle dalĹˇĂ­ch pravidel aplikace.
     *
     * @param id ID hrĂˇÄŤe
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     */
    SuccessResponseDTO approvePlayer(Long id);

    /**
     * ZamĂ­tne hrĂˇÄŤe.
     *
     * ZamĂ­tnutĂ˝ hrĂˇÄŤ se nepovaĹľuje za aktivnĂ­ho
     * a nemĹŻĹľe se ĂşÄŤastnit zĂˇpasĹŻ.
     *
     * @param id ID hrĂˇÄŤe
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     */
    SuccessResponseDTO rejectPlayer(Long id);

    /**
     * NastavĂ­ aktuĂˇlnĂ­ho hrĂˇÄŤe pro konkrĂ©tnĂ­ho uĹľivatele.
     *
     * Metoda slouĹľĂ­ k explicitnĂ­mu vĂ˝bÄ›ru hrĂˇÄŤe v pĹ™Ă­padÄ›,
     * Ĺľe mĂˇ uĹľivatel pĹ™iĹ™azeno vĂ­ce hrĂˇÄŤĹŻ.
     *
     * @param userEmail email uĹľivatele
     * @param playerId  ID hrĂˇÄŤe, kterĂ˝ mĂˇ bĂ˝t nastaven jako aktuĂˇlnĂ­
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     */
    SuccessResponseDTO setCurrentPlayerForUser(String userEmail, Long playerId);

    /**
     * Automaticky zvolĂ­ aktuĂˇlnĂ­ho hrĂˇÄŤe pro danĂ©ho uĹľivatele
     * podle jeho nastavenĂ­ (AppUserSettings.playerSelectionMode).
     *
     * TypickĂ© pouĹľitĂ­:
     * - po pĹ™ihlĂˇĹˇenĂ­ uĹľivatele,
     * - pĹ™i explicitnĂ­m volĂˇnĂ­ z frontendu (napĹ™Ă­klad tlaÄŤĂ­tko â€žVybrat vĂ˝chozĂ­ho hrĂˇÄŤeâ€ś).
     *
     * @param userEmail email pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @return odpovÄ›ÄŹ s vĂ˝sledkem operace
     */
    SuccessResponseDTO autoSelectCurrentPlayerForUser(String userEmail);

    /**
     * ZmÄ›nĂ­ pĹ™iĹ™azenĂ©ho uĹľivatele k existujĂ­cĂ­mu hrĂˇÄŤi.
     *
     * Metoda slouĹľĂ­ k administrĂˇtorskĂ© ĂşpravÄ› vazby mezi hrĂˇÄŤem a
     * uĹľivatelskĂ˝m ĂşÄŤtem, napĹ™Ă­klad pĹ™i opravÄ› chybnĂ©ho pĹ™iĹ™azenĂ­
     * nebo pĹ™evodu hrĂˇÄŤe pod jinĂ˝ uĹľivatelskĂ˝ ĂşÄŤet.
     *
     * Implementace mÄ›nĂ­ pouze vazbu hrĂˇÄŤ â†’ uĹľivatel,
     * ostatnĂ­ business logika (napĹ™Ă­klad zmÄ›na current player)
     * je ponechĂˇna volajĂ­cĂ­mu.
     *
     * @param id        ID hrĂˇÄŤe, kterĂ©mu se mĂˇ zmÄ›nit pĹ™iĹ™azenĂ˝ uĹľivatel
     * @param newUserId ID novĂ©ho uĹľivatele, ke kterĂ©mu mĂˇ bĂ˝t hrĂˇÄŤ pĹ™iĹ™azen
     */
    void changePlayerUser(Long id, Long newUserId);

}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.user.entities.AppUserEntity;
import cz.phsoft.hokej.player.entities.PlayerEntity;
import cz.phsoft.hokej.player.entities.PlayerSettingsEntity;
import cz.phsoft.hokej.user.enums.PlayerSelectionMode;
import cz.phsoft.hokej.player.enums.PlayerStatus;
import cz.phsoft.hokej.notifications.enums.NotificationType;
import cz.phsoft.hokej.user.repositories.AppUserRepository;
import cz.phsoft.hokej.player.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.shared.dto.SuccessResponseDTO;
import cz.phsoft.hokej.player.mappers.PlayerMapper;
import cz.phsoft.hokej.notifications.services.NotificationService;
import jakarta.transaction.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import cz.phsoft.hokej.player.dto.PlayerDTO;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

import static cz.phsoft.hokej.player.enums.PlayerStatus.APPROVED;
import static cz.phsoft.hokej.player.enums.PlayerStatus.REJECTED;

/**
 * Service vrstva pro prĂˇci s hrĂˇÄŤi ({@link PlayerEntity}).
 *
 * OdpovÄ›dnosti:
 * - provĂˇdÄ›nĂ­ CRUD operacĂ­ nad hrĂˇÄŤi,
 * - kontrola duplicity jmĂ©na a pĹ™Ă­jmenĂ­,
 * - sprĂˇva vazby hrĂˇÄŤe na uĹľivatele ({@link AppUserEntity}),
 * - zmÄ›na statusu hrĂˇÄŤe (APPROVED, REJECTED) vÄŤetnÄ› spuĹˇtÄ›nĂ­ notifikacĂ­,
 * - nastavenĂ­ aktuĂˇlnĂ­ho hrĂˇÄŤe v {@link CurrentPlayerService} pro pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
 *
 * Tato tĹ™Ă­da neĹ™eĹˇĂ­:
 * - HTTP vrstvu, session a mapovĂˇnĂ­ requestĹŻ a response (Ĺ™eĹˇĂ­ controllery),
 * - autentizaci a autorizaci (Ĺ™eĹˇĂ­ Spring Security a controller vrstva),
 * - detailnĂ­ logiku zĂˇpasĹŻ (Ĺ™eĹˇĂ­ {@link MatchServiceImpl} a navazujĂ­cĂ­ sluĹľby).
 *
 * Notifikace se delegujĂ­ do {@link NotificationService}.
 */
@Service
public class PlayerServiceImpl implements PlayerService {

    @Value("${app.demo-mode:false}")
    private boolean isDemoMode;

    private static final Logger logger = LoggerFactory.getLogger(PlayerServiceImpl.class);

    private final PlayerRepository playerRepository;
    private final PlayerMapper playerMapper;
    private final AppUserRepository appUserRepository;
    private final NotificationService notificationService;
    private final CurrentPlayerService currentPlayerService;
    private final AppUserSettingsService appUserSettingsService;
    private final PlayerSettingsService playerSettingsService;

    public PlayerServiceImpl(
            PlayerRepository playerRepository,
            PlayerMapper playerMapper,
            AppUserRepository appUserRepository,
            NotificationService notificationService,
            CurrentPlayerService currentPlayerService,
            AppUserSettingsService appUserSettingsService,
            PlayerSettingsService playerSettingsService
    ) {
        this.playerRepository = playerRepository;
        this.playerMapper = playerMapper;
        this.appUserRepository = appUserRepository;
        this.notificationService = notificationService;
        this.currentPlayerService = currentPlayerService;
        this.appUserSettingsService = appUserSettingsService;
        this.playerSettingsService = playerSettingsService;
    }

    // ======================
    // CREATE / UPDATE / DELETE
    // ======================

    /**
     * VytvĂˇĹ™Ă­ novĂ©ho hrĂˇÄŤe bez vazby na uĹľivatele.
     *
     * Postup:
     * - ovÄ›Ĺ™Ă­ se unikĂˇtnost kombinace jmĂ©no + pĹ™Ă­jmenĂ­,
     * - pĹ™evede se {@link PlayerDTO} na {@link PlayerEntity} pomocĂ­ {@link PlayerMapper},
     * - entita se uloĹľĂ­ do databĂˇze pĹ™es {@link PlayerRepository},
     * - vĂ˝sledek se namapuje zpÄ›t do {@link PlayerDTO}.
     *
     * Notifikace se po vytvoĹ™enĂ­ neodesĂ­lajĂ­, aby bylo zachovĂˇno pĹŻvodnĂ­ chovĂˇnĂ­.
     *
     * @param dto Data novĂ©ho hrĂˇÄŤe.
     * @return VytvoĹ™enĂ˝ hrĂˇÄŤ ve formÄ› {@link PlayerDTO}.
     * @throws DuplicateNameSurnameException Pokud jiĹľ existuje hrĂˇÄŤ se stejnĂ˝m jmĂ©nem a pĹ™Ă­jmenĂ­m.
     */
    @Override
    @Transactional
    public PlayerDTO createPlayer(PlayerDTO dto) {
        ensureUniqueNameSurname(dto.getName(), dto.getSurname(), null);

        PlayerEntity entity = playerMapper.toEntity(dto);
        PlayerEntity saved = playerRepository.save(entity);

        return playerMapper.toDTO(saved);
    }

    /**
     * VytvĂˇĹ™Ă­ novĂ©ho hrĂˇÄŤe a pĹ™iĹ™azuje jej k uĹľivateli podle e-mailu.
     *
     * Postup:
     * - vyhledĂˇ se uĹľivatel podle e-mailu,
     * - ovÄ›Ĺ™Ă­ se unikĂˇtnost kombinace jmĂ©no + pĹ™Ă­jmenĂ­,
     * - namapuje se {@link PlayerDTO} na {@link PlayerEntity},
     * - nastavĂ­ se vazba na uĹľivatele,
     * - entita se uloĹľĂ­ do databĂˇze,
     * - odeĹˇle se notifikace {@link NotificationType#PLAYER_CREATED}.
     *
     * @param dto       Data novĂ©ho hrĂˇÄŤe.
     * @param userEmail E-mail uĹľivatele, ke kterĂ©mu mĂˇ bĂ˝t hrĂˇÄŤ pĹ™iĹ™azen.
     * @return VytvoĹ™enĂ˝ hrĂˇÄŤ ve formÄ› {@link PlayerDTO}.
     * @throws UserNotFoundException         Pokud uĹľivatel s danĂ˝m e-mailem neexistuje.
     * @throws DuplicateNameSurnameException Pokud jiĹľ existuje jinĂ˝ hrĂˇÄŤ se stejnĂ˝m jmĂ©nem a pĹ™Ă­jmenĂ­m.
     */
    @Override
    @Transactional
    public PlayerDTO createPlayerForUser(PlayerDTO dto, String userEmail) {
        AppUserEntity user = appUserRepository.findByEmail(userEmail)
                .orElseThrow(() -> new UserNotFoundException(userEmail));

        ensureUniqueNameSurname(dto.getName(), dto.getSurname(), null);

        PlayerEntity player = playerMapper.toEntity(dto);
        player.setUser(user);
        PlayerEntity saved = playerRepository.save(player);

        notifyPlayer(saved, NotificationType.PLAYER_CREATED, saved);

        return playerMapper.toDTO(saved);
    }

    /**
     * Aktualizuje existujĂ­cĂ­ho hrĂˇÄŤe.
     *
     * Postup:
     * - naÄŤte se hrĂˇÄŤ podle ID,
     * - pokud se mÄ›nĂ­ jmĂ©no nebo pĹ™Ă­jmenĂ­, ovÄ›Ĺ™Ă­ se unikĂˇtnost kombinace jmĂ©no + pĹ™Ă­jmenĂ­,
     * - pĹ™epĂ­Ĺˇou se zĂˇkladnĂ­ Ăşdaje (jmĂ©no, pĹ™Ă­jmenĂ­, pĹ™ezdĂ­vka, telefon, typ, tĂ˝m, pozice),
     * - status hrĂˇÄŤe se zmÄ›nĂ­ pouze v pĹ™Ă­padÄ›, Ĺľe je v DTO explicitnÄ› uveden,
     * - entita se uloĹľĂ­ do databĂˇze,
     * - odeĹˇle se notifikace {@link NotificationType#PLAYER_UPDATED}.
     *
     * @param id  ID hrĂˇÄŤe.
     * @param dto NovĂ© hodnoty hrĂˇÄŤe.
     * @return AktualizovanĂ˝ hrĂˇÄŤ ve formÄ› {@link PlayerDTO}.
     * @throws PlayerNotFoundException       Pokud hrĂˇÄŤ neexistuje.
     * @throws DuplicateNameSurnameException Pokud novĂˇ kombinace jmĂ©no + pĹ™Ă­jmenĂ­ koliduje s jinĂ˝m hrĂˇÄŤem.
     */
    @Override
    @Transactional
    public PlayerDTO updatePlayer(Long id, PlayerDTO dto) {
        PlayerEntity existing = findPlayerOrThrow(id);

        boolean nameChanged =
                !existing.getName().equals(dto.getName()) ||
                        !existing.getSurname().equals(dto.getSurname());

        if (nameChanged) {
            ensureUniqueNameSurname(dto.getName(), dto.getSurname(), id);
        }

        existing.setName(dto.getName());
        existing.setSurname(dto.getSurname());
        existing.setNickname(dto.getNickname());
        existing.setPhoneNumber(dto.getPhoneNumber());
        existing.setType(dto.getType());
        existing.setTeam(dto.getTeam());
        existing.setPrimaryPosition(dto.getPrimaryPosition());
        existing.setSecondaryPosition(dto.getSecondaryPosition());

        if (dto.getPlayerStatus() != null) {
            existing.setPlayerStatus(dto.getPlayerStatus());
        }

        PlayerEntity saved = playerRepository.save(existing);
        notifyPlayer(saved, NotificationType.PLAYER_UPDATED, saved);

        return playerMapper.toDTO(saved);
    }

    // TODO - Nebude probĂ­hat mazĂˇnĂ­ hrĂˇÄŤe - bude nastaven statut ARCHIVED
    /**
     * MaĹľe hrĂˇÄŤe podle ID.
     *
     * PĹ™ed smazĂˇnĂ­m se ovÄ›Ĺ™uje demo reĹľim. V demo reĹľimu se operace zablokuje
     * vyhozenĂ­m {@link DemoModeOperationNotAllowedException}. PĹ™i ĂşspÄ›ĹˇnĂ©m smazĂˇnĂ­
     * se odeĹˇle notifikace {@link NotificationType#PLAYER_DELETED} a vracĂ­ se
     * standardizovanĂˇ odpovÄ›ÄŹ {@link SuccessResponseDTO}.
     *
     * @param id ID hrĂˇÄŤe.
     * @return OdpovÄ›ÄŹ s potvrzujĂ­cĂ­ zprĂˇvou.
     * @throws PlayerNotFoundException             Pokud hrĂˇÄŤ neexistuje.
     * @throws DemoModeOperationNotAllowedException Pokud aplikace bÄ›ĹľĂ­ v demo reĹľimu.
     */
    @Override
    @Transactional
    public SuccessResponseDTO deletePlayer(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);

        if (isDemoMode) {
            throw new DemoModeOperationNotAllowedException(
                    "HrĂˇÄŤ nebude smazĂˇn. Aplikace bÄ›ĹľĂ­ v DEMO reĹľimu."
            );
        }

        playerRepository.delete(player);

        String message = "HrĂˇÄŤ " + player.getFullName() + " byl ĂşspÄ›ĹˇnÄ› smazĂˇn";
        notifyPlayer(player, NotificationType.PLAYER_DELETED, player);

        return buildSuccessResponse(message, id);
    }

    // ======================
    // STATUS â€“ APPROVE / REJECT
    // ======================

    /**
     * Schvaluje hrĂˇÄŤe a nastavuje mu status {@link PlayerStatus#APPROVED}.
     *
     * ProvedenĂ­:
     * - ovÄ›Ĺ™Ă­ se, Ĺľe hrĂˇÄŤ jiĹľ nenĂ­ ve stavu APPROVED,
     * - nastavĂ­ se status APPROVED,
     * - pokud hrĂˇÄŤ jeĹˇtÄ› nemĂˇ nastavenĂ­, vytvoĹ™Ă­ se vĂ˝chozĂ­ nastavenĂ­ pĹ™es
     *   {@link PlayerSettingsService#createDefaultSettingsForPlayer(PlayerEntity)},
     * - hrĂˇÄŤ se uloĹľĂ­ a odeĹˇle se notifikace {@link NotificationType#PLAYER_APPROVED}.
     *
     * @param id ID hrĂˇÄŤe.
     * @return OdpovÄ›ÄŹ s vĂ˝sledkem operace.
     * @throws InvalidPlayerStatusException Pokud je hrĂˇÄŤ jiĹľ ve stavu APPROVED.
     */
    @Override
    @Transactional
    public SuccessResponseDTO approvePlayer(Long id) {
        return changePlayerStatus(
                id,
                PlayerStatus.APPROVED,
                PlayerStatus.APPROVED,
                NotificationType.PLAYER_APPROVED,
                "BE - HrĂˇÄŤ uĹľ je schvĂˇlen.",
                "HrĂˇÄŤ %s byl ĂşspÄ›ĹˇnÄ› aktivovĂˇn"
        );
    }

    /**
     * ZamĂ­tĂˇ hrĂˇÄŤe a nastavuje mu status {@link PlayerStatus#REJECTED}.
     *
     * Po ĂşspÄ›ĹˇnĂ© zmÄ›nÄ› stavu se odeĹˇle notifikace
     * {@link NotificationType#PLAYER_REJECTED}.
     *
     * @param id ID hrĂˇÄŤe.
     * @return OdpovÄ›ÄŹ s vĂ˝sledkem operace.
     * @throws InvalidPlayerStatusException Pokud je hrĂˇÄŤ jiĹľ ve stavu REJECTED.
     */
    @Override
    @Transactional
    public SuccessResponseDTO rejectPlayer(Long id) {
        return changePlayerStatus(
                id,
                REJECTED,
                REJECTED,
                NotificationType.PLAYER_REJECTED,
                "BE - HrĂˇÄŤ uĹľ je zamĂ­tnut.",
                "HrĂˇÄŤ %s byl ĂşspÄ›ĹˇnÄ› zamĂ­tnut"
        );
    }

    /**
     * MÄ›nĂ­ pĹ™iĹ™azenĂ©ho uĹľivatele k hrĂˇÄŤi a odesĂ­lĂˇ notifikace
     * o zmÄ›nÄ› vazby hrĂˇÄŤe a uĹľivatele.
     *
     * Postup:
     * - naÄŤte se hrĂˇÄŤ a novĂ˝ uĹľivatel,
     * - ovÄ›Ĺ™Ă­ se, Ĺľe se nepokouĹˇĂ­ pĹ™evĂ©st hrĂˇÄŤe na stejnĂ©ho uĹľivatele,
     * - nastavĂ­ se novĂ˝ uĹľivatel do entitiy hrĂˇÄŤe a entita se uloĹľĂ­,
     * - odeĹˇle se notifikace hrĂˇÄŤi i uĹľivateli typu {@link NotificationType#PLAYER_CHANGE_USER}.
     *
     * @param id        ID hrĂˇÄŤe.
     * @param newUserId ID novĂ©ho uĹľivatele.
     * @throws InvalidChangePlayerUserException Pokud je novĂ˝ uĹľivatel shodnĂ˝ s pĹŻvodnĂ­m.
     * @throws PlayerNotFoundException          Pokud hrĂˇÄŤ neexistuje.
     * @throws UserNotFoundException            Pokud uĹľivatel neexistuje.
     */
    @Transactional
    public void changePlayerUser(Long id, Long newUserId) {
        PlayerEntity player = findPlayerOrThrow(id);
        AppUserEntity newUser = findUserOrThrow(newUserId);
        AppUserEntity oldUser = player.getUser();

        if (oldUser != null && oldUser.getId().equals(newUserId)) {
            throw new InvalidChangePlayerUserException();
        }

        player.setUser(newUser);
        PlayerEntity saved = playerRepository.save(player);

        notifyPlayer(saved, NotificationType.PLAYER_CHANGE_USER, newUser);
        notifyUser(newUser, NotificationType.PLAYER_CHANGE_USER, player);
    }

    // ======================
    // READ
    // ======================

    /**
     * VracĂ­ vĹˇechny hrĂˇÄŤe v systĂ©mu.
     *
     * Data se naÄŤĂ­tajĂ­ z {@link PlayerRepository} a pĹ™evĂˇdĂ­ se do {@link PlayerDTO}
     * pomocĂ­ {@link PlayerMapper}.
     *
     * @return Seznam hrĂˇÄŤĹŻ ve formÄ› {@link PlayerDTO}.
     */
    @Override
    public List<PlayerDTO> getAllPlayers() {
        return playerRepository.findAll().stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    /**
     * VracĂ­ hrĂˇÄŤe podle ID.
     *
     * @param id ID hrĂˇÄŤe.
     * @return {@link PlayerDTO} odpovĂ­dajĂ­cĂ­ hrĂˇÄŤi.
     * @throws PlayerNotFoundException Pokud hrĂˇÄŤ s danĂ˝m ID neexistuje.
     */
    @Override
    public PlayerDTO getPlayerById(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);
        return playerMapper.toDTO(player);
    }

    /**
     * VracĂ­ vĹˇechny hrĂˇÄŤe pĹ™iĹ™azenĂ© uĹľivateli s danĂ˝m e-mailem.
     *
     * HrĂˇÄŤi jsou vrĂˇceni v poĹ™adĂ­ podle ID vzestupnÄ›.
     *
     * @param email E-mail uĹľivatele.
     * @return Seznam hrĂˇÄŤĹŻ ve formÄ› {@link PlayerDTO}.
     */
    @Override
    public List<PlayerDTO> getPlayersByUser(String email) {
        return playerRepository.findByUser_EmailOrderByIdAsc(email).stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    // ======================
    // CURRENT PLAYER â€“ SESSION
    // ======================

    /**
     * Nastavuje aktuĂˇlnĂ­ho hrĂˇÄŤe pro danĂ©ho uĹľivatele.
     *
     * Postup:
     * - naÄŤte se hrĂˇÄŤ podle ID,
     * - ovÄ›Ĺ™Ă­ se, Ĺľe hrĂˇÄŤ patĹ™Ă­ danĂ©mu uĹľivateli (podle e-mailu),
     * - ID hrĂˇÄŤe se pĹ™edĂˇ do {@link CurrentPlayerService#setCurrentPlayerId(Long)}.
     *
     * @param userEmail E-mail pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     * @param playerId  ID hrĂˇÄŤe, kterĂ˝ mĂˇ bĂ˝t nastaven jako aktuĂˇlnĂ­.
     * @return OdpovÄ›ÄŹ s vĂ˝sledkem operace.
     * @throws PlayerNotFoundException        Pokud hrĂˇÄŤ neexistuje.
     * @throws ForbiddenPlayerAccessException Pokud hrĂˇÄŤ nepatĹ™Ă­ danĂ©mu uĹľivateli.
     */
    @Override
    public SuccessResponseDTO setCurrentPlayerForUser(String userEmail, Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        assertPlayerBelongsToUser(player, userEmail);

        currentPlayerService.setCurrentPlayerId(playerId);

        String message = "BE - AktuĂˇlnĂ­ hrĂˇÄŤ nastaven na ID: " + playerId;
        return buildSuccessResponse(message, playerId);
    }

    /**
     * Automaticky vybĂ­rĂˇ aktuĂˇlnĂ­ho hrĂˇÄŤe pro uĹľivatele podle
     * nastavenĂ­ v AppUserSettings (playerSelectionMode).
     *
     * ReĹľimy:
     * - FIRST_PLAYER: vĹľdy se vybere prvnĂ­ hrĂˇÄŤ podle ID,
     * - ALWAYS_CHOOSE: automaticky se vybere pouze v pĹ™Ă­padÄ›,
     *   Ĺľe mĂˇ uĹľivatel prĂˇvÄ› jednoho schvĂˇlenĂ©ho hrĂˇÄŤe.
     *
     * @param userEmail E-mail uĹľivatele.
     * @return OdpovÄ›ÄŹ s vĂ˝sledkem operace.
     * @throws PlayerNotFoundException Pokud uĹľivatel nemĂˇ ĹľĂˇdnĂ©ho relevantnĂ­ho hrĂˇÄŤe.
     */
    @Override
    public SuccessResponseDTO autoSelectCurrentPlayerForUser(String userEmail) {

        var userSettingsDto = appUserSettingsService.getSettingsForUser(userEmail);

        PlayerSelectionMode mode = PlayerSelectionMode.FIRST_PLAYER;
        if (userSettingsDto.getPlayerSelectionMode() != null) {
            mode = PlayerSelectionMode.valueOf(userSettingsDto.getPlayerSelectionMode());
        }

        switch (mode) {
            case FIRST_PLAYER:
                return autoSelectFirstPlayer(userEmail);
            case ALWAYS_CHOOSE:
                return autoSelectIfSinglePlayer(userEmail);
            default:
                return autoSelectFirstPlayer(userEmail);
        }
    }

    /**
     * PomocnĂˇ metoda pro reĹľim FIRST_PLAYER.
     *
     * Najde prvnĂ­ho hrĂˇÄŤe uĹľivatele (podle ID) a nastavĂ­ ho
     * jako aktuĂˇlnĂ­ho hrĂˇÄŤe v {@link CurrentPlayerService}.
     * Pokud uĹľivatel nemĂˇ ĹľĂˇdnĂ©ho hrĂˇÄŤe nebo hrĂˇÄŤ nenĂ­ schvĂˇlen,
     * vyhodĂ­ se vĂ˝jimka.
     *
     * @param userEmail E-mail uĹľivatele.
     * @return OdpovÄ›ÄŹ s vĂ˝sledkem operace.
     * @throws PlayerNotFoundException     Pokud uĹľivatel nemĂˇ ĹľĂˇdnĂ©ho hrĂˇÄŤe.
     * @throws InvalidPlayerStatusException Pokud prvnĂ­ hrĂˇÄŤ nenĂ­ ve stavu APPROVED.
     */
    private SuccessResponseDTO autoSelectFirstPlayer(String userEmail) {
        List<PlayerEntity> players = playerRepository.findByUser_EmailOrderByIdAsc(userEmail);

        if (players.isEmpty()) {
            currentPlayerService.clear();
            throw new PlayerNotFoundException(
                    "BE - UĹľivatel nemĂˇ pĹ™iĹ™azenĂ©ho ĹľĂˇdnĂ©ho hrĂˇÄŤe. Nelze automaticky vybrat.",
                    userEmail
            );
        }

        PlayerEntity firstPlayer = players.get(0);
        if (firstPlayer.getPlayerStatus() != APPROVED) {
            throw new InvalidPlayerStatusException(
                    "BE - Nelze zvolit hrĂˇÄŤe, kterĂ˝ nenĂ­ schvĂˇlen administrĂˇtorem."
            );
        }

        currentPlayerService.setCurrentPlayerId(firstPlayer.getId());
        String message = "BE - Automaticky byl vybrĂˇn prvnĂ­ hrĂˇÄŤ: " + firstPlayer.getFullName();
        return buildSuccessResponse(message, firstPlayer.getId());
    }

    /**
     * PomocnĂˇ metoda pro reĹľim ALWAYS_CHOOSE.
     *
     * Pokud mĂˇ uĹľivatel prĂˇvÄ› jednoho schvĂˇlenĂ©ho hrĂˇÄŤe, tento hrĂˇÄŤ
     * se nastavĂ­ jako aktuĂˇlnĂ­. V ostatnĂ­ch pĹ™Ă­padech se current player
     * vyÄŤistĂ­ a oÄŤekĂˇvĂˇ se ruÄŤnĂ­ vĂ˝bÄ›r na frontendu.
     *
     * @param userEmail E-mail uĹľivatele.
     * @return OdpovÄ›ÄŹ s vĂ˝sledkem operace.
     * @throws PlayerNotFoundException Pokud uĹľivatel nemĂˇ ĹľĂˇdnĂ©ho schvĂˇlenĂ©ho hrĂˇÄŤe.
     */
    private SuccessResponseDTO autoSelectIfSinglePlayer(String userEmail) {
        List<PlayerEntity> players = playerRepository
                .findByUser_EmailOrderByIdAsc(userEmail).stream()
                .filter(p -> p.getPlayerStatus() == APPROVED)
                .toList();

        if (players.isEmpty()) {
            currentPlayerService.clear();

            throw new PlayerNotFoundException(
                    "BE - UĹľivatel nemĂˇ pĹ™iĹ™azenĂ©ho ĹľĂˇdnĂ©ho hrĂˇÄŤe schvĂˇlenĂ©ho AdministrĂˇtorem. Nelze automaticky vybrat.",
                    userEmail
            );
        }
        if (players.size() == 1) {
            PlayerEntity onlyPlayer = players.get(0);

            currentPlayerService.setCurrentPlayerId(onlyPlayer.getId());

            String message = "BE - Byl vybrĂˇn jedinĂ˝ schvĂˇlenĂ˝ hrĂˇÄŤ: " + onlyPlayer.getFullName();
            return buildSuccessResponse(message, onlyPlayer.getId());
        }

        currentPlayerService.clear();

        StringBuilder sb = new StringBuilder();
        for (PlayerEntity player : players) {
            sb.append(players.indexOf(player) + 1);
            sb.append(". - ");
            sb.append(player.getFullName());
            sb.append(" / ");
        }
        String message = "BE - UĹľivatel mĂˇ vĂ­ce hrĂˇÄŤĹŻ a musĂ­ je vybrat manuĂˇlnÄ› dle nastavenĂ­: " + sb;
        return buildSuccessResponse(message, 0L);
    }

    // ======================
    // PRIVATE HELPERY â€“ ENTITY / DUPLICITY
    // ======================

    /**
     * NaÄŤĂ­tĂˇ hrĂˇÄŤe podle ID nebo vyhazuje {@link PlayerNotFoundException}.
     *
     * @param id ID hrĂˇÄŤe.
     * @return Entita hrĂˇÄŤe.
     */
    private PlayerEntity findPlayerOrThrow(Long id) {
        return playerRepository.findById(id)
                .orElseThrow(() -> new PlayerNotFoundException(id));
    }

    /**
     * NaÄŤĂ­tĂˇ uĹľivatele podle ID nebo vyhazuje {@link UserNotFoundException}.
     *
     * @param id ID uĹľivatele.
     * @return Entita uĹľivatele.
     */
    private AppUserEntity findUserOrThrow(Long id) {
        return appUserRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException(id));
    }

    /**
     * ZajiĹˇĹĄuje unikĂˇtnost kombinace jmĂ©no + pĹ™Ă­jmenĂ­.
     *
     * PĹ™i vytvĂˇĹ™enĂ­ novĂ©ho hrĂˇÄŤe se oÄŤekĂˇvĂˇ ignoreId null.
     * PĹ™i aktualizaci se ignoruje hrĂˇÄŤ se stejnĂ˝m ID, aby nebyl
     * povaĹľovĂˇn za duplicitnĂ­ho sĂˇm se sebou.
     *
     * @param name     JmĂ©no hrĂˇÄŤe.
     * @param surname  PĹ™Ă­jmenĂ­ hrĂˇÄŤe.
     * @param ignoreId ID hrĂˇÄŤe, kterĂ˝ mĂˇ bĂ˝t ignorovĂˇn, nebo null.
     */
    private void ensureUniqueNameSurname(String name, String surname, Long ignoreId) {
        Optional<PlayerEntity> duplicateOpt = playerRepository.findByNameAndSurname(name, surname);

        if (duplicateOpt.isPresent()) {
            PlayerEntity duplicate = duplicateOpt.get();

            if (ignoreId == null || !duplicate.getId().equals(ignoreId)) {
                throw new DuplicateNameSurnameException(name, surname);
            }
        }
    }

    /**
     * OvÄ›Ĺ™uje, Ĺľe hrĂˇÄŤ patĹ™Ă­ danĂ©mu uĹľivateli (podle e-mailu).
     *
     * Pokud hrĂˇÄŤ uĹľivateli nepatĹ™Ă­, vyhodĂ­ se {@link ForbiddenPlayerAccessException}.
     *
     * @param player    HrĂˇÄŤ.
     * @param userEmail E-mail uĹľivatele.
     */
    private void assertPlayerBelongsToUser(PlayerEntity player, String userEmail) {
        if (player.getUser() == null ||
                player.getUser().getEmail() == null ||
                !player.getUser().getEmail().equals(userEmail)) {

            throw new ForbiddenPlayerAccessException(player.getId());
        }
    }

    /**
     * VytvĂˇĹ™Ă­ standardizovanou ĂşspÄ›Ĺˇnou odpovÄ›ÄŹ {@link SuccessResponseDTO}
     * s danou zprĂˇvou a ID.
     *
     * @param message TextovĂˇ zprĂˇva.
     * @param id      ID entity, kterĂ© se operace tĂ˝kala.
     * @return ĂšspÄ›ĹˇnĂˇ odpovÄ›ÄŹ.
     */
    private SuccessResponseDTO buildSuccessResponse(String message, Long id) {
        return new SuccessResponseDTO(
                message,
                id,
                LocalDateTime.now().toString()
        );
    }

    /**
     * ObecnĂˇ pomocnĂˇ metoda pro zmÄ›nu statusu hrĂˇÄŤe (approve/reject).
     *
     * Postup:
     * - ovÄ›Ĺ™Ă­ se, Ĺľe hrĂˇÄŤ jiĹľ nenĂ­ v cĂ­lovĂ©m stavu,
     * - nastavĂ­ se novĂ˝ status,
     * - v pĹ™Ă­padÄ› schvĂˇlenĂ­ se zajistĂ­ vĂ˝chozĂ­ nastavenĂ­ hrĂˇÄŤe,
     * - uloĹľĂ­ se entita a vyhodnotĂ­ se typ notifikace podle novĂ©ho statusu,
     * - odeĹˇle se notifikace hrĂˇÄŤi, pokud je typ notifikace definovĂˇn.
     *
     * @param id                     ID hrĂˇÄŤe.
     * @param targetStatus           CĂ­lovĂ˝ status.
     * @param alreadyStatus          Status, kterĂ˝ znamenĂˇ â€žuĹľ je v tomto stavuâ€ś.
     * @param notificationType       VĂ˝chozĂ­ typ notifikace (pĹ™Ă­padnÄ› pĹ™epsanĂ˝ podle statusu).
     * @param alreadyMessage         ZprĂˇva pro pĹ™Ă­pad, Ĺľe je hrĂˇÄŤ jiĹľ v cĂ­lovĂ©m stavu.
     * @param successMessageTemplate Ĺ ablona ĂşspÄ›ĹˇnĂ© zprĂˇvy.
     * @return OdpovÄ›ÄŹ s vĂ˝sledkem operace.
     */
    private SuccessResponseDTO changePlayerStatus(Long id,
                                                  PlayerStatus targetStatus,
                                                  PlayerStatus alreadyStatus,
                                                  NotificationType notificationType,
                                                  String alreadyMessage,
                                                  String successMessageTemplate) {

        PlayerEntity player = findPlayerOrThrow(id);

        if (player.getPlayerStatus() == alreadyStatus) {
            throw new InvalidPlayerStatusException(alreadyMessage);
        }

        player.setPlayerStatus(targetStatus);

        if (targetStatus == APPROVED && player.getSettings() == null) {
            PlayerSettingsEntity settings =
                    playerSettingsService.createDefaultSettingsForPlayer(player);
            player.setSettings(settings);
        }
        PlayerEntity saved = playerRepository.save(player);

        notificationType = resolveNotificationType(targetStatus);
        if (notificationType != null) {
            notifyPlayer(saved, notificationType, saved);
        }

        String message = String.format(successMessageTemplate, saved.getFullName());
        return buildSuccessResponse(message, id);
    }

    // ======================
    // PRIVĂTNĂŤ HELPERY â€“ NOTIFIKACE
    // ======================

    private void notifyPlayer(PlayerEntity player, NotificationType type, Object context) {
        notificationService.notifyPlayer(player, type, context);
    }

    private void notifyUser(AppUserEntity user, NotificationType type, Object context) {
        notificationService.notifyUser(user, type, context);
    }

    /**
     * PĹ™evĂˇdĂ­ status hrĂˇÄŤe na typ notifikace.
     *
     * Pokud se pro zadanĂ˝ status notifikace neposĂ­lĂˇ,
     * vracĂ­ se null. Status PENDING se zde nevyuĹľĂ­vĂˇ,
     * protoĹľe notifikace pĹ™i vytvoĹ™enĂ­ hrĂˇÄŤe jsou Ĺ™eĹˇeny jinde.
     *
     * @param newStatus NovĂ˝ status hrĂˇÄŤe.
     * @return OdpovĂ­dajĂ­cĂ­ {@link NotificationType} nebo null.
     */
    private NotificationType resolveNotificationType(PlayerStatus newStatus) {
        return switch (newStatus) {
            case APPROVED -> NotificationType.PLAYER_APPROVED;
            case REJECTED -> NotificationType.PLAYER_REJECTED;
            default -> null;
        };
    }

}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerSettingsService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.player.entities.PlayerEntity;
import cz.phsoft.hokej.player.entities.PlayerSettingsEntity;
import cz.phsoft.hokej.player.dto.PlayerSettingsDTO;

/**
 * Service rozhranĂ­ pro prĂˇci s nastavenĂ­m hrĂˇÄŤe ({@link PlayerSettingsEntity}).
 *
 * OdpovÄ›dnosti:
 * - poskytovat pĹ™Ă­stup k nastavenĂ­ konkrĂ©tnĂ­ho hrĂˇÄŤe,
 * - vytvĂˇĹ™et vĂ˝chozĂ­ nastavenĂ­ hrĂˇÄŤe,
 * - aktualizovat existujĂ­cĂ­ nastavenĂ­ hrĂˇÄŤe na zĂˇkladÄ› DTO.
 *
 * Architektura:
 * - pracuje s {@link PlayerSettingsDTO} jako pĹ™enosovĂ˝m objektem mezi backendem a frontendem,
 * - nezajiĹˇĹĄuje autorizaci ani kontrolu vlastnictvĂ­ hrĂˇÄŤe,
 *   tyto kontroly se provĂˇdÄ›jĂ­ v controlleru nebo ve vyĹˇĹˇĂ­ servisnĂ­ vrstvÄ›.
 */
public interface PlayerSettingsService {

    /**
     * VrĂˇtĂ­ nastavenĂ­ pro hrĂˇÄŤe podle jeho ID.
     *
     * Pokud nastavenĂ­ jeĹˇtÄ› neexistuje, vytvoĹ™Ă­ se z vĂ˝chozĂ­ch hodnot
     * a uloĹľĂ­ se pro danĂ©ho hrĂˇÄŤe. TĂ­m se zajiĹˇĹĄuje, Ĺľe volajĂ­cĂ­ vĹľdy
     * obdrĹľĂ­ platnĂ© nastavenĂ­.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return nastavenĂ­ hrĂˇÄŤe ve formÄ› {@link PlayerSettingsDTO}
     */
    PlayerSettingsDTO getSettingsForPlayer(Long playerId);

    /**
     * Aktualizuje nastavenĂ­ pro hrĂˇÄŤe podle jeho ID.
     *
     * Pokud hrĂˇÄŤ jeĹˇtÄ› nemĂˇ nastavenĂ­, vytvoĹ™Ă­ se vĂ˝chozĂ­ nastavenĂ­
     * a nĂˇslednÄ› se na nÄ›j aplikujĂ­ hodnoty z DTO.
     *
     * @param playerId ID hrĂˇÄŤe
     * @param dto      novĂ© hodnoty nastavenĂ­
     * @return aktualizovanĂ© nastavenĂ­ ve formÄ› {@link PlayerSettingsDTO}
     */
    PlayerSettingsDTO updateSettingsForPlayer(Long playerId, PlayerSettingsDTO dto);

    /**
     * VytvoĹ™Ă­ vĂ˝chozĂ­ nastavenĂ­ pro hrĂˇÄŤe.
     *
     * Metoda pouze vytvĂˇĹ™Ă­ instanci {@link PlayerSettingsEntity}
     * s nastavovanĂ˝mi default hodnotami. UloĹľenĂ­ do databĂˇze
     * je odpovÄ›dnostĂ­ volajĂ­cĂ­ho kĂłdu.
     *
     * @param player hrĂˇÄŤ, ke kterĂ©mu budou defaultnĂ­ hodnoty pĹ™iĹ™azeny
     * @return novĂˇ instance {@link PlayerSettingsEntity} s vĂ˝chozĂ­m nastavenĂ­m
     */
    PlayerSettingsEntity createDefaultSettingsForPlayer(PlayerEntity player);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerSettingsServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.user.entities.AppUserEntity;
import cz.phsoft.hokej.player.entities.PlayerEntity;
import cz.phsoft.hokej.player.entities.PlayerSettingsEntity;
import cz.phsoft.hokej.player.repositories.PlayerRepository;
import cz.phsoft.hokej.player.repositories.PlayerSettingsRepository;
import cz.phsoft.hokej.player.dto.PlayerSettingsDTO;
import cz.phsoft.hokej.player.mappers.PlayerSettingsMapper;
import cz.phsoft.hokej.player.exceptions.PlayerNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

/**
 * Implementace sluĹľby pro prĂˇci s nastavenĂ­m hrĂˇÄŤe (PlayerSettingsEntity).
 *
 * OdpovÄ›dnosti:
 * - naÄŤĂ­tĂˇnĂ­ nastavenĂ­ hrĂˇÄŤe podle jeho ID,
 * - vytvĂˇĹ™enĂ­ vĂ˝chozĂ­ho nastavenĂ­ pro hrĂˇÄŤe, pokud jeĹˇtÄ› neexistuje,
 * - aktualizace existujĂ­cĂ­ho nastavenĂ­ podle PlayerSettingsDTO.
 *
 * Tato tĹ™Ă­da:
 * - neĹ™eĹˇĂ­ autorizaci ani ovÄ›Ĺ™ovĂˇnĂ­ vlastnictvĂ­ hrĂˇÄŤe (Ĺ™eĹˇĂ­ controller),
 * - neodesĂ­lĂˇ notifikace, pouze spravuje data v databĂˇzi,
 * - spolupracuje s:
 *   - PlayerRepository pro ovÄ›Ĺ™enĂ­ existence hrĂˇÄŤe,
 *   - PlayerSettingsRepository pro prĂˇci s nastavenĂ­m,
 *   - PlayerSettingsMapper pro mapovĂˇnĂ­ mezi entitou a DTO.
 */
@Service
@Transactional
public class PlayerSettingsServiceImpl implements PlayerSettingsService {

    private final PlayerRepository playerRepository;
    private final PlayerSettingsRepository playerSettingsRepository;
    private final PlayerSettingsMapper mapper;

    public PlayerSettingsServiceImpl(PlayerRepository playerRepository,
                                     PlayerSettingsRepository playerSettingsRepository,
                                     PlayerSettingsMapper mapper) {
        this.playerRepository = playerRepository;
        this.playerSettingsRepository = playerSettingsRepository;
        this.mapper = mapper;
    }

    @Override
    public PlayerSettingsDTO getSettingsForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        Optional<PlayerSettingsEntity> existingOpt =
                playerSettingsRepository.findByPlayer(player);

        PlayerSettingsEntity settings = existingOpt.orElseGet(() -> {
            PlayerSettingsEntity created = createDefaultSettingsForPlayer(player);
            return playerSettingsRepository.save(created);
        });

        return mapper.toDTO(settings);
    }

    @Override
    public PlayerSettingsDTO updateSettingsForPlayer(Long playerId, PlayerSettingsDTO dto) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        PlayerSettingsEntity settings = playerSettingsRepository.findByPlayer(player)
                .orElseGet(() -> createDefaultSettingsForPlayer(player));

        mapper.updateEntityFromDTO(dto, settings);

        // pro jistotu se zajiĹˇĹĄuje navĂˇzĂˇnĂ­ na hrĂˇÄŤe
        settings.setPlayer(player);

        PlayerSettingsEntity saved = playerSettingsRepository.save(settings);

        return mapper.toDTO(saved);
    }

    // =========================
    // HELPER METODY
    // =========================

    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    /**
     * VytvoĹ™Ă­ vĂ˝chozĂ­ nastavenĂ­ pro danĂ©ho hrĂˇÄŤe.
     *
     * VĂ˝chozĂ­ chovĂˇnĂ­:
     * - kontaktnĂ­ email a telefon jsou ponechĂˇny prĂˇzdnĂ© (null),
     * - emailovĂ© notifikace:
     *   - notifyOnRegistration = true,
     *   - notifyOnExcuse = true,
     *   - notifyOnMatchChange = true,
     *   - notifyOnMatchCancel = true,
     *   - notifyOnPayment = false,
     * - pĹ™ipomĂ­nky:
     *   - notifyReminders = true,
     *   - reminderHoursBefore = 24,
     * - hernĂ­ preference pro automatickĂ© pĹ™esuny:
     *   - possibleMoveToAnotherTeam = false,
     *   - possibleChangePlayerPosition = false.
     */
    @Override
    public PlayerSettingsEntity createDefaultSettingsForPlayer(PlayerEntity player) {
        PlayerSettingsEntity settings = new PlayerSettingsEntity();

        settings.setPlayer(player);

        // kontakty
        settings.setContactEmail(null);
        settings.setContactPhone(null);

        // kanĂˇly
        settings.setEmailEnabled(true);
        settings.setSmsEnabled(false);

        // typy notifikacĂ­
        settings.setNotifyOnRegistration(true);
        settings.setNotifyOnExcuse(true);
        settings.setNotifyOnMatchChange(true);
        settings.setNotifyOnMatchCancel(true);
        settings.setNotifyOnPayment(false);

        // pĹ™ipomĂ­nky
        settings.setNotifyReminders(false);
        settings.setReminderHoursBefore(24);

        // hernĂ­ preference â€“ vĂ˝chozĂ­: ĹľĂˇdnĂ© automatickĂ© pĹ™esuny
        settings.setPossibleMoveToAnotherTeam(false);
        settings.setPossibleChangePlayerPosition(false);

        return settings;
    }

}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerStatsService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.player.dto.PlayerStatsDTO;

/**
 * Service rozhranĂ­ pro poskytovĂˇnĂ­ statistik hrĂˇÄŤe.
 *
 * SlouĹľĂ­ k zapouzdĹ™enĂ­ business logiky vĂ˝poÄŤtu statistik hrĂˇÄŤe
 * v rĂˇmci aktuĂˇlnĂ­ sezĂłny. Implementace je odpovÄ›dnĂˇ za naÄŤtenĂ­
 * relevantnĂ­ch zĂˇpasĹŻ, vyhodnocenĂ­ aktivity hrĂˇÄŤe a agregaci
 * registraÄŤnĂ­ch statusĹŻ do souhrnnĂ© podoby.
 *
 * Toto rozhranĂ­ je urÄŤeno pro pouĹľitĂ­ v aplikaÄŤnĂ­ vrstvÄ›
 * (napĹ™Ă­klad z controlleru) a oddÄ›luje kontrakt od konkrĂ©tnĂ­
 * implementace vĂ˝poÄŤtu.
 */
public interface PlayerStatsService {

    /**
     * VracĂ­ statistiku hrĂˇÄŤe za aktuĂˇlnĂ­ sezĂłnu.
     *
     * Statistika zahrnuje celkovĂ˝ poÄŤet odehranĂ˝ch zĂˇpasĹŻ sezĂłny
     * a poÄŤty zĂˇpasĹŻ rozdÄ›lenĂ© podle registraÄŤnĂ­ho statusu hrĂˇÄŤe.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, pro kterĂ©ho se statistika poÄŤĂ­tĂˇ.
     * @return DatovĂ˝ pĹ™enosovĂ˝ objekt obsahujĂ­cĂ­ souhrnnĂ© statistiky hrĂˇÄŤe.
     */
    PlayerStatsDTO getPlayerStats(Long playerId);

}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerStatsServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.match.entities.MatchEntity;
import cz.phsoft.hokej.player.entities.PlayerEntity;
import cz.phsoft.hokej.registration.enums.PlayerMatchStatus;
import cz.phsoft.hokej.player.enums.Team;
import cz.phsoft.hokej.match.repositories.MatchRepository;
import cz.phsoft.hokej.player.repositories.PlayerRepository;
import cz.phsoft.hokej.player.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.registration.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.player.dto.PlayerStatsDTO;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Service vrstva pro vĂ˝poÄŤet statistik hrĂˇÄŤe v rĂˇmci aktuĂˇlnĂ­ sezĂłny.
 *
 * OdpovÄ›dnosti:
 * - naÄŤĂ­tĂˇnĂ­ hrĂˇÄŤe a odehranĂ˝ch zĂˇpasĹŻ aktuĂˇlnĂ­ sezĂłny,
 * - filtrovĂˇnĂ­ zĂˇpasĹŻ podle data vytvoĹ™enĂ­ hrĂˇÄŤe a jeho aktivity v danĂ©m termĂ­nu,
 * - agregace registracĂ­ hrĂˇÄŤe do souhrnnĂ˝ch poÄŤtĹŻ podle {@link PlayerMatchStatus},
 * - sestavenĂ­ {@link PlayerStatsDTO} vÄŤetnÄ› domovskĂ©ho tĂ˝mu, pozic a registracĂ­ podle tĂ˝mĹŻ.
 *
 * Tato tĹ™Ă­da neĹ™eĹˇĂ­:
 * - HTTP vrstvu a mapovĂˇnĂ­ requestĹŻ na DTO (Ĺ™eĹˇĂ­ controllery),
 * - sprĂˇvu sezĂłn obecnÄ› (Ĺ™eĹˇĂ­ {@link SeasonService} a {@link CurrentSeasonService}),
 * - uklĂˇdĂˇnĂ­ nebo mÄ›nÄ›nĂ­ registracĂ­ (Ĺ™eĹˇĂ­ {@link MatchRegistrationService}).
 *
 * Spolupracuje s:
 * - {@link PlayerRepository} pro naÄŤtenĂ­ hrĂˇÄŤe,
 * - {@link MatchRepository} pro naÄŤtenĂ­ zĂˇpasĹŻ aktuĂˇlnĂ­ sezĂłny,
 * - {@link CurrentSeasonService} a {@link SeasonService} pro urÄŤenĂ­ sezĂłny,
 * - {@link PlayerInactivityPeriodService} pro vyhodnocenĂ­ aktivity hrĂˇÄŤe v termĂ­nu zĂˇpasu,
 * - {@link MatchRegistrationService} pro naÄŤtenĂ­ registracĂ­ na zĂˇpasy.
 */
@Service
public class PlayerStatsServiceImpl implements PlayerStatsService {

    private final PlayerRepository playerRepository;
    private final MatchRepository matchRepository;
    private final CurrentSeasonService currentSeasonService;
    private final SeasonService seasonService;
    private final PlayerInactivityPeriodService playerInactivityPeriodService;
    private final MatchRegistrationService matchRegistrationService;

    /**
     * VytvĂˇĹ™Ă­ sluĹľbu pro vĂ˝poÄŤet statistik hrĂˇÄŤe.
     *
     * @param playerRepository Repository pro prĂˇci s hrĂˇÄŤi.
     * @param matchRepository Repository pro prĂˇci se zĂˇpasy.
     * @param currentSeasonService Service poskytujĂ­cĂ­ identifikĂˇtor aktuĂˇlnĂ­ sezĂłny.
     * @param seasonService Service poskytujĂ­cĂ­ aktivnĂ­ sezĂłnu jako fallback.
     * @param playerInactivityPeriodService Service pro vyhodnocenĂ­ aktivity hrĂˇÄŤe v termĂ­nu zĂˇpasu.
     * @param matchRegistrationService Service pro naÄŤĂ­tĂˇnĂ­ registracĂ­ hrĂˇÄŤĹŻ na zĂˇpasy.
     */
    public PlayerStatsServiceImpl(PlayerRepository playerRepository,
                                  MatchRepository matchRepository,
                                  CurrentSeasonService currentSeasonService,
                                  SeasonService seasonService,
                                  PlayerInactivityPeriodService playerInactivityPeriodService,
                                  MatchRegistrationService matchRegistrationService) {
        this.playerRepository = playerRepository;
        this.matchRepository = matchRepository;
        this.currentSeasonService = currentSeasonService;
        this.seasonService = seasonService;
        this.playerInactivityPeriodService = playerInactivityPeriodService;
        this.matchRegistrationService = matchRegistrationService;
    }

    /**
     * VracĂ­ statistiky hrĂˇÄŤe pro odehranĂ© zĂˇpasy aktuĂˇlnĂ­ sezĂłny.
     *
     * Postup:
     * - naÄŤte se hrĂˇÄŤ podle ID a zĂ­skĂˇ se jeho ÄŤasovĂ© razĂ­tko vytvoĹ™enĂ­,
     * - naÄŤtou se vĹˇechny odehranĂ© zĂˇpasy aktuĂˇlnĂ­ sezĂłny a spoÄŤĂ­tĂˇ se jejich celkovĂ˝ poÄŤet,
     * - zĂˇpasy se filtrujĂ­ tak, aby byly zahrnuty pouze:
     *   - zĂˇpasy po datu vytvoĹ™enĂ­ hrĂˇÄŤe,
     *   - zĂˇpasy v obdobĂ­, kdy je hrĂˇÄŤ aktivnĂ­ (delegovĂˇno do {@link PlayerInactivityPeriodService}),
     * - pokud pro hrĂˇÄŤe nejsou ĹľĂˇdnĂ© relevantnĂ­ zĂˇpasy, sestavĂ­ se DTO
     *   s poÄŤtem zĂˇpasĹŻ v sezĂłnÄ›, poÄŤtem zĂˇpasĹŻ dostupnĂ˝ch pro hrĂˇÄŤe,
     *   domovskĂ˝m tĂ˝mem, pozicemi a prĂˇzdnou statistikou,
     * - pro relevantnĂ­ zĂˇpasy se naÄŤtou registrace pĹ™es {@link MatchRegistrationService},
     *   vytvoĹ™Ă­ se mapovĂˇnĂ­ matchId â†’ status a matchId â†’ tĂ˝m hrĂˇÄŤe,
     * - pro kaĹľdĂ˝ zĂˇpas se urÄŤĂ­ status hrĂˇÄŤe, pro zĂˇpasy bez registrace
     *   se pouĹľije status {@link PlayerMatchStatus#NO_RESPONSE},
     * - agregovanĂ© poÄŤty podle statusu a poÄŤty registracĂ­ podle tĂ˝mĹŻ se pĹ™enesou do DTO.
     *
     * DTO vĹľdy obsahuje:
     * - celkovĂ˝ poÄŤet zĂˇpasĹŻ v sezĂłnÄ›,
     * - poÄŤet zĂˇpasĹŻ, kterĂ© byly pro hrĂˇÄŤe relevantnĂ­,
     * - domovskĂ˝ tĂ˝m hrĂˇÄŤe,
     * - primĂˇrnĂ­ a sekundĂˇrnĂ­ pozici,
     * - poÄŤty registracĂ­ podle statusĹŻ,
     * - mapu {@code registeredByTeam} obsahujĂ­cĂ­ vĹˇechny hodnoty {@link Team}
     *   (i s nulovĂ˝mi poÄŤty), aby mÄ›l frontend stabilnĂ­ strukturu.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe, pro kterĂ©ho se statistiky poÄŤĂ­tajĂ­.
     * @return DTO obsahujĂ­cĂ­ souhrnnĂ© poÄŤty zĂˇpasĹŻ podle statusĹŻ a doplĹkovĂ© Ăşdaje.
     * @throws PlayerNotFoundException Pokud hrĂˇÄŤ se zadanĂ˝m identifikĂˇtorem neexistuje.
     */
    @Override
    public PlayerStatsDTO getPlayerStats(Long playerId) {
        PlayerEntity player = getPlayerOrThrow(playerId);
        LocalDateTime playerCreatedDate = player.getTimestamp();

        List<MatchEntity> pastMatchesInSeason = findPastMatchesForCurrentSeason();
        int allMatchesInCurrentSeason = pastMatchesInSeason.size();

        List<MatchEntity> availableMatches =
                pastMatchesInSeason.stream()
                        .filter(match -> match.getDateTime().isAfter(playerCreatedDate))
                        .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                        .toList();

        int allMatchesInSeasonForPlayer = availableMatches.size();

        PlayerStatsDTO statsDTO = new PlayerStatsDTO();
        statsDTO.setPlayerId(playerId);
        statsDTO.setAllMatchesInSeason(allMatchesInCurrentSeason);
        statsDTO.setAllMatchesInSeasonForPlayer(allMatchesInSeasonForPlayer);
        statsDTO.setHomeTeam(player.getTeam());
        statsDTO.setPrimaryPosition(player.getPrimaryPosition());
        statsDTO.setSecondaryPosition(player.getSecondaryPosition());

        // vĹľdy pĹ™ipravĂ­me mapu se vĹˇemi tĂ˝my (aĹĄ je vĂ˝stup stabilnĂ­ pro FE)
        EnumMap<Team, Integer> registeredByTeam = new EnumMap<>(Team.class);
        for (Team t : Team.values()) {
            registeredByTeam.put(t, 0);
        }

        if (availableMatches.isEmpty()) {
            statsDTO.setRegisteredByTeam(registeredByTeam);
            return statsDTO;
        }

        List<Long> matchIds = availableMatches.stream()
                .map(MatchEntity::getId)
                .toList();

        List<MatchRegistrationDTO> allRegistrations =
                matchRegistrationService.getRegistrationsForMatches(matchIds);

        // matchId -> status hrĂˇÄŤe v danĂ©m zĂˇpase
        Map<Long, PlayerMatchStatus> playerStatusByMatchId = allRegistrations.stream()
                .filter(r -> playerId.equals(r.getPlayerId()))
                .collect(Collectors.toMap(
                        MatchRegistrationDTO::getMatchId,
                        MatchRegistrationDTO::getStatus,
                        (a, b) -> a
                ));

        // matchId -> tĂ˝m hrĂˇÄŤe v danĂ©m zĂˇpase (podle registrace)
        Map<Long, Team> playerTeamByMatchId = allRegistrations.stream()
                .filter(r -> playerId.equals(r.getPlayerId()))
                .collect(Collectors.toMap(
                        MatchRegistrationDTO::getMatchId,
                        MatchRegistrationDTO::getTeam,
                        (a, b) -> a
                ));

        EnumMap<PlayerMatchStatus, Integer> counts = new EnumMap<>(PlayerMatchStatus.class);

        for (MatchEntity match : availableMatches) {
            PlayerMatchStatus status = playerStatusByMatchId.getOrDefault(
                    match.getId(),
                    PlayerMatchStatus.NO_RESPONSE
            );

            counts.merge(status, 1, Integer::sum);

            // jen REGISTERED a jen podle team z registrace
            if (status == PlayerMatchStatus.REGISTERED) {
                Team team = playerTeamByMatchId.get(match.getId());
                if (team != null) {
                    registeredByTeam.merge(team, 1, Integer::sum);
                }
            }
        }

        statsDTO.setRegistered(counts.getOrDefault(PlayerMatchStatus.REGISTERED, 0));
        statsDTO.setUnregistered(counts.getOrDefault(PlayerMatchStatus.UNREGISTERED, 0));
        statsDTO.setExcused(counts.getOrDefault(PlayerMatchStatus.EXCUSED, 0));
        statsDTO.setSubstituted(counts.getOrDefault(PlayerMatchStatus.SUBSTITUTE, 0));
        statsDTO.setReserved(counts.getOrDefault(PlayerMatchStatus.RESERVED, 0));
        statsDTO.setNoResponse(counts.getOrDefault(PlayerMatchStatus.NO_RESPONSE, 0));
        statsDTO.setNoExcused(counts.getOrDefault(PlayerMatchStatus.NO_EXCUSED, 0));

        // stabilnĂ­ mapa pro FE (obsahuje vĹˇechny Team.values())
        statsDTO.setRegisteredByTeam(registeredByTeam);

        return statsDTO;
    }

    /**
     * NaÄŤĂ­tĂˇ odehranĂ© zĂˇpasy aktuĂˇlnĂ­ sezĂłny.
     *
     * ZĂˇpasy se vybĂ­rajĂ­ podle identifikĂˇtoru sezĂłny a data zĂˇpasu menĹˇĂ­ho neĹľ aktuĂˇlnĂ­ ÄŤas.
     * VĂ˝sledek se Ĺ™adĂ­ sestupnÄ› podle data zĂˇpasu.
     *
     * @return Seznam odehranĂ˝ch zĂˇpasĹŻ aktuĂˇlnĂ­ sezĂłny.
     */
    private List<MatchEntity> findPastMatchesForCurrentSeason() {
        return matchRepository.findBySeasonIdAndDateTimeBeforeOrderByDateTimeDesc(
                getCurrentSeasonIdOrActive(),
                now()
        );
    }

    /**
     * VracĂ­ hrĂˇÄŤe podle identifikĂˇtoru nebo vyhazuje vĂ˝jimku, pokud neexistuje.
     *
     * @param playerId IdentifikĂˇtor hrĂˇÄŤe.
     * @return Entita hrĂˇÄŤe.
     * @throws PlayerNotFoundException Pokud hrĂˇÄŤ se zadanĂ˝m identifikĂˇtorem neexistuje.
     */
    private PlayerEntity getPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    /**
     * UrÄŤuje identifikĂˇtor sezĂłny, pro kterou se majĂ­ poÄŤĂ­tat statistiky.
     *
     * PrimĂˇrnÄ› se pouĹľĂ­vĂˇ identifikĂˇtor aktuĂˇlnĂ­ sezĂłny poskytnutĂ˝ sluĹľbou
     * {@link CurrentSeasonService}. Pokud nenĂ­ dostupnĂ˝, pouĹľije se
     * identifikĂˇtor aktivnĂ­ sezĂłny z {@link SeasonService}.
     *
     * @return IdentifikĂˇtor sezĂłny pouĹľitĂ˝ pro vĂ˝bÄ›r zĂˇpasĹŻ.
     */
    private Long getCurrentSeasonIdOrActive() {
        Long id = currentSeasonService.getCurrentSeasonIdOrDefault();
        if (id != null) {
            return id;
        }
        return seasonService.getActiveSeason().getId();
    }

    /**
     * VracĂ­ aktuĂˇlnĂ­ ÄŤas pouĹľĂ­vanĂ˝ pro porovnĂˇnĂ­ termĂ­nu zĂˇpasĹŻ.
     *
     * @return AktuĂˇlnĂ­ ÄŤas.
     */
    private LocalDateTime now() {
        return LocalDateTime.now();
    }

    /**
     * Vyhodnocuje, zda byl hrĂˇÄŤ aktivnĂ­ v dobÄ› konĂˇnĂ­ zĂˇpasu.
     *
     * Logika je delegovĂˇna do {@link PlayerInactivityPeriodService},
     * kterĂˇ zohledĹuje obdobĂ­ neaktivity hrĂˇÄŤe.
     *
     * @param player HrĂˇÄŤ, pro kterĂ©ho se aktivita vyhodnocuje.
     * @param dateTime TermĂ­n zĂˇpasu.
     * @return True, pokud byl hrĂˇÄŤ v danĂ©m termĂ­nu aktivnĂ­.
     */
    private boolean isPlayerActiveForMatch(PlayerEntity player, LocalDateTime dateTime) {
        return playerInactivityPeriodService.isActive(player, dateTime);
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\SeasonHistoryService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.season.dto.SeasonHistoryDTO;

import java.util.List;

/**
 * Service rozhranĂ­ pouĹľĂ­vanĂ© pro poskytovĂˇnĂ­ historickĂ˝ch dat sezĂłny.
 *
 * RozhranĂ­ definuje kontrakt pro naÄŤĂ­tĂˇnĂ­ pĹ™ehledovĂ˝ch nebo statistickĂ˝ch ĂşdajĹŻ
 * vztahujĂ­cĂ­ch se ke konkrĂ©tnĂ­ sezĂłnÄ›. Implementace je odpovÄ›dnĂˇ za sestavenĂ­
 * historickĂ˝ch dat z pĹ™Ă­sluĹˇnĂ˝ch entit a jejich pĹ™evod do DTO vrstvy.
 *
 * Vrstva service zajiĹˇĹĄuje business logiku a agregace dat. Controller vrstva
 * vyuĹľĂ­vĂˇ toto rozhranĂ­ pro zpĹ™Ă­stupnÄ›nĂ­ historie sezĂłny klientovi aplikace.
 */
public interface SeasonHistoryService {

    /**
     * VracĂ­ historickĂˇ data pro zadanou sezĂłnu.
     *
     * Implementace naÄŤĂ­tĂˇ potĹ™ebnĂˇ data pro danou sezĂłnu,
     * provĂˇdĂ­ agregace nebo vĂ˝poÄŤty podle business pravidel
     * a vĂ˝sledek pĹ™evĂˇdĂ­ do seznamu {@link SeasonHistoryDTO}.
     *
     * @param seasonId IdentifikĂˇtor sezĂłny, pro kterou se historie naÄŤĂ­tĂˇ.
     * @return Seznam historickĂ˝ch zĂˇznamĹŻ sezĂłny ve formÄ› DTO.
     */
    List<SeasonHistoryDTO> getHistoryForSeason(Long seasonId);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\SeasonHistoryServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.season.repositories.SeasonHistoryRepository;
import cz.phsoft.hokej.season.dto.SeasonHistoryDTO;
import cz.phsoft.hokej.season.mappers.SeasonHistoryMapper;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * Implementace service vrstvy pouĹľĂ­vanĂˇ pro poskytovĂˇnĂ­ historickĂ˝ch dat sezĂłny.
 *
 * TĹ™Ă­da zajiĹˇĹĄuje naÄŤtenĂ­ zĂˇznamĹŻ historie sezĂłny z repository vrstvy a jejich pĹ™evod do DTO.
 * NaÄŤĂ­tĂˇnĂ­ dat se deleguje do {@link SeasonHistoryRepository} a mapovĂˇnĂ­ entit na DTO se deleguje
 * do {@link SeasonHistoryMapper}.
 *
 * Implementace neposkytuje zĂˇpisovou logiku a slouĹľĂ­ pouze pro ÄŤtenĂ­ a prezentaci historie sezĂłny
 * vyĹˇĹˇĂ­m vrstvĂˇm aplikace, typicky controller vrstvÄ›.
 */
@Service
public class SeasonHistoryServiceImpl implements SeasonHistoryService {

    private final SeasonHistoryRepository repository;
    private final SeasonHistoryMapper mapper;

    public SeasonHistoryServiceImpl(
            SeasonHistoryRepository repository,
            SeasonHistoryMapper mapper
    ) {
        this.repository = repository;
        this.mapper = mapper;
    }

    /**
     * VracĂ­ historickĂˇ data pro zadanou sezĂłnu seĹ™azenĂˇ od nejnovÄ›jĹˇĂ­ zmÄ›ny.
     *
     * Data se naÄŤĂ­tajĂ­ z repository vrstvy filtrovĂˇnĂ­m podle identifikĂˇtoru sezĂłny.
     * VĂ˝sledek se pĹ™evĂˇdĂ­ do {@link SeasonHistoryDTO} pomocĂ­ mapper vrstvy.
     *
     * @param seasonId IdentifikĂˇtor sezĂłny, pro kterou se historie naÄŤĂ­tĂˇ.
     * @return Seznam historickĂ˝ch zĂˇznamĹŻ sezĂłny ve formÄ› DTO seĹ™azenĂ˝ sestupnÄ› podle ÄŤasu zmÄ›ny.
     */
    @Override
    public List<SeasonHistoryDTO> getHistoryForSeason(Long seasonId) {
        return mapper.toDTOList(
                repository.findBySeasonIdOrderByChangedAtDesc(seasonId)
        );
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\SeasonService.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.season.entities.SeasonEntity;
import cz.phsoft.hokej.season.dto.SeasonDTO;

import java.util.List;

/**
 * RozhranĂ­ pro sprĂˇvu sezĂłn v aplikaci.
 *
 * OdpovÄ›dnosti:
 * - definovat kontrakt pro prĂˇci se sezĂłnami jako ÄŤasovĂ˝m rĂˇmcem pro zĂˇpasy a statistiky,
 * - poskytovat operace pro vytvoĹ™enĂ­, Ăşpravu a naÄŤtenĂ­ sezĂłn,
 * - urÄŤovat aktivnĂ­ sezĂłnu, kterĂˇ se pouĹľĂ­vĂˇ v ostatnĂ­ch sluĹľbĂˇch (napĹ™. MatchServiceImpl).
 *
 * Architektura:
 * - vÄ›tĹˇina operacĂ­ pracuje s {@link SeasonDTO} jako pĹ™enosovĂ˝m objektem,
 * - metoda {@link #getActiveSeason()} vracĂ­ entitu {@link SeasonEntity}
 *   pro internĂ­ business logiku v jinĂ˝ch sluĹľbĂˇch.
 */
public interface SeasonService {

    /**
     * VytvoĹ™Ă­ novou sezĂłnu.
     *
     * OdpovÄ›dnost implementace:
     * - validovat datumovĂ© rozmezĂ­ sezĂłny,
     * - zajistit, aby se obdobĂ­ sezĂłny nepĹ™ekrĂ˝valo s jinĂ˝mi sezĂłnami.
     *
     * @param season data novĂ© sezĂłny
     * @return vytvoĹ™enĂˇ sezĂłna ve formÄ› {@link SeasonDTO}
     */
    SeasonDTO createSeason(SeasonDTO season);

    /**
     * Aktualizuje existujĂ­cĂ­ sezĂłnu.
     *
     * Implementace typicky:
     * - ovÄ›Ĺ™uje existenci sezĂłny,
     * - validuje datumovĂ© rozmezĂ­ a pĹ™ekryvy,
     * - aplikuje zmÄ›ny z DTO do entity.
     *
     * @param id     ID sezĂłny, kterĂˇ mĂˇ bĂ˝t aktualizovĂˇna
     * @param season novĂ© hodnoty sezĂłny
     * @return aktualizovanĂˇ sezĂłna ve formÄ› {@link SeasonDTO}
     */
    SeasonDTO updateSeason(Long id, SeasonDTO season);

    /**
     * VrĂˇtĂ­ aktuĂˇlnÄ› aktivnĂ­ sezĂłnu.
     *
     * AktivnĂ­ sezĂłna pĹ™edstavuje ÄŤasovĂ˝ rĂˇmec, ve kterĂ©m se povaĹľujĂ­
     * zĂˇpasy a jejich statistiky za â€žplatnĂ©â€ś. Hodnota se pouĹľĂ­vĂˇ
     * v dalĹˇĂ­ch sluĹľbĂˇch, napĹ™Ă­klad v {@code MatchServiceImpl}.
     *
     * @return aktivnĂ­ sezĂłna jako entita {@link SeasonEntity}
     */
    SeasonEntity getActiveSeason();

    /**
     * VrĂˇtĂ­ seznam vĹˇech sezĂłn v systĂ©mu.
     *
     * Metoda se typicky pouĹľĂ­vĂˇ v administrĂˇtorskĂ˝ch pĹ™ehledech
     * a v UI pro sprĂˇvu sezĂłn.
     *
     * @return seznam vĹˇech sezĂłn ve formÄ› {@link SeasonDTO}
     */
    List<SeasonDTO> getAllSeasons();

    /**
     * NastavĂ­ zadanou sezĂłnu jako aktivnĂ­.
     *
     * Implementace zajiĹˇĹĄuje, Ĺľe v systĂ©mu existuje
     * vĹľdy nejvĂ˝Ĺˇe jedna aktivnĂ­ sezĂłna.
     *
     * @param seasonId ID sezĂłny, kterĂˇ mĂˇ bĂ˝t nastavena jako aktivnĂ­
     */
    void setActiveSeason(Long seasonId);

    /**
     * VrĂˇtĂ­ aktivnĂ­ sezĂłnu ve formÄ› {@link SeasonDTO} nebo null,
     * pokud ĹľĂˇdnĂˇ aktivnĂ­ sezĂłna nenĂ­ nastavena.
     *
     * Metoda se pouĹľĂ­vĂˇ tam, kde je absence aktivnĂ­ sezĂłny
     * platnĂ˝m a oÄŤekĂˇvanĂ˝m stavem.
     *
     * @return aktivnĂ­ sezĂłna nebo null
     */
    SeasonDTO getActiveSeasonOrNull();

    /**
     * VrĂˇtĂ­ sezĂłnu podle jejĂ­ho ID.
     *
     * PouĹľĂ­vĂˇ se v administrĂˇtorskĂ© ÄŤĂˇsti a internĂ­ logice,
     * kde je potĹ™eba pracovat s konkrĂ©tnĂ­ sezĂłnou.
     *
     * @param id ID sezĂłny
     * @return sezĂłna ve formÄ› {@link SeasonDTO}
     */
    SeasonDTO getSeasonById(Long id);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\SeasonServiceImpl.java
-----
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.season.entities.SeasonEntity;
import cz.phsoft.hokej.user.repositories.AppUserRepository;
import cz.phsoft.hokej.season.repositories.SeasonRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.season.dto.SeasonDTO;
import cz.phsoft.hokej.season.mappers.SeasonMapper;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import cz.phsoft.hokej.user.entities.AppUserEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;

import java.time.LocalDate;
import java.util.List;

/**
 * Implementace service vrstvy pouĹľĂ­vanĂˇ pro sprĂˇvu sezĂłn.
 *
 * TĹ™Ă­da zajiĹˇĹĄuje vytvĂˇĹ™enĂ­ a Ăşpravy sezĂłn vÄŤetnÄ› validace datumovĂ©ho rozsahu, kontroly pĹ™ekryvĹŻ a kontroly duplicity nĂˇzvu.
 * SouÄŤasnÄ› se zajiĹˇĹĄuje sprĂˇva aktivnĂ­ sezĂłny tak, aby byl v systĂ©mu v jeden okamĹľik aktivnĂ­ prĂˇvÄ› jeden zĂˇznam.
 *
 * NaÄŤĂ­tĂˇnĂ­ a uklĂˇdĂˇnĂ­ dat se deleguje do {@link SeasonRepository} a pĹ™evod mezi entitou a DTO se deleguje do {@link SeasonMapper}.
 * IdentifikĂˇtor autora vytvoĹ™enĂ­ sezĂłny se odvozuje z bezpeÄŤnostnĂ­ho kontextu a dohledĂˇvĂˇ se pĹ™es {@link AppUserRepository}.
 *
 * TĹ™Ă­da neĹ™eĹˇĂ­ autorizaci endpointĹŻ, protoĹľe kontrola oprĂˇvnÄ›nĂ­ se pĹ™edpoklĂˇdĂˇ v controller vrstvÄ›.
 * ZĂˇroveĹ se zde neodesĂ­lajĂ­ notifikace a Ĺ™eĹˇĂ­ se pouze konzistence domĂ©novĂ©ho stavu sezĂłn.
 */
@Service
public class SeasonServiceImpl implements SeasonService {

    private final SeasonRepository seasonRepository;
    private final SeasonMapper mapper;
    private final AppUserRepository appUserRepository;

    public SeasonServiceImpl(SeasonRepository seasonRepository,
                             SeasonMapper mapper,
                             AppUserRepository appUserRepository) {
        this.seasonRepository = seasonRepository;
        this.mapper = mapper;
        this.appUserRepository = appUserRepository;
    }

    // CREATE

    /**
     * VytvĂˇĹ™Ă­ novou sezĂłnu.
     *
     * PĹ™ed uloĹľenĂ­m se provĂˇdĂ­ validace datumovĂ©ho rozmezĂ­, kontrola pĹ™ekryvu s existujĂ­cĂ­mi sezĂłnami a kontrola duplicity nĂˇzvu.
     * NĂˇslednÄ› se DTO pĹ™evede na entitu a uloĹľĂ­ se pĹ™es repository vrstvu. Do entity se doplnĂ­ identifikĂˇtor uĹľivatele,
     * kterĂ˝ sezĂłnu vytvoĹ™il, pokud je moĹľnĂ© jej odvodit z autentizace.
     *
     * Po uloĹľenĂ­ se vynucuje invariant aktivnĂ­ sezĂłny. Pokud je novĂˇ sezĂłna oznaÄŤena jako aktivnĂ­, nastavĂ­ se jako jedinĂˇ aktivnĂ­.
     * Pokud aktivnĂ­ sezĂłna v systĂ©mu neexistuje, nastavĂ­ se vytvoĹ™enĂˇ sezĂłna jako aktivnĂ­ automaticky.
     *
     * @param seasonDTO VstupnĂ­ data sezĂłny.
     * @return VytvoĹ™enĂˇ sezĂłna ve formÄ› {@link SeasonDTO}.
     * @throws InvalidSeasonPeriodDateException Pokud jsou neplatnĂˇ data od a do.
     * @throws SeasonPeriodOverlapException Pokud se sezĂłna pĹ™ekrĂ˝vĂˇ s existujĂ­cĂ­ sezĂłnou.
     * @throws DuplicateSeasonNameException Pokud jiĹľ existuje sezĂłna se stejnĂ˝m nĂˇzvem.
     */
    @Override
    @Transactional
    public SeasonDTO createSeason(SeasonDTO seasonDTO) {
        validateDates(seasonDTO, null);
        checkSeasonName(seasonDTO, null);

        SeasonEntity entity = mapper.toEntity(seasonDTO);

        // *** NOVĂ‰ *** â€“ nastavĂ­me ID uĹľivatele, kterĂ˝ sezĂłnu vytvoĹ™il
        Long currentUserId = getCurrentUserIdOrNull();
        entity.setCreatedByUserId(currentUserId);

        SeasonEntity saved = seasonRepository.save(entity);

        long activeCount = seasonRepository.countByActiveTrue();

        if (seasonDTO.isActive()) {
            setOnlyActiveSeason(saved.getId());
        } else if (activeCount == 0) {
            setOnlyActiveSeason(saved.getId());
        }

        return mapper.toDTO(saved);
    }

    // UPDATE

    /**
     * Aktualizuje existujĂ­cĂ­ sezĂłnu.
     *
     * Nejprve se ovÄ›Ĺ™Ă­ existence sezĂłny podle identifikĂˇtoru. PotĂ© se zvaliduje datumovĂ© rozmezĂ­ a pĹ™ekryvy s ostatnĂ­mi sezĂłnami
     * s tĂ­m, Ĺľe upravovanĂˇ sezĂłna se pĹ™i kontrole pĹ™ekryvĹŻ ignoruje. SouÄŤasnÄ› se kontroluje duplicita nĂˇzvu sezĂłny.
     *
     * PĹ™i pokusu o deaktivaci aktivnĂ­ sezĂłny se ovÄ›Ĺ™uje, Ĺľe v systĂ©mu zĹŻstane alespoĹ jedna aktivnĂ­ sezĂłna.
     * NĂˇslednÄ› se zmÄ›ny z DTO promĂ­tnou do entity pomocĂ­ mapper vrstvy a sezĂłna se uloĹľĂ­ pĹ™es repository vrstvu.
     *
     * Pokud se sezĂłna stane novÄ› aktivnĂ­, nastavĂ­ se jako jedinĂˇ aktivnĂ­ sezĂłna a ostatnĂ­ sezĂłny se deaktivujĂ­.
     *
     * @param id IdentifikĂˇtor upravovanĂ© sezĂłny.
     * @param seasonDTO NovĂ© hodnoty sezĂłny.
     * @return AktualizovanĂˇ sezĂłna ve formÄ› {@link SeasonDTO}.
     * @throws SeasonNotFoundException Pokud sezĂłna s danĂ˝m ID neexistuje.
     * @throws InvalidSeasonPeriodDateException Pokud jsou neplatnĂˇ data od a do.
     * @throws SeasonPeriodOverlapException Pokud se sezĂłna pĹ™ekrĂ˝vĂˇ s jinou sezĂłnou.
     * @throws InvalidSeasonStateException Pokud se pokouĹˇĂ­ deaktivovat jedinĂˇ aktivnĂ­ sezĂłna.
     * @throws DuplicateSeasonNameException Pokud jiĹľ existuje sezĂłna se stejnĂ˝m nĂˇzvem.
     */
    @Override
    @Transactional
    public SeasonDTO updateSeason(Long id, SeasonDTO seasonDTO) {
        SeasonEntity existing = seasonRepository.findById(id)
                .orElseThrow(() -> new SeasonNotFoundException(id));

        validateDates(seasonDTO, id);
        checkSeasonName(seasonDTO, id);

        boolean wasActive = existing.isActive();
        boolean willBeActive = seasonDTO.isActive();

        if (wasActive && !willBeActive) {
            long activeCount = seasonRepository.countByActiveTrue();
            if (activeCount <= 1) {
                throw new InvalidSeasonStateException(
                        "BE - Nelze deaktivovat jedinou aktivnĂ­ sezĂłnu. " +
                                "Nejprve nastav jinou sezĂłnu jako aktivnĂ­."
                );
            }
        }

        mapper.updateEntityFromDTO(seasonDTO, existing);
        SeasonEntity saved = seasonRepository.save(existing);

        if (!wasActive && saved.isActive()) {
            setOnlyActiveSeason(saved.getId());
        }

        return mapper.toDTO(saved);
    }

    // AKTIVNĂŤ SEZĂ“NA

    /**
     * VracĂ­ aktuĂˇlnÄ› aktivnĂ­ sezĂłnu jako entitu.
     *
     * Metoda se pouĹľĂ­vĂˇ v service vrstvÄ› jako zdroj pravdy pro aktuĂˇlnĂ­ sezĂłnu, typicky pro filtrovĂˇnĂ­ zĂˇpasĹŻ nebo dalĹˇĂ­ch dat.
     * NaÄŤtenĂ­ se deleguje do {@link SeasonRepository}. Pokud aktivnĂ­ sezĂłna nenĂ­ nastavena, vyhazuje se {@link SeasonNotFoundException}.
     *
     * @return AktuĂˇlnÄ› aktivnĂ­ sezĂłna jako {@link SeasonEntity}.
     * @throws SeasonNotFoundException Pokud nenĂ­ nastavena ĹľĂˇdnĂˇ aktivnĂ­ sezĂłna.
     */
    @Override
    public SeasonEntity getActiveSeason() {
        return seasonRepository.findByActiveTrue()
                .orElseThrow(() -> new SeasonNotFoundException(
                        "BE - NenĂ­ nastavena ĹľĂˇdnĂˇ aktivnĂ­ sezĂłna."
                ));
    }

    /**
     * VracĂ­ aktuĂˇlnÄ› aktivnĂ­ sezĂłnu ve formÄ› DTO nebo null.
     *
     * Metoda se pouĹľĂ­vĂˇ v mĂ­stech, kde je absence aktivnĂ­ sezĂłny akceptovatelnĂˇ a nemĂˇ bĂ˝t povaĹľovĂˇna za chybovĂ˝ stav.
     * NaÄŤtenĂ­ se deleguje do {@link SeasonRepository} a mapovĂˇnĂ­ se deleguje do {@link SeasonMapper}.
     *
     * @return AktivnĂ­ sezĂłna ve formÄ› {@link SeasonDTO}, nebo null pokud aktivnĂ­ sezĂłna neexistuje.
     */
    @Override
    public SeasonDTO getActiveSeasonOrNull() {
        return seasonRepository.findByActiveTrue()
                .map(mapper::toDTO)
                .orElse(null);
    }

    /**
     * VracĂ­ sezĂłnu podle identifikĂˇtoru ve formÄ› DTO.
     *
     * SezĂłna se naÄŤĂ­tĂˇ z repository vrstvy. Pokud sezĂłna neexistuje, vyhazuje se {@link SeasonNotFoundException}.
     * MapovĂˇnĂ­ entity na DTO se deleguje do {@link SeasonMapper}.
     *
     * @param id IdentifikĂˇtor sezĂłny.
     * @return SezĂłna ve formÄ› {@link SeasonDTO}.
     * @throws SeasonNotFoundException Pokud sezĂłna s danĂ˝m ID neexistuje.
     */
    @Override
    public SeasonDTO getSeasonById(Long id) {
        SeasonEntity entity = seasonRepository.findById(id)
                .orElseThrow(() -> new SeasonNotFoundException(id));
        return mapper.toDTO(entity);
    }

    // SEZNAM VĹ ECH SEZĂ“N

    /**
     * VracĂ­ vĹˇechny sezĂłny seĹ™azenĂ© podle zaÄŤĂˇtku vzestupnÄ›.
     *
     * NaÄŤtenĂ­ se deleguje do {@link SeasonRepository} a mapovĂˇnĂ­ na DTO se deleguje do {@link SeasonMapper}.
     * Metoda se pouĹľĂ­vĂˇ pro administrativnĂ­ pĹ™ehledy a pro zobrazenĂ­ seznamu sezĂłn v uĹľivatelskĂ©m rozhranĂ­.
     *
     * @return Seznam vĹˇech sezĂłn ve formÄ› {@link SeasonDTO}.
     */
    @Override
    public List<SeasonDTO> getAllSeasons() {
        return seasonRepository.findAllByOrderByStartDateAsc()
                .stream()
                .map(mapper::toDTO)
                .toList();
    }

    // NASTAVENĂŤ AKTIVNĂŤ SEZĂ“NY

    /**
     * Nastavuje konkrĂ©tnĂ­ sezĂłnu jako aktivnĂ­.
     *
     * Nejprve se ovÄ›Ĺ™uje existence sezĂłny podle identifikĂˇtoru. NĂˇslednÄ› se provede nastavenĂ­ sezĂłny jako jedinĂ© aktivnĂ­
     * pomocĂ­ internĂ­ metody {@link #setOnlyActiveSeason(Long)}, kterĂˇ souÄŤasnÄ› deaktivuje vĹˇechny ostatnĂ­ sezĂłny.
     *
     * @param seasonId IdentifikĂˇtor sezĂłny, kterĂˇ mĂˇ bĂ˝t nastavena jako aktivnĂ­.
     * @throws SeasonNotFoundException Pokud sezĂłna s danĂ˝m ID neexistuje.
     */
    @Override
    @Transactional
    public void setActiveSeason(Long seasonId) {
        SeasonEntity toActivate = seasonRepository.findById(seasonId)
                .orElseThrow(() -> new SeasonNotFoundException(seasonId));

        setOnlyActiveSeason(toActivate.getId());
    }

    // PRIVĂTNĂŤ VALIDACE DAT

    /**
     * Validuje datumovĂ© rozmezĂ­ sezĂłny a kontroluje pĹ™ekryv s ostatnĂ­mi sezĂłnami.
     *
     * Kontroluje se, Ĺľe datum zaÄŤĂˇtku a konce nenĂ­ null, Ĺľe datum zaÄŤĂˇtku pĹ™edchĂˇzĂ­ datu konce a Ĺľe rozsah sezĂłny
     * nenĂ­ v pĹ™ekryvu s jinou sezĂłnou. PĹ™i aktualizaci se z kontroly pĹ™ekryvu vynechĂˇvĂˇ sezĂłna s identifikĂˇtorem
     * currentSeasonId.
     *
     * @param seasonDTO DTO s daty sezĂłny.
     * @param currentSeasonId IdentifikĂˇtor aktuĂˇlnĂ­ sezĂłny pĹ™i aktualizaci, nebo null pĹ™i vytvĂˇĹ™enĂ­.
     * @throws InvalidSeasonPeriodDateException Pokud jsou data neplatnĂˇ.
     * @throws SeasonPeriodOverlapException Pokud se sezĂłna pĹ™ekrĂ˝vĂˇ s jinou sezĂłnou.
     */
    private void validateDates(SeasonDTO seasonDTO, Long currentSeasonId) {
        LocalDate start = seasonDTO.getStartDate();
        LocalDate end = seasonDTO.getEndDate();

        if (start == null || end == null) {
            throw new InvalidSeasonPeriodDateException("BE - Datum od a do nesmĂ­ bĂ˝t null.");
        }
        if (!start.isBefore(end)) {
            throw new InvalidSeasonPeriodDateException("BE - Datum 'od' musĂ­ bĂ˝t pĹ™ed 'do'.");
        }

        boolean overlaps;
        if (currentSeasonId == null) {
            overlaps = seasonRepository
                    .existsByStartDateLessThanEqualAndEndDateGreaterThanEqual(end, start);
        } else {
            overlaps = seasonRepository
                    .existsByStartDateLessThanEqualAndEndDateGreaterThanEqualAndIdNot(
                            end,
                            start,
                            currentSeasonId
                    );
        }

        if (overlaps) {
            throw new SeasonPeriodOverlapException("BE - SezĂłna se pĹ™ekrĂ˝vĂˇ s existujĂ­cĂ­ sezĂłnou.");
        }
    }

    /**
     * Validuje nĂˇzev sezĂłny kontrolou duplicity vĹŻÄŤi ostatnĂ­m sezĂłnĂˇm.
     *
     * PĹ™i vytvĂˇĹ™enĂ­ se ovÄ›Ĺ™uje existence nĂˇzvu vĹŻÄŤi vĹˇem sezĂłnĂˇm. PĹ™i aktualizaci se kontrola provĂˇdĂ­ vĹŻÄŤi vĹˇem sezĂłnĂˇm
     * s tĂ­m, Ĺľe sezĂłna s identifikĂˇtorem currentSeasonId se z kontroly vynechĂˇvĂˇ.
     *
     * @param seasonDTO DTO s daty sezĂłny.
     * @param currentSeasonId IdentifikĂˇtor aktuĂˇlnĂ­ sezĂłny pĹ™i aktualizaci, nebo null pĹ™i vytvĂˇĹ™enĂ­.
     * @throws DuplicateSeasonNameException Pokud jiĹľ existuje sezĂłna se stejnĂ˝m nĂˇzvem.
     */
    private void checkSeasonName(SeasonDTO seasonDTO, Long currentSeasonId) {
        String seasonName = seasonDTO.getName().trim();

        boolean existSeasonName;
        if (currentSeasonId == null) {
            existSeasonName = seasonRepository.existsByName(seasonName);
        } else {
            existSeasonName = seasonRepository.existsByNameAndIdNot(seasonName, currentSeasonId);
        }

        if (existSeasonName) {
            throw new DuplicateSeasonNameException(seasonName);
        }
    }

    // PRIVĂTNĂŤ POMOCNĂ METODA

    /**
     * Nastavuje zadanou sezĂłnu jako jedinou aktivnĂ­.
     *
     * VĹˇechny sezĂłny se naÄŤtou z repository vrstvy a nĂˇslednÄ› se u sezĂłny se zadanĂ˝m identifikĂˇtorem nastavĂ­ active na true,
     * zatĂ­mco u vĹˇech ostatnĂ­ch sezĂłn se active nastavĂ­ na false. ZmÄ›ny se uloĹľĂ­ hromadnÄ› pĹ™es {@link SeasonRepository}.
     * TĂ­m se vynucuje invariant, Ĺľe v systĂ©mu existuje v jeden okamĹľik prĂˇvÄ› jedna aktivnĂ­ sezĂłna.
     *
     * @param activeSeasonId IdentifikĂˇtor sezĂłny, kterĂˇ mĂˇ bĂ˝t nastavena jako jedinĂˇ aktivnĂ­.
     */
    private void setOnlyActiveSeason(Long activeSeasonId) {
        List<SeasonEntity> all = seasonRepository.findAll();
        for (SeasonEntity season : all) {
            season.setActive(season.getId().equals(activeSeasonId));
        }
        seasonRepository.saveAll(all);
    }

    /**
     * VracĂ­ identifikĂˇtor aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele nebo null, pokud nenĂ­ moĹľnĂ© uĹľivatele urÄŤit.
     *
     * IdentifikĂˇtor se odvozuje z autentizace v bezpeÄŤnostnĂ­m kontextu. Jako klĂ­ÄŤ se pouĹľĂ­vĂˇ e-mail uĹľivatele
     * a dohledĂˇnĂ­ se provĂˇdĂ­ pĹ™es {@link AppUserRepository}. Pokud autentizace neexistuje, uĹľivatel nenĂ­ pĹ™ihlĂˇĹˇen
     * nebo zĂˇznam uĹľivatele nelze dohledat, vracĂ­ se null.
     *
     * @return IdentifikĂˇtor aktuĂˇlnĂ­ho uĹľivatele, nebo null pokud jej nelze urÄŤit.
     */
    private Long getCurrentUserIdOrNull() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth == null || !auth.isAuthenticated()) {
            return null;
        }

        String email = auth.getName();
        return appUserRepository.findByEmail(email)
                .map(AppUserEntity::getId)
                .orElse(null);
    }
}
