Balíček (složka): services
Cesta: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services

Seznam souborů:
AppUserService.java
AppUserServiceImpl.java
AppUserSettingsService.java
AppUserSettingsServiceImpl.java
CurrentPlayerService.java
CurrentPlayerServiceImpl.java
CurrentSeasonService.java
CurrentSeasonServiceImpl.java
MatchRegistrationHistoryService.java
MatchRegistrationHistoryServiceImpl.java
MatchRegistrationService.java
MatchRegistrationServiceImpl.java
MatchService.java
MatchServiceImpl.java
NotificationDecision.java
PlayerInactivityPeriodService.java
PlayerInactivityPeriodServiceImpl.java
PlayerService.java
PlayerServiceImpl.java
PlayerSettingsService.java
PlayerSettingsServiceImpl.java
SeasonService.java
SeasonServiceImpl.java



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.ForgottenPasswordResetDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;

import java.util.List;

/**
 * Rozhraní pro správu uživatelských účtů aplikace.
 *
 * Definuje se smlouva pro registraci uživatelů, změnu a reset hesla,
 * aktivaci nebo deaktivaci účtů a čtení seznamů uživatelů. Rozhraní
 * se používá v controller vrstvách a v dalších service třídách.
 *
 * Implementace pracuje s DTO objekty a zajišťuje napojení
 * na perzistenční vrstvu (repozitáře) a notifikační mechanismy.
 */
public interface AppUserService {

    /**
     * Zaregistruje nového uživatele do systému.
     *
     * Provádí se kontrola jedinečnosti emailu, shody hesla a jeho potvrzení
     * a další validační pravidla. Nový účet se typicky zakládá jako neaktivní
     * a jeho aktivace se dokončuje přes aktivační odkaz.
     *
     * @param registerUserDTO registrační data nového uživatele
     */
    void register(RegisterUserDTO registerUserDTO);

    /**
     * Aktualizuje údaje uživatele podle emailu.
     *
     * Používá se pro změny běžných údajů (jméno, příjmení, email).
     * Bezpečnost a oprávnění se kontrolují v controller vrstvě.
     *
     * @param email email uživatele, který má být aktualizován
     * @param dto   nové hodnoty uživatelských údajů
     */
    void updateUser(String email, AppUserDTO dto);

    /**
     * Vrací aktuálně přihlášeného uživatele podle emailu.
     *
     * Metoda se používá zejména v kontextu endpointů typu "/me".
     *
     * @param email email přihlášeného uživatele
     * @return DTO reprezentace aktuálního uživatele
     */
    AppUserDTO getCurrentUser(String email);

    /**
     * Vrací seznam všech uživatelů v systému.
     *
     * Typicky se používá v administrátorském rozhraní
     * pro správu uživatelů.
     *
     * @return seznam uživatelů ve formě DTO
     */
    List<AppUserDTO> getAllUsers();

    /**
     * Vrací uživatele podle ID.
     *
     * Používá se v administraci, kde je potřeba pracovat
     * s konkrétním účtem podle jeho identifikátoru.
     *
     * @param userId ID uživatele
     * @return uživatel ve formě DTO
     */
    AppUserDTO getUserById(Long userId);

    /**
     * Změní heslo uživatele.
     *
     * Ověřuje se správnost původního hesla, shoda nového hesla
     * a jeho potvrzení a případné bezpečnostní požadavky.
     *
     * @param email              email uživatele
     * @param oldPassword        původní heslo
     * @param newPassword        nové heslo
     * @param newPasswordConfirm potvrzení nového hesla
     */
    void changePassword(
            String email,
            String oldPassword,
            String newPassword,
            String newPasswordConfirm
    );

    /**
     * Resetuje heslo uživatele na výchozí hodnotu.
     *
     * Operace se typicky používá v administraci, kde se řeší
     * problémy s přihlášením. Konkrétní politika bezpečného
     * zacházení s takovým heslem se řeší v aplikační logice.
     *
     * @param userId ID uživatele, jehož heslo má být resetováno
     */
    void resetPassword(Long userId);

    /**
     * Aktivuje uživatelský účet na základě aktivačního tokenu.
     *
     * Metoda se používá po registraci uživatele, kdy je odkaz
     * zaslán v aktivačním emailu. Při úspěchu se účet označí
     * jako povolený k přihlášení.
     *
     * @param token aktivační token
     * @return true, pokud byla aktivace úspěšná, jinak false
     */
    boolean activateUser(String token);

    /**
     * Aktivuje uživatelský účet v administraci.
     *
     * Aktivace se provádí bez použití aktivačního tokenu,
     * typicky v situaci, kdy má uživatel technický problém
     * s aktivačním emailem.
     *
     * @param id ID uživatele
     */
    void activateUserByAdmin(Long id);

    /**
     * Deaktivuje uživatelský účet v administraci.
     *
     * Účet se ponechá v databázi, ale uživatel se nemůže
     * dočasně přihlásit do aplikace.
     *
     * @param id ID uživatele
     */
    void deactivateUserByAdmin(Long id);

    /**
     * Vytvoří požadavek na reset zapomenutého hesla.
     *
     * Pro daný email se vygeneruje resetovací token a odešle
     * se odpovídající notifikace (například email s odkazem
     * na formulář pro nastavení nového hesla).
     *
     * @param email email uživatele
     */
    void requestForgottenPasswordReset(String email);

    /**
     * Vrací email uživatele pro zadaný resetovací token.
     *
     * Metoda se používá při načítání formuláře pro nastavení
     * nového hesla, aby se ověřilo, ke kterému účtu token patří.
     *
     * @param token resetovací token
     * @return email uživatele
     */
    String getForgottenPasswordResetEmail(String token);

    /**
     * Nastaví nové heslo na základě tokenu pro zapomenuté heslo.
     *
     * Token se ověří, zkontroluje se shoda hesla a jeho potvrzení
     * a poté se heslo uloží v zahashované podobě.
     *
     * @param dto data pro reset zapomenutého hesla
     */
    void forgottenPasswordReset(ForgottenPasswordResetDTO dto);
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.EmailVerificationTokenEntity;
import cz.phsoft.hokej.data.entities.ForgottenPasswordResetTokenEntity;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.EmailVerificationTokenRepository;
import cz.phsoft.hokej.data.repositories.ForgottenPasswordResetTokenRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.ForgottenPasswordResetDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;
import cz.phsoft.hokej.models.mappers.AppUserMapper;
import cz.phsoft.hokej.models.services.email.EmailService;
import cz.phsoft.hokej.models.services.notification.ForgottenPasswordResetContext;
import cz.phsoft.hokej.models.services.notification.NotificationService;
import cz.phsoft.hokej.models.services.notification.UserActivationContext;
import jakarta.transaction.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

/**
 * Service pro správu aplikačních uživatelských účtů.
 *
 * Zajišťuje se registrace, aktivace a deaktivace účtů,
 * změna a reset hesla a aktualizace základních údajů uživatele.
 * Třída se stará o bezpečné uložení hesel, práci s ověřovacími
 * a resetovacími tokeny a napojení na notifikační systém.
 *
 * Autentizace a autorizace se předpokládá v Spring Security,
 * nikoliv v této třídě.
 */
@Service
public class AppUserServiceImpl implements AppUserService {

    private static final Logger log = LoggerFactory.getLogger(AppUserServiceImpl.class);

    /**
     * Výchozí heslo při resetu účtu administrátorem.
     */
    private static final String DEFAULT_RESET_PASSWORD = "Player123";

    /**
     * Základní URL aplikace používaná pro generování odkazů
     * v aktivačních a resetovacích emailech.
     */
    @Value("${app.base-url}")
    private String baseUrl;

    private String buildActivationLink(EmailVerificationTokenEntity token) {
        return baseUrl + "/api/auth/verify?token=" + token.getToken();
    }

    private String buildResetPasswordlink(ForgottenPasswordResetTokenEntity token) {
        return baseUrl + "/api/auth/reset-password?token=" + token.getToken();
    }

    private final AppUserRepository userRepository;
    private final BCryptPasswordEncoder passwordEncoder;
    private final AppUserMapper appUserMapper;
    private final EmailService emailService;
    private final EmailVerificationTokenRepository tokenRepository;
    private final AppUserSettingsService appUserSettingsService;
    private final NotificationService notificationService;
    private final ForgottenPasswordResetTokenRepository forgottenPasswordResetTokenRepository;

    public AppUserServiceImpl(AppUserRepository userRepository,
                              BCryptPasswordEncoder passwordEncoder,
                              AppUserMapper appUserMapper,
                              EmailService emailService,
                              EmailVerificationTokenRepository tokenRepository,
                              AppUserSettingsService appUserSettingsService,
                              NotificationService notificationService,
                              ForgottenPasswordResetTokenRepository forgottenPasswordResetTokenRepository) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
        this.appUserMapper = appUserMapper;
        this.emailService = emailService;
        this.tokenRepository = tokenRepository;
        this.appUserSettingsService = appUserSettingsService;
        this.notificationService = notificationService;
        this.forgottenPasswordResetTokenRepository = forgottenPasswordResetTokenRepository;
    }

    /**
     * Zaregistruje nového uživatele.
     *
     * Provádí se kontrola shody hesel a jedinečnosti emailu.
     * Uživatel se vytvoří jako neaktivní, vygeneruje se ověřovací token
     * a odešle se notifikační zpráva s aktivačním odkazem.
     *
     * @param dto registrační údaje uživatele
     */
    @Override
    @Transactional
    public void register(RegisterUserDTO dto) {

        ensurePasswordsMatch(dto.getPassword(), dto.getPasswordConfirm(), null);
        ensureEmailNotUsed(dto.getEmail(), null);

        AppUserEntity user = createUserFromRegisterDto(dto);
        AppUserEntity savedUser = userRepository.save(user);

        EmailVerificationTokenEntity verificationToken =
                createVerificationToken(savedUser);

        String activationLink = buildActivationLink(verificationToken);
        log.info("Aktivační odkaz pro {}: {}", user.getEmail(), activationLink);

        notificationService.notifyUser(
                savedUser,
                NotificationType.USER_CREATED,
                new UserActivationContext(savedUser, activationLink)
        );
    }

    /**
     * Aktivuje uživatelský účet na základě ověřovacího tokenu.
     *
     * Token se ověří, zkontroluje se jeho platnost a případně
     * se účet označí jako povolený. Pokud uživatel nemá nastavení,
     * vytvoří se pro něj výchozí konfigurace.
     *
     * @param token aktivační token
     * @return true při úspěšné aktivaci, jinak false
     */
    @Override
    @Transactional
    public boolean activateUser(String token) {

        EmailVerificationTokenEntity verificationToken =
                tokenRepository.findByToken(token).orElse(null);

        if (verificationToken == null ||
                verificationToken.getExpiresAt().isBefore(LocalDateTime.now())) {
            return false;
        }

        AppUserEntity user = verificationToken.getUser();
        boolean newlyActivated = false;

        if (!user.isEnabled()) {
            user.setEnabled(true);
            newlyActivated = true;

            if (user.getSettings() == null) {
                appUserSettingsService.createDefaultSettingsForUser(user);
            }
            userRepository.save(user);
        }

        tokenRepository.delete(verificationToken);

        if (newlyActivated) {
            notifyUser(user, NotificationType.USER_ACTIVATED);
        }
        return true;
    }

    /**
     * Aktivuje uživatelský účet v administraci.
     *
     * Kontroluje se, zda není účet již aktivní. Pokud nemá uživatel
     * nastavení, vytvoří se pro něj výchozí AppUserSettingsEntity.
     * Všechny aktivační tokeny se odstraní a odešle se notifikace
     * o úspěšné aktivaci.
     *
     * @param id ID uživatele
     */
    @Override
    public void activateUserByAdmin(Long id) {
        AppUserEntity user = findUserByIdOrThrow(id);
        if (user.isEnabled()) {
            throw new InvalidUserActivationException(
                    "BE - Aktivace účtu již byla provedena"
            );
        }
        boolean newlyActivated = false;

        if (!user.isEnabled()) {
            user.setEnabled(true);
            newlyActivated = true;

            if (user.getSettings() == null) {
                appUserSettingsService.createDefaultSettingsForUser(user);
            }

            userRepository.save(user);
        }

        tokenRepository.deleteByUser(user);

        if (newlyActivated) {
            notifyUser(user, NotificationType.USER_ACTIVATED);
        }

    }

    /**
     * Aktualizuje základní údaje uživatele podle emailu.
     *
     * Při změně emailu se ověřuje, že nový email není obsazen
     * jiným účtem. Po úspěšné aktualizaci se odešle notifikace.
     *
     * @param email email aktuálního uživatele
     * @param dto   aktualizovaná data účtu
     */
    @Override
    @Transactional
    public void updateUser(String email, AppUserDTO dto) {

        AppUserEntity user = findUserByEmailOrThrow(email);

        if (!user.getEmail().equals(dto.getEmail())) {
            ensureEmailNotUsed(dto.getEmail(), user.getId());
        }

        user.setName(dto.getName());
        user.setSurname(dto.getSurname());
        user.setEmail(dto.getEmail());

        userRepository.save(user);
        notifyUser(user, NotificationType.USER_UPDATED);
    }

    /**
     * Vrací detail aktuálně přihlášeného uživatele.
     *
     * @param email email uživatele
     * @return DTO reprezentace uživatele
     */
    @Override
    public AppUserDTO getCurrentUser(String email) {
        AppUserEntity user = findUserByEmailOrThrow(email);
        return appUserMapper.toDTO(user);
    }

    /**
     * Vrací všechny uživatele systému.
     *
     * Výsledek se mapuje na DTO a používá se v administraci
     * pro přehled a správu uživatelských účtů.
     *
     * @return seznam uživatelů
     */
    @Override
    public List<AppUserDTO> getAllUsers() {
        return userRepository.findAll().stream()
                .map(appUserMapper::toDTO)
                .toList();
    }

    /**
     * Změní heslo aktuálního uživatele.
     *
     * Ověří se shoda nového hesla a potvrzení, poté se zkontroluje
     * původní heslo pomocí BCrypt. Po úspěšné změně se odešle
     * notifikace o změně hesla.
     *
     * @param email              email uživatele
     * @param oldPassword        původní heslo
     * @param newPassword        nové heslo
     * @param newPasswordConfirm potvrzení nového hesla
     */
    @Override
    @Transactional
    public void changePassword(String email,
                               String oldPassword,
                               String newPassword,
                               String newPasswordConfirm) {

        ensurePasswordsMatch(
                newPassword,
                newPasswordConfirm,
                "BE - Nové heslo a potvrzení nového hesla se neshodují"
        );

        AppUserEntity user = findUserByEmailOrThrow(email);

        if (!passwordEncoder.matches(oldPassword, user.getPassword())) {
            throw new InvalidOldPasswordException();
        }

        user.setPassword(passwordEncoder.encode(newPassword));
        userRepository.save(user);

        notifyUser(user, NotificationType.USER_CHANGE_PASSWORD);
    }

    /**
     * Resetuje heslo uživatele na výchozí hodnotu.
     *
     * Používá se v administraci při ručním resetu hesla. Po změně
     * se odešle notifikace o resetu hesla.
     *
     * @param userId ID uživatele
     */
    @Override
    @Transactional
    public void resetPassword(Long userId) {
        AppUserEntity user = findUserByIdOrThrow(userId);
        user.setPassword(passwordEncoder.encode(DEFAULT_RESET_PASSWORD));
        userRepository.save(user);

        notifyUser(user, NotificationType.PASSWORD_RESET);
    }

    /**
     * Deaktivuje uživatelský účet v administraci.
     *
     * Pokud je účet již deaktivovaný, vyhodí se výjimka.
     * Po deaktivaci se odešle notifikace.
     *
     * @param id ID uživatele
     */
    @Override
    public void deactivateUserByAdmin(Long id) {
        AppUserEntity user = findUserByIdOrThrow(id);

        if (!user.isEnabled()) {
            throw new InvalidUserActivationException(
                    "BE - Deaktivace účtu již byla provedena"
            );
        }
        user.setEnabled(false);
        userRepository.save(user);
        notifyUser(user, NotificationType.USER_DEACTIVATED);

    }

    /**
     * Vrací uživatele podle ID ve formě DTO.
     *
     * Používá se v administraci při zobrazení detailu účtu.
     *
     * @param id ID uživatele
     * @return DTO reprezentace uživatele
     */
    public AppUserDTO getUserById(Long id) {
        AppUserEntity user = findUserByIdOrThrow(id);
        return appUserMapper.toDTO(user);
    }

    /**
     * Vytvoří požadavek na reset zapomenutého hesla.
     *
     * Případné staré tokeny se odstraní a vygeneruje se nový
     * resetovací token. Navenek se neprozrazuje, zda email
     * v systému existuje, kvůli bezpečnosti.
     *
     * @param email email uživatele
     */
    @Override
    @Transactional
    public void requestForgottenPasswordReset(String email) {

        AppUserEntity user = userRepository.findByEmail(email)
                .orElse(null);

        if (user == null) {
            log.info("Požadavek na forgotten password reset pro neexistující email: {}", email);
            return;
        }

        forgottenPasswordResetTokenRepository.deleteByUser(user);

        ForgottenPasswordResetTokenEntity forgottenPasswordToken = createResetPasswordToken(user);

        String resetPasswordlink = buildResetPasswordlink(forgottenPasswordToken);

        log.info("Odkaz pro reset hesla {}: {}", user.getEmail(), resetPasswordlink);

        notifyUser(
                user,
                NotificationType.FORGOTTEN_PASSWORD_RESET_REQUEST,
                new ForgottenPasswordResetContext(user, resetPasswordlink)
        );
    }

    /**
     * Vrací email uživatele svázaný s daným resetovacím tokenem.
     *
     * Ověřuje se platnost a neexpirovanost tokenu. Metoda se používá
     * při načítání formuláře pro zadání nového hesla.
     *
     * @param token resetovací token
     * @return email uživatele
     */
    @Override
    @Transactional
    public String getForgottenPasswordResetEmail(String token) {

        ForgottenPasswordResetTokenEntity resetToken =
                forgottenPasswordResetTokenRepository.findByToken(token)
                        .orElseThrow(InvalidResetTokenException::new);

        if (resetToken.getExpiresAt().isBefore(LocalDateTime.now())) {
            throw new InvalidResetTokenException("BE - Reset token expiroval.");
        }

        return resetToken.getUser().getEmail();
    }

    /**
     * Nastaví nové heslo na základě resetovacího tokenu.
     *
     * Provádí se kontrola shody nového hesla a jeho potvrzení,
     * ověření platnosti tokenu a následné uložení nového hesla
     * v zahashované podobě. Token se poté odstraní
     * a odešle se notifikace o dokončení resetu hesla.
     *
     * @param dto data pro reset zapomenutého hesla
     */
    @Override
    @Transactional
    public void forgottenPasswordReset(ForgottenPasswordResetDTO dto) {

        ensurePasswordsMatch(
                dto.getNewPassword(),
                dto.getNewPasswordConfirm(),
                "BE - Nové heslo a potvrzení nového hesla se neshodují"
        );

        ForgottenPasswordResetTokenEntity resetToken =
                forgottenPasswordResetTokenRepository.findByToken(dto.getToken())
                        .orElseThrow(InvalidResetTokenException::new);

        if (resetToken.getExpiresAt().isBefore(LocalDateTime.now())) {
            throw new InvalidResetTokenException("BE - Reset token expiroval.");
        }

        AppUserEntity user = resetToken.getUser();

        user.setPassword(passwordEncoder.encode(dto.getNewPassword()));
        userRepository.save(user);

        forgottenPasswordResetTokenRepository.delete(resetToken);

        notifyUser(user, NotificationType.FORGOTTEN_PASSWORD_RESET_COMPLETED);
    }

    // ==================================================
    // HELPER METODY
    // ==================================================

    private AppUserEntity findUserByEmailOrThrow(String email) {
        return userRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException(email));
    }

    private AppUserEntity findUserByIdOrThrow(Long id) {
        return userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException(id));
    }

    /**
     * Ověří shodu hesla a jeho potvrzení.
     *
     * Pokud se hodnoty neshodují, vyhodí se výjimka
     * PasswordsDoNotMatchException s případnou vlastním textem.
     */
    private void ensurePasswordsMatch(String password,
                                      String confirm,
                                      String customMessage) {

        if (password == null || confirm == null || !password.equals(confirm)) {
            if (customMessage == null) {
                throw new PasswordsDoNotMatchException();
            }
            throw new PasswordsDoNotMatchException(customMessage);
        }
    }

    /**
     * Ověří, že email není používán jiným uživatelem.
     *
     * @param email         nový email
     * @param currentUserId ID aktuálního uživatele nebo null při registraci
     */
    private void ensureEmailNotUsed(String email, Long currentUserId) {
        userRepository.findByEmail(email).ifPresent(existing -> {
            if (currentUserId == null || !existing.getId().equals(currentUserId)) {
                throw new UserAlreadyExistsException(
                        "BE - Uživatel s tímto emailem již existuje"
                );
            }
        });
    }

    /**
     * Vytvoří nového uživatele z registračního DTO.
     *
     * Uživatel se nastaví jako neaktivní s rolí hráče.
     *
     * @param dto registrační data
     * @return nová entita uživatele
     */
    private AppUserEntity createUserFromRegisterDto(RegisterUserDTO dto) {
        AppUserEntity user = appUserMapper.fromRegisterDto(dto);
        user.setPassword(passwordEncoder.encode(dto.getPassword()));
        user.setRole(Role.ROLE_PLAYER);
        user.setEnabled(false);
        return user;
    }

    /**
     * Vytvoří a uloží aktivační token pro uživatele.
     *
     * Token je platný omezenou dobu a používá se
     * při aktivaci účtu přes email.
     *
     * @param user uživatel, pro kterého se token vytváří
     * @return uložený aktivační token
     */
    private EmailVerificationTokenEntity createVerificationToken(AppUserEntity user) {
        EmailVerificationTokenEntity token = new EmailVerificationTokenEntity();
        token.setToken(UUID.randomUUID().toString());
        token.setUser(user);
        token.setExpiresAt(LocalDateTime.now().plusHours(24));
        return tokenRepository.save(token);
    }

    /**
     * Vytvoří a uloží resetovací token pro zapomenuté heslo.
     *
     * Token se používá v procesu resetu hesla a má omezenou platnost.
     *
     * @param user uživatel, pro kterého se token vytváří
     * @return uložený resetovací token
     */
    private ForgottenPasswordResetTokenEntity createResetPasswordToken(AppUserEntity user) {
        ForgottenPasswordResetTokenEntity token = new ForgottenPasswordResetTokenEntity();
        token.setToken(UUID.randomUUID().toString());
        token.setUser(user);
        token.setExpiresAt(LocalDateTime.now().plusHours(1));
        return forgottenPasswordResetTokenRepository.save(token);
    }

    /**
     * Odesílá notifikaci uživateli bez kontextu.
     */
    private void notifyUser(AppUserEntity user, NotificationType type) {
        notificationService.notifyUser(user, type, null);
    }

    /**
     * Odesílá notifikaci uživateli s volitelným kontextem.
     */
    private void notifyUser(AppUserEntity user, NotificationType type, Object context) {
        notificationService.notifyUser(user, type, context);
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserSettingsService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.AppUserSettingsEntity;
import cz.phsoft.hokej.models.dto.AppUserSettingsDTO;

/**
 * Service se používá pro práci s uživatelským nastavením.
 *
 * Odpovědností je získávání, vytváření a aktualizace nastavení
 * v kontextu uživatelského účtu, nikoli v kontextu hráče.
 * V této vrstvě se používá typ AppUserSettingsDTO, aby byla
 * oddělena prezentační vrstva od perzistentních entit.
 */
public interface AppUserSettingsService {

    /**
     * Vrátí nastavení pro uživatele identifikovaného e-mailem.
     * Pokud nastavení neexistuje, vytvoří se nový záznam
     * s výchozími hodnotami a uloží se k danému uživateli.
     *
     * Metoda se typicky používá v controlleru pro načtení
     * dat do formuláře na frontendu.
     *
     * @param userEmail e-mail uživatele, který slouží jako unikátní login
     * @return nastavení uživatele převedené do AppUserSettingsDTO
     */
    AppUserSettingsDTO getSettingsForUser(String userEmail);

    /**
     * Aktualizuje nastavení pro uživatele identifikovaného e-mailem.
     * Pokud uživatel nemá dosud žádné nastavení, vytvoří se nejprve
     * výchozí záznam a poté se na něj aplikují hodnoty z DTO.
     *
     * Metoda se obvykle volá z controlleru po odeslání formuláře
     * s uživatelskými preferencemi.
     *
     * @param userEmail e-mail uživatele, pro kterého se nastavení aktualizuje
     * @param dto nové hodnoty nastavení z frontendu
     * @return aktuální stav nastavení po uložení v podobě AppUserSettingsDTO
     */
    AppUserSettingsDTO updateSettingsForUser(String userEmail, AppUserSettingsDTO dto);

    /**
     * Vytvoří výchozí nastavení pro daného uživatele.
     *
     * Metoda se používá interně při prvním přístupu k nastavení,
     * kdy neexistuje žádný záznam v tabulce s nastavením.
     * Výchozí hodnoty se nastaví tak, aby byla aplikace použitelná
     * i bez ručního nastavení.
     *
     * @param user entita uživatele, ke které se nastavení naváže
     * @return nově vytvořená entita AppUserSettingsEntity s výchozími hodnotami
     */
    AppUserSettingsEntity createDefaultSettingsForUser(AppUserEntity user);

}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserSettingsServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.AppUserSettingsEntity;
import cz.phsoft.hokej.data.enums.GlobalNotificationLevel;
import cz.phsoft.hokej.data.enums.PlayerSelectionMode;
import cz.phsoft.hokej.data.repositories.AppUserSettingsRepository;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.exceptions.UserNotFoundException;
import cz.phsoft.hokej.models.dto.AppUserSettingsDTO;
import cz.phsoft.hokej.models.mappers.AppUserSettingsMapper;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

/**
 * Implementace service pro práci s uživatelským nastavením.
 *
 * Odpovědností je vyhledávání uživatele podle e-mailu,
 * získávání nebo vytváření odpovídajícího AppUserSettingsEntity
 * a mapování na AppUserSettingsDTO. V rámci této třídy se udržuje
 * vazba mezi nastavením a uživatelským účtem.
 *
 * Třída představuje transakční hranici pro operace s uživatelským
 * nastavením. Validace vstupů z HTTP vrstvy a autorizace se řeší
 * v controllerech a bezpečnostní vrstvě.
 */
@Service
@Transactional
public class AppUserSettingsServiceImpl implements AppUserSettingsService {

    private final AppUserRepository appUserRepository;
    private final AppUserSettingsRepository appUserSettingsRepository;
    private final AppUserSettingsMapper mapper;

    /**
     * Vytvoří instanci service s repository a mapperem.
     *
     * Repository se používají pro práci s entitami AppUserEntity
     * a AppUserSettingsEntity. Mapper zajišťuje převod mezi entitou
     * a AppUserSettingsDTO pro komunikaci s frontendem.
     *
     * @param appUserRepository repository pro uživatelské účty
     * @param appUserSettingsRepository repository pro uživatelská nastavení
     * @param mapper mapper pro převod mezi entitou a DTO
     */
    public AppUserSettingsServiceImpl(AppUserRepository appUserRepository,
                                      AppUserSettingsRepository appUserSettingsRepository,
                                      AppUserSettingsMapper mapper) {
        this.appUserRepository = appUserRepository;
        this.appUserSettingsRepository = appUserSettingsRepository;
        this.mapper = mapper;
    }

    /**
     * Načte nastavení pro uživatele identifikovaného e-mailem.
     *
     * Pokud nastavení neexistuje, vytvoří se nová entita s výchozími
     * hodnotami pomocí metody createDefaultSettingsForUser a uloží se.
     * Volající část aplikace tak vždy obdrží validní nastavení.
     *
     * @param userEmail e-mail uživatele, pro kterého se nastavení načítá
     * @return AppUserSettingsDTO s aktuálním nastavením uživatele
     * @throws UserNotFoundException pokud uživatel s daným e-mailem neexistuje
     */
    @Override
    public AppUserSettingsDTO getSettingsForUser(String userEmail) {
        AppUserEntity user = findUserByEmailOrThrow(userEmail);

        Optional<AppUserSettingsEntity> existingOpt = appUserSettingsRepository.findByUser(user);

        AppUserSettingsEntity settings = existingOpt.orElseGet(() -> {
            AppUserSettingsEntity created = createDefaultSettingsForUser(user);
            return appUserSettingsRepository.save(created);
        });

        return mapper.toDTO(settings);
    }

    /**
     * Aktualizuje nastavení pro uživatele identifikovaného e-mailem.
     *
     * Pokud uživatel žádné nastavení nemá, vytvoří se nová entita
     * s výchozími hodnotami a následně se do ní aplikují hodnoty
     * z předaného DTO. Je zajištěno, že nastavení je navázáno
     * na správného uživatele.
     *
     * @param userEmail e-mail uživatele, pro kterého se nastavení aktualizuje
     * @param dto nové hodnoty nastavení z frontendu
     * @return AppUserSettingsDTO reprezentující uložené nastavení
     * @throws UserNotFoundException pokud uživatel s daným e-mailem neexistuje
     */
    @Override
    public AppUserSettingsDTO updateSettingsForUser(String userEmail, AppUserSettingsDTO dto) {
        AppUserEntity user = findUserByEmailOrThrow(userEmail);

        AppUserSettingsEntity settings = appUserSettingsRepository.findByUser(user)
                .orElseGet(() -> createDefaultSettingsForUser(user));

        mapper.updateEntityFromDTO(dto, settings);

        settings.setUser(user);

        AppUserSettingsEntity saved = appUserSettingsRepository.save(settings);

        return mapper.toDTO(saved);
    }

    // =========================================
    // Helper metody
    // =========================================

    /**
     * Najde uživatele podle e-mailu nebo vyhodí výjimku.
     *
     * Metoda centralizuje logiku pro vyhledávání uživatele v databázi.
     *
     * @param email e-mail hledaného uživatele
     * @return entita AppUserEntity, pokud byla nalezena
     * @throws UserNotFoundException pokud uživatel s daným e-mailem neexistuje
     */
    private AppUserEntity findUserByEmailOrThrow(String email) {
        return appUserRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException(email));
    }

    /**
     * Vytvoří výchozí nastavení pro daného uživatele.
     *
     * Výchozí hodnoty jsou nastaveny explicitně, aby byly
     * snadno dohledatelné na jednom místě. Metoda se používá
     * při prvním načtení nastavení nebo při zakládání nového účtu.
     *
     * @param user entita uživatele, ke které se nastavení naváže
     * @return entita AppUserSettingsEntity s výchozími hodnotami
     */
    @Override
    public AppUserSettingsEntity createDefaultSettingsForUser(AppUserEntity user) {
        AppUserSettingsEntity settings = new AppUserSettingsEntity();
        settings.setUser(user);

        settings.setPlayerSelectionMode(PlayerSelectionMode.FIRST_PLAYER);
        settings.setGlobalNotificationLevel(GlobalNotificationLevel.ALL);
        settings.setCopyAllPlayerNotificationsToUserEmail(false);
        settings.setReceiveNotificationsForPlayersWithOwnEmail(false);
        settings.setEmailDigestEnabled(false);
        settings.setEmailDigestTime(null);
        settings.setUiLanguage("cs");
        settings.setTimezone("Europe/Prague");
        settings.setDefaultLandingPage("DASHBOARD");

        appUserSettingsRepository.save(settings);

        return settings;
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\CurrentPlayerService.java
-----

package cz.phsoft.hokej.models.services;

/**
 * Rozhraní se používá pro správu aktuálně zvoleného hráče přihlášeného uživatele.
 *
 * Uživatel může mít v systému více hráčů, ale většina aplikačních operací
 * (registrace na zápasy, přehledy, statistiky) pracuje vždy s jedním
 * jednoznačně určeným hráčem. Rozhraní definuje jednotný kontrakt
 * pro práci s tímto kontextem napříč aplikací.
 *
 * Rozhraní odděluje práci s uživatelským kontextem od business logiky.
 * Konkrétní implementace obvykle ukládá identifikátor hráče do uživatelské
 * session. Ověření existence a stavu hráče je odpovědností implementace.
 */
public interface CurrentPlayerService {

    /**
     * Vrátí identifikátor aktuálně zvoleného hráče.
     *
     * @return ID hráče nebo null, pokud aktuální hráč není nastaven
     */
    Long getCurrentPlayerId();

    /**
     * Nastaví aktuálního hráče v uživatelském kontextu.
     *
     * Metoda slouží ke změně kontextu přihlášeného uživatele
     * na konkrétního hráče. Implementace je odpovědná za to,
     * aby byl zvolen pouze platný hráč v odpovídajícím stavu.
     *
     * @param playerId ID hráče, který má být nastaven jako aktuální
     */
    void setCurrentPlayerId(Long playerId);

    /**
     * Ověří, že je aktuální hráč nastaven.
     *
     * Metoda se používá před operacemi, které vyžadují kontext
     * aktuálně zvoleného hráče. Pokud hráč není zvolen, je vyhozena výjimka.
     *
     * @throws RuntimeException pokud aktuální hráč není nastaven
     */
    void requireCurrentPlayer();

    /**
     * Odstraní informaci o aktuálním hráči z uživatelského kontextu.
     *
     * Metoda se používá zejména při odhlášení uživatele nebo při
     * explicitním resetu uživatelského kontextu.
     */
    void clear();
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\CurrentPlayerServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.CurrentPlayerNotSelectedException;
import cz.phsoft.hokej.exceptions.InvalidPlayerStatusException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.security.SessionKeys;
import jakarta.servlet.http.HttpSession;
import org.springframework.stereotype.Service;

/**
 * Implementace rozhraní CurrentPlayerService.
 *
 * Třída spravuje identifikátor aktuálně zvoleného hráče v HTTP session
 * přihlášeného uživatele. V session se ukládá pouze ID hráče, nikoli
 * celá entita. Pomocí PlayerRepository se ověřuje, zda hráč existuje
 * a zda je ve stavu vhodném pro použití v aplikaci.
 *
 * Třída neřeší oprávnění uživatele k danému hráči ani business logiku
 * zápasů a registrací. Tyto oblasti jsou pokryty jinými service třídami.
 */
@Service
public class CurrentPlayerServiceImpl implements CurrentPlayerService {

    /**
     * HTTP session vázaná na přihlášeného uživatele.
     * Slouží k uchování identifikátoru aktuálního hráče.
     */
    private final HttpSession session;

    /**
     * Repository pro práci s entitami hráčů.
     * Používá se k ověření existence hráče a jeho aktuálního stavu.
     */
    private final PlayerRepository playerRepository;

    public CurrentPlayerServiceImpl(HttpSession session,
                                    PlayerRepository playerRepository) {
        this.session = session;
        this.playerRepository = playerRepository;
    }

    /**
     * Vrátí identifikátor aktuálně zvoleného hráče ze session.
     *
     * @return ID hráče nebo null, pokud aktuální hráč ještě nebyl zvolen
     */
    @Override
    public Long getCurrentPlayerId() {
        return (Long) session.getAttribute(SessionKeys.CURRENT_PLAYER_ID);
    }

    /**
     * Nastaví aktuálního hráče do HTTP session.
     *
     * Před uložením do session se ověří, že hráč existuje
     * a že je ve stavu PlayerStatus.APPROVED. Pokud některá
     * z podmínek není splněna, je vyhozena výjimka.
     *
     * @param playerId ID hráče, který má být nastaven jako aktuální
     * @throws PlayerNotFoundException pokud hráč s daným ID neexistuje
     * @throws InvalidPlayerStatusException pokud hráč není ve schváleném stavu
     */
    @Override
    public void setCurrentPlayerId(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        validatePlayerSelectable(player);

        session.setAttribute(SessionKeys.CURRENT_PLAYER_ID, playerId);
    }

    /**
     * Ověří, že je aktuální hráč nastaven v session.
     *
     * Metoda se používá před operacemi, které vyžadují kontext
     * aktuálního hráče, například před registrací na zápas
     * nebo při volání endpointů pracujících s „/me“.
     *
     * @throws CurrentPlayerNotSelectedException pokud aktuální hráč není nastaven
     */
    @Override
    public void requireCurrentPlayer() {
        Long currentPlayerId = getCurrentPlayerId();
        if (currentPlayerId == null) {
            throw new CurrentPlayerNotSelectedException();
        }
    }

    /**
     * Odstraní informaci o aktuálním hráči z HTTP session.
     *
     * Metoda se používá při odhlášení uživatele nebo při resetu
     * uživatelského kontextu, kdy již nemá být vazba na konkrétního hráče.
     */
    @Override
    public void clear() {
        session.removeAttribute(SessionKeys.CURRENT_PLAYER_ID);
    }

    // ==================================================
    // Helper metody
    // ==================================================

    /**
     * Najde hráče podle ID nebo vyhodí výjimku.
     *
     * @param playerId ID hledaného hráče
     * @return entita PlayerEntity odpovídající zadanému ID
     * @throws PlayerNotFoundException pokud hráč s daným ID neexistuje
     */
    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    /**
     * Ověří, zda může být hráč zvolen jako aktuální.
     *
     * V současné době je povolen pouze stav PlayerStatus.APPROVED.
     * Ostatní stavy jsou považovány za neplatné pro použití
     * v kontextu přihlášeného uživatele.
     *
     * @param player entita hráče, která má být ověřena
     * @throws InvalidPlayerStatusException pokud hráč není ve schváleném stavu
     */
    private void validatePlayerSelectable(PlayerEntity player) {
        if (player.getPlayerStatus() != PlayerStatus.APPROVED) {
            throw new InvalidPlayerStatusException(
                    "BE - Nelze zvolit hráče, který není schválen administrátorem."
            );
        }
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\CurrentSeasonService.java
-----

package cz.phsoft.hokej.models.services;

/**
 * Rozhraní se používá pro správu aktuálně zvolené sezóny
 * v kontextu přihlášeného uživatele.
 *
 * Sezóna slouží jako globální kontextový filtr pro většinu
 * aplikačních operací, jako jsou zápasy, statistiky a přehledy.
 * Uživatel může pracovat buď s automaticky zvolenou aktivní sezónou,
 * nebo si může sezónu explicitně vybrat.
 *
 * Rozhraní definuje jednotný kontrakt pro práci s aktuální sezónou
 * a odděluje práci se session od business logiky správy sezón.
 */
public interface CurrentSeasonService {

    /**
     * Vrátí identifikátor aktuálně používané sezóny.
     *
     * Pokud je v session uložena sezóna, kterou si uživatel
     * explicitně zvolil, vrátí se tato hodnota.
     * Pokud sezóna nastavena není nebo nebyla zvolena vědomě,
     * použije se globálně aktivní sezóna definovaná v systému.
     *
     * Při použití globálně aktivní sezóny se její identifikátor
     * uloží do session jako automaticky zvolený.
     *
     * @return ID aktuální sezóny nebo null, pokud neexistuje žádná aktivní sezóna
     */
    Long getCurrentSeasonIdOrDefault();

    /**
     * Nastaví sezónu jako aktuální pro přihlášeného uživatele.
     *
     * Metoda se používá v okamžiku, kdy si uživatel sezónu
     * explicitně vybere. Zvolená sezóna je uložena do session
     * jako uživatelská volba.
     *
     * @param seasonId ID sezóny, která má být nastavena jako aktuální
     */
    void setCurrentSeasonId(Long seasonId);

    /**
     * Odstraní informaci o aktuální sezóně z uživatelského kontextu.
     *
     * Metoda se používá zejména při odhlášení uživatele
     * nebo při resetu session.
     */
    void clearCurrentSeason();
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\CurrentSeasonServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.SeasonDTO;
import jakarta.servlet.http.HttpSession;
import org.springframework.stereotype.Service;

/**
 * Implementace rozhraní CurrentSeasonService.
 *
 * Třída spravuje identifikátor aktuálně zvolené sezóny
 * v HTTP session přihlášeného uživatele.
 * Rozlišuje se, zda byla sezóna zvolena explicitně uživatelem,
 * nebo byla nastavena automaticky na základě globálně aktivní sezóny.
 *
 * Správa samotných sezón a jejich životního cyklu není
 * odpovědností této třídy a je řešena v SeasonService.
 */
@Service
public class CurrentSeasonServiceImpl implements CurrentSeasonService {

    /**
     * Název session atributu pro uložení ID aktuální sezóny.
     */
    private static final String CURRENT_SEASON_SESSION_ATTR = "CURRENT_SEASON_ID";

    /**
     * Session atribut určující, zda byla sezóna zvolena uživatelem.
     *
     * Hodnota true značí explicitní uživatelskou volbu.
     * Hodnota false nebo null značí automatické nastavení.
     */
    private static final String CURRENT_SEASON_CUSTOM_ATTR = "CURRENT_SEASON_CUSTOM";

    /**
     * HTTP session přihlášeného uživatele.
     */
    private final HttpSession session;

    /**
     * Service poskytující informace o sezónách.
     *
     * Používá se k získání globálně aktivní sezóny.
     */
    private final SeasonService seasonService;

    public CurrentSeasonServiceImpl(HttpSession session,
                                    SeasonService seasonService) {
        this.session = session;
        this.seasonService = seasonService;
    }

    /**
     * Vrátí identifikátor aktuální sezóny podle stanovené priority.
     *
     * Nejprve se zohlední sezóna explicitně zvolená uživatelem.
     * Pokud taková volba neexistuje, použije se globálně aktivní sezóna.
     * Při automatickém nastavení se identifikátor sezóny uloží do session.
     *
     * @return ID aktuální sezóny nebo null, pokud není k dispozici žádná aktivní sezóna
     */
    @Override
    public Long getCurrentSeasonIdOrDefault() {
        Object value = session.getAttribute(CURRENT_SEASON_SESSION_ATTR);
        Boolean custom = (Boolean) session.getAttribute(CURRENT_SEASON_CUSTOM_ATTR);

        if (Boolean.TRUE.equals(custom) && value != null) {
            return toLong(value);
        }

        SeasonDTO active = seasonService.getActiveSeasonOrNull();
        if (active != null) {
            Long id = active.getId();
            session.setAttribute(CURRENT_SEASON_SESSION_ATTR, id);
            session.setAttribute(CURRENT_SEASON_CUSTOM_ATTR, Boolean.FALSE);
            return id;
        }

        return null;
    }

    /**
     * Nastaví sezónu jako aktuální pro přihlášeného uživatele.
     *
     * Sezóna je uložena do session a označena jako
     * explicitní uživatelská volba.
     *
     * @param seasonId ID sezóny, která má být nastavena
     */
    @Override
    public void setCurrentSeasonId(Long seasonId) {
        session.setAttribute(CURRENT_SEASON_SESSION_ATTR, seasonId);
        session.setAttribute(CURRENT_SEASON_CUSTOM_ATTR, Boolean.TRUE);
    }

    /**
     * Odstraní informaci o aktuální sezóně z HTTP session.
     *
     * Metoda se používá při odhlášení uživatele
     * nebo při resetu uživatelského kontextu.
     */
    @Override
    public void clearCurrentSeason() {
        session.removeAttribute(CURRENT_SEASON_SESSION_ATTR);
        session.removeAttribute(CURRENT_SEASON_CUSTOM_ATTR);
    }

    /**
     * Zajistí bezpečný převod hodnoty ze session na typ Long.
     *
     * Metoda slouží jako ochrana proti rozdílným typům hodnot,
     * které může servlet container vrátit.
     *
     * @param value hodnota načtená ze session
     * @return hodnota převedená na Long
     */
    private Long toLong(Object value) {
        if (value instanceof Long l) return l;
        if (value instanceof Integer i) return i.longValue();
        return Long.valueOf(value.toString());
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationHistoryService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.MatchRegistrationHistoryDTO;

import java.util.List;

/**
 * Service se používá pro práci s historickými (auditními) záznamy
 * registrací hráčů k zápasům.
 *
 * Tato service je čistě pro čtení. Pracuje s historickými daty,
 * neprovádí žádné změny v databázi a neobsahuje vlastní business logiku.
 * Slouží k oddělení auditních dotazů od hlavní logiky registrací.
 *
 * Typickým použitím je zobrazení historie změn registrace
 * aktuálně přihlášeného hráče nebo provádění administrativního auditu
 * registrací konkrétního hráče k danému zápasu.
 */
public interface MatchRegistrationHistoryService {

    /**
     * Vrátí historii všech změn registrace aktuálně přihlášeného hráče
     * pro zadaný zápas.
     *
     * Metoda pracuje s kontextem aktuálního hráče
     * a vrací pouze záznamy, které se k tomuto hráči vztahují.
     * Historie je seřazena sestupně podle času změny, takže
     * nejnovější změna je na prvním místě.
     *
     * @param matchId ID zápasu, ke kterému se historie načítá
     * @return seznam historických záznamů registrace hráče k zápasu
     */
    List<MatchRegistrationHistoryDTO> getHistoryForCurrentPlayerAndMatch(Long matchId);

    /**
     * Vrátí historii všech změn registrace zadaného hráče
     * k danému zápasu.
     *
     * Metoda se používá zejména pro administrativní a auditní účely,
     * například při kontrole zásahů do registrací hráčů
     * nebo při řešení sporů a reklamací.
     * Historie je seřazena sestupně podle času změny.
     *
     * @param matchId  ID zápasu
     * @param playerId ID hráče
     * @return seznam historických záznamů registrace hráče k zápasu
     */
    List<MatchRegistrationHistoryDTO> getHistoryForPlayerAndMatch(Long matchId, Long playerId);
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationHistoryServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.repositories.MatchRegistrationHistoryRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.exceptions.MatchNotFoundException;
import cz.phsoft.hokej.models.dto.MatchRegistrationHistoryDTO;
import cz.phsoft.hokej.models.mappers.MatchRegistrationHistoryMapper;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * Implementace rozhraní MatchRegistrationHistoryService.
 *
 * Třída zajišťuje načítání historických záznamů registrací hráčů
 * k zápasům z databáze a jejich převod do DTO. Odpovědností je
 * ověření existence zápasu, provedení dotazu do historie a mapování
 * výsledků do podoby vhodné pro controller a frontend.
 *
 * Třída neprovádí žádné změny stavu systému. Slouží jako read-only
 * vrstva nad auditními daty a nenahrazuje hlavní logiku registrací.
 */
@Service
public class MatchRegistrationHistoryServiceImpl implements MatchRegistrationHistoryService {

    /**
     * Repository pro čtení historických záznamů registrací.
     */
    private final MatchRegistrationHistoryRepository historyRepository;

    /**
     * Mapper pro převod historických entit do DTO.
     */
    private final MatchRegistrationHistoryMapper historyMapper;

    /**
     * Service pro práci s aktuálně zvoleným hráčem.
     *
     * Používá se při načítání historie pro přihlášeného hráče.
     */
    private final CurrentPlayerService currentPlayerService;

    /**
     * Repository pro práci se zápasy.
     *
     * Používá se k ověření, že požadovaný zápas existuje.
     */
    private final MatchRepository matchRepository;

    public MatchRegistrationHistoryServiceImpl(
            MatchRegistrationHistoryRepository historyRepository,
            MatchRegistrationHistoryMapper historyMapper,
            CurrentPlayerService currentPlayerService,
            MatchRepository matchRepository
    ) {
        this.historyRepository = historyRepository;
        this.historyMapper = historyMapper;
        this.currentPlayerService = currentPlayerService;
        this.matchRepository = matchRepository;
    }

    /**
     * Načte historii registrací aktuálně přihlášeného hráče pro daný zápas.
     *
     * Nejprve se ověří, že zápas existuje. Poté se ověří,
     * že je nastaven aktuální hráč, a získá se jeho identifikátor.
     * Následně se načtou auditní záznamy pro kombinaci daného zápasu
     * a aktuálního hráče. Výsledky jsou mapovány do DTO.
     *
     * @param matchId ID zápasu
     * @return seznam historických záznamů registrace aktuálního hráče k zápasu
     * @throws MatchNotFoundException pokud zápas s daným ID neexistuje
     */
    @Override
    public List<MatchRegistrationHistoryDTO> getHistoryForCurrentPlayerAndMatch(Long matchId) {
        MatchEntity match = matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));

        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        var history = historyRepository
                .findByMatchIdAndPlayerIdOrderByChangedAtDesc(match.getId(), currentPlayerId);

        return historyMapper.toDTOList(history);
    }

    /**
     * Načte historii registrací zadaného hráče pro daný zápas.
     *
     * Metoda je vhodná pro administrativní a auditní endpointy,
     * kde se nepracuje s kontextem aktuálního hráče, ale s konkrétním
     * hráčem určeným parametrem. Nejprve se ověří existence zápasu,
     * poté se načtou odpovídající historické záznamy a převedou se do DTO.
     *
     * @param matchId  ID zápasu
     * @param playerId ID hráče
     * @return seznam historických záznamů registrace hráče k zápasu
     * @throws MatchNotFoundException pokud zápas s daným ID neexistuje
     */
    @Override
    public List<MatchRegistrationHistoryDTO> getHistoryForPlayerAndMatch(Long matchId, Long playerId) {
        MatchEntity match = matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));

        var history = historyRepository
                .findByMatchIdAndPlayerIdOrderByChangedAtDesc(match.getId(), playerId);

        return historyMapper.toDTOList(history);
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;

import java.util.List;

/**
 * Rozhraní se používá pro správu registrací hráčů na zápasy.
 *
 * Definuje kontrakt pro práci s účastí hráčů na zápasech
 * z pohledu business logiky aplikace. Poskytuje operace pro
 * vytvoření nebo změnu registrace, získávání přehledů a
 * administrativní zásahy do stavů registrací.
 *
 * Rozhraní pracuje s DTO objekty a odděluje business logiku
 * od persistence vrstvy. Implementace je odpovědná za validace
 * a přechody stavů registrací.
 */
public interface MatchRegistrationService {

    /**
     * Vytvoří nebo aktualizuje registraci hráče na zápas.
     *
     * Metoda slouží jako jednotný vstupní bod pro reakci hráče
     * na zápas. Registrace se podle potřeby vytvoří nebo upraví.
     * Implementace zajišťuje validaci vstupních dat, kontrolu
     * povolených přechodů stavů a uložení výsledné registrace.
     *
     * Typickým scénářem je přihlášení hráče k zápasu, odhlášení
     * nebo omluva z účasti.
     *
     * @param playerId ID hráče, který reaguje na zápas
     * @param request  požadavek obsahující data o registraci
     * @return DTO reprezentace výsledného stavu registrace
     */
    MatchRegistrationDTO upsertRegistration(
            Long playerId,
            MatchRegistrationRequest request
    );

    /**
     * Vrátí seznam registrací pro konkrétní zápas.
     *
     * @param matchId ID zápasu
     * @return seznam registrací hráčů k danému zápasu
     */
    List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId);

    /**
     * Vrátí seznam registrací pro více zápasů.
     *
     * Metoda se typicky používá pro hromadné přehledy
     * nebo statistiky přes více zápasů.
     *
     * @param matchIds seznam ID zápasů
     * @return seznam registrací pro zadané zápasy
     */
    List<MatchRegistrationDTO> getRegistrationsForMatches(List<Long> matchIds);

    /**
     * Vrátí všechny registrace v systému omezené
     * na relevantní sezónu podle implementace.
     *
     * Metoda se používá zejména pro administrátorské přehledy.
     *
     * @return seznam všech registrací
     */
    List<MatchRegistrationDTO> getAllRegistrations();

    /**
     * Vrátí seznam registrací konkrétního hráče.
     *
     * @param playerId ID hráče
     * @return seznam registrací daného hráče
     */
    List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId);

    /**
     * Vrátí seznam hráčů, kteří dosud nereagovali na daný zápas.
     *
     * Metoda se používá například pro připomínkové notifikace
     * nebo pro přehledy nevyřešené účasti.
     *
     * @param matchId ID zápasu
     * @return seznam hráčů bez reakce na zápas
     */
    List<PlayerDTO> getNoResponsePlayers(Long matchId);

    /**
     * Přepočítá stavy registrací pro daný zápas.
     *
     * Metoda slouží k zajištění konzistence stavů registrovaných
     * a rezervních hráčů podle kapacity zápasu, typicky po změnách
     * provedených administrátorem.
     *
     * @param matchId ID zápasu
     */
    void recalcStatusesForMatch(Long matchId);

    /**
     * Změní stav registrace hráče na zápas.
     *
     * Metoda se používá převážně v administrátorském kontextu,
     * kde je nutné ručně upravit stav registrace. Nastavení
     * stavu NO_EXCUSED má vlastní logiku a řeší se samostatně.
     *
     * @param matchId  ID zápasu
     * @param playerId ID hráče
     * @param status   nový stav registrace
     * @return DTO reprezentace aktualizované registrace
     */
    MatchRegistrationDTO updateStatus(
            Long matchId,
            Long playerId,
            PlayerMatchStatus status
    );

    /**
     * Označí hráče jako neomluveného pro konkrétní zápas.
     *
     * Metoda se používá v administrátorském kontextu po vyhodnocení
     * účasti na zápase. Původní omluva se odstraní a registrace
     * se nastaví do stavu NO_EXCUSED včetně poznámky administrátora.
     *
     * @param matchId   ID zápasu
     * @param playerId  ID hráče
     * @param adminNote poznámka administrátora
     * @return DTO reprezentace aktualizované registrace
     */
    MatchRegistrationDTO markNoExcused(
            Long matchId,
            Long playerId,
            String adminNote
    );
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.mappers.MatchRegistrationMapper;
import cz.phsoft.hokej.models.mappers.PlayerMapper;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;
import cz.phsoft.hokej.models.services.notification.NotificationService;
import cz.phsoft.hokej.models.services.sms.SmsMessageBuilder;
import cz.phsoft.hokej.models.services.sms.SmsService;
import jakarta.transaction.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Implementace service pro správu registrací hráčů na zápasy.
 *
 * Třída zajišťuje vytvoření a změny registrací, přepočítávání stavů
 * podle kapacity zápasu a poskytování přehledů registrací.
 * Současně spouští notifikace hráčům podle typu změny registrace.
 *
 * Třída řeší business logiku registrací a stavových přechodů,
 * ale neřeší UI, autentizaci ani výběr aktuálního hráče.
 * Tyto oblasti náleží jiným vrstvám aplikace.
 */
@Service
public class MatchRegistrationServiceImpl implements MatchRegistrationService {

    private static final Logger log = LoggerFactory.getLogger(MatchRegistrationServiceImpl.class);

    private final MatchRegistrationRepository registrationRepository;
    private final MatchRepository matchRepository;
    private final PlayerRepository playerRepository;
    private final MatchRegistrationMapper matchRegistrationMapper;
    private final PlayerMapper playerMapper;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;
    private final NotificationService notificationService;
    private final SeasonService seasonService;
    private final CurrentSeasonService currentSeasonService;

    public MatchRegistrationServiceImpl(
            MatchRegistrationRepository registrationRepository,
            MatchRepository matchRepository,
            PlayerRepository playerRepository,
            MatchRegistrationMapper matchRegistrationMapper,
            PlayerMapper playerMapper,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder,
            NotificationService notificationService,
            SeasonService seasonService,
            CurrentSeasonService currentSeasonService
    ) {
        this.registrationRepository = registrationRepository;
        this.matchRepository = matchRepository;
        this.playerRepository = playerRepository;
        this.matchRegistrationMapper = matchRegistrationMapper;
        this.playerMapper = playerMapper;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
        this.notificationService = notificationService;
        this.seasonService = seasonService;
        this.currentSeasonService = currentSeasonService;
    }

    // ==========================================
    // HLAVNÍ METODA – UPSERT REGISTRACE HRÁČE
    // ==========================================

    /**
     * Vytvoří nebo aktualizuje registraci hráče na zápas.
     *
     * Metoda načte zápas a hráče, ověří, že zápas patří do aktivní sezóny
     * a že aktuální uživatel může registraci upravovat. Poté podle obsahu
     * požadavku zvolí větev pro odhlášení, omluvu nebo registraci
     * a nastaví odpovídající stav registrace. Společné údaje se převezmou
     * z požadavku a registrace se uloží. Po odhlášení se stav registrací
     * přepočítá a podle výsledného statusu se odešlou notifikace.
     *
     * @param playerId ID hráče
     * @param request  požadavek na změnu registrace
     * @return DTO výsledné registrace
     */
    @Transactional
    @Override
    public MatchRegistrationDTO upsertRegistration(Long playerId, MatchRegistrationRequest request) {

        MatchEntity match = getMatchOrThrow(request.getMatchId());
        PlayerEntity player = getPlayerOrThrow(playerId);

        // Ověření, že zápas patří do aktuálně aktivní sezóny.
        // Zápisy do neaktivní sezóny nejsou povoleny.
        assertMatchInActiveSeason(match);

        // Ověření, zda aktuální uživatel smí měnit registraci
        // s ohledem na svou roli a čas zápasu.
        assertPlayerCanModifyMatch(match);

        MatchRegistrationEntity registration =
                getRegistrationOrNull(playerId, request.getMatchId());

        if (registration == null && !request.isUnregister()) {
            registration = new MatchRegistrationEntity();
            registration.setMatch(match);
            registration.setPlayer(player);
        }

        PlayerMatchStatus newStatus;

        if (request.isUnregister()) {
            newStatus = handleUnregister(request, playerId, registration);
        } else if (request.getExcuseReason() != null) {
            newStatus = handleExcuse(request, match, player, registration);
        } else {
            newStatus = handleRegisterOrReserveOrSubstitute(request, match, player, registration);
        }

        applyRequestDetails(registration, request);

        registration.setStatus(newStatus);
        registration.setTimestamp(now());
        registration.setCreatedBy("user");

        registration = registrationRepository.save(registration);

        if (request.isUnregister()) {
            recalcStatusesForMatch(request.getMatchId());
        }

        NotificationType notificationType = resolveNotificationType(newStatus);
        if (notificationType != null) {
            notifyPlayer(player, notificationType, registration);
        }

        return matchRegistrationMapper.toDTO(registration);
    }

    /**
     * Zpracuje větev pro registraci typu REGISTER, RESERVED nebo SUBSTITUTE.
     *
     * Metoda nepovolí opakovanou registraci již registrovaného hráče.
     * Při volbě SUBSTITUTE se hráč označí jako náhradník, který
     * neblokuje kapacitu a může později přejít na jiný stav.
     * Při běžné registraci se podle kapacity zápasu rozhodne,
     * zda se použije stav REGISTERED nebo RESERVED. Případná
     * předchozí omluva se odstraní.
     */
    private PlayerMatchStatus handleRegisterOrReserveOrSubstitute(
            MatchRegistrationRequest request,
            MatchEntity match,
            PlayerEntity player,
            MatchRegistrationEntity registration
    ) {
        PlayerMatchStatus currentStatus =
                (registration != null) ? registration.getStatus() : null;

        boolean isAlreadyRegistered = currentStatus == PlayerMatchStatus.REGISTERED;

        if (isAlreadyRegistered) {
            throw new DuplicateRegistrationException(request.getMatchId(), player.getId());
        }

        // Registrace jako náhradník (SUBSTITUTE) – hráč je označen jako „možná“
        // a neblokuje kapacitu ani pořadí.
        if (request.isSubstitute()) {
            if (currentStatus == PlayerMatchStatus.SUBSTITUTE) {
                throw new DuplicateRegistrationException(
                        request.getMatchId(),
                        player.getId(),
                        "Hráč již má zaregistrováno - možná"
                );
            }

            clearExcuseIfNeeded(registration);
            return PlayerMatchStatus.SUBSTITUTE;
        }

        PlayerMatchStatus newStatus =
                isSlotAvailable(match) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;

        clearExcuseIfNeeded(registration);
        return newStatus;
    }

    /**
     * Zpracuje odhlášení hráče ze zápasu (UNREGISTER).
     *
     * Odhlášení je povoleno pouze v případě, že registrace existuje
     * a má stav REGISTERED nebo RESERVED. Při úspěšném odhlášení
     * se nastaví informace o omluvě a stav UNREGISTERED.
     */
    private PlayerMatchStatus handleUnregister(
            MatchRegistrationRequest request,
            Long playerId,
            MatchRegistrationEntity registration
    ) {
        boolean isAllowedUnregisterStatus =
                registration != null &&
                        (registration.getStatus() == PlayerMatchStatus.REGISTERED
                                || registration.getStatus() == PlayerMatchStatus.RESERVED);

        if (!isAllowedUnregisterStatus) {
            throw new RegistrationNotFoundException(request.getMatchId(), playerId);
        }

        registration.setExcuseReason(request.getExcuseReason());
        registration.setExcuseNote(request.getExcuseNote());

        return PlayerMatchStatus.UNREGISTERED;
    }

    /**
     * Zpracuje omluvu hráče z účasti na zápase (EXCUSED).
     *
     * Omluva je povolena pouze v případě, že hráč dosud nereagoval
     * nebo byl veden jako náhradník. Při úspěšné omluvě se nastaví
     * důvod a poznámka a registrace se přepne do stavu EXCUSED.
     */
    private PlayerMatchStatus handleExcuse(
            MatchRegistrationRequest request,
            MatchEntity match,
            PlayerEntity player,
            MatchRegistrationEntity registration
    ) {
        boolean isNoResponseOrSubstitute =
                (registration == null
                        || registration.getStatus() == null
                        || registration.getStatus() == PlayerMatchStatus.SUBSTITUTE);


        if (!isNoResponseOrSubstitute) {
            throw new DuplicateRegistrationException(
                    request.getMatchId(),
                    player.getId(),
                    "BE - Omluva je možná pouze pokud hráč dosud nereagoval na zápas, nebo byl náhradník."
            );
        }
        registration.setExcuseReason(request.getExcuseReason());
        registration.setExcuseNote(request.getExcuseNote());

        return PlayerMatchStatus.EXCUSED;
    }

    /**
     * Nastaví registraci do stavu NO_EXCUSED na základě rozhodnutí administrátora.
     *
     * Zápas musí být již odehraný a předchozí stav registrace musí být REGISTERED.
     * Případná omluva se odstraní a uloží se poznámka administrátora. Po změně
     * se odešle notifikace podle nastaveného typu.
     */
    @Override
    @Transactional
    public MatchRegistrationDTO markNoExcused(Long matchId,
                                              Long playerId,
                                              String adminNote) {

        MatchEntity match = getMatchOrThrow(matchId);
        PlayerEntity player = getPlayerOrThrow(playerId);

        if (match.getDateTime().isAfter(now())) {
            throw new InvalidPlayerStatusException(
                    "BE - Status NO_EXCUSED lze nastavit pouze u již proběhlého zápasu."
            );
        }

        MatchRegistrationEntity registration = getRegistrationOrThrow(playerId, matchId);

        if (registration.getStatus() != PlayerMatchStatus.REGISTERED) {
            throw new InvalidPlayerStatusException(
                    "BE - Status NO_EXCUSED lze nastavit pouze z registrace REGISTERED."
            );
        }

        registration.setExcuseReason(null);
        registration.setExcuseNote(null);

        if (adminNote == null || adminNote.isBlank()) {
            registration.setAdminNote("Nedostavil se bez omluvy");
        } else {
            registration.setAdminNote(adminNote);
        }

        MatchRegistrationEntity updated =
                updateRegistrationStatus(
                        registration,
                        PlayerMatchStatus.NO_EXCUSED,
                        "admin",
                        true
                );

        PlayerMatchStatus newStatus = PlayerMatchStatus.NO_EXCUSED;

        NotificationType notificationType = resolveNotificationType(newStatus);
        if (notificationType != null) {
            notifyPlayer(player, notificationType, updated);
        }

        return matchRegistrationMapper.toDTO(updated);
    }

    /**
     * Nastaví do registrace společné údaje z požadavku.
     *
     * Upravuje tým, administrátorskou poznámku a případné informace
     * o omluvě, pokud jsou v požadavku uvedeny.
     */
    private void applyRequestDetails(MatchRegistrationEntity registration,
                                     MatchRegistrationRequest request) {

        if (request.getTeam() != null) {
            registration.setTeam(request.getTeam());
        }

        if (request.getAdminNote() != null) {
            registration.setAdminNote(request.getAdminNote());
        }

        if (request.getExcuseReason() != null) {
            registration.setExcuseReason(request.getExcuseReason());
        }

        if (request.getExcuseNote() != null) {
            registration.setExcuseNote(request.getExcuseNote());
        }
    }

    /*
     Společný helper pro přechody, kde se nemá zachovat omluva.
     */
    private void clearExcuseIfNeeded(MatchRegistrationEntity registration) {
        if (registration == null) {
            return;
        }
        if (registration.getExcuseReason() != null || registration.getExcuseNote() != null) {
            registration.setExcuseReason(null);
            registration.setExcuseNote(null);
        }
    }

    /**
     * Vrátí všechny registrace pro daný zápas omezené na aktuální sezónu.
     *
     * Pokud zápas nepatří do aktuálně vybrané sezóny, vrátí se prázdný seznam.
     */
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);

        if (!isMatchInCurrentSeason(match)) {
            return List.of();
        }

        return matchRegistrationMapper.toDTOList(
                registrationRepository.findByMatchId(matchId)
        );
    }

    /**
     * Vrátí všechny registrace pro zadané zápasy omezené na aktuální sezónu.
     *
     * Pokud je seznam ID prázdný nebo null, vrátí se prázdný seznam.
     */
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatches(List<Long> matchIds) {
        if (matchIds == null || matchIds.isEmpty()) {
            return List.of();
        }

        List<MatchRegistrationEntity> regsInSeason = registrationRepository
                .findByMatchIdIn(matchIds).stream()
                .filter(this::isRegistrationInCurrentSeason)
                .toList();

        return matchRegistrationMapper.toDTOList(regsInSeason);
    }

    /**
     * Vrátí všechny registrace v systému omezené na aktuální sezónu.
     */
    @Override
    public List<MatchRegistrationDTO> getAllRegistrations() {
        List<MatchRegistrationEntity> regsInSeason = registrationRepository
                .findAll().stream()
                .filter(this::isRegistrationInCurrentSeason)
                .toList();

        return matchRegistrationMapper.toDTOList(regsInSeason);
    }

    /**
     * Vrátí všechny registrace zadaného hráče omezené na aktuální sezónu.
     */
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId) {
        List<MatchRegistrationEntity> regsInSeason = registrationRepository
                .findByPlayerId(playerId).stream()
                .filter(this::isRegistrationInCurrentSeason)
                .toList();

        return matchRegistrationMapper.toDTOList(regsInSeason);
    }

    /**
     * Vrátí hráče, kteří na daný zápas nijak nereagovali.
     *
     * Registrace se berou bez ohledu na konkrétní stav.
     * Pokud zápas nepatří do aktuálně vybrané sezóny,
     * vrátí se prázdný seznam.
     */
    @Override
    public List<PlayerDTO> getNoResponsePlayers(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);

        if (!isMatchInCurrentSeason(match)) {
            return List.of();
        }

        Set<Long> respondedIds = getRespondedPlayerIds(matchId);

        List<PlayerEntity> noResponsePlayers = playerRepository.findAll().stream()
                .filter(p -> !respondedIds.contains(p.getId()))
                .toList();

        return noResponsePlayers.stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    /**
     * Přepočítá statusy REGISTERED a RESERVED pro daný zápas.
     *
     * Registrace se seřadí podle času vytvoření a prvním hráčům
     * do výše kapacity zápasu se nastaví stav REGISTERED.
     * Ostatním se nastaví stav RESERVED. Náhradníci se do
     * tohoto přepočtu nezahrnují.
     */
    @Override
    @Transactional
    public void recalcStatusesForMatch(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);
        int maxPlayers = match.getMaxPlayers();

        List<MatchRegistrationEntity> regs = registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED
                        || r.getStatus() == PlayerMatchStatus.RESERVED)
                .sorted((a, b) -> a.getTimestamp().compareTo(b.getTimestamp()))
                .toList();

        for (int i = 0; i < regs.size(); i++) {
            MatchRegistrationEntity reg = regs.get(i);
            PlayerMatchStatus newStatus =
                    (i < maxPlayers) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;

            if (reg.getStatus() != newStatus) {
                updateRegistrationStatus(reg, newStatus, "system", false);
            }
        }
    }

    // =========================
    // SMS – HROMADNÉ ODESÍLÁNÍ
    // =========================

    /**
     * Odešle SMS všem hráčům, kteří jsou na daný zápas registrováni
     * se statusem REGISTERED a mají povolené SMS notifikace.
     */
    @Transactional
    public void sendSmsToRegisteredPlayers(Long matchId) {
        registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .forEach(r -> {
                    PlayerEntity player = r.getPlayer();
                    if (player == null) {
                        return;
                    }

                    var settings = player.getSettings();
                    if (settings == null || !settings.isSmsEnabled()) {
                        return;
                    }

                    sendSms(r, smsMessageBuilder.buildMessageFinal(r));
                });
    }

    // poznámka: sendNoResponseSmsForMatch je aktuálně zakomentovaný blok,
    // takže dokumentace k němu se neřeší; pokud ho znovu aktivuješ,
    // můžeme mu dopsat Javadoc ve stejném stylu.

    /**
     * Obecná administrátorská operace pro změnu statusu registrace.
     *
     * Metoda neumožňuje nastavit status NO_EXCUSED, protože ten má
     * vlastní samostatnou logiku. Před změnou se ověří existence
     * zápasu, hráče i samotné registrace.
     *
     * @param matchId  ID zápasu
     * @param playerId ID hráče
     * @param status   cílový status registrace (mimo NO_EXCUSED)
     * @return DTO aktualizované registrace
     */
    @Override
    @Transactional
    public MatchRegistrationDTO updateStatus(Long matchId, Long playerId, PlayerMatchStatus status) {

        getMatchOrThrow(matchId);
        getPlayerOrThrow(playerId);

        if (status == PlayerMatchStatus.NO_EXCUSED) {
            throw new InvalidPlayerStatusException(
                    "BE - Status NO_EXCUSED musí být nastaven přes speciální endpoint / logiku."
            );
        }

        MatchRegistrationEntity registration = getRegistrationOrThrow(playerId, matchId);

        MatchRegistrationEntity updated =
                updateRegistrationStatus(registration, status, "admin", true);

        return matchRegistrationMapper.toDTO(updated);
    }


    // ====================================================
    // PRIVÁTNÍ HELPERY – NAČÍTÁNÍ ENTIT A ZÁKLADNÍ LOGIKA
    // ====================================================

    // TODO - možná změnit Object context na MatchRegistrationEntity entity
    private void notifyPlayer(PlayerEntity player, NotificationType type, Object context) {
        notificationService.notifyPlayer(player, type, context);
    }

    /**
     * Vrátí množinu ID hráčů, kteří mají k zápasu nějakou registraci.
     */
    private Set<Long> getRespondedPlayerIds(Long matchId) {
        return registrationRepository.findByMatchId(matchId).stream()
                .map(r -> r.getPlayer().getId())
                .collect(Collectors.toSet());
    }

    /**
     * Najde zápas podle ID nebo vyhodí MatchNotFoundException.
     */
    private MatchEntity getMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }

    /**
     * Najde hráče podle ID nebo vyhodí PlayerNotFoundException.
     */
    private PlayerEntity getPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    /**
     * Vrátí registraci hráče na zápas, pokud existuje, jinak null.
     */
    private MatchRegistrationEntity getRegistrationOrNull(Long playerId, Long matchId) {
        return registrationRepository
                .findByPlayerIdAndMatchId(playerId, matchId)
                .orElse(null);
    }

    /**
     * Vrátí registraci hráče na zápas nebo vyhodí RegistrationNotFoundException.
     */
    private MatchRegistrationEntity getRegistrationOrThrow(Long playerId, Long matchId) {
        return registrationRepository
                .findByPlayerIdAndMatchId(playerId, matchId)
                .orElseThrow(() -> new RegistrationNotFoundException(matchId, playerId));
    }

    /**
     * Zjistí, zda je ve zápase ještě volné místo pro stav REGISTERED.
     */
    private boolean isSlotAvailable(MatchEntity match) {
        long registeredCount = registrationRepository
                .countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);
        return registeredCount < match.getMaxPlayers();
    }

    // TODO - ŘEŠENO NOTIFIKACEMI - ASI SMAZAT
    /**
     * Bezpečně odešle SMS hráči z registrace.
     *
     * Pokud je registrace nebo hráč null, metoda nic neprovede.
     * Chyby při odesílání jsou pouze zalogovány.
     */
    private void sendSms(MatchRegistrationEntity registration, String message) {
        if (registration == null || registration.getPlayer() == null) {
            return;
        }

        PlayerEntity player = registration.getPlayer();
        var settings = player.getSettings();

        String phone = null;
        if (settings != null && settings.getContactPhone() != null && !settings.getContactPhone().isBlank()) {
            phone = settings.getContactPhone();
        } else if (player.getPhoneNumber() != null && !player.getPhoneNumber().isBlank()) {
            phone = player.getPhoneNumber();
        }

        if (phone == null || phone.isBlank()) {
            log.debug("sendSms: hráč {} nemá žádné telefonní číslo – SMS se nepošle", player.getId());
            return;
        }

        try {
            smsService.sendSms(phone, message);
        } catch (Exception e) {
            log.error(
                    "Chyba při odesílání SMS pro registraci {}: {}",
                    registration.getId(),
                    e.getMessage(),
                    e
            );
        }
    }

    /**
     * Společná metoda pro změnu statusu registrace.
     *
     * Nastaví nový status, případně aktualizuje čas změny
     * a informaci o tom, kdo změnu provedl, a registraci uloží.
     *
     * @param registration    registrace ke změně
     * @param status          nový status
     * @param updatedBy       identifikace původce změny (user, admin, system)
     * @param updateTimestamp příznak, zda má být přepsán čas na aktuální
     */
    private MatchRegistrationEntity updateRegistrationStatus(
            MatchRegistrationEntity registration,
            PlayerMatchStatus status,
            String updatedBy,
            boolean updateTimestamp
    ) {
        registration.setStatus(status);
        registration.setCreatedBy(updatedBy);
        if (updateTimestamp) {
            registration.setTimestamp(LocalDateTime.now());
        }
        return registrationRepository.saveAndFlush(registration);
    }

    /**
     * Převede status registrace na odpovídající typ notifikace.
     *
     * Pokud se pro daný status notifikace neposílá, vrací se null.
     */
    private NotificationType resolveNotificationType(PlayerMatchStatus newStatus) {
        return switch (newStatus) {
            case REGISTERED -> NotificationType.MATCH_REGISTRATION_CREATED;
            case UNREGISTERED -> NotificationType.MATCH_REGISTRATION_CANCELED;
            case EXCUSED -> NotificationType.PLAYER_EXCUSED;
            case RESERVED -> NotificationType.MATCH_REGISTRATION_RESERVED;
            case NO_RESPONSE -> NotificationType.MATCH_REGISTRATION_NO_RESPONSE;
            case SUBSTITUTE -> NotificationType.MATCH_REGISTRATION_SUBSTITUTE;
            case NO_EXCUSED -> NotificationType.PLAYER_NO_EXCUSED;
            default -> null;
        };
    }

    /**
     * Pomocná metoda pro získání aktuálního času.
     *
     * Oddělení do samostatné metody usnadňuje testování.
     */
    private LocalDateTime now() {
        return LocalDateTime.now();
    }

    /**
     * Ověří, že zápas patří do aktivní sezóny.
     *
     * Metoda se používá před zápisem registrace, aby se zabránilo
     * změnám v neaktivních sezónách.
     */
    private void assertMatchInActiveSeason(MatchEntity match) {
        if (match.getSeason() == null || !match.getSeason().isActive()) {
            throw new InvalidSeasonStateException(
                    "BE - Registrace lze měnit pouze u zápasů v aktivní sezóně."
            );
        }
    }

    /**
     * Ověří, zda aktuálně přihlášený uživatel může měnit registraci na daný zápas.
     *
     * Uživatel s rolí ADMIN nebo MANAGER není časově omezen.
     * Uživatel s rolí PLAYER může registraci měnit pouze
     * v definovaném časovém okně kolem začátku zápasu.
     */
    private void assertPlayerCanModifyMatch(MatchEntity match) {
        if (!isCurrentUserPlayer()) {
            return;
        }

        if (!isMatchEditableForPlayer(match)) {
            throw new InvalidPlayerStatusException(
                    "BE - Jako hráč můžeš měnit registraci pouze do 30 minut po začátku zápasu."
            );
        }
    }

    /**
     * Zjistí, zda je zápas ještě v časovém okně, ve kterém může hráč měnit registraci.
     *
     * Zápas je považován za editovatelný pro hráče do třiceti minut
     * po začátku zápasu. Po uplynutí této doby už změna registrace není povolena.
     *
     * @param match zápas, ke kterému se vztahuje registrace
     * @return true, pokud je změna registrace ještě povolena
     */
    private boolean isMatchEditableForPlayer(MatchEntity match) {
        LocalDateTime editLimit = match.getDateTime().plusMinutes(30);
        return now().isBefore(editLimit);
    }

    /**
     * Zjistí, zda má aktuálně přihlášený uživatel roli ROLE_PLAYER.
     *
     * Metoda se používá pro odlišení časového omezení
     * oproti administrátorům nebo manažerům.
     *
     * @return true, pokud má uživatel roli PLAYER, jinak false
     */
    private boolean isCurrentUserPlayer() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth == null) {
            return false;
        }

        return auth.getAuthorities().stream()
                .anyMatch(a -> "ROLE_PLAYER".equals(a.getAuthority()));
    }

    // ======================================
    // SEASON – POMOCNÉ METODY PRO CURRENT SEASON
    // ======================================

    /**
     * Zjistí, zda daný zápas patří do aktuálně vybrané sezóny.
     *
     * Porovnává se identifikátor sezóny zápasu s identifikátorem,
     * který vrací metoda getCurrentSeasonIdOrActive.
     */
    private boolean isMatchInCurrentSeason(MatchEntity match) {
        if (match == null || match.getSeason() == null) {
            return false;
        }
        Long seasonId = getCurrentSeasonIdOrActive();
        return seasonId.equals(match.getSeason().getId());
    }

    /**
     * Zjistí, zda registrace patří k zápasu v aktuálně vybrané sezóně.
     */
    private boolean isRegistrationInCurrentSeason(MatchRegistrationEntity registration) {
        if (registration == null) {
            return false;
        }
        return isMatchInCurrentSeason(registration.getMatch());
    }

    /**
     * Vrátí identifikátor sezóny, která se má použít pro filtrování registrací.
     *
     * Nejprve se použije sezóna uložená v CurrentSeasonService.
     * Pokud není k dispozici, použije se globálně aktivní sezóna
     * ze SeasonService.
     *
     * @return ID aktuální nebo aktivní sezóny
     */
    private Long getCurrentSeasonIdOrActive() {
        Long id = currentSeasonService.getCurrentSeasonIdOrDefault();
        if (id != null) {
            return id;
        }
        return seasonService.getActiveSeason().getId();
    }

}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.enums.MatchCancelReason;
import cz.phsoft.hokej.models.dto.*;

import java.util.List;

/**
 * Rozhraní se používá pro správu zápasů v aplikaci.
 *
 * Definuje kontrakt pro práci se zápasy z pohledu business logiky.
 * Zajišťuje vytváření, úpravy, mazání zápasů, získávání přehledů
 * a práci s dostupností zápasů pro konkrétního hráče.
 *
 * Rozhraní je navrženo tak, aby oddělovalo business logiku
 * od persistence vrstvy a poskytovalo jednotný vstupní bod
 * pro controllery a např. plánovače (scheduler).
 */
public interface MatchService {

    /**
     * Vrátí seznam všech zápasů v systému.
     *
     * Metoda se typicky používá pro administrátorské přehledy
     * nebo pro globální seznam zápasů v rámci vybrané sezóny.
     *
     * @return seznam všech zápasů ve formě {@link MatchDTO}
     */
    List<MatchDTO> getAllMatches();

    /**
     * Vrátí seznam všech nadcházejících zápasů.
     *
     * Za nadcházející zápasy se považují ty, které mají
     * datum a čas v budoucnosti podle interně zvolených pravidel.
     *
     * @return seznam nadcházejících zápasů
     */
    List<MatchDTO> getUpcomingMatches();

    /**
     * Vrátí seznam všech již odehraných zápasů.
     *
     * Zápasy jsou obvykle řazené od nejnovějšího po nejstarší.
     *
     * @return seznam minulých zápasů
     */
    List<MatchDTO> getPastMatches();

    /**
     * Vrátí nejbližší nadcházející zápas.
     *
     * Metoda se používá například pro zobrazení
     * „dalšího zápasu“ na dashboardu nebo
     * pro potřeby notifikací.
     *
     * @return nejbližší nadcházející zápas nebo {@code null},
     * pokud žádný neexistuje
     */
    MatchDTO getNextMatch();

    /**
     * Vrátí základní informace o zápasu podle jeho ID.
     *
     * @param id ID zápasu
     * @return zápas ve formě {@link MatchDTO}
     */
    MatchDTO getMatchById(Long id);

    /**
     * Vytvoří nový zápas.
     *
     * Metoda je typicky dostupná pouze pro administrátory
     * nebo manažery. Implementace zajišťuje validaci
     * data v rámci aktivní sezóny a přiřazení sezóny k zápasu.
     *
     * @param dto data nového zápasu
     * @return vytvořený zápas
     */
    MatchDTO createMatch(MatchDTO dto);

    /**
     * Aktualizuje existující zápas.
     *
     * Implementace je odpovědná za načtení stávajícího zápasu,
     * přenesení změn z DTO, validaci a uložení výsledného stavu.
     *
     * @param id  ID zápasu, který má být upraven
     * @param dto nové hodnoty pro zápas
     * @return aktualizovaný zápas
     */
    MatchDTO updateMatch(Long id, MatchDTO dto);

    /**
     * Smaže zápas podle ID.
     *
     * Metoda typicky vrací standardizovanou odpověď
     * s informací o úspěchu operace.
     *
     * @param id ID zápasu, který má být smazán
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO deleteMatch(Long id);

    /**
     * Vrátí detailní informace o zápasu.
     *
     * Oproti metodě {@link #getMatchById(Long)} může detail
     * obsahovat rozšířená data, například statistiky,
     * seznamy hráčů v jednotlivých stavech nebo agregované údaje.
     *
     * @param id ID zápasu
     * @return detail zápasu
     */
    MatchDetailDTO getMatchDetail(Long id);

    /**
     * Vrátí seznam zápasů, na které se daný hráč může registrovat.
     *
     * Implementace obvykle filtruje pouze nadcházející zápasy,
     * kontroluje kapacitu a respektuje pravidla sezóny
     * a případná další business omezení.
     *
     * @param playerId ID hráče
     * @return seznam dostupných zápasů pro hráče
     */
    List<MatchDTO> getAvailableMatchesForPlayer(Long playerId);

    /**
     * Vrátí nadcházející zápasy pro konkrétního hráče.
     *
     * Metoda může zohledňovat, zda je hráč registrovaný,
     * případně další business pravidla. Výsledek je
     * určen pro podrobnější zobrazení seznamu zápasů.
     *
     * @param playerId ID hráče
     * @return seznam nadcházejících zápasů pro daného hráče
     */
    List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId);

    /**
     * Najde ID hráče podle e-mailu uživatele.
     *
     * Metoda se používá jako pomocný nástroj v situaci,
     * kdy je k dispozici e-mail přihlášeného uživatele
     * a je potřeba zjistit navázaného hráče.
     *
     * @param email e-mail uživatele
     * @return ID hráče nebo {@code null}, pokud neexistuje
     */
    Long getPlayerIdByEmail(String email);

    /**
     * Vrátí přehled nadcházejících zápasů pro hráče.
     *
     * Přehled slouží pro zobrazení na dashboardu
     * nebo v jednoduchých seznamech, kde se zobrazují
     * základní informace o zápasech včetně stavu
     * daného hráče.
     *
     * @param playerId ID hráče
     * @return přehled nadcházejících zápasů pro daného hráče
     */
    List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId);

    /**
     * Vrátí přehled všech odehraných zápasů pro hráče.
     *
     * Metoda se používá pro statistiky, historii účasti
     * a přehled minulých zápasů daného hráče v rámci sezóny.
     *
     * @param playerId ID hráče
     * @return přehled všech odehraných zápasů pro daného hráče
     */
    List<MatchOverviewDTO> getAllPassedMatchesForPlayer(Long playerId);

    /**
     * Zruší zápas a nastaví důvod zrušení.
     *
     * Zápas je označen jako zrušený včetně uvedeného důvodu.
     * Implementace může navazovat další logiku, například
     * odeslání notifikací hráčům.
     *
     * @param matchId ID zápasu
     * @param reason  důvod zrušení
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO cancelMatch(Long matchId, MatchCancelReason reason);

    /**
     * Obnoví dříve zrušený zápas.
     *
     * Zápas se vrací do stavu, kdy je opět platný a může se konat,
     * pokud jsou splněny ostatní podmínky (datum, kapacita a podobně).
     *
     * @param matchId ID zápasu
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO unCancelMatch(Long matchId);

}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.*;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.models.dto.*;
import cz.phsoft.hokej.models.mappers.MatchMapper;
import cz.phsoft.hokej.models.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.notification.NotificationService;
import cz.phsoft.hokej.models.services.notification.MatchTimeChangeContext;
import jakarta.transaction.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Service vrstva se používá pro práci se zápasy.
 *
 * Zajišťuje CRUD operace nad zápasy v rámci sezón, filtrování
 * nadcházejících a proběhlých zápasů, výpočet statistik a přehledů
 * pro hráče i administrátory a rušení či obnovu zápasů.
 *
 * Třída neřeší podrobnou logiku registrací hráčů, která je
 * umístěna v {@link MatchRegistrationService}, ani výběr
 * aktuálního hráče, který je spravován v {@link CurrentPlayerService}
 * a ve vrstvách controllerů.
 */
@Service
public class MatchServiceImpl implements MatchService {

    private static final Logger logger = LoggerFactory.getLogger(MatchServiceImpl.class);

    private static final String ROLE_ADMIN = "ROLE_ADMIN";
    private static final String ROLE_MANAGER = "ROLE_MANAGER";

    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository matchRegistrationRepository;
    private final MatchMapper matchMapper;
    private final MatchRegistrationService registrationService;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodService playerInactivityPeriodService;
    private final PlayerMapper playerMapper;
    private final CurrentPlayerService currentPlayerService;
    private final SeasonService seasonService;
    private final CurrentSeasonService currentSeasonService;
    private final NotificationService notificationService;

    public MatchServiceImpl(MatchRepository matchRepository,
                            MatchRegistrationRepository matchRegistrationRepository,
                            MatchMapper matchMapper,
                            MatchRegistrationService registrationService,
                            PlayerRepository playerRepository,
                            PlayerInactivityPeriodService playerInactivityPeriodService,
                            PlayerMapper playerMapper,
                            CurrentPlayerService currentPlayerService,
                            SeasonService seasonService,
                            CurrentSeasonService currentSeasonService,
                            NotificationService notificationService) {
        this.matchRepository = matchRepository;
        this.matchRegistrationRepository = matchRegistrationRepository;
        this.matchMapper = matchMapper;
        this.registrationService = registrationService;
        this.playerRepository = playerRepository;
        this.playerInactivityPeriodService = playerInactivityPeriodService;
        this.playerMapper = playerMapper;
        this.currentPlayerService = currentPlayerService;
        this.seasonService = seasonService;
        this.currentSeasonService = currentSeasonService;
        this.notificationService = notificationService;
    }

    // ======================
    // ZÁKLADNÍ SEZNAMY ZÁPASŮ
    // ======================

    /**
     * Vrátí všechny zápasy v rámci aktuálně používané sezóny.
     *
     * Zápasy jsou seřazeny podle data a času vzestupně.
     * Součástí výstupu je i číslo zápasu v sezóně.
     */
    @Override
    public List<MatchDTO> getAllMatches() {
        Long seasonId = getCurrentSeasonIdOrActive();
        List<MatchEntity> matches =
                matchRepository.findAllBySeasonIdOrderByDateTimeAsc(seasonId);

        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);
        return assignMatchNumbers(matches, matchMapper::toDTO, matchNumberMap);
    }

    /**
     * Vrátí všechny nadcházející zápasy v aktuální sezóně.
     *
     * Zápasy mají datum a čas v budoucnosti a jsou řazeny
     * podle data vzestupně. Výstup zahrnuje i číslo zápasu
     * v rámci sezóny.
     */
    @Override
    public List<MatchDTO> getUpcomingMatches() {
        Long seasonId = getCurrentSeasonIdOrActive();
        List<MatchEntity> upcomingMatches = findUpcomingMatchesForCurrentSeason();

        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);
        return assignMatchNumbers(upcomingMatches, matchMapper::toDTO, matchNumberMap);
    }

    /**
     * Vrátí všechny proběhlé zápasy v aktuální sezóně.
     *
     * Zápasy mají datum a čas v minulosti a jsou řazeny
     * podle data sestupně (nejnovější jako první).
     * Výstup zahrnuje i číslo zápasu v rámci sezóny.
     */
    @Override
    public List<MatchDTO> getPastMatches() {
        Long seasonId = getCurrentSeasonIdOrActive();
        List<MatchEntity> pastMatches = findPastMatchesForCurrentSeason();

        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);
        return assignMatchNumbers(pastMatches, matchMapper::toDTO, matchNumberMap);
    }

    /**
     * Vrátí nejbližší nadcházející zápas v aktuální sezóně.
     *
     * Pokud žádný nadcházející zápas neexistuje, vrací se {@code null}.
     */
    @Override
    public MatchDTO getNextMatch() {
        return findUpcomingMatchesForCurrentSeason()
                .stream()
                .findFirst()
                .map(matchMapper::toDTO)
                .orElse(null);
    }

    /**
     * Vrátí základní informace o zápasu podle ID.
     *
     * Pokud zápas neexistuje, vyvolá se {@link MatchNotFoundException}.
     *
     * @param id ID zápasu
     * @return zápas ve formě {@link MatchDTO}
     */
    @Override
    public MatchDTO getMatchById(Long id) {
        return matchMapper.toDTO(findMatchOrThrow(id));
    }

    /**
     * Vytvoří nový zápas.
     *
     * DTO se namapuje na entitu, ověří se, že datum zápasu
     * spadá do intervalu aktivní sezóny, a k zápasu se přiřadí
     * aktivní sezóna. Zápas se uloží a vrátí se ve formě DTO.
     */
    @Override
    public MatchDTO createMatch(MatchDTO dto) {
        MatchEntity entity = matchMapper.toEntity(dto);
        validateMatchDateInActiveSeason(entity.getDateTime());

        entity.setSeason(seasonService.getActiveSeason());

        return matchMapper.toDTO(matchRepository.save(entity));
    }

    /**
     * Aktualizuje existující zápas.
     *
     * Zápas se načte z databáze, zkontroluje se oprávnění
     * podle role uživatele a ověří se, zda může být v aktivní sezóně upravován.
     * Poté se přenesou změny z DTO do entity a zápas se uloží.
     * Pokud se změní kapacita, přepočítají se stavy registrací.
     * Pokud se změní datum nebo čas, spustí se notifikace
     * o změně termínu zápasu.
     *
     * @throws InvalidMatchStatusException pokud uživatel bez role administrátora
     *                                     nebo manažera upravuje zápas mimo aktivní sezónu
     * @throws InvalidMatchDateTimeException pokud by po úpravě zápas spadl do minulosti
     */
    @Override
    public MatchDTO updateMatch(Long id, MatchDTO dto) {
        MatchEntity entity = findMatchOrThrow(id);

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        boolean isAdminOrManager = hasAdminOrManagerRole(auth);

        if (!isAdminOrManager) {
            Long activeSeasonId = seasonService.getActiveSeason().getId();
            if (!entity.getSeason().getId().equals(activeSeasonId)) {
                throw new InvalidMatchStatusException(
                        id, " - Zápas nepatří do aktuální sezóny, nelze ho upravit."
                );
            }
        }

        int oldMaxPlayers = entity.getMaxPlayers();
        LocalDateTime oldDateTime = entity.getDateTime();

        matchMapper.updateEntity(dto, entity);

        if (!isAdminOrManager) {
            validateMatchDateInActiveSeason(entity.getDateTime());
        }

        MatchEntity saved = matchRepository.save(entity);

        if (saved.getMaxPlayers() != oldMaxPlayers) {
            registrationService.recalcStatusesForMatch(saved.getId());
        }

        if (saved.getDateTime().isBefore(LocalDateTime.now())) {
            throw new InvalidMatchDateTimeException("Zápas by již byl minulostí");
        }

        boolean dateTimeChanged = !saved.getDateTime().isEqual(oldDateTime);

        if (dateTimeChanged) {
            MatchTimeChangeContext ctx = new MatchTimeChangeContext(saved, oldDateTime);
            notifyPlayersAboutMatchChanges(ctx, MatchStatus.UPDATED);
        }

        return matchMapper.toDTO(saved);
    }

    /**
     * Smaže zápas podle ID.
     *
     * Pokud zápas neexistuje, vyvolá se {@link MatchNotFoundException}.
     * Při úspěchu vrací standardizovanou odpověď s potvrzením
     * a časovou známkou operace.
     *
     * @param id ID zápasu
     * @return odpověď s informací o úspěchu smazání
     */
    @Override
    public SuccessResponseDTO deleteMatch(Long id) {
        MatchEntity match = findMatchOrThrow(id);
        matchRepository.delete(match);

        return new SuccessResponseDTO(
                "BE - Zápas " + match.getId() + match.getDateTime() + " byl úspěšně smazán",
                id,
                LocalDateTime.now().toString()
        );
    }

    /**
     * Zruší zápas s uvedeným důvodem.
     *
     * Zápasu se nastaví stav {@link MatchStatus#CANCELLED}
     * a uloží se důvod zrušení. Pokud je zápas již zrušen,
     * vyvolá se {@link InvalidMatchStatusException}. Po zrušení
     * se odešlou notifikace přihlášeným hráčům.
     */
    @Override
    @Transactional
    public SuccessResponseDTO cancelMatch(Long matchId, MatchCancelReason reason) {
        MatchEntity match = findMatchOrThrow(matchId);
        String message = " je již zrušen";

        if (match.getMatchStatus() == MatchStatus.CANCELLED) {
            throw new InvalidMatchStatusException(matchId, message);
        }

        match.setMatchStatus(MatchStatus.CANCELLED);
        match.setCancelReason(reason);

        MatchEntity saved = matchRepository.save(match);
        notifyPlayersAboutMatchChanges(saved, MatchStatus.CANCELLED);

        return new SuccessResponseDTO(
                "BE - Zápas " + match.getId() + match.getDateTime() + " byl úspěšně zrušen",
                match.getId(),
                LocalDateTime.now().toString()
        );
    }

    /**
     * Obnoví dříve zrušený zápas.
     *
     * Zápasu se odstraní stav {@link MatchStatus#CANCELLED}
     * a důvod zrušení. Pokud zápas zrušen nebyl, vyvolá se
     * {@link InvalidMatchStatusException}. Implementace může
     * navazovat odeslání notifikací o obnovení zápasu.
     */
    @Override
    @Transactional
    public SuccessResponseDTO unCancelMatch(Long matchId) {
        MatchEntity match = findMatchOrThrow(matchId);
        String message = " ještě nebyl zrušen";

        if (match.getMatchStatus() != MatchStatus.CANCELLED) {
            throw new InvalidMatchStatusException(matchId, message);
        }

        match.setMatchStatus(null);
        match.setCancelReason(null);

        return new SuccessResponseDTO(
                "BE - Zápas " + match.getId() + match.getDateTime() + " byl úspěšně obnoven",
                match.getId(),
                LocalDateTime.now().toString()
        );
    }

    // ======================
    // DETAIL ZÁPASU
    // ======================

    /**
     * Vrátí detail zápasu ve formě {@link MatchDetailDTO}.
     *
     * Detail obsahuje souhrnné statistiky, seskupení hráčů podle stavu,
     * informace o kapacitě, cenu na registrovaného hráče a stav
     * aktuálně zvoleného hráče v zápase. Metoda současně uplatňuje
     * přístupová pravidla podle role uživatele a jeho navázaných hráčů.
     */
    @Override
    public MatchDetailDTO getMatchDetail(Long id) {
        MatchEntity match = findMatchOrThrow(id);

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        boolean isAdminOrManager = hasAdminOrManagerRole(auth);

        checkAccessForPlayer(match, auth);

        MatchDetailDTO dto = collectPlayerStatus(match, isAdminOrManager);

        Long currentPlayerId = null;
        try {
            currentPlayerId = currentPlayerService.getCurrentPlayerId();
        } catch (Exception e) {
            logger.debug("Nebyl nalezen currentPlayerId pro match detail {}", id);
        }

        PlayerMatchStatus playerMatchStatus = resolveStatusForPlayer(dto, currentPlayerId);
        dto.setPlayerMatchStatus(playerMatchStatus);

        if (currentPlayerId != null) {
            matchRegistrationRepository.findByPlayerIdAndMatchId(currentPlayerId, match.getId())
                    .ifPresent(reg -> {
                        dto.setExcuseReason(reg.getExcuseReason());
                        dto.setExcuseNote(reg.getExcuseNote());
                    });
        } else {
            dto.setExcuseReason(null);
            dto.setExcuseNote(null);
        }

        dto.setMatchStatus(match.getMatchStatus());
        dto.setCancelReason(match.getCancelReason());

        if (match.getSeason() != null && match.getSeason().getId() != null) {
            Long seasonId = match.getSeason().getId();
            Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);
            Integer number = matchNumberMap.get(match.getId());
            dto.setMatchNumber(number);
        }

        return dto;
    }

    /**
     * Ověří, zda má aktuální uživatel přístup k detailu zápasu.
     *
     * Uživatel musí být přihlášen. Uživatel s rolí administrátora
     * nebo manažera má přístup vždy. Běžný uživatel musí mít
     * navázaného hráče a splnit podmínky podle toho, zda jde
     * o nadcházející nebo proběhlý zápas.
     *
     * Pokud podmínky nejsou splněny, vyvolá se přístupová výjimka.
     */
    private void checkAccessForPlayer(MatchEntity match, Authentication auth) {
        if (auth == null || !auth.isAuthenticated()) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - Musíte být přihlášen."
            );
        }

        boolean isAdminOrManager = hasAdminOrManagerRole(auth);
        if (isAdminOrManager) {
            return;
        }

        Long currentSeasonId = getCurrentSeasonIdOrActive();
        if (match.getSeason() == null || !match.getSeason().getId().equals(currentSeasonId)) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - K detailu zápasu z jiné sezóny nemáte přístup."
            );
        }

        Object principal = auth.getPrincipal();
        if (!(principal instanceof org.springframework.security.core.userdetails.UserDetails userDetails)) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - Nemáte přístup k detailu tohoto zápasu."
            );
        }

        List<PlayerEntity> ownedPlayers =
                playerRepository.findByUser_EmailOrderByIdAsc(userDetails.getUsername());

        if (ownedPlayers.isEmpty()) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - Nemáte přiřazeného žádného hráče."
            );
        }

        LocalDateTime now = now();
        boolean isPastOrNow = !match.getDateTime().isAfter(now);
        List<Long> ownedPlayerIds = ownedPlayers.stream()
                .map(PlayerEntity::getId)
                .toList();

        List<MatchRegistrationDTO> registrations =
                registrationService.getRegistrationsForMatch(match.getId());

        if (!isPastOrNow) {
            boolean hasActivePlayerForMatch = ownedPlayers.stream()
                    .anyMatch(p -> isPlayerActiveForMatch(p, match.getDateTime()));

            if (!hasActivePlayerForMatch) {
                throw new org.springframework.security.access.AccessDeniedException(
                        "BE - Nemáte aktivního hráče pro tento zápas."
                );
            }
            return;
        }

        boolean wasRegistered = registrations.stream()
                .anyMatch(r ->
                        r.getStatus() == PlayerMatchStatus.REGISTERED
                                && ownedPlayerIds.contains(r.getPlayerId())
                );

        if (!wasRegistered) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - K tomuto uplynulému zápasu nemáte oprávnění (nejste mezi registrovanými hráči)."
            );
        }
    }

    /**
     * Sestaví {@link MatchDetailDTO} pro daný zápas.
     *
     * Zápis obsahuje seskupení hráčů podle statusů, počty hráčů
     * v jednotlivých kategoriích, počet volných míst, cenu
     * na registrovaného hráče a seznam hráčů bez reakce.
     * Seznam hráčů bez reakce je dostupný pouze pro administrátory
     * a manažery.
     */
    private MatchDetailDTO collectPlayerStatus(MatchEntity match, boolean isAdminOrManager) {
        List<MatchRegistrationDTO> registrations =
                registrationService.getRegistrationsForMatch(match.getId());

        var statusToPlayersMap = registrations.stream()
                .map(r -> playerRepository.findById(r.getPlayerId())
                        .map(playerMapper::toDTO)
                        .map(dto -> new AbstractMap.SimpleEntry<>(r.getStatus(), dto))
                )
                .filter(Optional::isPresent)
                .map(Optional::get)
                .collect(Collectors.groupingBy(
                        java.util.Map.Entry::getKey,
                        Collectors.mapping(java.util.Map.Entry::getValue, Collectors.toList())
                ));

        List<PlayerDTO> noResponsePlayers =
                registrationService.getNoResponsePlayers(match.getId());

        int inGamePlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()).size();

        int inGamePlayersDark =
                (int) registrations.stream()
                        .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                        .filter(r -> r.getTeam() == Team.DARK)
                        .count();

        int inGamePlayersLight =
                (int) registrations.stream()
                        .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                        .filter(r -> r.getTeam() == Team.LIGHT)
                        .count();

        int substitutePlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.SUBSTITUTE, List.of()).size();

        int outGamePlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()).size()
                        + statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()).size()
                        + statusToPlayersMap.getOrDefault(PlayerMatchStatus.NO_EXCUSED, List.of()).size();

        int waitingPlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()).size();

        int noExcusedPlayersSum =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.NO_EXCUSED, List.of()).size();

        int noActionPlayers = noResponsePlayers.size();

        int remainingSlots = match.getMaxPlayers() - inGamePlayers;
        double pricePerRegistered = inGamePlayers > 0
                ? match.getPrice() / (double) inGamePlayers
                : match.getPrice();

        MatchDetailDTO dto = new MatchDetailDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setLocation(match.getLocation());
        dto.setDescription(match.getDescription());
        dto.setPrice(match.getPrice());
        dto.setMaxPlayers(match.getMaxPlayers());
        dto.setInGamePlayers(inGamePlayers);
        dto.setInGamePlayersDark(inGamePlayersDark);
        dto.setInGamePlayersLight(inGamePlayersLight);
        dto.setSubstitutePlayers(substitutePlayers);
        dto.setOutGamePlayers(outGamePlayers);
        dto.setWaitingPlayers(waitingPlayers);
        dto.setNoExcusedPlayersSum(noExcusedPlayersSum);
        dto.setNoActionPlayers(noActionPlayers);
        dto.setPricePerRegisteredPlayer(pricePerRegistered);
        dto.setRemainingSlots(remainingSlots);

        dto.setRegisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()));
        dto.setReservedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()));
        dto.setUnregisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()));
        dto.setExcusedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()));
        dto.setSubstitutedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.SUBSTITUTE, List.of()));
        dto.setNoExcusedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.NO_EXCUSED, List.of()));

        dto.setNoResponsePlayers(isAdminOrManager ? noResponsePlayers : null);

        return dto;
    }

    /**
     * Odvodí status konkrétního hráče z detailu zápasu.
     *
     * Hráč se hledá v seznamech podle statusu. Pokud není
     * nalezen v žádné kategorii, vrací se stav NO_RESPONSE.
     */
    private PlayerMatchStatus resolveStatusForPlayer(MatchDetailDTO dto, Long playerId) {
        if (dto == null || playerId == null) {
            return PlayerMatchStatus.NO_RESPONSE;
        }

        if (isIn(dto.getRegisteredPlayers(), playerId)) {
            return PlayerMatchStatus.REGISTERED;
        }
        if (isIn(dto.getReservedPlayers(), playerId)) {
            return PlayerMatchStatus.RESERVED;
        }
        if (isIn(dto.getExcusedPlayers(), playerId)) {
            return PlayerMatchStatus.EXCUSED;
        }
        if (isIn(dto.getSubstitutedPlayers(), playerId)) {
            return PlayerMatchStatus.SUBSTITUTE;
        }

        if (isIn(dto.getUnregisteredPlayers(), playerId)) {
            return PlayerMatchStatus.UNREGISTERED;
        }
        if (isIn(dto.getNoExcusedPlayers(), playerId)) {
            return PlayerMatchStatus.NO_EXCUSED;
        }

        return PlayerMatchStatus.NO_RESPONSE;
    }

    /**
     * Ověří, zda je hráč s daným ID přítomen v seznamu hráčů.
     */
    private boolean isIn(List<PlayerDTO> players, Long playerId) {
        return players != null
                && players.stream().anyMatch(p -> p.getId().equals(playerId));
    }

    // ======================
    // DALŠÍ PUBLIC METODY
    // ======================

    /**
     * Vrátí všechny zápasy, ve kterých může daný hráč potenciálně hrát.
     *
     * Zápasy se vybírají napříč všemi sezónami a následně se filtrují
     * podle toho, zda je hráč v daném období aktivní podle
     * {@link PlayerInactivityPeriodService}.
     */
    @Override
    public List<MatchDTO> getAvailableMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        return matchRepository.findAll().stream()
                .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                .map(matchMapper::toDTO)
                .toList();
    }

    /**
     * Najde ID hráče podle e-mailu uživatele.
     *
     * Pokud uživatel nemá žádného hráče, vyvolá se {@link PlayerNotFoundException}.
     */
    @Override
    public Long getPlayerIdByEmail(String email) {
        return playerRepository.findByUserEmail(email)
                .map(PlayerEntity::getId)
                .orElseThrow(() -> new PlayerNotFoundException(email));
    }

    /**
     * Vrátí přehled nadcházejících zápasů pro konkrétního hráče.
     *
     * Zohledňuje typ hráče (VIP, STANDARD, BASIC) a omezuje počet
     * zobrazených zápasů. Současně filtruje jen zápasy, pro které
     * je hráč v daném datu aktivní, a nastavuje stav hráče v zápase.
     */
    @Override
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        List<MatchEntity> upcomingAll = findUpcomingMatchesForCurrentSeason();
        List<MatchEntity> limited = limitMatchesByPlayerType(upcomingAll, type);

        List<MatchEntity> activeMatches = limited.stream()
                .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                .toList();

        Long seasonId = getCurrentSeasonIdOrActive();
        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);

        return assignMatchNumbers(
                activeMatches,
                match -> toOverviewDTO(match, playerId),
                matchNumberMap
        );
    }

    /**
     * Vrátí seznam nadcházejících zápasů pro konkrétního hráče.
     *
     * Výsledek je v plném formátu {@link MatchDTO} a je omezen
     * podle typu hráče a jeho aktivity v termínu zápasu.
     */
    @Override
    public List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        List<MatchEntity> upcomingAll = findUpcomingMatchesForCurrentSeason();
        List<MatchEntity> limited = limitMatchesByPlayerType(upcomingAll, type);

        List<MatchEntity> activeMatches = limited.stream()
                .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                .toList();

        Long seasonId = getCurrentSeasonIdOrActive();
        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);

        return assignMatchNumbers(activeMatches, matchMapper::toDTO, matchNumberMap);
    }

    /**
     * Vrátí přehled všech proběhlých zápasů aktuální sezóny,
     * kterých se hráč mohl účastnit.
     *
     * Zápasy se filtrují podle aktivity hráče v datu zápasu,
     * hromadně se načtou registrace k těmto zápasům a pro každý
     * zápas se odvodí stav hráče. Výstup obsahuje i číslo zápasu
     * v sezóně.
     */
    @Override
    public List<MatchOverviewDTO> getAllPassedMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        List<MatchEntity> availableMatches =
                findPastMatchesForCurrentSeason().stream()
                        .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                        .toList();

        if (availableMatches.isEmpty()) {
            return List.of();
        }

        List<Long> matchIds = availableMatches.stream()
                .map(MatchEntity::getId)
                .toList();

        List<MatchRegistrationDTO> allRegistrations =
                registrationService.getRegistrationsForMatches(matchIds);

        var statusMap = allRegistrations.stream()
                .collect(Collectors.groupingBy(
                        MatchRegistrationDTO::getMatchId,
                        Collectors.toMap(
                                MatchRegistrationDTO::getPlayerId,
                                MatchRegistrationDTO::getStatus,
                                (a, b) -> a
                        )
                ));

        List<MatchOverviewDTO> overviews = availableMatches.stream()
                .map(match -> {
                    MatchOverviewDTO overview = toOverviewDTO(match);
                    PlayerMatchStatus playerMatchStatus = Optional.ofNullable(statusMap.get(match.getId()))
                            .map(m -> normalizePlayerStatus(m.get(playerId)))
                            .orElse(PlayerMatchStatus.NO_RESPONSE);
                    overview.setPlayerMatchStatus(playerMatchStatus);
                    return overview;
                })
                .toList();

        Long seasonId = getCurrentSeasonIdOrActive();
        Map<Long, Integer> matchNumberMap = buildMatchNumberMapForSeason(seasonId);

        overviews.forEach(o -> o.setMatchNumber(matchNumberMap.get(o.getId())));

        return overviews;
    }

    /**
     * Najde hráče podle ID nebo vyhodí {@link PlayerNotFoundException}.
     */
    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    /**
     * Najde zápas podle ID nebo vyhodí {@link MatchNotFoundException}.
     */
    private MatchEntity findMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }

    /**
     * Najde registraci hráče k zápasu nebo vyhodí {@link MatchRegistrationNotFoundException}.
     */
    private MatchRegistrationEntity findMatchRegistrationOrThrow(Long playerId, Long matchId) {
        return matchRegistrationRepository.findByPlayerIdAndMatchId(playerId, matchId)
                .orElseThrow(() -> new MatchRegistrationNotFoundException(playerId, matchId));
    }

    /**
     * Vrátí aktuální čas.
     *
     * Metoda je oddělena kvůli jednoduššímu testování.
     */
    private LocalDateTime now() {
        return LocalDateTime.now();
    }

    // ======================
    // POMOCNÉ METODY – DTO MAPOVÁNÍ
    // ======================

    /**
     * Sestaví základní {@link MatchOverviewDTO} pro daný zápas.
     *
     * DTO obsahuje základní informace o zápasu a počet hráčů
     * se stavem REGISTERED včetně vypočtené ceny na registrovaného
     * hráče.
     */
    private MatchOverviewDTO toOverviewDTO(MatchEntity match) {
        MatchOverviewDTO dto = new MatchOverviewDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setLocation(match.getLocation());
        dto.setDescription(match.getDescription());
        dto.setPrice(match.getPrice());
        dto.setMaxPlayers(match.getMaxPlayers());

        int inGamePlayers = registrationService.getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .mapToInt(r -> 1)
                .sum();
        dto.setInGamePlayers(inGamePlayers);

        double pricePerPlayer = inGamePlayers > 0 && match.getPrice() != null
                ? match.getPrice() / (double) inGamePlayers
                : match.getPrice();
        dto.setPricePerRegisteredPlayer(pricePerPlayer);

        return dto;
    }

    /**
     * Sestaví {@link MatchOverviewDTO} pro daný zápas v kontextu konkrétního hráče.
     *
     * K základním údajům o zápasu doplní i stav hráče v daném zápase.
     */
    private MatchOverviewDTO toOverviewDTO(MatchEntity match, Long playerId) {
        MatchOverviewDTO dto = toOverviewDTO(match);

        PlayerMatchStatus playerMatchStatus = registrationService
                .getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getPlayerId().equals(playerId))
                .map(MatchRegistrationDTO::getStatus)
                .findFirst()
                .map(this::normalizePlayerStatus)
                .orElse(PlayerMatchStatus.NO_RESPONSE);

        dto.setPlayerMatchStatus(playerMatchStatus);
        return dto;
    }

    // ======================
    // DALŠÍ POMOCNÉ METODY
    // ======================

    /**
     * Zjistí, zda má uživatel roli administrátora nebo manažera.
     */
    private boolean hasAdminOrManagerRole(Authentication auth) {
        if (auth == null) {
            return false;
        }
        return auth.getAuthorities().stream()
                .anyMatch(a ->
                        ROLE_ADMIN.equals(a.getAuthority()) ||
                                ROLE_MANAGER.equals(a.getAuthority())
                );
    }

    /**
     * Vrátí všechny nadcházející zápasy v aktuální sezóně.
     *
     * Zápasy mají datum a čas větší než aktuální okamžik
     * a jsou seřazeny podle data vzestupně.
     */
    private List<MatchEntity> findUpcomingMatchesForCurrentSeason() {
        return matchRepository.findBySeasonIdAndDateTimeAfterOrderByDateTimeAsc(
                getCurrentSeasonIdOrActive(),
                now()
        );
    }

    /**
     * Vrátí všechny proběhlé zápasy v aktuální sezóně.
     *
     * Zápasy mají datum a čas menší než aktuální okamžik
     * a jsou seřazeny podle data sestupně.
     */
    private List<MatchEntity> findPastMatchesForCurrentSeason() {
        return matchRepository.findBySeasonIdAndDateTimeBeforeOrderByDateTimeDesc(
                getCurrentSeasonIdOrActive(),
                now()
        );
    }

    /**
     * Omezuje nadcházející zápasy podle typu hráče.
     *
     * Pro typ VIP vrací tři nejbližší zápasy, pro STANDARD dva
     * a pro BASIC pouze jeden nejbližší zápas.
     */
    private List<MatchEntity> limitMatchesByPlayerType(List<MatchEntity> upcomingAll, PlayerType type) {
        if (upcomingAll == null || upcomingAll.isEmpty()) {
            return List.of();
        }

        return switch (type) {
            case VIP -> upcomingAll.stream().limit(3).toList();
            case STANDARD -> upcomingAll.stream().limit(2).toList();
            case BASIC -> List.of(upcomingAll.get(0));
        };
    }

    /**
     * Ověří, zda je hráč aktivní pro dané datum zápasu.
     *
     * Informace o aktivitě hráče se zjišťuje pomocí
     * {@link PlayerInactivityPeriodService}.
     */
    private boolean isPlayerActiveForMatch(PlayerEntity player, LocalDateTime dateTime) {
        return playerInactivityPeriodService.isActive(player, dateTime);
    }

    /**
     * Normalizuje stav registrace hráče.
     *
     * Pokud je stav {@code null}, vrací se NO_RESPONSE.
     * V případě ostatních podporovaných stavů se vrací
     * původní hodnota, jinak se použije NO_RESPONSE.
     */
    private PlayerMatchStatus normalizePlayerStatus(PlayerMatchStatus status) {
        if (status == null) {
            return PlayerMatchStatus.NO_RESPONSE;
        }

        return switch (status) {
            case REGISTERED,
                 UNREGISTERED,
                 EXCUSED,
                 SUBSTITUTE,
                 RESERVED,
                 NO_EXCUSED -> status;
            default -> PlayerMatchStatus.NO_RESPONSE;
        };
    }

    /**
     * Ověří, že datum zápasu spadá do období aktivní sezóny.
     *
     * Pokud datum leží mimo interval aktivní sezóny, vyvolá se
     * {@link InvalidSeasonPeriodDateException}.
     */
    private void validateMatchDateInActiveSeason(LocalDateTime dateTime) {
        var activeSeason = seasonService.getActiveSeason();
        var date = dateTime.toLocalDate();

        if (date.isBefore(activeSeason.getStartDate()) ||
                date.isAfter(activeSeason.getEndDate())) {

            throw new InvalidSeasonPeriodDateException(
                    "BE - Datum zápasu musí být v rozmezí aktivní sezóny (" +
                            activeSeason.getStartDate() + " - " + activeSeason.getEndDate() + ")."
            );
        }
    }

    /**
     * Vrátí ID sezóny, která se má použít pro práci se zápasy.
     *
     * Nejprve se použije sezóna uložená v {@link CurrentSeasonService}.
     * Pokud není k dispozici, použije se globálně aktivní sezóna
     * z {@link SeasonService}.
     */
    private Long getCurrentSeasonIdOrActive() {
        Long id = currentSeasonService.getCurrentSeasonIdOrDefault();
        if (id != null) {
            return id;
        }
        return seasonService.getActiveSeason().getId();
    }

    /**
     * Přidá zápasům číslo v sezóně podle mapy matchId → pořadí.
     *
     * Metoda se používá jako společný pomocník pro mapování
     * entit na DTO, která implementují {@link NumberedMatchDTO}.
     */
    private <D extends NumberedMatchDTO> List<D> assignMatchNumbers(
            List<MatchEntity> matches,
            Function<MatchEntity, D> mapper,
            Map<Long, Integer> matchNumberMap
    ) {
        return matches.stream()
                .map(entity -> {
                    D dto = mapper.apply(entity);
                    Integer number = matchNumberMap.get(entity.getId());
                    dto.setMatchNumber(number);
                    return dto;
                })
                .toList();
    }

    /**
     * Pro danou sezónu sestaví mapu matchId → pořadové číslo zápasu v sezóně.
     *
     * Pořadí zápasů vychází z datumu a času zápasu řazeného vzestupně.
     */
    private Map<Long, Integer> buildMatchNumberMapForSeason(Long seasonId) {
        List<MatchEntity> allMatchesInSeason =
                matchRepository.findAllBySeasonIdOrderByDateTimeAsc(seasonId);

        Map<Long, Integer> map = new HashMap<>();
        int counter = 1;
        for (MatchEntity m : allMatchesInSeason) {
            map.put(m.getId(), counter++);
        }
        return map;
    }

    /**
     * Odešle notifikace hráčům o změnách souvisejících se zápasem.
     *
     * Context představuje buď samotný zápas, nebo objekt
     * {@link MatchTimeChangeContext} v případě změny termínu.
     * Na základě typu změny zápasu se určí konkrétní typ notifikace.
     */
    private void notifyPlayersAboutMatchChanges(Object context, MatchStatus matchStatus) {
        MatchEntity match;
        if (context instanceof MatchTimeChangeContext mtc) {
            match = mtc.match();
        } else if (context instanceof MatchEntity m) {
            match = m;
        } else {
            throw new IllegalArgumentException("Nepodporovaný typ contextu: " + context);
        }

        var registrations = matchRegistrationRepository.findByMatchId(match.getId());

        registrations.stream()
                .filter(reg -> reg.getStatus() == PlayerMatchStatus.REGISTERED
                        || reg.getStatus() == PlayerMatchStatus.RESERVED)
                .forEach(reg -> {
                    PlayerEntity player = reg.getPlayer();

                    if (matchStatus == MatchStatus.UPDATED) {
                        notificationService.notifyPlayer(
                                player,
                                NotificationType.MATCH_TIME_CHANGED,
                                context
                        );
                    }

                    if (matchStatus == MatchStatus.CANCELLED) {
                        notificationService.notifyPlayer(
                                player,
                                NotificationType.MATCH_CANCELED,
                                match
                        );
                    }

                    if (matchStatus == MatchStatus.UNCANCELED) {
                        notificationService.notifyPlayer(
                                player,
                                NotificationType.MATCH_UNCANCELED,
                                match
                        );
                    }
                });
    }

}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\NotificationDecision.java
-----

package cz.phsoft.hokej.models.services;

/**
 * Datový objekt reprezentující výsledek vyhodnocení
 * notifikačních preferencí pro konkrétní událost.
 *
 * Slouží jako přenosový objekt mezi logikou vyhodnocení
 * notifikací a konkrétními kanály odesílání (email, SMS).
 *
 * Objekt jednoznačně určuje:
 * - zda má být odeslán email uživateli (AppUser),
 * - zda má být odeslán email hráči na jeho vlastní kontakt,
 * - zda má být odeslána SMS hráči,
 * - jaké konkrétní kontaktní údaje se mají použít.
 *
 * Třída neřeší:
 * - samotné odesílání notifikací,
 * - sestavení obsahu zpráv,
 * - validaci kontaktních údajů.
 *
 * Používá se typicky v NotificationService
 * jako výsledek rozhodovací logiky.
 */
public class NotificationDecision {

    // ==================================================
    // EMAIL – UŽIVATEL (AppUser)
    // ==================================================

    /**
     * Určuje, zda má být odeslán email uživateli (AppUser).
     *
     * Hodnota {@code true} znamená, že notifikace má být
     * odeslána na email navázaný na uživatelský účet.
     */
    private boolean sendEmailToUser;

    /**
     * Emailová adresa uživatele (AppUser.email),
     * na kterou má být případná notifikace odeslána.
     */
    private String userEmail;

    /**
     * Celé jméno uživatele.
     *
     * Používá se zejména pro personalizaci textu
     * emailové zprávy.
     */
    private String fullname;

    // ==================================================
    // EMAIL – HRÁČ
    // ==================================================

    /**
     * Určuje, zda má být odeslán email přímo hráči.
     *
     * Email se odesílá na kontakt definovaný v nastavení hráče,
     * typicky {@code PlayerSettings.contactEmail}.
     */
    private boolean sendEmailToPlayer;

    /**
     * Emailová adresa hráče.
     *
     * Hodnota obvykle pochází z {@code PlayerSettings.contactEmail},
     * případně může být použita náhradní (fallback) hodnota
     * podle logiky vyhodnocení.
     */
    private String playerEmail;

    // ==================================================
    // SMS – HRÁČ
    // ==================================================

    /**
     * Určuje, zda má být odeslána SMS hráči.
     *
     * Hodnota {@code true} znamená, že hráč má povolené
     * SMS notifikace a je k dispozici platné telefonní číslo.
     */
    private boolean sendSmsToPlayer;

    /**
     * Telefonní číslo hráče.
     *
     * Hodnota obvykle pochází z {@code PlayerSettings.contactPhone},
     * případně se použije fallback hodnota uložená přímo u hráče.
     */
    private String playerPhone;

    // ==================================================
    // GETTERY / SETTERY
    // ==================================================

    public boolean isSendEmailToUser() {
        return sendEmailToUser;
    }

    public void setSendEmailToUser(boolean sendEmailToUser) {
        this.sendEmailToUser = sendEmailToUser;
    }

    public String getUserEmail() {
        return userEmail;
    }

    public void setUserEmail(String userEmail) {
        this.userEmail = userEmail;
    }

    public boolean isSendEmailToPlayer() {
        return sendEmailToPlayer;
    }

    public void setSendEmailToPlayer(boolean sendEmailToPlayer) {
        this.sendEmailToPlayer = sendEmailToPlayer;
    }

    public String getPlayerEmail() {
        return playerEmail;
    }

    public void setPlayerEmail(String playerEmail) {
        this.playerEmail = playerEmail;
    }

    public boolean isSendSmsToPlayer() {
        return sendSmsToPlayer;
    }

    public void setSendSmsToPlayer(boolean sendSmsToPlayer) {
        this.sendSmsToPlayer = sendSmsToPlayer;
    }

    public String getPlayerPhone() {
        return playerPhone;
    }

    public void setPlayerPhone(String playerPhone) {
        this.playerPhone = playerPhone;
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;

import java.time.LocalDateTime;
import java.util.List;

/**
 * Rozhraní pro správu období neaktivity hráčů.
 *
 * Tato service definuje kontrakt pro práci s časovými úseky,
 * ve kterých je hráč považován za neaktivního
 * (zranění, dovolená, dlouhodobá absence a podobné situace).
 *
 * Odpovědnosti:
 * - eviduje období, kdy se hráč nemůže účastnit zápasů,
 * - poskytuje přehledy období neaktivity pro konkrétního hráče i pro administraci,
 * - umožňuje ověření, zda je hráč v daném okamžiku aktivní.
 *
 * Tato service:
 * - pracuje s DTO {@link PlayerInactivityPeriodDTO}, nikoliv přímo s entitami,
 * - odděluje business logiku neaktivity od persistence vrstvy.
 *
 * Tato service neřeší:
 * - autorizaci a role uživatelů,
 * - notifikace,
 * - UI logiku.
 */
public interface PlayerInactivityPeriodService {

    /**
     * Vrátí seznam všech období neaktivity v systému.
     *
     * Typicky se používá v administrátorských přehledech.
     *
     * @return seznam všech období neaktivity ve formě DTO
     */
    List<PlayerInactivityPeriodDTO> getAll();

    /**
     * Vrátí období neaktivity podle jeho ID.
     *
     * @param id ID období neaktivity
     * @return období neaktivity ve formě DTO
     */
    PlayerInactivityPeriodDTO getById(Long id);

    /**
     * Vrátí seznam období neaktivity pro konkrétního hráče.
     *
     * @param playerId ID hráče
     * @return seznam období neaktivity daného hráče
     */
    List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId);

    /**
     * Vytvoří nové období neaktivity hráče.
     *
     * Implementace je zodpovědná za:
     * - validaci časového rozsahu (začátek před koncem),
     * - kontrolu překryvů s existujícími obdobími neaktivity.
     *
     * @param dto data nového období neaktivity
     * @return vytvořené období neaktivity ve formě DTO
     */
    PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto);

    /**
     * Aktualizuje existující období neaktivity.
     *
     * Implementace je zodpovědná za:
     * - validaci časového rozsahu,
     * - kontrolu překryvů s ostatními obdobími neaktivity daného hráče.
     *
     * @param id  ID období neaktivity, které má být upraveno
     * @param dto nové hodnoty období neaktivity
     * @return aktualizované období neaktivity ve formě DTO
     */
    PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto);

    /**
     * Odstraní období neaktivity podle ID.
     *
     * @param id ID období neaktivity, které má být smazáno
     */
    void delete(Long id);

    /**
     * Ověří, zda je hráč v daném okamžiku aktivní.
     *
     * Metoda vrací informaci, zda se zadaný čas
     * nenachází v žádném z evidovaných období neaktivity hráče.
     *
     * Typické použití:
     * - při registraci hráče na zápas,
     * - při validaci účasti hráče v konkrétním čase,
     * - při filtrování dostupných zápasů pro hráče.
     *
     * @param player   hráč, jehož aktivita se ověřuje
     * @param dateTime časový okamžik, pro který se aktivita kontroluje
     * @return true, pokud je hráč v daném čase aktivní, jinak false
     */
    boolean isActive(PlayerEntity player, LocalDateTime dateTime);
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.data.repositories.PlayerInactivityPeriodRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.InactivityPeriodNotFoundException;
import cz.phsoft.hokej.exceptions.InactivityPeriodOverlapException;
import cz.phsoft.hokej.exceptions.InvalidInactivityPeriodDateException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import cz.phsoft.hokej.models.mappers.PlayerInactivityPeriodMapper;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

/**
 * Service implementace pro správu období neaktivity hráčů.
 *
 * Obchodní význam:
 * - určuje, zda je hráč v daném čase aktivní nebo neaktivní,
 * - poskytuje podklady pro rozhodování, zda může být hráč
 *   zařazen do zápasu nebo mít přístup k určitým funkcím.
 *
 * Typické použití:
 * - při filtrování zápasů dostupných pro hráče,
 * - v přístupové logice k detailu zápasu,
 * - při registraci hráče na zápas.
 *
 * Klíčové pravidlo:
 * - hráč nesmí mít překrývající se období neaktivity
 *   (překryv je považován za chybu dat).
 *
 * Tato service:
 * - řeší pouze doménová pravidla pro neaktivitu,
 * - neřeší bezpečnost, role ani notifikace,
 * - využívá mapper {@link PlayerInactivityPeriodMapper}
 *   pro převod mezi entitami a DTO.
 */
@Service
public class PlayerInactivityPeriodServiceImpl implements PlayerInactivityPeriodService {

    private final PlayerInactivityPeriodRepository inactivityRepository;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodMapper mapper;

    public PlayerInactivityPeriodServiceImpl(
            PlayerInactivityPeriodRepository inactivityRepository,
            PlayerRepository playerRepository,
            PlayerInactivityPeriodMapper mapper
    ) {
        this.inactivityRepository = inactivityRepository;
        this.playerRepository = playerRepository;
        this.mapper = mapper;
    }

    // ======================
    // READ OPERACE
    // ======================

    /**
     * Vrátí všechna období neaktivity všech hráčů.
     *
     * Používá se zejména v administrátorských přehledech
     * nebo interních reportech.
     *
     * @return seznam všech období neaktivity ve formě DTO
     */
    @Override
    public List<PlayerInactivityPeriodDTO> getAll() {
        return inactivityRepository.findAll().stream()
                .map(mapper::toDTO)
                .toList();
    }

    /**
     * Vrátí konkrétní období neaktivity podle ID.
     *
     * @param id ID období neaktivity
     * @return DTO reprezentace období neaktivity
     * @throws InactivityPeriodNotFoundException pokud záznam neexistuje
     */
    @Override
    public PlayerInactivityPeriodDTO getById(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new InactivityPeriodNotFoundException(id));

        return mapper.toDTO(entity);
    }

    /**
     * Vrátí všechna období neaktivity konkrétního hráče,
     * seřazená podle začátku neaktivity od nejstaršího.
     *
     * @param playerId ID hráče
     * @return seznam období neaktivity ve formě DTO
     * @throws PlayerNotFoundException pokud hráč neexistuje
     */
    @Override
    public List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId) {
        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));

        return inactivityRepository.findByPlayerOrderByInactiveFromAsc(player).stream()
                .map(mapper::toDTO)
                .toList();
    }

    // ======================
    // CREATE
    // ======================

    /**
     * Vytvoří nové období neaktivity hráče.
     *
     * Před uložením se ověřuje:
     * - existence hráče,
     * - platnost dat (od/do),
     * - nepřekrývání s jinými obdobími neaktivity daného hráče.
     *
     * @param dto data nového období neaktivity
     * @return nově vytvořené období neaktivity ve formě DTO
     * @throws PlayerNotFoundException              pokud hráč neexistuje
     * @throws InvalidInactivityPeriodDateException pokud je rozsah dat neplatný
     * @throws InactivityPeriodOverlapException     pokud se nové období překrývá s existujícím
     */
    @Override
    @Transactional
    public PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto) {

        PlayerEntity player = playerRepository.findById(dto.getPlayerId())
                .orElseThrow(() -> new PlayerNotFoundException(dto.getPlayerId()));

        validateDates(dto);

        // kontrola překryvu existujících období pro daného hráče
        boolean overlaps = !inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        player,
                        dto.getInactiveFrom(),
                        dto.getInactiveTo()
                ).isEmpty();

        if (overlaps) {
            throw new InactivityPeriodOverlapException();
        }

        PlayerInactivityPeriodEntity entity = mapper.toEntity(dto, player);
        PlayerInactivityPeriodEntity saved = inactivityRepository.save(entity);

        return mapper.toDTO(saved);
    }

    // ======================
    // UPDATE
    // ======================

    /**
     * Aktualizuje existující období neaktivity.
     *
     * Oproti vytvoření nového období se při kontrole překryvu
     * ignoruje aktuální záznam (aby nebyl považován za kolizi sám se sebou).
     *
     * @param id  ID upravovaného období
     * @param dto nové hodnoty období neaktivity
     * @return aktualizované období neaktivity ve formě DTO
     * @throws InactivityPeriodNotFoundException     pokud záznam neexistuje
     * @throws InvalidInactivityPeriodDateException  pokud je rozsah dat neplatný
     * @throws InactivityPeriodOverlapException      pokud se upravené období překrývá s jiným
     */
    @Override
    @Transactional
    public PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto) {

        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new InactivityPeriodNotFoundException(id));

        validateDates(dto);

        // kontrola překryvu – existující záznamy kromě aktuálního ID
        boolean overlaps = inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        entity.getPlayer(),
                        dto.getInactiveFrom(),
                        dto.getInactiveTo()
                ).stream()
                .anyMatch(p -> !p.getId().equals(id));

        if (overlaps) {
            throw new InactivityPeriodOverlapException(
                    "BE - Upravené období se překrývá s jiným obdobím neaktivity hráče."
            );
        }

        mapper.updateEntityFromDto(dto, entity);
        PlayerInactivityPeriodEntity saved = inactivityRepository.save(entity);

        return mapper.toDTO(saved);
    }

    // ======================
    // DELETE
    // ======================

    /**
     * Smaže období neaktivity podle ID.
     *
     * @param id ID období neaktivity
     * @throws InactivityPeriodNotFoundException pokud záznam neexistuje
     */
    @Override
    @Transactional
    public void delete(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new InactivityPeriodNotFoundException(id));

        inactivityRepository.delete(entity);
    }

    // ======================
    // AKTIVITA HRÁČE
    // ======================

    /**
     * Ověří, zda je hráč v daném čase aktivní.
     *
     * Hráč je považován za neaktivního, pokud existuje období neaktivity,
     * které daný časový okamžik zahrnuje. Metoda vrací negaci této podmínky.
     *
     * Typické použití:
     * - v {@link MatchServiceImpl} při filtrování dostupných zápasů,
     * - v přístupové logice k detailu zápasu,
     * - při posuzování, zda má hráč „nárok“ na účast v zápase.
     *
     * @param player   hráč, jehož aktivita se ověřuje
     * @param dateTime časový okamžik, pro který se aktivita kontroluje
     * @return true, pokud hráč není v daném čase v žádném období neaktivity, jinak false
     */
    @Override
    public boolean isActive(PlayerEntity player, LocalDateTime dateTime) {
        // pokud existuje záznam pokrývající daný čas → hráč je neaktivní
        return !inactivityRepository
                .existsByPlayerAndInactiveFromLessThanEqualAndInactiveToGreaterThanEqual(
                        player,
                        dateTime,
                        dateTime
                );
    }

    // ======================
    // PRIVÁTNÍ VALIDACE
    // ======================

    /**
     * Validuje časový rozsah období neaktivity.
     *
     * Kontroluje se:
     * - že datum od i do není null,
     * - že datum od je před datem do.
     *
     * @param dto DTO s daty období neaktivity
     * @throws InvalidInactivityPeriodDateException při neplatném rozsahu dat
     */
    private void validateDates(PlayerInactivityPeriodDTO dto) {
        if (dto.getInactiveFrom() == null || dto.getInactiveTo() == null) {
            throw new InvalidInactivityPeriodDateException(
                    "BE - Datum od a do nesmí být null."
            );
        }

        if (!dto.getInactiveFrom().isBefore(dto.getInactiveTo())) {
            throw new InvalidInactivityPeriodDateException(
                    "BE - Datum 'od' musí být před 'do'."
            );
        }
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;

import java.util.List;

/**
 * Rozhraní pro správu hráčů v aplikaci.
 *
 * Rozhraní definuje kontrakt pro práci s hráči z pohledu business logiky,
 * včetně jejich vytváření, úprav, schvalování a vazby na uživatele.
 *
 * Odpovědnosti:
 * - správa životního cyklu hráčů (vytvoření, úprava, smazání),
 * - správa vazby hráčů na uživatelské účty,
 * - řízení stavu hráče (čekající, schválený, zamítnutý),
 * - správa „aktuálního hráče“ v kontextu uživatele.
 *
 * Rozhraní se používá:
 * - v controllerech pro hráče a administraci,
 * - v dalších service třídách, které potřebují pracovat s hráči na DTO úrovni.
 */
public interface PlayerService {

    /**
     * Vrátí seznam všech hráčů v systému.
     *
     * Metoda se používá typicky v administrátorských přehledech.
     *
     * @return seznam všech hráčů ve formě {@link PlayerDTO}
     */
    List<PlayerDTO> getAllPlayers();

    /**
     * Vrátí hráče podle jeho ID.
     *
     * @param id ID hráče
     * @return hráč ve formě {@link PlayerDTO}
     */
    PlayerDTO getPlayerById(Long id);

    /**
     * Vytvoří nového hráče bez explicitní vazby na uživatele.
     *
     * Typicky se používá v administraci pro ruční založení hráče.
     *
     * @param player data nového hráče
     * @return vytvořený hráč ve formě {@link PlayerDTO}
     */
    PlayerDTO createPlayer(PlayerDTO player);

    /**
     * Vytvoří nového hráče a přiřadí jej ke konkrétnímu uživateli.
     *
     * Metoda se používá v případech, kdy je hráč vytvářen
     * v kontextu již existujícího uživatelského účtu.
     *
     * @param dto       data nového hráče
     * @param userEmail email uživatele, ke kterému má být hráč přiřazen
     * @return vytvořený hráč ve formě {@link PlayerDTO}
     */
    PlayerDTO createPlayerForUser(PlayerDTO dto, String userEmail);

    /**
     * Aktualizuje údaje existujícího hráče.
     *
     * Metoda aktualizuje základní identifikační a kontaktní údaje
     * i parametry hráče (typ, tým, status).
     *
     * @param id     ID hráče, který má být aktualizován
     * @param player nové hodnoty hráče
     * @return aktualizovaný hráč ve formě {@link PlayerDTO}
     */
    PlayerDTO updatePlayer(Long id, PlayerDTO player);

    /**
     * Odstraní hráče ze systému.
     *
     * Typicky se používá v administraci. Návratová hodnota informuje
     * o úspěchu operace ve formě {@link SuccessResponseDTO}.
     *
     * @param id ID hráče, který má být odstraněn
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO deletePlayer(Long id);

    /**
     * Vrátí seznam hráčů přiřazených ke konkrétnímu uživateli.
     *
     * Metoda se používá například při zobrazení hráčů přihlášeného uživatele.
     *
     * @param email email uživatele
     * @return seznam hráčů daného uživatele ve formě {@link PlayerDTO}
     */
    List<PlayerDTO> getPlayersByUser(String email);

    /**
     * Schválí hráče.
     *
     * Po schválení je hráč považován za aktivního
     * a může se účastnit zápasů podle dalších pravidel aplikace.
     *
     * @param id ID hráče
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO approvePlayer(Long id);

    /**
     * Zamítne hráče.
     *
     * Zamítnutý hráč se nepovažuje za aktivního
     * a nemůže se účastnit zápasů.
     *
     * @param id ID hráče
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO rejectPlayer(Long id);

    /**
     * Nastaví aktuálního hráče pro konkrétního uživatele.
     *
     * Metoda slouží k explicitnímu výběru hráče v případě,
     * že má uživatel přiřazeno více hráčů.
     *
     * @param userEmail email uživatele
     * @param playerId  ID hráče, který má být nastaven jako aktuální
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO setCurrentPlayerForUser(String userEmail, Long playerId);

    /**
     * Automaticky zvolí aktuálního hráče pro daného uživatele
     * podle jeho nastavení (AppUserSettings.playerSelectionMode).
     *
     * Typické použití:
     * - po přihlášení uživatele,
     * - při explicitním volání z frontendu (například tlačítko „Vybrat výchozího hráče“).
     *
     * @param userEmail email přihlášeného uživatele
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO autoSelectCurrentPlayerForUser(String userEmail);

    /**
     * Změní přiřazeného uživatele k existujícímu hráči.
     *
     * Metoda slouží k administrátorské úpravě vazby mezi hráčem a
     * uživatelským účtem, například při opravě chybného přiřazení
     * nebo převodu hráče pod jiný uživatelský účet.
     *
     * Implementace mění pouze vazbu hráč → uživatel,
     * ostatní business logika (například změna current player)
     * je ponechána volajícímu.
     *
     * @param id        ID hráče, kterému se má změnit přiřazený uživatel
     * @param newUserId ID nového uživatele, ke kterému má být hráč přiřazen
     */
    void changePlayerUser(Long id, Long newUserId);

}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerSettingsEntity;
import cz.phsoft.hokej.data.enums.PlayerSelectionMode;
import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.notification.NotificationService;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;
import cz.phsoft.hokej.models.dto.PlayerDTO;

import static cz.phsoft.hokej.data.enums.PlayerStatus.APPROVED;
import static cz.phsoft.hokej.data.enums.PlayerStatus.REJECTED;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Service vrstva pro práci s hráči ({@link PlayerEntity}).
 *
 * Tato třída zodpovídá za:
 * - provádění CRUD operací nad hráči,
 * - kontrolu duplicity jména a příjmení,
 * - správu vazby hráče na uživatele ({@link AppUserEntity}),
 * - změnu statusu hráče (APPROVED, REJECTED) včetně spuštění notifikací,
 * - nastavení aktuálního hráče v {@link CurrentPlayerService}
 *   pro přihlášeného uživatele.
 *
 * Tato třída neřeší:
 * - HTTP vrstvu, session a mapování requestů a response (řeší controllery),
 * - autentizaci a autorizaci (řeší Spring Security a controller vrstva),
 * - detailní logiku zápasů (řeší {@link MatchServiceImpl} a navazující služby).
 */
@Service
public class PlayerServiceImpl implements PlayerService {

    private final PlayerRepository playerRepository;
    private final PlayerMapper playerMapper;
    private final AppUserRepository appUserRepository;
    private final NotificationService notificationService;
    private final CurrentPlayerService currentPlayerService;
    private final AppUserSettingsService appUserSettingsService;
    private final PlayerSettingsService playerSettingsService;

    public PlayerServiceImpl(
            PlayerRepository playerRepository,
            PlayerMapper playerMapper,
            AppUserRepository appUserRepository,
            NotificationService notificationService,
            CurrentPlayerService currentPlayerService,
            AppUserSettingsService appUserSettingsService,
            PlayerSettingsService playerSettingsService
    ) {
        this.playerRepository = playerRepository;
        this.playerMapper = playerMapper;
        this.appUserRepository = appUserRepository;
        this.notificationService = notificationService;
        this.currentPlayerService = currentPlayerService;
        this.appUserSettingsService = appUserSettingsService;
        this.playerSettingsService = playerSettingsService;
    }

    // ======================
    // CREATE / UPDATE / DELETE
    // ======================

    /**
     * Vytvoří nového hráče bez vazby na uživatele.
     *
     * Před uložením se kontroluje duplicita kombinace jména a příjmení.
     * Po vytvoření se notifikace neodesílá, aby bylo zachováno původní chování.
     *
     * @param dto data nového hráče
     * @return vytvořený hráč ve formě {@link PlayerDTO}
     */
    @Override
    @Transactional
    public PlayerDTO createPlayer(PlayerDTO dto) {
        ensureUniqueNameSurname(dto.getName(), dto.getSurname(), null);

        PlayerEntity entity = playerMapper.toEntity(dto);
        PlayerEntity saved = playerRepository.save(entity);

        return playerMapper.toDTO(saved);
    }

    /**
     * Vytvoří nového hráče a přiřadí jej k uživateli podle emailu.
     *
     * Postup:
     * - vyhledá se uživatel podle emailu,
     * - ověří se, že neexistuje jiný hráč se stejným jménem a příjmením,
     * - namapuje se {@link PlayerDTO} na {@link PlayerEntity},
     * - nastaví se vazba na uživatele a hráč se uloží,
     * - odešle se notifikace {@link NotificationType#PLAYER_CREATED}.
     *
     * @param dto       data nového hráče
     * @param userEmail email uživatele, ke kterému má být hráč přiřazen
     * @return vytvořený hráč ve formě {@link PlayerDTO}
     * @throws UserNotFoundException         pokud uživatel neexistuje
     * @throws DuplicateNameSurnameException pokud existuje hráč se stejným jménem a příjmením
     */
    @Override
    @Transactional
    public PlayerDTO createPlayerForUser(PlayerDTO dto, String userEmail) {
        AppUserEntity user = appUserRepository.findByEmail(userEmail)
                .orElseThrow(() -> new UserNotFoundException(userEmail));

        ensureUniqueNameSurname(dto.getName(), dto.getSurname(), null);

        PlayerEntity player = playerMapper.toEntity(dto);
        player.setUser(user);
        PlayerEntity saved = playerRepository.save(player);

        notifyPlayer(saved, NotificationType.PLAYER_CREATED, saved);

        return playerMapper.toDTO(saved);
    }

    /**
     * Aktualizuje existujícího hráče.
     *
     * Při změně jména nebo příjmení se kontroluje duplicita kombinace jméno + příjmení.
     * Poté se přepíší základní údaje hráče a odešle se notifikace
     * {@link NotificationType#PLAYER_UPDATED}.
     *
     * @param id  ID hráče
     * @param dto nové hodnoty hráče
     * @return aktualizovaný hráč ve formě {@link PlayerDTO}
     * @throws PlayerNotFoundException       pokud hráč neexistuje
     * @throws DuplicateNameSurnameException pokud nová kombinace jméno + příjmení koliduje
     *                                       s jiným hráčem
     */
    @Override
    @Transactional
    public PlayerDTO updatePlayer(Long id, PlayerDTO dto) {
        PlayerEntity existing = findPlayerOrThrow(id);

        boolean nameChanged =
                !existing.getName().equals(dto.getName()) ||
                        !existing.getSurname().equals(dto.getSurname());

        if (nameChanged) {
            ensureUniqueNameSurname(dto.getName(), dto.getSurname(), id);
        }

        existing.setName(dto.getName());
        existing.setSurname(dto.getSurname());
        existing.setNickname(dto.getNickname());
        existing.setPhoneNumber(dto.getPhoneNumber());
        existing.setType(dto.getType());
        existing.setTeam(dto.getTeam());
        if (dto.getPlayerStatus() != null) {
            existing.setPlayerStatus(dto.getPlayerStatus());
        }

        PlayerEntity saved = playerRepository.save(existing);
        notifyPlayer(saved, NotificationType.PLAYER_UPDATED, saved);

        return playerMapper.toDTO(saved);
    }

    /**
     * Smaže hráče podle ID.
     *
     * Po smazání je odeslána notifikace {@link NotificationType#PLAYER_DELETED}.
     *
     * @param id ID hráče
     * @return {@link SuccessResponseDTO} s potvrzující zprávou
     * @throws PlayerNotFoundException pokud hráč neexistuje
     */
    @Override
    @Transactional
    public SuccessResponseDTO deletePlayer(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);
        playerRepository.delete(player);

        String message = "Hráč " + player.getFullName() + " byl úspěšně smazán";
        notifyPlayer(player, NotificationType.PLAYER_DELETED, player);

        return buildSuccessResponse(message, id);
    }

    // ======================
    // STATUS – APPROVE / REJECT
    // ======================

    /**
     * Schválí hráče a nastaví mu status {@link PlayerStatus#APPROVED}.
     *
     * Pokud je hráč již schválen, vyhodí se výjimka
     * {@link InvalidPlayerStatusException}. Po schválení se odešle
     * notifikace {@link NotificationType#PLAYER_APPROVED}.
     *
     * @param id ID hráče
     * @return odpověď s výsledkem operace
     */
    @Override
    @Transactional
    public SuccessResponseDTO approvePlayer(Long id) {
        return changePlayerStatus(
                id,
                PlayerStatus.APPROVED,
                PlayerStatus.APPROVED,
                NotificationType.PLAYER_APPROVED,
                "BE - Hráč už je schválen.",
                "Hráč %s byl úspěšně aktivován"
        );
    }

    /**
     * Zamítne hráče a nastaví mu status {@link PlayerStatus#REJECTED}.
     *
     * Pokud je hráč již zamítnut, vyhodí se výjimka
     * {@link InvalidPlayerStatusException}. Po zamítnutí se odešle
     * notifikace {@link NotificationType#PLAYER_REJECTED}.
     *
     * @param id ID hráče
     * @return odpověď s výsledkem operace
     */
    @Override
    @Transactional
    public SuccessResponseDTO rejectPlayer(Long id) {
        return changePlayerStatus(
                id,
                REJECTED,
                REJECTED,
                NotificationType.PLAYER_REJECTED,
                "BE - Hráč už je zamítnut.",
                "Hráč %s byl úspěšně zamítnut"
        );
    }

    /**
     * Změní přiřazeného uživatele k hráči a odešle notifikace
     * o změně vazby hráče a uživatele.
     *
     * Při pokusu převést hráče na stejného uživatele se vyhodí
     * {@link InvalidChangePlayerUserException}.
     *
     * @param id        ID hráče
     * @param newUserId ID nového uživatele
     */
    @Transactional
    public void changePlayerUser(Long id, Long newUserId) {
        PlayerEntity player = findPlayerOrThrow(id);
        AppUserEntity newUser = findUserOrThrow(newUserId);
        AppUserEntity oldUser = player.getUser();

        if (oldUser != null && oldUser.getId().equals(newUserId)) {
            throw new InvalidChangePlayerUserException();
        }
        player.setUser(newUser);
        PlayerEntity saved = playerRepository.save(player);

        notifyPlayer(saved, NotificationType.PLAYER_CHANGE_USER, newUser);
        notifyUser(newUser, NotificationType.PLAYER_CHANGE_USER, player);
    }

    // ======================
    // READ
    // ======================

    /**
     * Vrátí všechny hráče v systému.
     *
     * @return seznam hráčů ve formě {@link PlayerDTO}
     */
    @Override
    public List<PlayerDTO> getAllPlayers() {
        return playerRepository.findAll().stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    /**
     * Vrátí hráče podle ID.
     *
     * @param id ID hráče
     * @return {@link PlayerDTO} odpovídající hráči
     * @throws PlayerNotFoundException pokud hráč s daným ID neexistuje
     */
    @Override
    public PlayerDTO getPlayerById(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);
        return playerMapper.toDTO(player);
    }

    /**
     * Vrátí všechny hráče přiřazené uživateli s daným emailem.
     *
     * Hráči jsou vráceni v pořadí podle ID vzestupně.
     *
     * @param email email uživatele
     * @return seznam hráčů ve formě {@link PlayerDTO}
     */
    @Override
    public List<PlayerDTO> getPlayersByUser(String email) {
        return playerRepository.findByUser_EmailOrderByIdAsc(email).stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    // ======================
    // CURRENT PLAYER – SESSION
    // ======================

    /**
     * Nastaví aktuálního hráče pro daného uživatele.
     *
     * Nejprve se ověří, že hráč existuje a patří danému uživateli
     * (podle emailu). Poté se jeho ID předá do
     * {@link CurrentPlayerService#setCurrentPlayerId(Long)}.
     *
     * @param userEmail email přihlášeného uživatele
     * @param playerId  ID hráče, který má být nastaven jako aktuální
     * @return odpověď s výsledkem operace
     * @throws PlayerNotFoundException        pokud hráč neexistuje
     * @throws ForbiddenPlayerAccessException pokud hráč nepatří danému uživateli
     */
    @Override
    public SuccessResponseDTO setCurrentPlayerForUser(String userEmail, Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        assertPlayerBelongsToUser(player, userEmail);

        currentPlayerService.setCurrentPlayerId(playerId);

        String message = "BE - Aktuální hráč nastaven na ID: " + playerId;
        return buildSuccessResponse(message, playerId);
    }

    /**
     * Automaticky vybere aktuálního hráče pro uživatele podle
     * nastavení v AppUserSettings (playerSelectionMode).
     *
     * Režimy:
     * - FIRST_PLAYER: vždy se vybere první hráč podle ID,
     * - ALWAYS_CHOOSE: automaticky se vybere pouze v případě,
     *   že má uživatel právě jednoho schváleného hráče.
     *
     * @param userEmail email uživatele
     * @return odpověď s výsledkem operace
     */
    @Override
    public SuccessResponseDTO autoSelectCurrentPlayerForUser(String userEmail) {

        var userSettingsDto = appUserSettingsService.getSettingsForUser(userEmail);

        PlayerSelectionMode mode = PlayerSelectionMode.FIRST_PLAYER;
        if (userSettingsDto.getPlayerSelectionMode() != null) {
            mode = PlayerSelectionMode.valueOf(userSettingsDto.getPlayerSelectionMode());
        }

        switch (mode) {
            case FIRST_PLAYER:
                return autoSelectFirstPlayer(userEmail);
            case ALWAYS_CHOOSE:
                return autoSelectIfSinglePlayer(userEmail);
            default:
                return autoSelectFirstPlayer(userEmail);
        }
    }

    /**
     * Pomocná metoda pro režim FIRST_PLAYER.
     *
     * Najde prvního hráče uživatele (podle ID) a nastaví ho
     * jako aktuálního hráče v {@link CurrentPlayerService}.
     * Pokud uživatel nemá žádného hráče nebo hráč není schválen,
     * vyhodí se výjimka.
     *
     * @param userEmail email uživatele
     * @return odpověď s výsledkem operace
     */
    private SuccessResponseDTO autoSelectFirstPlayer(String userEmail) {
        List<PlayerEntity> players = playerRepository.findByUser_EmailOrderByIdAsc(userEmail);

        if (players.isEmpty()) {
            currentPlayerService.clear();
            throw new PlayerNotFoundException(
                    "BE - Uživatel nemá přiřazeného žádného hráče. Nelze automaticky vybrat.",
                    userEmail
            );
        }

        PlayerEntity firstPlayer = players.get(0);
        if (firstPlayer.getPlayerStatus() != APPROVED) {
            throw new InvalidPlayerStatusException(
                    "BE - Nelze zvolit hráče, který není schválen administrátorem."
            );
        }

        currentPlayerService.setCurrentPlayerId(firstPlayer.getId());
        String message = "BE - Automaticky byl vybrán první hráč: " + firstPlayer.getFullName();
        return buildSuccessResponse(message, firstPlayer.getId());
    }

    /**
     * Pomocná metoda pro režim ALWAYS_CHOOSE.
     *
     * Pokud má uživatel právě jednoho schváleného hráče, tento hráč
     * se nastaví jako aktuální. V ostatních případech se current player
     * vyčistí a očekává se ruční výběr na frontendu.
     *
     * @param userEmail email uživatele
     * @return odpověď s výsledkem operace
     */
    private SuccessResponseDTO autoSelectIfSinglePlayer(String userEmail) {
        List<PlayerEntity> players = playerRepository
                .findByUser_EmailOrderByIdAsc(userEmail).stream()
                .filter(p -> p.getPlayerStatus() == APPROVED)
                .toList();

        if (players.isEmpty()) {
            currentPlayerService.clear();

            throw new PlayerNotFoundException(
                    "BE - Uživatel nemá přiřazeného žádného hráče schváleného Administrátorem. Nelze automaticky vybrat.",
                    userEmail
            );
        }
        if (players.size() == 1) {
            PlayerEntity onlyPlayer = players.get(0);

            currentPlayerService.setCurrentPlayerId(onlyPlayer.getId());

            String message = "BE - Byl vybrán jediný schválený hráč: " + onlyPlayer.getFullName();
            return buildSuccessResponse(message, onlyPlayer.getId());
        }

        currentPlayerService.clear();

        StringBuilder sb = new StringBuilder();
        for (PlayerEntity player : players) {
            sb.append(players.indexOf(player) + 1);
            sb.append(". - ");
            sb.append(player.getFullName());
            sb.append(" / ");
        }
        String message = "BE - Uživatel má více hráčů a musí je vybrat manuálně dle nastavení: " + sb;
        return buildSuccessResponse(message, 0L);
    }

    // ======================
    // PRIVATE HELPERY – ENTITY / DUPLICITY
    // ======================

    /**
     * Najde hráče podle ID nebo vyhodí {@link PlayerNotFoundException}.
     *
     * @param id ID hráče
     * @return entita hráče
     */
    private PlayerEntity findPlayerOrThrow(Long id) {
        return playerRepository.findById(id)
                .orElseThrow(() -> new PlayerNotFoundException(id));
    }

    /**
     * Najde uživatele podle ID nebo vyhodí {@link UserNotFoundException}.
     *
     * @param id ID uživatele
     * @return entita uživatele
     */
    private AppUserEntity findUserOrThrow(Long id) {
        return appUserRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException(id));
    }

    /**
     * Zajistí unikátnost kombinace jméno + příjmení.
     *
     * Při vytváření nového hráče se očekává ignoreId null.
     * Při aktualizaci se ignoruje hráč se stejným ID, aby nebyl
     * považován za duplicitního sám se sebou.
     *
     * @param name     jméno hráče
     * @param surname  příjmení hráče
     * @param ignoreId ID hráče, který má být ignorován, nebo null
     */
    private void ensureUniqueNameSurname(String name, String surname, Long ignoreId) {
        Optional<PlayerEntity> duplicateOpt = playerRepository.findByNameAndSurname(name, surname);

        if (duplicateOpt.isPresent()) {
            PlayerEntity duplicate = duplicateOpt.get();

            if (ignoreId == null || !duplicate.getId().equals(ignoreId)) {
                throw new DuplicateNameSurnameException(name, surname);
            }
        }
    }

    /**
     * Ověří, že hráč patří danému uživateli (podle emailu).
     *
     * Pokud hráč uživateli nepatří, vyhodí se {@link ForbiddenPlayerAccessException}.
     *
     * @param player    hráč
     * @param userEmail email uživatele
     */
    private void assertPlayerBelongsToUser(PlayerEntity player, String userEmail) {
        if (player.getUser() == null ||
                player.getUser().getEmail() == null ||
                !player.getUser().getEmail().equals(userEmail)) {

            throw new ForbiddenPlayerAccessException(player.getId());
        }
    }

    /**
     * Vytvoří standardizovanou úspěšnou odpověď {@link SuccessResponseDTO}
     * s danou zprávou a ID.
     *
     * @param message textová zpráva
     * @param id      ID entity, které se operace týkala
     * @return úspěšná odpověď
     */
    private SuccessResponseDTO buildSuccessResponse(String message, Long id) {
        return new SuccessResponseDTO(
                message,
                id,
                LocalDateTime.now().toString()
        );
    }

    /**
     * Obecná pomocná metoda pro změnu statusu hráče (approve/reject).
     *
     * Ověří se, že hráč již není v cílovém stavu, případně se nastaví
     * výchozí nastavení pro hráče při schválení. Po uložení se odešle
     * notifikace podle nového statusu.
     *
     * @param id                     ID hráče
     * @param targetStatus           cílový status
     * @param alreadyStatus          status, který znamená „už je v tomto stavu“
     * @param notificationType       typ notifikace (případně přepsaný podle statusu)
     * @param alreadyMessage         zpráva pro případ, že je hráč již v cílovém stavu
     * @param successMessageTemplate šablona úspěšné zprávy
     * @return odpověď s výsledkem operace
     */
    private SuccessResponseDTO changePlayerStatus(Long id,
                                                  PlayerStatus targetStatus,
                                                  PlayerStatus alreadyStatus,
                                                  NotificationType notificationType,
                                                  String alreadyMessage,
                                                  String successMessageTemplate) {

        PlayerEntity player = findPlayerOrThrow(id);

        if (player.getPlayerStatus() == alreadyStatus) {
            throw new InvalidPlayerStatusException(alreadyMessage);
        }

        player.setPlayerStatus(targetStatus);

        if (targetStatus == APPROVED && player.getSettings() == null) {
            PlayerSettingsEntity settings =
                    playerSettingsService.createDefaultSettingsForPlayer(player);
            player.setSettings(settings);
        }

        PlayerEntity saved = playerRepository.save(player);

        notificationType = resolveNotificationType(targetStatus);
        if (notificationType != null) {
            notifyPlayer(saved, notificationType, saved);
        }

        String message = String.format(successMessageTemplate, saved.getFullName());
        return buildSuccessResponse(message, id);
    }

    // ====================================================
    // PRIVÁTNÍ HELPERY – NOTIFIKACE
    // ====================================================

    // TODO - možná změnit Object context
    private void notifyPlayer(PlayerEntity player, NotificationType type, Object context) {
        notificationService.notifyPlayer(player, type, context);
    }

    private void notifyUser(AppUserEntity user, NotificationType type, Object context) {
        notificationService.notifyUser(user, type, context);
    }

    /**
     * Převede status hráče na typ notifikace.
     *
     * Pokud se pro zadaný status notifikace neposílá,
     * vrací se null. Status PENDING se zde nevyužívá,
     * protože notifikace při vytvoření hráče jsou řešeny jinde.
     *
     * @param newStatus nový status hráče
     * @return odpovídající {@link NotificationType} nebo null
     */
    private NotificationType resolveNotificationType(PlayerStatus newStatus) {
        return switch (newStatus) {
            case APPROVED -> NotificationType.PLAYER_APPROVED;
            case REJECTED -> NotificationType.MATCH_REGISTRATION_CANCELED;
            default -> null;
        };
    }

}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerSettingsService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerSettingsEntity;
import cz.phsoft.hokej.models.dto.PlayerSettingsDTO;

/**
 * Service rozhraní pro práci s nastavením hráče ({@link PlayerSettingsEntity}).
 *
 * Odpovědnosti:
 * - poskytovat přístup k nastavení konkrétního hráče,
 * - vytvářet výchozí nastavení hráče,
 * - aktualizovat existující nastavení hráče na základě DTO.
 *
 * Architektura:
 * - pracuje s {@link PlayerSettingsDTO} jako přenosovým objektem mezi backendem a frontendem,
 * - nezajišťuje autorizaci ani kontrolu vlastnictví hráče,
 *   tyto kontroly se provádějí v controlleru nebo ve vyšší servisní vrstvě.
 */
public interface PlayerSettingsService {

    /**
     * Vrátí nastavení pro hráče podle jeho ID.
     *
     * Pokud nastavení ještě neexistuje, vytvoří se z výchozích hodnot
     * a uloží se pro daného hráče. Tím se zajišťuje, že volající vždy
     * obdrží platné nastavení.
     *
     * @param playerId ID hráče
     * @return nastavení hráče ve formě {@link PlayerSettingsDTO}
     */
    PlayerSettingsDTO getSettingsForPlayer(Long playerId);

    /**
     * Aktualizuje nastavení pro hráče podle jeho ID.
     *
     * Pokud hráč ještě nemá nastavení, vytvoří se výchozí nastavení
     * a následně se na něj aplikují hodnoty z DTO.
     *
     * @param playerId ID hráče
     * @param dto      nové hodnoty nastavení
     * @return aktualizované nastavení ve formě {@link PlayerSettingsDTO}
     */
    PlayerSettingsDTO updateSettingsForPlayer(Long playerId, PlayerSettingsDTO dto);

    /**
     * Vytvoří výchozí nastavení pro hráče.
     *
     * Metoda pouze vytváří instanci {@link PlayerSettingsEntity}
     * s nastavovanými default hodnotami. Uložení do databáze
     * je odpovědností volajícího kódu.
     *
     * @param player hráč, ke kterému budou defaultní hodnoty přiřazeny
     * @return nová instance {@link PlayerSettingsEntity} s výchozím nastavením
     */
    PlayerSettingsEntity createDefaultSettingsForPlayer(PlayerEntity player);
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerSettingsServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerSettingsEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.data.repositories.PlayerSettingsRepository;
import cz.phsoft.hokej.models.dto.PlayerSettingsDTO;
import cz.phsoft.hokej.models.mappers.PlayerSettingsMapper;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

/**
 * Implementace služby pro práci s nastavením hráče ({@link PlayerSettingsEntity}).
 *
 * Odpovědnosti:
 * - načítání nastavení hráče podle jeho ID,
 * - vytváření výchozího nastavení pro hráče, pokud ještě neexistuje,
 * - aktualizace existujícího nastavení podle {@link PlayerSettingsDTO}.
 *
 * Tato třída:
 * - neřeší autorizaci ani ověřování vlastnictví hráče (řeší controller),
 * - neodesílá notifikace, pouze spravuje data v databázi,
 * - spolupracuje s:
 *   - {@link PlayerRepository} pro ověření existence hráče,
 *   - {@link PlayerSettingsRepository} pro práci s nastavením,
 *   - {@link PlayerSettingsMapper} pro mapování mezi entitou a DTO.
 */
@Service
@Transactional
public class PlayerSettingsServiceImpl implements PlayerSettingsService {

    private final PlayerRepository playerRepository;
    private final PlayerSettingsRepository playerSettingsRepository;
    private final PlayerSettingsMapper mapper;

    public PlayerSettingsServiceImpl(PlayerRepository playerRepository,
                                     PlayerSettingsRepository playerSettingsRepository,
                                     PlayerSettingsMapper mapper) {
        this.playerRepository = playerRepository;
        this.playerSettingsRepository = playerSettingsRepository;
        this.mapper = mapper;
    }

    /**
     * Vrátí nastavení pro hráče podle jeho ID.
     *
     * Postup:
     * - ověří se existence hráče,
     * - pokusí se načíst existující nastavení hráče,
     * - pokud neexistuje žádný záznam, vytvoří se výchozí nastavení
     *   pomocí {@link #createDefaultSettingsForPlayer(PlayerEntity)} a uloží se,
     * - výsledek se namapuje na {@link PlayerSettingsDTO}.
     *
     * @param playerId ID hráče
     * @return nastavení hráče ve formě {@link PlayerSettingsDTO}
     * @throws PlayerNotFoundException pokud hráč neexistuje
     */
    @Override
    public PlayerSettingsDTO getSettingsForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        Optional<PlayerSettingsEntity> existingOpt =
                playerSettingsRepository.findByPlayer(player);

        PlayerSettingsEntity settings = existingOpt.orElseGet(() -> {
            PlayerSettingsEntity created = createDefaultSettingsForPlayer(player);
            return playerSettingsRepository.save(created);
        });

        return mapper.toDTO(settings);
    }

    /**
     * Aktualizuje nastavení hráče podle jeho ID.
     *
     * Postup:
     * - ověří se existence hráče,
     * - načte se existující nastavení hráče, nebo se vytvoří nové výchozí,
     * - na entitu se aplikují hodnoty z {@link PlayerSettingsDTO},
     * - zajišťuje se navázání na hráče (settings.setPlayer),
     * - entita se uloží a navrátí se ve formě DTO.
     *
     * @param playerId ID hráče
     * @param dto      nové hodnoty nastavení
     * @return aktualizované nastavení ve formě {@link PlayerSettingsDTO}
     * @throws PlayerNotFoundException pokud hráč neexistuje
     */
    @Override
    public PlayerSettingsDTO updateSettingsForPlayer(Long playerId, PlayerSettingsDTO dto) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        PlayerSettingsEntity settings = playerSettingsRepository.findByPlayer(player)
                .orElseGet(() -> createDefaultSettingsForPlayer(player));

        mapper.updateEntityFromDTO(dto, settings);

        // pro jistotu se zajišťuje navázání na hráče
        settings.setPlayer(player);

        PlayerSettingsEntity saved = playerSettingsRepository.save(settings);

        return mapper.toDTO(saved);
    }

    // =========================
    // HELPER METODY
    // =========================

    /**
     * Najde hráče podle ID nebo vyhodí {@link PlayerNotFoundException}.
     *
     * Metoda centralizuje práci s {@link PlayerRepository} a
     * zjednodušuje obsluhu chyb při neexistujícím hráči.
     *
     * @param playerId ID hráče
     * @return entita hráče
     * @throws PlayerNotFoundException pokud hráč s daným ID neexistuje
     */
    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    /**
     * Vytvoří výchozí nastavení pro daného hráče.
     *
     * Výchozí chování:
     * - kontaktní email a telefon jsou ponechány prázdné (null),
     * - emailové notifikace:
     *   - notifyOnRegistration = true,
     *   - notifyOnExcuse = true,
     *   - notifyOnMatchChange = true,
     *   - notifyOnMatchCancel = true,
     *   - notifyOnPayment = false,
     * - připomínky:
     *   - notifyReminders = true,
     *   - reminderHoursBefore = 24.
     *
     * Default hodnoty odpovídají původní logice, která byla dříve
     * uložena přímo v entitě {@link PlayerEntity} (emailEnabled, smsEnabled)
     * a nyní je přesunuta do dedikované entity {@link PlayerSettingsEntity}.
     *
     * Metoda pouze vrací neinicializovanou entitu, uložení do databáze
     * provádí volající kód.
     *
     * @param player hráč, pro kterého se výchozí nastavení vytváří
     * @return nová instance {@link PlayerSettingsEntity} s výchozím nastavením
     */
    @Override
    public PlayerSettingsEntity createDefaultSettingsForPlayer(PlayerEntity player) {
        PlayerSettingsEntity settings = new PlayerSettingsEntity();
        settings.setPlayer(player);

        // explicitně nastavené default hodnoty

        settings.setContactEmail(null);
        settings.setContactPhone(null);

        // původní logika z PlayerEntity.emailEnabled / smsEnabled přesunuta do nastavení hráče
        settings.setNotifyOnRegistration(true);
        settings.setNotifyOnExcuse(true);
        settings.setNotifyOnMatchChange(true);
        settings.setNotifyOnMatchCancel(true);
        settings.setNotifyOnPayment(false);

        settings.setNotifyReminders(true);
        settings.setReminderHoursBefore(24);

        return settings;
    }

}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\SeasonService.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.SeasonEntity;
import cz.phsoft.hokej.models.dto.SeasonDTO;

import java.util.List;

/**
 * Rozhraní pro správu sezón v aplikaci.
 *
 * Odpovědnosti:
 * - definovat kontrakt pro práci se sezónami jako časovým rámcem pro zápasy a statistiky,
 * - poskytovat operace pro vytvoření, úpravu a načtení sezón,
 * - určovat aktivní sezónu, která se používá v ostatních službách (např. MatchServiceImpl).
 *
 * Architektura:
 * - většina operací pracuje s {@link SeasonDTO} jako přenosovým objektem,
 * - metoda {@link #getActiveSeason()} vrací entitu {@link SeasonEntity}
 *   pro interní business logiku v jiných službách.
 */
public interface SeasonService {

    /**
     * Vytvoří novou sezónu.
     *
     * Odpovědnost implementace:
     * - validovat datumové rozmezí sezóny,
     * - zajistit, aby se období sezóny nepřekrývalo s jinými sezónami.
     *
     * @param season data nové sezóny
     * @return vytvořená sezóna ve formě {@link SeasonDTO}
     */
    SeasonDTO createSeason(SeasonDTO season);

    /**
     * Aktualizuje existující sezónu.
     *
     * Implementace typicky:
     * - ověřuje existenci sezóny,
     * - validuje datumové rozmezí a překryvy,
     * - aplikuje změny z DTO do entity.
     *
     * @param id     ID sezóny, která má být aktualizována
     * @param season nové hodnoty sezóny
     * @return aktualizovaná sezóna ve formě {@link SeasonDTO}
     */
    SeasonDTO updateSeason(Long id, SeasonDTO season);

    /**
     * Vrátí aktuálně aktivní sezónu.
     *
     * Aktivní sezóna představuje časový rámec, ve kterém se považují
     * zápasy a jejich statistiky za „platné“. Hodnota se používá
     * v dalších službách, například v {@code MatchServiceImpl}.
     *
     * @return aktivní sezóna jako entita {@link SeasonEntity}
     */
    SeasonEntity getActiveSeason();

    /**
     * Vrátí seznam všech sezón v systému.
     *
     * Metoda se typicky používá v administrátorských přehledech
     * a v UI pro správu sezón.
     *
     * @return seznam všech sezón ve formě {@link SeasonDTO}
     */
    List<SeasonDTO> getAllSeasons();

    /**
     * Nastaví zadanou sezónu jako aktivní.
     *
     * Implementace zajišťuje, že v systému existuje
     * vždy nejvýše jedna aktivní sezóna.
     *
     * @param seasonId ID sezóny, která má být nastavena jako aktivní
     */
    void setActiveSeason(Long seasonId);

    /**
     * Vrátí aktivní sezónu ve formě {@link SeasonDTO} nebo null,
     * pokud žádná aktivní sezóna není nastavena.
     *
     * Metoda se používá tam, kde je absence aktivní sezóny
     * platným a očekávaným stavem.
     *
     * @return aktivní sezóna nebo null
     */
    SeasonDTO getActiveSeasonOrNull();

    /**
     * Vrátí sezónu podle jejího ID.
     *
     * Používá se v administrátorské části a interní logice,
     * kde je potřeba pracovat s konkrétní sezónou.
     *
     * @param id ID sezóny
     * @return sezóna ve formě {@link SeasonDTO}
     */
    SeasonDTO getSeasonById(Long id);
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\SeasonServiceImpl.java
-----

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.SeasonEntity;
import cz.phsoft.hokej.data.repositories.SeasonRepository;
import cz.phsoft.hokej.exceptions.InvalidSeasonPeriodDateException;
import cz.phsoft.hokej.exceptions.InvalidSeasonStateException;
import cz.phsoft.hokej.exceptions.SeasonNotFoundException;
import cz.phsoft.hokej.exceptions.SeasonPeriodOverlapException;
import cz.phsoft.hokej.models.dto.SeasonDTO;
import cz.phsoft.hokej.models.mappers.SeasonMapper;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;

/**
 * Service vrstva pro správu sezón ({@link SeasonEntity}).
 *
 * Odpovědnosti:
 * - vytváření a úprava sezón včetně validace datumů a překryvů,
 * - správa aktivní sezóny (právě jedna aktivní sezóna v systému),
 * - poskytování seznamu sezón pro administrativní přehledy,
 * - poskytování aktivní sezóny pro další služby (např. {@code MatchServiceImpl}).
 *
 * Invarianty:
 * - datum začátku sezóny musí předcházet datu konce,
 * - dvě sezóny se nesmí časově překrývat,
 * - v jednom okamžiku smí být aktivní právě jedna sezóna,
 * - systém by neměl zůstat bez aktivní sezóny (řeší se při vytvoření a změně sezóny).
 *
 * Třída je čistě doménová:
 * - neřeší autentizaci ani autorizaci (tyto kontroly se provádějí v controlleru),
 * - neodesílá notifikace,
 * - garantuje konzistentní stav kalendáře sezón pro zbytek aplikace.
 */
@Service
public class SeasonServiceImpl implements SeasonService {

    private final SeasonRepository seasonRepository;
    private final SeasonMapper mapper;

    public SeasonServiceImpl(SeasonRepository seasonRepository, SeasonMapper mapper) {
        this.seasonRepository = seasonRepository;
        this.mapper = mapper;
    }

    // ======================
    // CREATE
    // ======================

    /**
     * Vytvoří novou sezónu.
     *
     * Postup:
     * - provede validaci datumového rozmezí a překryvů s ostatními sezónami,
     * - uloží novou sezónu do databáze,
     * - zajistí, aby v systému vždy existovala aktivní sezóna:
     *   - pokud je nová sezóna označena jako aktivní, stane se jedinou aktivní,
     *   - pokud je to první sezóna v systému a není aktivní, nastaví se jako aktivní automaticky.
     *
     * @param seasonDTO vstupní data sezóny
     * @return vytvořená sezóna ve formě {@link SeasonDTO}
     *
     * @throws InvalidSeasonPeriodDateException pokud jsou neplatná data od/do
     * @throws SeasonPeriodOverlapException     pokud se sezóna překrývá s existující sezónou
     */
    @Override
    @Transactional
    public SeasonDTO createSeason(SeasonDTO seasonDTO) {
        // u create neexistuje ID → validace ignoruje ID a kontroluje překryv se všemi sezónami
        validateDates(seasonDTO, null);

        SeasonEntity entity = mapper.toEntity(seasonDTO);
        SeasonEntity saved = seasonRepository.save(entity);

        long activeCount = seasonRepository.countByActiveTrue();

        if (seasonDTO.isActive()) {
            // nová sezóna má být aktivní → nastaví se jako jediná aktivní
            setOnlyActiveSeason(saved.getId());
        } else if (activeCount == 0) {
            // v systému není žádná aktivní sezóna → tato sezóna se nastaví jako aktivní
            setOnlyActiveSeason(saved.getId());
        }

        return mapper.toDTO(saved);
    }

    // ======================
    // UPDATE
    // ======================

    /**
     * Aktualizuje existující sezónu.
     *
     * Postup:
     * - ověří se existence sezóny podle ID,
     * - zvaliduje se datumové rozmezí s ignorováním této sezóny
     *   při kontrole překryvů,
     * - zkontroluje se, že nelze deaktivovat poslední aktivní sezónu,
     * - promítnou se změny z DTO do entity a sezóna se uloží,
     * - pokud se sezóna stala nově aktivní, nastaví se jako jediná aktivní.
     *
     * @param id        ID upravované sezóny
     * @param seasonDTO nové hodnoty sezóny
     *
     * @return aktualizovaná sezóna ve formě {@link SeasonDTO}
     *
     * @throws SeasonNotFoundException            pokud sezóna s daným ID neexistuje
     * @throws InvalidSeasonPeriodDateException   pokud jsou neplatná data od/do
     * @throws SeasonPeriodOverlapException       pokud se sezóna překrývá s jinou
     * @throws InvalidSeasonStateException        pokud se pokouší deaktivovat jediná aktivní sezóna
     */
    @Override
    @Transactional
    public SeasonDTO updateSeason(Long id, SeasonDTO seasonDTO) {
        SeasonEntity existing = seasonRepository.findById(id)
                .orElseThrow(() -> new SeasonNotFoundException(id));

        validateDates(seasonDTO, id);

        boolean wasActive = existing.isActive();
        boolean willBeActive = seasonDTO.isActive();

        // striktní režim: nelze deaktivovat poslední aktivní sezónu
        if (wasActive && !willBeActive) {
            long activeCount = seasonRepository.countByActiveTrue();
            if (activeCount <= 1) {
                throw new InvalidSeasonStateException(
                        "BE - Nelze deaktivovat jedinou aktivní sezónu. " +
                                "Nejprve nastav jinou sezónu jako aktivní."
                );
            }
        }

        mapper.updateEntityFromDTO(seasonDTO, existing);
        SeasonEntity saved = seasonRepository.save(existing);

        if (!wasActive && saved.isActive()) {
            setOnlyActiveSeason(saved.getId());
        }

        return mapper.toDTO(saved);
    }

    // ======================
    // AKTIVNÍ SEZÓNA
    // ======================

    /**
     * Vrátí aktuálně aktivní sezónu.
     *
     * Metoda se používá v business vrstvě (například v {@code MatchServiceImpl})
     * pro filtrování zápasů podle sezóny.
     *
     * @return aktivní sezóna jako entita {@link SeasonEntity}
     * @throws SeasonNotFoundException pokud není nastavena žádná aktivní sezóna
     */
    @Override
    public SeasonEntity getActiveSeason() {
        return seasonRepository.findByActiveTrue()
                .orElseThrow(() -> new SeasonNotFoundException(
                        "BE - Není nastavena žádná aktivní sezóna."
                ));
    }

    /**
     * Vrátí aktivní sezónu ve formě {@link SeasonDTO} nebo null.
     *
     * Metoda se používá tam, kde je absence aktivní sezóny
     * akceptovatelná a nemá být považována za výjimku.
     *
     * @return aktivní sezóna nebo null
     */
    @Override
    public SeasonDTO getActiveSeasonOrNull() {
        return seasonRepository.findByActiveTrue()
                .map(mapper::toDTO)
                .orElse(null);
    }

    /**
     * Vrátí sezónu podle ID.
     *
     * @param id ID sezóny
     * @return sezóna ve formě {@link SeasonDTO}
     * @throws RuntimeException pokud sezóna neexistuje
     *                          (lze později nahradit za SeasonNotFoundException)
     */
    @Override
    public SeasonDTO getSeasonById(Long id) {
        SeasonEntity entity = seasonRepository.findById(id)
                .orElseThrow(() -> new SeasonNotFoundException(id));
        return mapper.toDTO(entity);
    }

    // ======================
    // SEZNAM VŠECH SEZÓN
    // ======================

    /**
     * Vrátí všechny sezóny seřazené podle začátku stoupajícím způsobem.
     *
     * Typické použití:
     * - administrace sezón,
     * - přehled sezón v UI.
     *
     * @return seznam všech sezón ve formě {@link SeasonDTO}
     */
    @Override
    public List<SeasonDTO> getAllSeasons() {
        return seasonRepository.findAllByOrderByStartDateAsc()
                .stream()
                .map(mapper::toDTO)
                .toList();
    }

    // ======================
    // NASTAVENÍ AKTIVNÍ SEZÓNY
    // ======================

    /**
     * Nastaví konkrétní sezónu jako aktivní.
     *
     * Postup:
     * - ověří se existence sezóny podle ID,
     * - pomocí metody {@link #setOnlyActiveSeason(Long)} se sezóna nastaví
     *   jako jediná aktivní a ostatní sezóny se deaktivují.
     *
     * @param seasonId ID sezóny, která má být aktivní
     * @throws SeasonNotFoundException pokud sezóna s daným ID neexistuje
     */
    @Override
    @Transactional
    public void setActiveSeason(Long seasonId) {
        SeasonEntity toActivate = seasonRepository.findById(seasonId)
                .orElseThrow(() -> new SeasonNotFoundException(seasonId));

        setOnlyActiveSeason(toActivate.getId());
    }

    // ======================
    // PRIVÁTNÍ VALIDACE DAT
    // ======================

    /**
     * Validuje datumy sezóny a kontroluje překryvy s ostatními sezónami.
     *
     * Kontroluje:
     * - startDate a endDate nesmí být null,
     * - startDate musí být před endDate,
     * - existující sezóny se nesmí překrývat s rozsahem nové sezóny.
     *
     * Při CREATE:
     * - kontroluje se překryv se všemi existujícími sezónami.
     *
     * Při UPDATE:
     * - kontroluje se překryv se všemi ostatními sezónami
     *   (sezóna s ID currentSeasonId se ignoruje).
     *
     * @param seasonDTO       DTO s daty sezóny
     * @param currentSeasonId ID aktuální sezóny (u UPDATE), nebo null u CREATE
     *
     * @throws InvalidSeasonPeriodDateException pokud jsou neplatná data
     * @throws SeasonPeriodOverlapException     pokud se sezóna překrývá s jinou
     */
    private void validateDates(SeasonDTO seasonDTO, Long currentSeasonId) {
        LocalDate start = seasonDTO.getStartDate();
        LocalDate end = seasonDTO.getEndDate();

        if (start == null || end == null) {
            throw new InvalidSeasonPeriodDateException("BE - Datum od a do nesmí být null.");
        }

        if (!start.isBefore(end)) {
            throw new InvalidSeasonPeriodDateException("BE - Datum 'od' musí být před 'do'.");
        }

        boolean overlaps;

        if (currentSeasonId == null) {
            overlaps = seasonRepository
                    .existsByStartDateLessThanEqualAndEndDateGreaterThanEqual(end, start);
        } else {
            overlaps = seasonRepository
                    .existsByStartDateLessThanEqualAndEndDateGreaterThanEqualAndIdNot(
                            end,
                            start,
                            currentSeasonId
                    );
        }

        if (overlaps) {
            throw new SeasonPeriodOverlapException("BE - Sezóna se překrývá s existující sezónou.");
        }
    }

    // ======================
    // PRIVÁTNÍ POMOCNÁ METODA
    // ======================

    /**
     * Nastaví zadanou sezónu jako jedinou aktivní.
     *
     * Implementace:
     * - načte všechny sezóny z databáze,
     * - sezóně s odpovídajícím ID nastaví příznak active na true,
     * - všem ostatním sezónám nastaví active na false,
     * - uloží změny hromadně pomocí {@link SeasonRepository#saveAll(Iterable)}.
     *
     * Tím se zajišťuje invariant, že v aplikaci existuje v každém okamžiku
     * právě jedna aktivní sezóna.
     *
     * @param activeSeasonId ID sezóny, která má být jedinou aktivní sezónou
     */
    private void setOnlyActiveSeason(Long activeSeasonId) {
        List<SeasonEntity> all = seasonRepository.findAll();
        for (SeasonEntity season : all) {
            season.setActive(season.getId().equals(activeSeasonId));
        }
        seasonRepository.saveAll(all);
    }
}


