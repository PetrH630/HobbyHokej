Balíček (složka): sms
Cesta: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms

Seznam souborů:
SmsMessageBuilder.java
SmsService.java
SmsSchedulerService.java
SmsTextBeeService.java



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsMessageBuilder.java
-----

package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.MatchCancelReason;
import cz.phsoft.hokej.data.enums.MatchStatus;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import org.springframework.stereotype.Component;

import java.time.format.DateTimeFormatter;

/**
 * Builder pro generování textů SMS zpráv.
 *
 * Odpovědnosti:
 * - sestavení lidsky čitelného obsahu SMS pro různé typy notifikací,
 * - centralizace formátování SMS zpráv (princip DRY),
 * - oddělení textové logiky od business logiky a schedulingu.
 *
 * Tato třída se používá zejména v NotificationServiceImpl a SmsService
 * jako zdroj výsledného textu SMS zpráv.
 *
 * Třída neřeší:
 * - odesílání SMS (to zajišťuje SmsService),
 * - změny v databázi,
 * - oprávnění ani validace vstupů (předpokládá se, že vstupy jsou zvalidované dříve).
 */
@Component
public class SmsMessageBuilder {

    /**
     * Repozitář registrací používaný pro read-only výpočty
     * (například aktuální počet hráčů se statusem REGISTERED).
     */
    private final MatchRegistrationRepository matchRegistrationRepository;

    /**
     * Repozitář zápasů používaný pro doplňující informace o zápase.
     *
     * Aktuálně se využívá minimálně, je zde ponechán pro možné rozšíření.
     */
    private final MatchRepository matchRepository;

    /**
     * Repozitář hráčů používaný pro případné rozšíření zpráv
     * o detailnější informace o hráčích.
     */
    private final PlayerRepository playerRepository;

    /**
     * Jednotný formát data používaný v SMS zprávách.
     *
     * Slouží k tomu, aby měly všechny SMS zprávy konzistentní formát data.
     */
    private final DateTimeFormatter dateFormatter =
            DateTimeFormatter.ofPattern("yyyy-MM-dd");

    public SmsMessageBuilder(MatchRegistrationRepository matchRegistrationRepository,
                             MatchRepository matchRepository,
                             PlayerRepository playerRepository) {
        this.matchRegistrationRepository = matchRegistrationRepository;
        this.matchRepository = matchRepository;
        this.playerRepository = playerRepository;
    }

    // ====================================================
    // HLAVNÍ VSTUPNÍ METODA PRO NotificationServiceImpl
    // ====================================================

    /**
     * Sestaví SMS text pro hráče podle typu notifikace a kontextu.
     *
     * Metoda slouží jako hlavní vstupní bod pro NotificationServiceImpl,
     * kde se podle NotificationType a typu contextu rozhoduje,
     * který specializovaný builder se použije.
     *
     * Podporované scénáře:
     * - změny registrace hráče na zápas,
     * - obecné informace o zápase (zrušení, změna času, připomenutí).
     *
     * @param type    typ notifikace, pro kterou se SMS generuje
     * @param player  hráč, pro kterého se SMS generuje
     * @param context kontext notifikace, obvykle MatchRegistrationEntity nebo MatchEntity
     * @return hotový text SMS nebo {@code null}, pokud se pro daný typ notifikace SMS neposílá
     */
    public String buildForNotification(NotificationType type,
                                       PlayerEntity player,
                                       Object context) {

        return switch (type) {

            // Registrace / odhlášení / přesun ve frontě / omluvy
            case MATCH_REGISTRATION_CREATED,
                 MATCH_REGISTRATION_UPDATED,
                 MATCH_REGISTRATION_CANCELED,
                 MATCH_REGISTRATION_RESERVED,
                 MATCH_WAITING_LIST_MOVED_UP,
                 PLAYER_EXCUSED,
                 PLAYER_NO_EXCUSED -> {
                MatchRegistrationEntity reg =
                        castContext(context, MatchRegistrationEntity.class);
                if (reg == null) {
                    yield null;
                }
                yield buildMessageRegistration(reg);
            }

            // Obecné info / změny zápasu
            case MATCH_REMINDER,
                 MATCH_CANCELED,
                 MATCH_TIME_CHANGED -> {
                MatchEntity match = castContext(context, MatchEntity.class);
                if (match == null) {
                    yield null;
                }
                yield buildMessageMatchInfo(type, match);
            }

            // ostatní typy se přes SMS neposílají
            default -> null;
        };
    }

    /**
     * Bezpečné přetypování contextu na očekávaný typ.
     *
     * Pokud context není zadaného typu, vrací se null.
     *
     * @param context      vstupní objekt kontextu
     * @param expectedType očekávaný typ kontextu
     * @param <T>          generický typ výsledku
     * @return přetypovaný objekt nebo null, pokud typ neodpovídá
     */
    @SuppressWarnings("unchecked")
    private <T> T castContext(Object context, Class<T> expectedType) {
        if (context == null) {
            return null;
        }
        if (!expectedType.isInstance(context)) {
            return null;
        }
        return (T) context;
    }

    // ====================================================
    // REGISTRACE / ODHLÁŠENÍ / OMLUVA
    // ====================================================

    /**
     * Vytvoří SMS zprávu po změně registrace hráče na zápas.
     *
     * Zpráva popisuje:
     * - datum zápasu,
     * - aktuální obsazenost zápasu,
     * - jméno hráče,
     * - slovní popis změny stavu (přihlášení, odhlášení, omluva, náhradník).
     *
     * Použité stavy:
     * - REGISTERED,
     * - UNREGISTERED,
     * - EXCUSED,
     * - SUBSTITUTE,
     * - RESERVED.
     *
     * Text se liší podle toho, zda změnu provedl uživatel nebo systém.
     *
     * @param registration registrace hráče k zápasu
     * @return text SMS zprávy popisující změnu registrace
     */
    public String buildMessageRegistration(MatchRegistrationEntity registration) {

        PlayerMatchStatus status = registration.getStatus();
        boolean createdByUser = "user".equals(registration.getCreatedBy());

        String statusText;

        if (createdByUser) {
            statusText = switch (status) {
                case REGISTERED -> "přihlásil se";
                case UNREGISTERED -> "odhlásil se";
                case EXCUSED -> "omluvil se";
                case SUBSTITUTE -> "možná bude";
                case RESERVED -> "byl z důvodu snížení kapacity přesunut mezi náhradníky";
                default -> "neznámý stav";
            };
        } else {
            statusText = switch (status) {
                case REGISTERED -> "byl systémem po uvolnění kapacity přihlášen";
                case UNREGISTERED -> "byl systémem odhlášen";
                case EXCUSED -> "byl systémem omluven";
                case SUBSTITUTE -> "byl systémem nastaven že možná bude";
                case RESERVED -> "byl z důvodu snížení kapacity přesunut mezi náhradníky";
                default -> "neznámý stav";
            };
        }

        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(
                        registration.getMatch().getId(),
                        PlayerMatchStatus.REGISTERED
                );

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - datum: ")
                .append(registration.getMatch().getDateTime().toLocalDate().format(dateFormatter));

        // Obsazenost se neuvádí u EXCUSED – hráč se nepočítá mezi přihlášené.
        if (status != PlayerMatchStatus.EXCUSED) {
            sb.append(", ")
                    .append(registeredCount)
                    .append("/")
                    .append(registration.getMatch().getMaxPlayers());
        }

        sb.append(", hráč: ")
                .append(registration.getPlayer().getFullName())
                .append(", status: ")
                .append(statusText);

        return sb.toString();
    }

    // ====================================================
    // NO RESPONSE – HRÁČ JEŠTĚ NEREAGOVAL
    // ====================================================

    /**
     * Vytvoří SMS zprávu pro hráče, kteří dosud nereagovali na zápas.
     *
     * Zpráva se používá typicky několik dní před zápasem
     * v rámci plánovače, který připomíná blížící se zápasy
     * a upozorňuje na volná místa.
     *
     * Obsah zprávy:
     * - datum zápasu,
     * - aktuální počet volných míst,
     * - upozornění, že hráč ještě nereagoval.
     *
     * @param player hráč, pro kterého se zpráva vytváří
     * @param match  zápas, ke kterému se připomínka vztahuje
     * @return text SMS zprávy pro nereagujícího hráče
     */
    public String buildMessageNoResponse(PlayerDTO player, MatchEntity match) {

        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(
                        match.getId(),
                        PlayerMatchStatus.REGISTERED
                );

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - upozornění: zápas ")
                .append(match.getDateTime().format(dateFormatter))
                .append(" - volná místa: ")
                .append(match.getMaxPlayers() - registeredCount)
                .append(". Ještě jste nereagoval.");

        return sb.toString();
    }

    // ====================================================
    // ZMĚNY STAVU ZÁPASU
    // ====================================================

    /**
     * Vytvoří SMS zprávu s informací o změně stavu zápasu.
     *
     * Typické scénáře:
     * - zápas byl zrušen,
     * - zápas byl obnoven nebo změněn.
     *
     * Zpráva obsahuje:
     * - datum zápasu,
     * - slovní popis stavu zápasu,
     * - slovní popis důvodu zrušení (pokud je k dispozici).
     *
     * Parametr type se používá na úrovni volající služby pro rozhodnutí,
     * kdy se zpráva generuje. V této metodě se stav určuje primárně
     * z vlastností MatchEntity.
     *
     * @param type  typ notifikace, pro kterou se zpráva vytváří
     * @param match zápas, jehož stav se oznamuje
     * @return text SMS zprávy popisující stav zápasu
     */
    public String buildMessageMatchInfo(NotificationType type, MatchEntity match) {
        MatchStatus matchStatus = match.getMatchStatus();
        MatchCancelReason cancelReason = match.getCancelReason();

        String statusText = switch (matchStatus) {
            case CANCELLED -> "byl zrušen";
            case UNCANCELED -> "byl obnoven";
            default -> "neznámý stav";
        };

        String cancelReasonText = switch (cancelReason) {
            case NOT_ENOUGH_PLAYERS -> "málo hráčů";
            case TECHNICAL_ISSUE -> "technické problémy (led, hala)";
            case WEATHER -> "počasí";
            case ORGANIZER_DECISION -> "rozhodnutí organizátora";
            case OTHER -> "jiný důvod";
            default -> "neznámý důvod";
        };

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - UPOZORNĚNÍ: zápas ")
                .append(match.getDateTime().format(dateFormatter))
                .append(" - ")
                .append(statusText)
                .append(" (důvod: ")
                .append(cancelReasonText)
                .append(")");

        return sb.toString();
    }

    // ====================================================
    // FINÁLNÍ SMS – DEN ZÁPASU
    // ====================================================

    /**
     * Vytvoří finální SMS zprávu v den zápasu
     * pro již přihlášené hráče.
     *
     * Zpráva shrnuje:
     * - datum zápasu,
     * - aktuální počet přihlášených hráčů a maximální kapacitu,
     * - orientační cenu na jednoho hráče (celková cena dělená počtem přihlášených).
     *
     * @param registration registrace hráče k zápasu, pro kterou se připomínka vytváří
     * @return text finální SMS zprávy v den zápasu
     */
    public String buildMessageFinal(MatchRegistrationEntity registration) {

        MatchEntity match = registration.getMatch();

        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(
                        match.getId(),
                        PlayerMatchStatus.REGISTERED
                );

        double pricePerPlayer =
                match.getPrice() / Math.max(registeredCount, 1);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - připomínka zápasu ")
                .append(match.getDateTime().format(dateFormatter))
                .append(", přihlášeno: ")
                .append(registeredCount)
                .append("/")
                .append(match.getMaxPlayers())
                .append(", cena na hráče: ")
                .append(String.format("%.2f Kč", pricePerPlayer));

        return sb.toString();
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsService.java
-----

package cz.phsoft.hokej.models.services.sms;

/**
 * Rozhraní definující kontrakt pro odesílání SMS zpráv v aplikaci.
 *
 * Rozhraní slouží jako jednotný vstupní bod pro odesílání SMS
 * bez vazby na konkrétní technickou implementaci nebo poskytovatele služby.
 * Business logika aplikace pracuje výhradně s tímto rozhraním
 * a není závislá na detailech odesílání zpráv.
 *
 * Odpovědnost rozhraní:
 * - definování operace pro odeslání SMS zprávy,
 * - oddělení business logiky od technické implementace,
 * - umožnění snadné výměny nebo rozšíření SMS providerů.
 *
 * Rozhraní je typicky používáno ve službách aplikační vrstvy,
 * například v notifikačních službách nebo plánovaných schedulerech.
 */
public interface SmsService {

    /**
     * Odesílá SMS zprávu na zadané telefonní číslo.
     *
     * Metoda představuje abstraktní operaci odeslání SMS
     * a nezaručuje její skutečné doručení koncovému příjemci.
     * Způsob odeslání, práce s externí službou a případné chyby
     * jsou plně v odpovědnosti konkrétní implementace rozhraní.
     *
     * Očekávané chování implementace:
     * - selhání odeslání SMS nesmí ovlivnit chod aplikace,
     * - technické chyby by měly být zachyceny a zalogovány,
     * - odesílání SMS je považováno za best-effort operaci.
     *
     * @param phoneNumber telefonní číslo příjemce SMS zprávy
     * @param message text SMS zprávy
     */
    void sendSms(String phoneNumber, String message);
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsSchedulerService.java
-----

package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import jakarta.transaction.Transactional;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;

/**
 * Scheduler služba, která zajišťuje plánované odesílání SMS notifikací hráčům.
 *
 * Odpovědnost třídy je:
 * - vyhledávání zápasů podle data konání,
 * - určení cílových hráčů pro daný typ SMS,
 * - předání textu zpráv službě SmsService k odeslání.
 *
 * Třída se používá ve vrstvě služeb a navazuje na MatchRepository,
 * MatchRegistrationRepository, MatchRegistrationService a SmsMessageBuilder.
 */
@Service
public class SmsSchedulerService {

    /**
     * Repozitář zápasů, který se používá pro vyhledávání zápasů podle data konání.
     */
    private final MatchRepository matchRepository;

    /**
     * Repozitář registrací hráčů na zápasy, který se používá pro získání registrací
     * ke konkrétnímu zápasu.
     */
    private final MatchRegistrationRepository registrationRepository;

    /**
     * Služba pro odesílání SMS zpráv, která představuje technický vstupní bod
     * pro komunikaci s externím SMS providerem.
     */
    private final SmsService smsService;

    /**
     * Builder pro tvorbu textů SMS zpráv, který zajišťuje jednotný formát
     * a obsah SMS napříč aplikací.
     */
    private final SmsMessageBuilder smsMessageBuilder;

    /**
     * Služba s business logikou registrací hráčů na zápasy, která se používá
     * zejména pro zjištění hráčů bez reakce na pozvánku.
     */
    private final MatchRegistrationService matchRegistrationService;

    /**
     * Vytváří instanci scheduler služby a injektuje závislosti ze Spring kontextu.
     */
    public SmsSchedulerService(
            MatchRepository matchRepository,
            MatchRegistrationRepository registrationRepository,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder,
            MatchRegistrationService matchRegistrationService) {

        this.matchRepository = matchRepository;
        this.registrationRepository = registrationRepository;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
        this.matchRegistrationService = matchRegistrationService;
    }

    /**
     * Metoda odesílá finální SMS všem hráčům registrovaným na zápasy,
     * které se konají v aktuální den.
     *
     * Metoda se plánuje pomocí Spring scheduleru a spouští se každý den ve 12:30
     * v časové zóně Europe/Prague. V rámci zpracování se vyhledají všechny dnešní zápasy,
     * načtou se registrace hráčů k těmto zápasům a pro každou registraci se vygeneruje
     * text finální SMS a předá se službě SmsService k odeslání.
     *
     * Metoda pracuje pouze s existujícími daty a nemění stav databáze, transakce
     * se používá pro zajištění konzistence při čtení.
     */
    @Scheduled(cron = "0 30 12 * * *", zone = "Europe/Prague")
    @Transactional
    public void sendFinalSmsForTodayMatches() {

        LocalDate today = LocalDate.now();

        // Zápasy, které se konají v aktuální den.
        List<MatchEntity> todaysMatches = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().toLocalDate().isEqual(today))
                .toList();

        for (MatchEntity match : todaysMatches) {

            // Registrace hráčů k danému zápasu.
            List<MatchRegistrationEntity> registrations =
                    registrationRepository.findByMatchId(match.getId());

            for (MatchRegistrationEntity reg : registrations) {

                String smsMsg = smsMessageBuilder.buildMessageFinal(reg);

                try {
                    smsService.sendSms(
                            reg.getPlayer().getPhoneNumber(),
                            smsMsg
                    );

                    System.out.println(
                            "Finální SMS poslána hráči " +
                                    reg.getPlayer().getFullName()
                    );

                } catch (Exception e) {
                    // Chyba při odesílání jednomu hráči nesmí zastavit běh celé naplánované úlohy.
                    System.err.println(
                            "Chyba SMS pro hráče " +
                                    reg.getPlayer().getFullName() +
                                    ": " + e.getMessage()
                    );
                }
            }
        }
    }

    /**
     * Metoda odesílá připomínkovou SMS hráčům, kteří mají zápas naplánovaný
     * za tři dny a dosud na zápas nijak nereagovali (stav NO_RESPONSE).
     *
     * Metoda se plánuje pomocí Spring scheduleru a spouští se každý den ve 12:30
     * v časové zóně Europe/Prague. V rámci zpracování se vyhledají zápasy,
     * které se konají přesně za tři dny od aktuálního data. Pro každý takový zápas
     * se využije logika služby MatchRegistrationService k získání hráčů bez reakce
     * a těmto hráčům se odešle připomínková SMS prostřednictvím SmsService.
     *
     * Metoda slouží k podpoře včasného plánování sestavy a k omezení situací,
     * kdy hráči zapomenou na blížící se zápas.
     */
    @Scheduled(cron = "0 30 12 * * *", zone = "Europe/Prague")
    @Transactional
    public void sendNoResponseSmsForMatchesIn3Days() {

        LocalDate targetDate = LocalDate.now().plusDays(3);

        // Zápasy, které se konají za tři dny.
        List<MatchEntity> matchesInThreeDays = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().toLocalDate().isEqual(targetDate))
                .toList();

        for (MatchEntity match : matchesInThreeDays) {

            // Hráči bez reakce se získávají pomocí MatchRegistrationService.
            List<PlayerDTO> noResponsePlayers =
                    matchRegistrationService.getNoResponsePlayers(match.getId());

            for (PlayerDTO player : noResponsePlayers) {

                String smsMsg =
                        smsMessageBuilder.buildMessageNoResponse(player, match);

                try {
                    smsService.sendSms(
                            player.getPhoneNumber(),
                            smsMsg
                    );

                    System.out.println(
                            "NO_RESPONSE SMS poslána hráči " +
                                    player.getFullName()
                    );

                } catch (Exception e) {
                    // Chyba při odesílání jednomu hráči nesmí zastavit běh celé naplánované úlohy.
                    System.err.println(
                            "Chyba NO_RESPONSE SMS pro hráče " +
                                    player.getFullName() +
                                    ": " + e.getMessage()
                    );
                }
            }
        }
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsTextBeeService.java
-----

package cz.phsoft.hokej.models.services.sms;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;

/**
 * Implementace rozhraní SmsService využívající externí SMS službu TextBee.
 *
 * Třída představuje technickou implementaci odesílání SMS zpráv.
 * Business vrstvy aplikace pracují výhradně s rozhraním SmsService
 * a nejsou závislé na konkrétním SMS providerovi ani na detailech
 * HTTP komunikace.
 *
 * Odpovědnost třídy:
 * - odesílání SMS zpráv prostřednictvím TextBee API,
 * - respektování globálního nastavení zapnutí nebo vypnutí SMS,
 * - jednotné logování úspěšných i neúspěšných pokusů o odeslání,
 * - zajištění, že technické selhání SMS neovlivní business logiku aplikace.
 *
 * Třída je navržena tak, aby byla snadno nahraditelná jinou implementací
 * SmsService bez zásahu do vyšších vrstev aplikace.
 */
@Service
public class SmsTextBeeService implements SmsService {

    private static final Logger log =
            LoggerFactory.getLogger(SmsTextBeeService.class);

    /**
     * Globální přepínač pro zapnutí nebo vypnutí odesílání SMS.
     *
     * Hodnota se načítá z konfiguračních properties aplikace.
     * V produkčním prostředí je obvykle nastavena na true,
     * v lokálním vývoji nebo testech může být nastavena na false.
     */
    @Value("${sms.enabled:true}")
    private boolean smsEnabled;

    /**
     * URL endpointu TextBee API.
     *
     * Používá se jako cílová adresa pro HTTP POST požadavky
     * při odesílání SMS zpráv.
     */
    @Value("${textbee.api-url}")
    private String apiUrl;

    /**
     * API klíč pro autentizaci vůči službě TextBee.
     *
     * Klíč se odesílá v HTTP hlavičce každého požadavku
     * a slouží k autorizaci aplikace vůči externí službě.
     */
    @Value("${textbee.api-key}")
    private String apiKey;

    /**
     * HTTP klient používaný pro komunikaci s TextBee API.
     *
     * Pro jednoduchost je instancován přímo v této třídě.
     * V případě potřeby lze tuto implementaci nahradit
     * konfigurovaným Beanem nebo WebClientem.
     */
    private final RestTemplate restTemplate = new RestTemplate();

    /**
     * Odesílá SMS zprávu na zadané telefonní číslo.
     *
     * Metoda nejprve ověřuje globální nastavení odesílání SMS.
     * Pokud jsou SMS vypnuté, zpráva se neodesílá a událost se pouze zaloguje.
     * Pokud jsou SMS povolené, vytvoří se HTTP POST požadavek
     * a odešle se na TextBee API.
     *
     * Veškeré výjimky vzniklé během odesílání jsou zachyceny
     * a nejsou propagovány do vyšších vrstev aplikace.
     * Odesílání SMS je považováno za best-effort operaci,
     * jejíž selhání nesmí ohrozit stabilitu systému.
     *
     * @param phoneNumber cílové telefonní číslo příjemce
     * @param message text SMS zprávy
     */
    @Override
    public void sendSms(String phoneNumber, String message) {

        // Ověření globálního nastavení odesílání SMS.
        if (!smsEnabled) {
            log.info(
                    "SMS jsou globálně vypnuté. Zpráva nebyla odeslána. Tel: {}, msg: {}",
                    phoneNumber, message
            );

            System.out.println(
                    "SMS disabled (global), message not sent: "
                            + phoneNumber + " -> " + message
            );
            return;
        }

        // Příprava HTTP hlaviček požadavku.
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("x-api-key", apiKey);

        // Příprava těla požadavku dle specifikace TextBee API.
        Map<String, Object> body = Map.of(
                "recipients", List.of(phoneNumber),
                "message", message
        );

        HttpEntity<Map<String, Object>> request =
                new HttpEntity<>(body, headers);

        try {
            // Odeslání HTTP POST požadavku na TextBee API.
            ResponseEntity<String> response =
                    restTemplate.postForEntity(apiUrl, request, String.class);

            log.info(
                    "SMS úspěšně odeslána přes TextBee na {}, response: {}",
                    phoneNumber, response.getBody()
            );

            System.out.println(
                    "SMS odeslána (TextBee) na " + phoneNumber +
                            ", response: " + response.getBody()
            );

        } catch (Exception e) {
            // Selhání odeslání SMS nesmí ovlivnit chod aplikace.
            log.error(
                    "Chyba při odesílání SMS přes TextBee na {}: {}",
                    phoneNumber, e.getMessage(), e
            );

            System.err.println(
                    "Chyba při odesílání SMS přes TextBee na "
                            + phoneNumber + ": " + e.getMessage()
            );
        }
    }
}


