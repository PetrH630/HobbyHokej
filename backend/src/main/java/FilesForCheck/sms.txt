Balíček (složka): sms
Cesta: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms

Seznam souborů:
SmsMessageBuilder.java
SmsService.java
SmsServiceImpl.java
SmsSchedulerService.java
SmsTextBeeService.java



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsMessageBuilder.java
-----

package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.MatchCancelReason;
import cz.phsoft.hokej.data.enums.MatchStatus;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import org.springframework.stereotype.Component;

import java.time.format.DateTimeFormatter;

/**
 * Builder pro generování textů SMS zpráv.
 * <p>
 * Slouží jako centrální místo pro skládání lidsky čitelných SMS
 * používaných v aplikaci. Řeší pouze textovou podobu zprávy, nikoliv
 * odesílání nebo business logiku.
 * </p>
 *
 * Odpovědnost:
 * <ul>
 *     <li>sestavení lidsky čitelného obsahu SMS,</li>
 *     <li>centrální místo pro formátování zpráv (princip DRY),</li>
 *     <li>oddělení textové logiky od business logiky a schedulingu.</li>
 * </ul>
 *
 * Třída vytváří SMS texty pro:
 * <ul>
 *     <li>registraci / odhlášení / omluvu hráče,</li>
 *     <li>připomenutí hráčům, kteří nereagovali,</li>
 *     <li>finální připomínku v den zápasu,</li>
 *     <li>obecné info o zápasu (zrušení, změna času).</li>
 * </ul>
 *
 * Třída neřeší:
 * <ul>
 *     <li>odesílání SMS (to zajišťuje {@link SmsService}),</li>
 *     <li>změny v databázi,</li>
 *     <li>oprávnění ani validace (předpokládá validní vstup).</li>
 * </ul>
 */
@Component
public class SmsMessageBuilder {

    /**
     * Repozitář registrací – používá se pro read-only výpočty
     * (např. aktuální počet hráčů se statusem REGISTERED).
     */
    private final MatchRegistrationRepository matchRegistrationRepository;
    private final MatchRepository matchRepository;
    private final PlayerRepository playerRepository;

    /**
     * Jednotný formát data používaný v SMS zprávách.
     */
    private final DateTimeFormatter dateFormatter =
            DateTimeFormatter.ofPattern("yyyy-MM-dd");

    public SmsMessageBuilder(MatchRegistrationRepository matchRegistrationRepository,
                             MatchRepository matchRepository,
                             PlayerRepository playerRepository) {
        this.matchRegistrationRepository = matchRegistrationRepository;
        this.matchRepository = matchRepository;
        this.playerRepository = playerRepository;
    }

    // ====================================================
    // HLAVNÍ METODA PRO NotificationServiceImpl
    // ====================================================

    /**
     * Sestaví SMS text pro hráče podle typu notifikace a kontextu.
     *
     * @param type    typ notifikace
     * @param player  hráč (aktuálně se používá hlavně pro jméno – pro rozšíření do budoucna)
     * @param context kontext – typicky {@link MatchRegistrationEntity} nebo {@link MatchEntity}
     * @return hotový text SMS nebo {@code null}, pokud pro daný typ nic neposíláme
     */
    public String buildForNotification(NotificationType type,
                                       PlayerEntity player,
                                       Object context) {

        return switch (type) {

            // Registrace / odhlášení / přesun ve frontě / omluvy
            case MATCH_REGISTRATION_CREATED,
                 MATCH_REGISTRATION_UPDATED,
                 MATCH_REGISTRATION_CANCELED,
                 MATCH_REGISTRATION_RESERVED,
                 MATCH_WAITING_LIST_MOVED_UP,
                 PLAYER_EXCUSED,
                 PLAYER_NO_EXCUSED -> {
                MatchRegistrationEntity reg =
                        castContext(context, MatchRegistrationEntity.class);
                if (reg == null) {
                    yield null;
                }
                yield buildMessageRegistration(reg);
            }

            // Obecné info / změny zápasu
            case MATCH_REMINDER,
                 MATCH_CANCELED,
                 MATCH_TIME_CHANGED -> {
                MatchEntity match = castContext(context, MatchEntity.class);
                if (match == null) {
                    yield null;
                }
                yield buildMessageMatchInfo(type, match);
            }

            // ostatní typy přes SMS neposíláme
            default -> null;
        };
    }

    @SuppressWarnings("unchecked")
    private <T> T castContext(Object context, Class<T> expectedType) {
        if (context == null) {
            return null;
        }
        if (!expectedType.isInstance(context)) {
            return null;
        }
        return (T) context;
    }

    // ====================================================
    // REGISTRACE / ODHLÁŠENÍ / OMLUVA
    // ====================================================

    /**
     * Vytvoří SMS zprávu po změně registrace hráče na zápas.
     *
     * Používá se pro stavy:
     * <ul>
     *     <li>{@link PlayerMatchStatus#REGISTERED},</li>
     *     <li>{@link PlayerMatchStatus#UNREGISTERED},</li>
     *     <li>{@link PlayerMatchStatus#EXCUSED},</li>
     *     <li>{@link PlayerMatchStatus#SUBSTITUTE},</li>
     *     <li>{@link PlayerMatchStatus#RESERVED}.</li>
     * </ul>
     *
     * @param registration registrace hráče k zápasu
     * @return text SMS zprávy
     */
    public String buildMessageRegistration(MatchRegistrationEntity registration) {

        PlayerMatchStatus status = registration.getStatus();
        boolean createdByUser = "user".equals(registration.getCreatedBy());

        String statusText;

        if (createdByUser) {
            statusText = switch (status) {
                case REGISTERED -> "přihlásil se";
                case UNREGISTERED -> "odhlásil se";
                case EXCUSED -> "omluvil se";
                case SUBSTITUTE -> "možná bude";
                case RESERVED -> "byl z důvodu snížení kapacity přesunut mezi náhradníky";
                default -> "neznámý stav";
            };
        } else {
            statusText = switch (status) {
                case REGISTERED -> "byl systémem po uvolnění kapacity přihlášen";
                case UNREGISTERED -> "byl systémem odhlášen";
                case EXCUSED -> "byl systémem omluven";
                case SUBSTITUTE -> "byl systémem nastaven že možná bude";
                case RESERVED -> "byl z důvodu snížení kapacity přesunut mezi náhradníky";
                default -> "neznámý stav";
            };
        }

        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(
                        registration.getMatch().getId(),
                        PlayerMatchStatus.REGISTERED
                );

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - datum: ")
                .append(registration.getMatch().getDateTime().toLocalDate().format(dateFormatter));

        // Obsazenost se neuvádí u EXCUSED – hráč se nepočítá mezi přihlášené.
        if (status != PlayerMatchStatus.EXCUSED) {
            sb.append(", ")
                    .append(registeredCount)
                    .append("/")
                    .append(registration.getMatch().getMaxPlayers());
        }

        sb.append(", hráč: ")
                .append(registration.getPlayer().getFullName())
                .append(", status: ")
                .append(statusText);

        return sb.toString();
    }

    // ====================================================
    // NO RESPONSE – HRÁČ JEŠTĚ NEREAGOVAL
    // ====================================================

    /**
     * Vytvoří SMS zprávu pro hráče, kteří dosud nereagovali
     * na zápas (nemají žádnou registraci).
     *
     * Používá se typicky několik dní před zápasem v rámci
     * scheduleru, který připomíná blížící se zápasy.
     */
    public String buildMessageNoResponse(PlayerDTO player, MatchEntity match) {

        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(
                        match.getId(),
                        PlayerMatchStatus.REGISTERED
                );

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - upozornění: zápas ")
                .append(match.getDateTime().format(dateFormatter))
                .append(" - volná místa: ")
                .append(match.getMaxPlayers() - registeredCount)
                .append(". Ještě jste nereagoval.");

        return sb.toString();
    }

    // ====================================================
    // ZMĚNY STAVU ZÁPASU
    // ====================================================

    /**
     * Vytvoří SMS zprávu s informací o změně stavu zápasu
     * (zrušen / obnoven apod.).
     *
     * @param type  typ notifikace (např. MATCH_CANCELED, MATCH_TIME_CHANGED)
     * @param match zápas
     */
    public String buildMessageMatchInfo(NotificationType type, MatchEntity match) {
        MatchStatus matchStatus = match.getMatchStatus();
        MatchCancelReason cancelReason = match.getCancelReason();

        String statusText = switch (matchStatus) {
            case CANCELLED -> "byl zrušen";
            case UNCANCELED -> "byl obnoven";
            default -> "neznámý stav";
        };

        String cancelReasonText = switch (cancelReason) {
            case NOT_ENOUGH_PLAYERS -> "málo hráčů";
            case TECHNICAL_ISSUE -> "technické problémy (led, hala)";
            case WEATHER -> "počasí";
            case ORGANIZER_DECISION -> "rozhodnutí organizátora";
            case OTHER -> "jiný důvod";
            default -> "neznámý důvod";
        };

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - UPOZORNĚNÍ: zápas ")
                .append(match.getDateTime().format(dateFormatter))
                .append(" - ")
                .append(statusText)
                .append(" (důvod: ")
                .append(cancelReasonText)
                .append(")");

        return sb.toString();
    }

    // ====================================================
    // FINÁLNÍ SMS – DEN ZÁPASU
    // ====================================================

    /**
     * Vytvoří finální SMS zprávu v den zápasu
     * pro již přihlášené hráče.
     *
     * Obsah:
     * <ul>
     *     <li>datum zápasu,</li>
     *     <li>aktuální počet přihlášených hráčů / maximální kapacita,</li>
     *     <li>cena na jednoho hráče (celková cena / počet přihlášených).</li>
     * </ul>
     *
     * @param registration registrace hráče k zápasu
     * @return text finální SMS zprávy
     */
    public String buildMessageFinal(MatchRegistrationEntity registration) {

        MatchEntity match = registration.getMatch();

        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(
                        match.getId(),
                        PlayerMatchStatus.REGISTERED
                );

        double pricePerPlayer =
                match.getPrice() / Math.max(registeredCount, 1);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - připomínka zápasu ")
                .append(match.getDateTime().format(dateFormatter))
                .append(", přihlášeno: ")
                .append(registeredCount)
                .append("/")
                .append(match.getMaxPlayers())
                .append(", cena na hráče: ")
                .append(String.format("%.2f Kč", pricePerPlayer));

        return sb.toString();
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsService.java
-----

package cz.phsoft.hokej.models.services.sms;

/**
 * Rozhraní pro odesílání SMS zpráv v aplikaci.
 * <p>
 * Definuje kontrakt pro odesílání SMS bez závislosti
 * na konkrétním technickém řešení nebo poskytovateli služby.
 * </p>
 *
 * Účel:
 * <ul>
 *     <li>poskytnout jednotný vstupní bod pro odesílání SMS,</li>
 *     <li>oddělit business logiku od technické implementace,</li>
 *     <li>umožnit snadnou výměnu nebo rozšíření SMS providerů.</li>
 * </ul>
 *
 * Použití:
 * <ul>
 *     <li>využívá se v business službách (např. NotificationService, schedulery),</li>
 *     <li>implementace zajišťuje konkrétní způsob odeslání SMS.</li>
 * </ul>
 *
 * Implementační poznámky:
 * <ul>
 *     <li>implementace by měla být odolná vůči chybám externích služeb,</li>
 *     <li>výjimky by neměly být propagovány do business vrstvy,</li>
 *     <li>odesílání SMS je typicky „best-effort“ operace.</li>
 * </ul>
 */
public interface SmsService {

    /**
     * Odešle SMS zprávu na zadané telefonní číslo.
     * <p>
     * Metoda představuje abstraktní operaci odeslání SMS
     * a nezaručuje její skutečné doručení koncovému uživateli.
     * </p>
     *
     * Očekávané chování implementace:
     * <ul>
     *     <li>validní formát telefonního čísla je předpokladem,</li>
     *     <li>selhání odeslání SMS nesmí shodit aplikaci,</li>
     *     <li>chyby by měly být zalogovány.</li>
     * </ul>
     *
     * @param phoneNumber cílové telefonní číslo příjemce
     * @param message     text SMS zprávy
     */
    void sendSms(String phoneNumber, String message);
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsServiceImpl.java
-----

/* package cz.phsoft.hokej.models.services.sms;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;

@Service
public class SmsServiceImpl {

   // private final RestTemplate restTemplate = new RestTemplate();

    @Value("${textbee.api-url}")
    private String apiUrl;

    @Value("${textbee.api-key}")
    private String apiKey;

    // testovací číslo
    //private final String testNumber = "+420776609956";

    /**
     * Odešle SMS na testovací číslo.
     * @param message text zprávy
     */

/*
    public void sendSms(String phoneNumber, String message) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("x-api-key", apiKey);

        Map<String, Object> body = Map.of(
                "recipients", List.of(phoneNumber),
                "message", message
        );

        HttpEntity<Map<String,Object>> request = new HttpEntity<>(body, headers);

        try {
            ResponseEntity<String> response = restTemplate.postForEntity(apiUrl, request, String.class);
            System.out.println("SMS poslána na testovací číslo  xxx   : " + response.getBody());
        } catch (Exception e) {
            System.err.println("Chyba při odesílání SMS: " + e.getMessage());
        }
    }

*/


-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsSchedulerService.java
-----

package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import jakarta.transaction.Transactional;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;

/**
 * Scheduler služba pro automatické odesílání SMS notifikací hráčům.
 * <p>
 * Automaticky odesílá SMS hráčům podle času a stavu zápasů:
 * </p>
 * <ul>
 *     <li>v den zápasu („finální“ SMS s informacemi o zápasu),</li>
 *     <li>několik dní před zápasem hráčům, kteří dosud nereagovali.</li>
 * </ul>
 *
 * Význam v aplikaci:
 * <ul>
 *     <li>zajišťuje pravidelnou a konzistentní komunikaci s hráči,</li>
 *     <li>snižuje riziko zapomenutí zápasu,</li>
 *     <li>pomáhá organizátorům získat včasné reakce hráčů.</li>
 * </ul>
 *
 * Technické řešení:
 * <ul>
 *     <li>využívá Spring scheduler ({@link Scheduled}),</li>
 *     <li>používá {@link SmsService} – nezávislá na konkrétním SMS providerovi,</li>
 *     <li>texty SMS jsou generovány centrálně pomocí {@link SmsMessageBuilder}.</li>
 * </ul>
 *
 * Chování a odolnost:
 * <ul>
 *     <li>služba pracuje pouze se čtením dat (read-only),</li>
 *     <li>selhání odeslání SMS jednomu hráči nesmí ovlivnit ostatní,</li>
 *     <li>výjimky jsou zachyceny a nezastavují běh scheduleru.</li>
 * </ul>
 */
@Service
public class SmsSchedulerService {

    /**
     * Repozitář zápasů.
     * <p>
     * Slouží k vyhledávání zápasů podle data konání.
     * </p>
     */
    private final MatchRepository matchRepository;

    /**
     * Repozitář registrací hráčů na zápasy.
     * <p>
     * Umožňuje získat seznam hráčů registrovaných ke konkrétnímu zápasu.
     * </p>
     */
    private final MatchRegistrationRepository registrationRepository;

    /**
     * Service pro odesílání SMS zpráv.
     * <p>
     * Jedná se o jediný vstupní bod pro odesílání SMS v aplikaci.
     * </p>
     */
    private final SmsService smsService;

    /**
     * Builder pro jednotnou tvorbu textů SMS zpráv.
     * <p>
     * Zajišťuje konzistentní formát a obsah SMS napříč aplikací.
     * </p>
     */
    private final SmsMessageBuilder smsMessageBuilder;

    /**
     * Service s business logikou registrací hráčů na zápasy.
     * <p>
     * Používá se zejména pro zjištění hráčů bez reakce.
     * </p>
     */
    private final MatchRegistrationService matchRegistrationService;

    public SmsSchedulerService(
            MatchRepository matchRepository,
            MatchRegistrationRepository registrationRepository,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder,
            MatchRegistrationService matchRegistrationService) {

        this.matchRepository = matchRepository;
        this.registrationRepository = registrationRepository;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
        this.matchRegistrationService = matchRegistrationService;
    }

    /**
     * Odešle „finální“ SMS všem hráčům registrovaným na zápasy,
     * které se konají v aktuální den.
     * <p>
     * Tato SMS slouží jako poslední připomenutí a shrnutí informací
     * o zápasu pro hráče, kteří jsou již registrováni.
     * </p>
     *
     * Obsah SMS typicky zahrnuje:
     * <ul>
     *     <li>datum a čas zápasu,</li>
     *     <li>místo konání,</li>
     *     <li>informaci o účasti konkrétního hráče.</li>
     * </ul>
     *
     * Spouštění:
     * <ul>
     *     <li>každý den ve 12:30.</li>
     * </ul>
     */
    @Scheduled(cron = "0 30 12 * * *")
    @Transactional
    public void sendFinalSmsForTodayMatches() {

        LocalDate today = LocalDate.now();

        // všechny zápasy, které se konají dnes
        List<MatchEntity> todaysMatches = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().toLocalDate().isEqual(today))
                .toList();

        for (MatchEntity match : todaysMatches) {

            // všechny registrace k danému zápasu
            List<MatchRegistrationEntity> registrations =
                    registrationRepository.findByMatchId(match.getId());

            for (MatchRegistrationEntity reg : registrations) {

                String smsMsg = smsMessageBuilder.buildMessageFinal(reg);

                try {
                    smsService.sendSms(
                            reg.getPlayer().getPhoneNumber(),
                            smsMsg
                    );

                    System.out.println(
                            "Finální SMS poslána hráči " +
                                    reg.getPlayer().getFullName()
                    );

                } catch (Exception e) {
                    // chyba jednoho hráče nesmí zastavit celý scheduler
                    System.err.println(
                            "Chyba SMS pro hráče " +
                                    reg.getPlayer().getFullName() +
                                    ": " + e.getMessage()
                    );
                }
            }
        }
    }

    /**
     * Odešle připomínkovou SMS hráčům, kteří:
     * <ul>
     *     <li>mají zápas za 3 dny,</li>
     *     <li>dosud na zápas nijak nereagovali (NO_RESPONSE).</li>
     * </ul>
     *
     * Smysl této SMS:
     * <ul>
     *     <li>upozornit hráče na blížící se zápas,</li>
     *     <li>motivovat je k reakci (účast / omluva),</li>
     *     <li>umožnit včasné plánování sestavy.</li>
     * </ul>
     *
     * Spouštění:
     * <ul>
     *     <li>každý den ve 14:40.</li>
     * </ul>
     */
    @Scheduled(cron = "0 40 14 * * *")
    @Transactional
    public void sendNoResponseSmsForMatchesIn3Days() {

        LocalDate targetDate = LocalDate.now().plusDays(3);

        // zápasy, které se konají za 3 dny
        List<MatchEntity> matchesInThreeDays = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().toLocalDate().isEqual(targetDate))
                .toList();

        for (MatchEntity match : matchesInThreeDays) {

            // využijeme existující logiku z MatchRegistrationService
            List<PlayerDTO> noResponsePlayers =
                    matchRegistrationService.getNoResponsePlayers(match.getId());

            for (PlayerDTO player : noResponsePlayers) {

                String smsMsg =
                        smsMessageBuilder.buildMessageNoResponse(player, match);

                try {
                    smsService.sendSms(
                            player.getPhoneNumber(),
                            smsMsg
                    );

                    System.out.println(
                            "NO_RESPONSE SMS poslána hráči " +
                                    player.getFullName()
                    );

                } catch (Exception e) {
                    System.err.println(
                            "Chyba NO_RESPONSE SMS pro hráče " +
                                    player.getFullName() +
                                    ": " + e.getMessage()
                    );
                }
            }
        }
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsTextBeeService.java
-----

package cz.phsoft.hokej.models.services.sms;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;

/**
 * Implementace {@link SmsService} využívající externí službu TextBee.
 * <p>
 * Tato service představuje jediný vstupní bod pro odesílání SMS zpráv
 * v aplikaci. Business vrstvy pracují výhradně s rozhraním
 * {@link SmsService} a nejsou závislé na konkrétním SMS providerovi.
 * </p>
 *
 * Odpovědnost:
 * <ul>
 *     <li>odesílání SMS zpráv přes TextBee API,</li>
 *     <li>respektování globálního přepínače {@code sms.enabled},</li>
 *     <li>jednotné logování úspěchů i chyb,</li>
 *     <li>zajištění, že selhání SMS neovlivní business logiku.</li>
 * </ul>
 *
 * Technické poznámky:
 * <ul>
 *     <li>integrace probíhá pomocí REST API služby TextBee,</li>
 *     <li>chyby jsou zachyceny a nejsou propagovány výše,</li>
 *     <li>service je vhodná jak pro produkci, tak pro dev/test režim.</li>
 * </ul>
 */
@Service
public class SmsTextBeeService implements SmsService {

    private static final Logger log =
            LoggerFactory.getLogger(SmsTextBeeService.class);

    /**
     * Globální zapnutí / vypnutí SMS.
     * <p>
     * Typické použití:
     * </p>
     * <ul>
     *     <li>{@code true} – produkční prostředí (SMS se skutečně odesílají),</li>
     *     <li>{@code false} – lokální vývoj / testy (SMS se pouze logují).</li>
     * </ul>
     */
    @Value("${sms.enabled:true}")
    private boolean smsEnabled;

    /**
     * URL endpointu TextBee API.
     */
    @Value("${textbee.api-url}")
    private String apiUrl;

    /**
     * API klíč pro autentizaci vůči TextBee.
     * <p>
     * Klíč se odesílá v HTTP hlavičce {@code x-api-key}.
     * </p>
     */
    @Value("${textbee.api-key}")
    private String apiKey;

    /**
     * HTTP klient pro komunikaci s TextBee API.
     * <p>
     * Pro jednoduchost je vytvořen přímo zde. V případě potřeby
     * lze tuto implementaci snadno nahradit injektovaným {@code @Bean}
     * nebo {@code WebClientem}.
     * </p>
     */
    private final RestTemplate restTemplate = new RestTemplate();

    /**
     * Odešle SMS zprávu na zadané telefonní číslo.
     * <p>
     * Chování metody:
     * </p>
     * <ul>
     *     <li>pokud jsou SMS globálně vypnuté, zpráva se neodesílá, pouze se zaloguje,</li>
     *     <li>jinak se odešle HTTP POST požadavek na TextBee API,</li>
     *     <li>jakákoli chyba při odesílání je zachycena a zalogována.</li>
     * </ul>
     *
     * Důležité:
     * <ul>
     *     <li>výjimky nejsou propagovány do business vrstvy,</li>
     *     <li>odesílání SMS je „best-effort“ operace,</li>
     *     <li>selhání SMS nesmí shodit aplikaci.</li>
     * </ul>
     *
     * @param phoneNumber cílové telefonní číslo
     * @param message     text SMS zprávy
     */
    @Override
    public void sendSms(String phoneNumber, String message) {

        // Globální vypnutí SMS (typicky dev / test)
        if (!smsEnabled) {
            log.info(
                    "SMS jsou globálně vypnuté (sms.enabled=false). Zpráva NEODESLÁNA. Tel: {}, msg: {}",
                    phoneNumber, message
            );

            System.out.println(
                    "SMS disabled (global), message not sent: "
                            + phoneNumber + " -> " + message
            );
            return;
        }

        // HTTP hlavičky
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("x-api-key", apiKey);

        // Tělo requestu
        Map<String, Object> body = Map.of(
                "recipients", List.of(phoneNumber),
                "message", message
        );

        HttpEntity<Map<String, Object>> request =
                new HttpEntity<>(body, headers);

        try {
            // Odeslání požadavku na TextBee API
            ResponseEntity<String> response =
                    restTemplate.postForEntity(apiUrl, request, String.class);

            log.info(
                    "SMS odeslána (TextBee) na {}, response: {}",
                    phoneNumber, response.getBody()
            );

            // Paralelní výstup do konzole (užitečné zejména v DEV)
            System.out.println(
                    "SMS odeslána (TextBee) na " + phoneNumber +
                            ", response: " + response.getBody()
            );

        } catch (Exception e) {
            // Chyby při odesílání SMS nesmí ovlivnit chod aplikace
            log.error(
                    "Chyba při odesílání SMS přes TextBee na {}: {}",
                    phoneNumber, e.getMessage(), e
            );

            System.err.println(
                    "Chyba při odesílání SMS přes TextBee na "
                            + phoneNumber + ": " + e.getMessage()
            );
        }
    }
}


