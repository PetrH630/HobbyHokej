Balíček (složka): sms
Cesta: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\sms

Seznam souborů:
package-info.java
SmsMessageBuilder.java
SmsService.java
SmsSchedulerService.java
SmsTextBeeService.java


-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\sms\package-info.java
-----
/**
 * SMS subsystĂ©m aplikace.
 *
 * Obsahuje tĹ™Ă­dy zodpovÄ›dnĂ© za sklĂˇdĂˇnĂ­ textĹŻ SMS zprĂˇv
 * a jejich odesĂ­lĂˇnĂ­ prostĹ™ednictvĂ­m SMS brĂˇny.
 *
 * Tento balĂ­ÄŤek je pouĹľĂ­vĂˇn servisnĂ­ vrstvou pĹ™i odesĂ­lĂˇnĂ­
 * notifikacĂ­ hrĂˇÄŤĹŻm a uĹľivatelĹŻm formou SMS.
 */
package cz.phsoft.hokej.models.services.sms;

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsMessageBuilder.java
-----
package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.MatchCancelReason;
import cz.phsoft.hokej.data.enums.MatchStatus;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import org.springframework.stereotype.Component;

import java.time.format.DateTimeFormatter;

/**
 * Builder pro generovĂˇnĂ­ textĹŻ SMS zprĂˇv.
 *
 * OdpovÄ›dnosti:
 * - sestavenĂ­ lidsky ÄŤitelnĂ©ho obsahu SMS pro rĹŻznĂ© typy notifikacĂ­,
 * - centralizace formĂˇtovĂˇnĂ­ SMS zprĂˇv (princip DRY),
 * - oddÄ›lenĂ­ textovĂ© logiky od business logiky a schedulingu.
 *
 * Tato tĹ™Ă­da se pouĹľĂ­vĂˇ zejmĂ©na v NotificationServiceImpl a SmsService
 * jako zdroj vĂ˝slednĂ©ho textu SMS zprĂˇv.
 *
 * TĹ™Ă­da neĹ™eĹˇĂ­:
 * - odesĂ­lĂˇnĂ­ SMS (to zajiĹˇĹĄuje SmsService),
 * - zmÄ›ny v databĂˇzi,
 * - oprĂˇvnÄ›nĂ­ ani validace vstupĹŻ (pĹ™edpoklĂˇdĂˇ se, Ĺľe vstupy jsou zvalidovanĂ© dĹ™Ă­ve).
 */
@Component
public class SmsMessageBuilder {

    /**
     * RepozitĂˇĹ™ registracĂ­ pouĹľĂ­vanĂ˝ pro read-only vĂ˝poÄŤty
     * (napĹ™Ă­klad aktuĂˇlnĂ­ poÄŤet hrĂˇÄŤĹŻ se statusem REGISTERED).
     */
    private final MatchRegistrationRepository matchRegistrationRepository;

    /**
     * RepozitĂˇĹ™ zĂˇpasĹŻ pouĹľĂ­vanĂ˝ pro doplĹujĂ­cĂ­ informace o zĂˇpase.
     *
     * AktuĂˇlnÄ› se vyuĹľĂ­vĂˇ minimĂˇlnÄ›, je zde ponechĂˇn pro moĹľnĂ© rozĹˇĂ­Ĺ™enĂ­.
     */
    private final MatchRepository matchRepository;

    /**
     * RepozitĂˇĹ™ hrĂˇÄŤĹŻ pouĹľĂ­vanĂ˝ pro pĹ™Ă­padnĂ© rozĹˇĂ­Ĺ™enĂ­ zprĂˇv
     * o detailnÄ›jĹˇĂ­ informace o hrĂˇÄŤĂ­ch.
     */
    private final PlayerRepository playerRepository;

    /**
     * JednotnĂ˝ formĂˇt data pouĹľĂ­vanĂ˝ v SMS zprĂˇvĂˇch.
     *
     * SlouĹľĂ­ k tomu, aby mÄ›ly vĹˇechny SMS zprĂˇvy konzistentnĂ­ formĂˇt data.
     */
    private final DateTimeFormatter dateFormatter =
            DateTimeFormatter.ofPattern("yyyy-MM-dd");

    public SmsMessageBuilder(MatchRegistrationRepository matchRegistrationRepository,
                             MatchRepository matchRepository,
                             PlayerRepository playerRepository) {
        this.matchRegistrationRepository = matchRegistrationRepository;
        this.matchRepository = matchRepository;
        this.playerRepository = playerRepository;
    }

    // ====================================================
    // HLAVNĂŤ VSTUPNĂŤ METODA PRO NotificationServiceImpl
    // ====================================================

    /**
     * SestavĂ­ SMS text pro hrĂˇÄŤe podle typu notifikace a kontextu.
     *
     * Metoda slouĹľĂ­ jako hlavnĂ­ vstupnĂ­ bod pro NotificationServiceImpl,
     * kde se podle NotificationType a typu contextu rozhoduje,
     * kterĂ˝ specializovanĂ˝ builder se pouĹľije.
     *
     * PodporovanĂ© scĂ©nĂˇĹ™e:
     * - zmÄ›ny registrace hrĂˇÄŤe na zĂˇpas,
     * - obecnĂ© informace o zĂˇpase (zruĹˇenĂ­, zmÄ›na ÄŤasu, pĹ™ipomenutĂ­).
     *
     * @param type    typ notifikace, pro kterou se SMS generuje
     * @param player  hrĂˇÄŤ, pro kterĂ©ho se SMS generuje
     * @param context kontext notifikace, obvykle MatchRegistrationEntity nebo MatchEntity
     * @return hotovĂ˝ text SMS nebo {@code null}, pokud se pro danĂ˝ typ notifikace SMS neposĂ­lĂˇ
     */
    public String buildForNotification(NotificationType type,
                                       PlayerEntity player,
                                       Object context) {

        return switch (type) {

            // Registrace / odhlĂˇĹˇenĂ­ / pĹ™esun ve frontÄ› / omluvy
            case MATCH_REGISTRATION_CREATED,
                 MATCH_REGISTRATION_UPDATED,
                 MATCH_REGISTRATION_CANCELED,
                 MATCH_REGISTRATION_RESERVED,
                 MATCH_WAITING_LIST_MOVED_UP,
                 PLAYER_EXCUSED,
                 PLAYER_NO_EXCUSED -> {
                MatchRegistrationEntity reg =
                        castContext(context, MatchRegistrationEntity.class);
                if (reg == null) {
                    yield null;
                }
                yield buildMessageRegistration(reg);
            }

            // ObecnĂ© info / zmÄ›ny zĂˇpasu
            case MATCH_REMINDER,
                 MATCH_CANCELED,
                 MATCH_TIME_CHANGED -> {
                MatchEntity match = castContext(context, MatchEntity.class);
                if (match == null) {
                    yield null;
                }
                yield buildMessageMatchInfo(type, match);
            }

            // ostatnĂ­ typy se pĹ™es SMS neposĂ­lajĂ­
            default -> null;
        };
    }

    /**
     * BezpeÄŤnĂ© pĹ™etypovĂˇnĂ­ contextu na oÄŤekĂˇvanĂ˝ typ.
     *
     * Pokud context nenĂ­ zadanĂ©ho typu, vracĂ­ se null.
     *
     * @param context      vstupnĂ­ objekt kontextu
     * @param expectedType oÄŤekĂˇvanĂ˝ typ kontextu
     * @param <T>          generickĂ˝ typ vĂ˝sledku
     * @return pĹ™etypovanĂ˝ objekt nebo null, pokud typ neodpovĂ­dĂˇ
     */
    @SuppressWarnings("unchecked")
    private <T> T castContext(Object context, Class<T> expectedType) {
        if (context == null) {
            return null;
        }
        if (!expectedType.isInstance(context)) {
            return null;
        }
        return (T) context;
    }

    // ====================================================
    // REGISTRACE / ODHLĂĹ ENĂŤ / OMLUVA
    // ====================================================

    /**
     * VytvoĹ™Ă­ SMS zprĂˇvu po zmÄ›nÄ› registrace hrĂˇÄŤe na zĂˇpas.
     *
     * ZprĂˇva popisuje:
     * - datum zĂˇpasu,
     * - aktuĂˇlnĂ­ obsazenost zĂˇpasu,
     * - jmĂ©no hrĂˇÄŤe,
     * - slovnĂ­ popis zmÄ›ny stavu (pĹ™ihlĂˇĹˇenĂ­, odhlĂˇĹˇenĂ­, omluva, nĂˇhradnĂ­k).
     *
     * PouĹľitĂ© stavy:
     * - REGISTERED,
     * - UNREGISTERED,
     * - EXCUSED,
     * - SUBSTITUTE,
     * - RESERVED.
     *
     * Text se liĹˇĂ­ podle toho, zda zmÄ›nu provedl uĹľivatel nebo systĂ©m.
     *
     * @param registration registrace hrĂˇÄŤe k zĂˇpasu
     * @return text SMS zprĂˇvy popisujĂ­cĂ­ zmÄ›nu registrace
     */
    public String buildMessageRegistration(MatchRegistrationEntity registration) {

        PlayerMatchStatus status = registration.getStatus();
        boolean createdByUser = "user".equals(registration.getCreatedBy());

        String statusText;

        if (createdByUser) {
            statusText = switch (status) {
                case REGISTERED -> "pĹ™ihlĂˇsil se";
                case UNREGISTERED -> "odhlĂˇsil se";
                case EXCUSED -> "omluvil se";
                case SUBSTITUTE -> "moĹľnĂˇ bude";
                case RESERVED -> "byl z dĹŻvodu snĂ­ĹľenĂ­ kapacity pĹ™esunut mezi nĂˇhradnĂ­ky";
                default -> "neznĂˇmĂ˝ stav";
            };
        } else {
            statusText = switch (status) {
                case REGISTERED -> "byl systĂ©mem po uvolnÄ›nĂ­ kapacity pĹ™ihlĂˇĹˇen";
                case UNREGISTERED -> "byl systĂ©mem odhlĂˇĹˇen";
                case EXCUSED -> "byl systĂ©mem omluven";
                case SUBSTITUTE -> "byl systĂ©mem nastaven Ĺľe moĹľnĂˇ bude";
                case RESERVED -> "byl z dĹŻvodu snĂ­ĹľenĂ­ kapacity pĹ™esunut mezi nĂˇhradnĂ­ky";
                default -> "neznĂˇmĂ˝ stav";
            };
        }

        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(
                        registration.getMatch().getId(),
                        PlayerMatchStatus.REGISTERED
                );

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - datum: ")
                .append(registration.getMatch().getDateTime().toLocalDate().format(dateFormatter));

        // Obsazenost se neuvĂˇdĂ­ u EXCUSED â€“ hrĂˇÄŤ se nepoÄŤĂ­tĂˇ mezi pĹ™ihlĂˇĹˇenĂ©.
        if (status != PlayerMatchStatus.EXCUSED) {
            sb.append(", ")
                    .append(registeredCount)
                    .append("/")
                    .append(registration.getMatch().getMaxPlayers());
        }

        sb.append(", hrĂˇÄŤ: ")
                .append(registration.getPlayer().getFullName())
                .append(", status: ")
                .append(statusText);

        return sb.toString();
    }

    // ====================================================
    // NO RESPONSE â€“ HRĂÄŚ JEĹ TÄš NEREAGOVAL
    // ====================================================

    /**
     * VytvoĹ™Ă­ SMS zprĂˇvu pro hrĂˇÄŤe, kteĹ™Ă­ dosud nereagovali na zĂˇpas.
     *
     * ZprĂˇva se pouĹľĂ­vĂˇ typicky nÄ›kolik dnĂ­ pĹ™ed zĂˇpasem
     * v rĂˇmci plĂˇnovaÄŤe, kterĂ˝ pĹ™ipomĂ­nĂˇ blĂ­ĹľĂ­cĂ­ se zĂˇpasy
     * a upozorĹuje na volnĂˇ mĂ­sta.
     *
     * Obsah zprĂˇvy:
     * - datum zĂˇpasu,
     * - aktuĂˇlnĂ­ poÄŤet volnĂ˝ch mĂ­st,
     * - upozornÄ›nĂ­, Ĺľe hrĂˇÄŤ jeĹˇtÄ› nereagoval.
     *
     * @param player hrĂˇÄŤ, pro kterĂ©ho se zprĂˇva vytvĂˇĹ™Ă­
     * @param match  zĂˇpas, ke kterĂ©mu se pĹ™ipomĂ­nka vztahuje
     * @return text SMS zprĂˇvy pro nereagujĂ­cĂ­ho hrĂˇÄŤe
     */
    public String buildMessageNoResponse(PlayerDTO player, MatchEntity match) {

        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(
                        match.getId(),
                        PlayerMatchStatus.REGISTERED
                );

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - upozornÄ›nĂ­: zĂˇpas ")
                .append(match.getDateTime().format(dateFormatter))
                .append(" - volnĂˇ mĂ­sta: ")
                .append(match.getMaxPlayers() - registeredCount)
                .append(". JeĹˇtÄ› jste nereagoval.");

        return sb.toString();
    }

    // ====================================================
    // ZMÄšNY STAVU ZĂPASU
    // ====================================================

    /**
     * VytvoĹ™Ă­ SMS zprĂˇvu s informacĂ­ o zmÄ›nÄ› stavu zĂˇpasu.
     *
     * TypickĂ© scĂ©nĂˇĹ™e:
     * - zĂˇpas byl zruĹˇen,
     * - zĂˇpas byl obnoven nebo zmÄ›nÄ›n.
     *
     * ZprĂˇva obsahuje:
     * - datum zĂˇpasu,
     * - slovnĂ­ popis stavu zĂˇpasu,
     * - slovnĂ­ popis dĹŻvodu zruĹˇenĂ­ (pokud je k dispozici).
     *
     * Parametr type se pouĹľĂ­vĂˇ na Ăşrovni volajĂ­cĂ­ sluĹľby pro rozhodnutĂ­,
     * kdy se zprĂˇva generuje. V tĂ©to metodÄ› se stav urÄŤuje primĂˇrnÄ›
     * z vlastnostĂ­ MatchEntity.
     *
     * @param type  typ notifikace, pro kterou se zprĂˇva vytvĂˇĹ™Ă­
     * @param match zĂˇpas, jehoĹľ stav se oznamuje
     * @return text SMS zprĂˇvy popisujĂ­cĂ­ stav zĂˇpasu
     */
    public String buildMessageMatchInfo(NotificationType type, MatchEntity match) {
        MatchStatus matchStatus = match.getMatchStatus();
        MatchCancelReason cancelReason = match.getCancelReason();

        String statusText = switch (matchStatus) {
            case CANCELED -> "byl zruĹˇen";
            case UNCANCELED -> "byl obnoven";
            case UPDATED -> "byl zmÄ›nÄ›n";
            default -> "neznĂˇmĂ˝ stav";
        };

        String cancelReasonText = switch (cancelReason) {
            case NOT_ENOUGH_PLAYERS -> "mĂˇlo hrĂˇÄŤĹŻ";
            case TECHNICAL_ISSUE -> "technickĂ© problĂ©my (led, hala)";
            case WEATHER -> "poÄŤasĂ­";
            case ORGANIZER_DECISION -> "rozhodnutĂ­ organizĂˇtora";
            case OTHER -> "jinĂ˝ dĹŻvod";
            default -> "neznĂˇmĂ˝ dĹŻvod";
        };

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - UPOZORNÄšNĂŤ: zĂˇpas ")
                .append(match.getDateTime().format(dateFormatter))
                .append(" - ")
                .append(statusText)
                .append(" (dĹŻvod: ")
                .append(cancelReasonText)
                .append(")");

        return sb.toString();
    }

    // ====================================================
    // FINĂLNĂŤ SMS â€“ DEN ZĂPASU
    // ====================================================

    /**
     * VytvoĹ™Ă­ finĂˇlnĂ­ SMS zprĂˇvu v den zĂˇpasu
     * pro jiĹľ pĹ™ihlĂˇĹˇenĂ© hrĂˇÄŤe.
     *
     * ZprĂˇva shrnuje:
     * - datum zĂˇpasu,
     * - aktuĂˇlnĂ­ poÄŤet pĹ™ihlĂˇĹˇenĂ˝ch hrĂˇÄŤĹŻ a maximĂˇlnĂ­ kapacitu,
     * - orientaÄŤnĂ­ cenu na jednoho hrĂˇÄŤe (celkovĂˇ cena dÄ›lenĂˇ poÄŤtem pĹ™ihlĂˇĹˇenĂ˝ch).
     *
     * @param registration registrace hrĂˇÄŤe k zĂˇpasu, pro kterou se pĹ™ipomĂ­nka vytvĂˇĹ™Ă­
     * @return text finĂˇlnĂ­ SMS zprĂˇvy v den zĂˇpasu
     */
    public String buildMessageFinal(MatchRegistrationEntity registration) {

        MatchEntity match = registration.getMatch();

        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(
                        match.getId(),
                        PlayerMatchStatus.REGISTERED
                );

        double pricePerPlayer =
                match.getPrice() / Math.max(registeredCount, 1);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - pĹ™ipomĂ­nka zĂˇpasu ")
                .append(match.getDateTime().format(dateFormatter))
                .append(", pĹ™ihlĂˇĹˇeno: ")
                .append(registeredCount)
                .append("/")
                .append(match.getMaxPlayers())
                .append(", cena na hrĂˇÄŤe: ")
                .append(String.format("%.2f KÄŤ", pricePerPlayer));

        return sb.toString();
    }

    // v SmsMessageBuilder.java â€“ ke konci tĹ™Ă­dy

    /**
     * SestavĂ­ SMS pro speciĂˇlnĂ­ zprĂˇvu od administrĂˇtora.
     *
     * PouĹľĂ­vĂˇ konzistentnĂ­ prefix a jednoduchĂ˝ formĂˇt.
     *
     * @param title   titulek zprĂˇvy (napĹ™. "ZmÄ›na ÄŤasu trĂ©ninku")
     * @param message text zprĂˇvy
     * @param player  hrĂˇÄŤ, kterĂ©ho se zprĂˇva tĂ˝kĂˇ (volitelnÄ› pro doplnÄ›nĂ­ jmĂ©na)
     * @return text SMS
     */
    public String buildSpecialMessage(String title,
                                      String message,
                                      PlayerEntity player) {

        StringBuilder sb = new StringBuilder();
        sb.append("HobbyHokej â€“ ");

        if (title != null && !title.isBlank()) {
            sb.append(title.trim());
        } else {
            sb.append("zprĂˇva od sprĂˇvce");
        }

        if (player != null && player.getFullName() != null && !player.getFullName().isBlank()) {
            sb.append(" (hrĂˇÄŤ: ").append(player.getFullName()).append(")");
        }

        if (message != null && !message.isBlank()) {
            sb.append(": ").append(message.replaceAll("\\s+", " ").trim());
        }

        return sb.toString();
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsService.java
-----
package cz.phsoft.hokej.models.services.sms;

/**
 * RozhranĂ­ definujĂ­cĂ­ kontrakt pro odesĂ­lĂˇnĂ­ SMS zprĂˇv v aplikaci.
 *
 * RozhranĂ­ slouĹľĂ­ jako jednotnĂ˝ vstupnĂ­ bod pro odesĂ­lĂˇnĂ­ SMS
 * bez vazby na konkrĂ©tnĂ­ technickou implementaci nebo poskytovatele sluĹľby.
 * Business logika aplikace pracuje vĂ˝hradnÄ› s tĂ­mto rozhranĂ­m
 * a nenĂ­ zĂˇvislĂˇ na detailech odesĂ­lĂˇnĂ­ zprĂˇv.
 *
 * OdpovÄ›dnost rozhranĂ­:
 * - definovĂˇnĂ­ operace pro odeslĂˇnĂ­ SMS zprĂˇvy,
 * - oddÄ›lenĂ­ business logiky od technickĂ© implementace,
 * - umoĹľnÄ›nĂ­ snadnĂ© vĂ˝mÄ›ny nebo rozĹˇĂ­Ĺ™enĂ­ SMS providerĹŻ.
 *
 * RozhranĂ­ je typicky pouĹľĂ­vĂˇno ve sluĹľbĂˇch aplikaÄŤnĂ­ vrstvy,
 * napĹ™Ă­klad v notifikaÄŤnĂ­ch sluĹľbĂˇch nebo plĂˇnovanĂ˝ch schedulerech.
 */
public interface SmsService {

    /**
     * OdesĂ­lĂˇ SMS zprĂˇvu na zadanĂ© telefonnĂ­ ÄŤĂ­slo.
     *
     * Metoda pĹ™edstavuje abstraktnĂ­ operaci odeslĂˇnĂ­ SMS
     * a nezaruÄŤuje jejĂ­ skuteÄŤnĂ© doruÄŤenĂ­ koncovĂ©mu pĹ™Ă­jemci.
     * ZpĹŻsob odeslĂˇnĂ­, prĂˇce s externĂ­ sluĹľbou a pĹ™Ă­padnĂ© chyby
     * jsou plnÄ› v odpovÄ›dnosti konkrĂ©tnĂ­ implementace rozhranĂ­.
     *
     * OÄŤekĂˇvanĂ© chovĂˇnĂ­ implementace:
     * - selhĂˇnĂ­ odeslĂˇnĂ­ SMS nesmĂ­ ovlivnit chod aplikace,
     * - technickĂ© chyby by mÄ›ly bĂ˝t zachyceny a zalogovĂˇny,
     * - odesĂ­lĂˇnĂ­ SMS je povaĹľovĂˇno za best-effort operaci.
     *
     * @param phoneNumber telefonnĂ­ ÄŤĂ­slo pĹ™Ă­jemce SMS zprĂˇvy
     * @param message text SMS zprĂˇvy
     */
    void sendSms(String phoneNumber, String message);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsSchedulerService.java
-----
package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import jakarta.transaction.Transactional;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;

/**
 * Scheduler sluĹľba, kterĂˇ zajiĹˇĹĄuje plĂˇnovanĂ© odesĂ­lĂˇnĂ­ SMS notifikacĂ­ hrĂˇÄŤĹŻm.
 *
 * OdpovÄ›dnost tĹ™Ă­dy je:
 * - vyhledĂˇvĂˇnĂ­ zĂˇpasĹŻ podle data konĂˇnĂ­,
 * - urÄŤenĂ­ cĂ­lovĂ˝ch hrĂˇÄŤĹŻ pro danĂ˝ typ SMS,
 * - pĹ™edĂˇnĂ­ textu zprĂˇv sluĹľbÄ› SmsService k odeslĂˇnĂ­.
 *
 * TĹ™Ă­da se pouĹľĂ­vĂˇ ve vrstvÄ› sluĹľeb a navazuje na MatchRepository,
 * MatchRegistrationRepository, MatchRegistrationService a SmsMessageBuilder.
 */
@Service
public class SmsSchedulerService {

    /**
     * RepozitĂˇĹ™ zĂˇpasĹŻ, kterĂ˝ se pouĹľĂ­vĂˇ pro vyhledĂˇvĂˇnĂ­ zĂˇpasĹŻ podle data konĂˇnĂ­.
     */
    private final MatchRepository matchRepository;

    /**
     * RepozitĂˇĹ™ registracĂ­ hrĂˇÄŤĹŻ na zĂˇpasy, kterĂ˝ se pouĹľĂ­vĂˇ pro zĂ­skĂˇnĂ­ registracĂ­
     * ke konkrĂ©tnĂ­mu zĂˇpasu.
     */
    private final MatchRegistrationRepository registrationRepository;

    /**
     * SluĹľba pro odesĂ­lĂˇnĂ­ SMS zprĂˇv, kterĂˇ pĹ™edstavuje technickĂ˝ vstupnĂ­ bod
     * pro komunikaci s externĂ­m SMS providerem.
     */
    private final SmsService smsService;

    /**
     * Builder pro tvorbu textĹŻ SMS zprĂˇv, kterĂ˝ zajiĹˇĹĄuje jednotnĂ˝ formĂˇt
     * a obsah SMS napĹ™Ă­ÄŤ aplikacĂ­.
     */
    private final SmsMessageBuilder smsMessageBuilder;

    /**
     * SluĹľba s business logikou registracĂ­ hrĂˇÄŤĹŻ na zĂˇpasy, kterĂˇ se pouĹľĂ­vĂˇ
     * zejmĂ©na pro zjiĹˇtÄ›nĂ­ hrĂˇÄŤĹŻ bez reakce na pozvĂˇnku.
     */
    private final MatchRegistrationService matchRegistrationService;

    /**
     * VytvĂˇĹ™Ă­ instanci scheduler sluĹľby a injektuje zĂˇvislosti ze Spring kontextu.
     */
    public SmsSchedulerService(
            MatchRepository matchRepository,
            MatchRegistrationRepository registrationRepository,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder,
            MatchRegistrationService matchRegistrationService) {

        this.matchRepository = matchRepository;
        this.registrationRepository = registrationRepository;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
        this.matchRegistrationService = matchRegistrationService;
    }

    /**
     * Metoda odesĂ­lĂˇ finĂˇlnĂ­ SMS vĹˇem hrĂˇÄŤĹŻm registrovanĂ˝m na zĂˇpasy,
     * kterĂ© se konajĂ­ v aktuĂˇlnĂ­ den.
     *
     * Metoda se plĂˇnuje pomocĂ­ Spring scheduleru a spouĹˇtĂ­ se kaĹľdĂ˝ den ve 12:30
     * v ÄŤasovĂ© zĂłnÄ› Europe/Prague. V rĂˇmci zpracovĂˇnĂ­ se vyhledajĂ­ vĹˇechny dneĹˇnĂ­ zĂˇpasy,
     * naÄŤtou se registrace hrĂˇÄŤĹŻ k tÄ›mto zĂˇpasĹŻm a pro kaĹľdou registraci se vygeneruje
     * text finĂˇlnĂ­ SMS a pĹ™edĂˇ se sluĹľbÄ› SmsService k odeslĂˇnĂ­.
     *
     * Metoda pracuje pouze s existujĂ­cĂ­mi daty a nemÄ›nĂ­ stav databĂˇze, transakce
     * se pouĹľĂ­vĂˇ pro zajiĹˇtÄ›nĂ­ konzistence pĹ™i ÄŤtenĂ­.
     */
    @Scheduled(cron = "0 30 12 * * *", zone = "Europe/Prague")
    @Transactional
    public void sendFinalSmsForTodayMatches() {

        LocalDate today = LocalDate.now();

        // ZĂˇpasy, kterĂ© se konajĂ­ v aktuĂˇlnĂ­ den.
        List<MatchEntity> todaysMatches = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().toLocalDate().isEqual(today))
                .toList();

        for (MatchEntity match : todaysMatches) {

            // Registrace hrĂˇÄŤĹŻ k danĂ©mu zĂˇpasu.
            List<MatchRegistrationEntity> registrations =
                    registrationRepository.findByMatchId(match.getId());

            for (MatchRegistrationEntity reg : registrations) {

                String smsMsg = smsMessageBuilder.buildMessageFinal(reg);

                try {
                    smsService.sendSms(
                            reg.getPlayer().getPhoneNumber(),
                            smsMsg
                    );

                    System.out.println(
                            "FinĂˇlnĂ­ SMS poslĂˇna hrĂˇÄŤi " +
                                    reg.getPlayer().getFullName()
                    );

                } catch (Exception e) {
                    // Chyba pĹ™i odesĂ­lĂˇnĂ­ jednomu hrĂˇÄŤi nesmĂ­ zastavit bÄ›h celĂ© naplĂˇnovanĂ© Ăşlohy.
                    System.err.println(
                            "Chyba SMS pro hrĂˇÄŤe " +
                                    reg.getPlayer().getFullName() +
                                    ": " + e.getMessage()
                    );
                }
            }
        }
    }

    /**
     * Metoda odesĂ­lĂˇ pĹ™ipomĂ­nkovou SMS hrĂˇÄŤĹŻm, kteĹ™Ă­ majĂ­ zĂˇpas naplĂˇnovanĂ˝
     * za tĹ™i dny a dosud na zĂˇpas nijak nereagovali (stav NO_RESPONSE).
     *
     * Metoda se plĂˇnuje pomocĂ­ Spring scheduleru a spouĹˇtĂ­ se kaĹľdĂ˝ den ve 12:30
     * v ÄŤasovĂ© zĂłnÄ› Europe/Prague. V rĂˇmci zpracovĂˇnĂ­ se vyhledajĂ­ zĂˇpasy,
     * kterĂ© se konajĂ­ pĹ™esnÄ› za tĹ™i dny od aktuĂˇlnĂ­ho data. Pro kaĹľdĂ˝ takovĂ˝ zĂˇpas
     * se vyuĹľije logika sluĹľby MatchRegistrationService k zĂ­skĂˇnĂ­ hrĂˇÄŤĹŻ bez reakce
     * a tÄ›mto hrĂˇÄŤĹŻm se odeĹˇle pĹ™ipomĂ­nkovĂˇ SMS prostĹ™ednictvĂ­m SmsService.
     *
     * Metoda slouĹľĂ­ k podpoĹ™e vÄŤasnĂ©ho plĂˇnovĂˇnĂ­ sestavy a k omezenĂ­ situacĂ­,
     * kdy hrĂˇÄŤi zapomenou na blĂ­ĹľĂ­cĂ­ se zĂˇpas.
     */
    @Scheduled(cron = "0 30 12 * * *", zone = "Europe/Prague")
    @Transactional
    public void sendNoResponseSmsForMatchesIn3Days() {

        LocalDate targetDate = LocalDate.now().plusDays(3);

        // ZĂˇpasy, kterĂ© se konajĂ­ za tĹ™i dny.
        List<MatchEntity> matchesInThreeDays = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().toLocalDate().isEqual(targetDate))
                .toList();

        for (MatchEntity match : matchesInThreeDays) {

            // HrĂˇÄŤi bez reakce se zĂ­skĂˇvajĂ­ pomocĂ­ MatchRegistrationService.
            List<PlayerDTO> noResponsePlayers =
                    matchRegistrationService.getNoResponsePlayers(match.getId());

            for (PlayerDTO player : noResponsePlayers) {

                String smsMsg =
                        smsMessageBuilder.buildMessageNoResponse(player, match);

                try {
                    smsService.sendSms(
                            player.getPhoneNumber(),
                            smsMsg
                    );

                    System.out.println(
                            "NO_RESPONSE SMS poslĂˇna hrĂˇÄŤi " +
                                    player.getFullName()
                    );

                } catch (Exception e) {
                    // Chyba pĹ™i odesĂ­lĂˇnĂ­ jednomu hrĂˇÄŤi nesmĂ­ zastavit bÄ›h celĂ© naplĂˇnovanĂ© Ăşlohy.
                    System.err.println(
                            "Chyba NO_RESPONSE SMS pro hrĂˇÄŤe " +
                                    player.getFullName() +
                                    ": " + e.getMessage()
                    );
                }
            }
        }
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsTextBeeService.java
-----
package cz.phsoft.hokej.models.services.sms;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;

/**
 * Implementace rozhranĂ­ SmsService vyuĹľĂ­vajĂ­cĂ­ externĂ­ SMS sluĹľbu TextBee.
 *
 * TĹ™Ă­da pĹ™edstavuje technickou implementaci odesĂ­lĂˇnĂ­ SMS zprĂˇv.
 * Business vrstvy aplikace pracujĂ­ vĂ˝hradnÄ› s rozhranĂ­m SmsService
 * a nejsou zĂˇvislĂ© na konkrĂ©tnĂ­m SMS providerovi ani na detailech
 * HTTP komunikace.
 *
 * OdpovÄ›dnost tĹ™Ă­dy:
 * - odesĂ­lĂˇnĂ­ SMS zprĂˇv prostĹ™ednictvĂ­m TextBee API,
 * - respektovĂˇnĂ­ globĂˇlnĂ­ho nastavenĂ­ zapnutĂ­ nebo vypnutĂ­ SMS,
 * - jednotnĂ© logovĂˇnĂ­ ĂşspÄ›ĹˇnĂ˝ch i neĂşspÄ›ĹˇnĂ˝ch pokusĹŻ o odeslĂˇnĂ­,
 * - zajiĹˇtÄ›nĂ­, Ĺľe technickĂ© selhĂˇnĂ­ SMS neovlivnĂ­ business logiku aplikace.
 *
 * TĹ™Ă­da je navrĹľena tak, aby byla snadno nahraditelnĂˇ jinou implementacĂ­
 * SmsService bez zĂˇsahu do vyĹˇĹˇĂ­ch vrstev aplikace.
 */
@Service
public class SmsTextBeeService implements SmsService {

    private static final Logger log =
            LoggerFactory.getLogger(SmsTextBeeService.class);

    /**
     * GlobĂˇlnĂ­ pĹ™epĂ­naÄŤ pro zapnutĂ­ nebo vypnutĂ­ odesĂ­lĂˇnĂ­ SMS.
     *
     * Hodnota se naÄŤĂ­tĂˇ z konfiguraÄŤnĂ­ch properties aplikace.
     * V produkÄŤnĂ­m prostĹ™edĂ­ je obvykle nastavena na true,
     * v lokĂˇlnĂ­m vĂ˝voji nebo testech mĹŻĹľe bĂ˝t nastavena na false.
     */
    @Value("${sms.enabled:true}")
    private boolean smsEnabled;

    /**
     * URL endpointu TextBee API.
     *
     * PouĹľĂ­vĂˇ se jako cĂ­lovĂˇ adresa pro HTTP POST poĹľadavky
     * pĹ™i odesĂ­lĂˇnĂ­ SMS zprĂˇv.
     */
    @Value("${textbee.api-url}")
    private String apiUrl;

    /**
     * API klĂ­ÄŤ pro autentizaci vĹŻÄŤi sluĹľbÄ› TextBee.
     *
     * KlĂ­ÄŤ se odesĂ­lĂˇ v HTTP hlaviÄŤce kaĹľdĂ©ho poĹľadavku
     * a slouĹľĂ­ k autorizaci aplikace vĹŻÄŤi externĂ­ sluĹľbÄ›.
     */
    @Value("${textbee.api-key}")
    private String apiKey;

    /**
     * HTTP klient pouĹľĂ­vanĂ˝ pro komunikaci s TextBee API.
     *
     * Pro jednoduchost je instancovĂˇn pĹ™Ă­mo v tĂ©to tĹ™Ă­dÄ›.
     * V pĹ™Ă­padÄ› potĹ™eby lze tuto implementaci nahradit
     * konfigurovanĂ˝m Beanem nebo WebClientem.
     */
    private final RestTemplate restTemplate = new RestTemplate();

    /**
     * OdesĂ­lĂˇ SMS zprĂˇvu na zadanĂ© telefonnĂ­ ÄŤĂ­slo.
     *
     * Metoda nejprve ovÄ›Ĺ™uje globĂˇlnĂ­ nastavenĂ­ odesĂ­lĂˇnĂ­ SMS.
     * Pokud jsou SMS vypnutĂ©, zprĂˇva se neodesĂ­lĂˇ a udĂˇlost se pouze zaloguje.
     * Pokud jsou SMS povolenĂ©, vytvoĹ™Ă­ se HTTP POST poĹľadavek
     * a odeĹˇle se na TextBee API.
     *
     * VeĹˇkerĂ© vĂ˝jimky vzniklĂ© bÄ›hem odesĂ­lĂˇnĂ­ jsou zachyceny
     * a nejsou propagovĂˇny do vyĹˇĹˇĂ­ch vrstev aplikace.
     * OdesĂ­lĂˇnĂ­ SMS je povaĹľovĂˇno za best-effort operaci,
     * jejĂ­Ĺľ selhĂˇnĂ­ nesmĂ­ ohrozit stabilitu systĂ©mu.
     *
     * @param phoneNumber cĂ­lovĂ© telefonnĂ­ ÄŤĂ­slo pĹ™Ă­jemce
     * @param message text SMS zprĂˇvy
     */
    @Override
    public void sendSms(String phoneNumber, String message) {

        // OvÄ›Ĺ™enĂ­ globĂˇlnĂ­ho nastavenĂ­ odesĂ­lĂˇnĂ­ SMS.
        if (!smsEnabled) {
            log.info(
                    "SMS jsou globĂˇlnÄ› vypnutĂ©. ZprĂˇva nebyla odeslĂˇna. Tel: {}, msg: {}",
                    phoneNumber, message
            );

            System.out.println(
                    "SMS disabled (global), message not sent: "
                            + phoneNumber + " -> " + message
            );
            return;
        }

        // PĹ™Ă­prava HTTP hlaviÄŤek poĹľadavku.
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("x-api-key", apiKey);

        // PĹ™Ă­prava tÄ›la poĹľadavku dle specifikace TextBee API.
        Map<String, Object> body = Map.of(
                "recipients", List.of(phoneNumber),
                "message", message
        );

        HttpEntity<Map<String, Object>> request =
                new HttpEntity<>(body, headers);

        try {
            // OdeslĂˇnĂ­ HTTP POST poĹľadavku na TextBee API.
            ResponseEntity<String> response =
                    restTemplate.postForEntity(apiUrl, request, String.class);

            log.info(
                    "SMS ĂşspÄ›ĹˇnÄ› odeslĂˇna pĹ™es TextBee na {}, response: {}",
                    phoneNumber, response.getBody()
            );

            System.out.println(
                    "SMS odeslĂˇna (TextBee) na " + phoneNumber +
                            ", response: " + response.getBody()
            );

        } catch (Exception e) {
            // SelhĂˇnĂ­ odeslĂˇnĂ­ SMS nesmĂ­ ovlivnit chod aplikace.
            log.error(
                    "Chyba pĹ™i odesĂ­lĂˇnĂ­ SMS pĹ™es TextBee na {}: {}",
                    phoneNumber, e.getMessage(), e
            );

            System.err.println(
                    "Chyba pĹ™i odesĂ­lĂˇnĂ­ SMS pĹ™es TextBee na "
                            + phoneNumber + ": " + e.getMessage()
            );
        }
    }
}
