Balíček (složka): notification
Cesta: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification

Seznam souborů:
DemoModeService.java
DemoNotificationStore.java
ForgottenPasswordResetContext.java
InAppNotificationService.java
InAppNotificationServiceImpl.java
MatchTimeChangeContext.java
NotificationCleanupService.java
NotificationContext.java
NotificationPreferencesService.java
NotificationPreferencesServiceImpl.java
NotificationService.java
NotificationServiceImpl.java
package-info.java
UserActivationContext.java


-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\DemoModeService.java
-----
package cz.phsoft.hokej.models.services.notification;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

/**
 * SluĹľba, kterĂˇ poskytuje informaci, zda je aplikace v demo reĹľimu.
 *
 * Hodnota se ÄŤte z application properties:
 *   hobbyhokej.demo-mode=true/false
 *
 * Pokud nenĂ­ vlastnost nastavena, vĂ˝chozĂ­ hodnota je false.
 */
@Component
public class DemoModeService {

    private final boolean demoMode;

    public DemoModeService(
            @Value("${app.demo-mode:false}") boolean demoMode
    ) {
        this.demoMode = demoMode;
    }

    /**
     * VracĂ­ true, pokud je aplikace spuĹˇtÄ›na v demo reĹľimu.
     */
    public boolean isDemoMode() {
        return demoMode;
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\DemoNotificationStore.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.models.dto.DemoNotificationsDTO;
import cz.phsoft.hokej.models.dto.DemoNotificationsDTO.DemoEmailDTO;
import cz.phsoft.hokej.models.dto.DemoNotificationsDTO.DemoSmsDTO;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;

/**
 * ĂšloĹľiĹˇtÄ› notifikacĂ­ pro DEMO reĹľim.
 *
 * Pokud je aplikace spuĹˇtÄ›na v demo mĂłdu,
 * e-maily a SMS se neodesĂ­lajĂ­, ale uklĂˇdajĂ­
 * se do tĂ©to tĹ™Ă­dy a nĂˇslednÄ› vracĂ­ na frontend.
 *
 * Data jsou drĹľena pouze v pamÄ›ti.
 */
@Component
public class DemoNotificationStore {

    private final List<DemoEmailDTO> emails = new ArrayList<>();
    private final List<DemoSmsDTO> sms = new ArrayList<>();

    /**
     * PĹ™idĂˇ e-mail do demo ĂşloĹľiĹˇtÄ›.
     */
    public synchronized void addEmail(String to,
                                      String subject,
                                      String body,
                                      boolean html,
                                      NotificationType type,
                                      String recipientKind) {

        emails.add(new DemoEmailDTO(
                to,
                subject,
                body,
                html,
                type,
                recipientKind
        ));
    }

    /**
     * PĹ™idĂˇ SMS do demo ĂşloĹľiĹˇtÄ›.
     */
    public synchronized void addSms(String to,
                                    String text,
                                    NotificationType type) {

        sms.add(new DemoSmsDTO(
                to,
                text,
                type
        ));
    }

    /**
     * VrĂˇtĂ­ vĹˇechny notifikace a nĂˇslednÄ› je vymaĹľe.
     */
    public synchronized DemoNotificationsDTO getAndClear() {

        DemoNotificationsDTO dto = new DemoNotificationsDTO(
                new ArrayList<>(emails),
                new ArrayList<>(sms)
        );

        emails.clear();
        sms.clear();

        return dto;
    }

    /**
     * RuÄŤnÄ› vyÄŤistĂ­ ĂşloĹľiĹˇtÄ› bez vrĂˇcenĂ­ dat.
     */
    public synchronized void clear() {
        emails.clear();
        sms.clear();
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\ForgottenPasswordResetContext.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.AppUserEntity;

/**
 * Kontext pro notifikace souvisejĂ­cĂ­ se zapomenutĂ˝m heslem.
 *
 * Obsahuje:
 * - uĹľivatele, kterĂ©ho se reset tĂ˝kĂˇ,
 * - odkaz pro nastavenĂ­ novĂ©ho hesla.
 *
 * SlouĹľĂ­ k pĹ™enesenĂ­ potĹ™ebnĂ˝ch ĂşdajĹŻ do builderu notifikacĂ­
 * (email, SMS) bez nutnosti pracovat pĹ™Ă­mo s entitami na vyĹˇĹˇĂ­ Ăşrovni.
 * @param user UĹľivatel, kterĂ©mu je reset hesla urÄŤen.
 * @param resetLink JednorĂˇzovĂ˝ odkaz pro zmÄ›nu hesla.
 */
public record ForgottenPasswordResetContext(
        AppUserEntity user,
        String resetLink
) {
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\InAppNotificationService.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.NotificationType;

/**
 * Servis pro uklĂˇdĂˇnĂ­ aplikaÄŤnĂ­ch (in-app) notifikacĂ­ do databĂˇze.
 *
 * SlouĹľĂ­ jako doplnÄ›k k NotificationService, kterĂ© Ĺ™eĹˇĂ­ e-mail
 * a SMS notifikace. Tento servis vytvĂˇĹ™Ă­ zjednoduĹˇenĂ© notifikace
 * pro zobrazenĂ­ v UI (badge, pĹ™ehled poslednĂ­ch udĂˇlostĂ­).
 */
public interface InAppNotificationService {

    /**
     * UloĹľĂ­ notifikaci souvisejĂ­cĂ­ s hrĂˇÄŤem.
     *
     * Typicky se pouĹľĂ­vĂˇ z notifyPlayer a vytvĂˇĹ™Ă­ notifikaci
     * pro uĹľivatele vlastnĂ­cĂ­ho hrĂˇÄŤe.
     *
     * @param player  hrĂˇÄŤ, kterĂ©ho se notifikace tĂ˝kĂˇ
     * @param type    typ notifikace
     * @param context volitelnĂ˝ kontext pro sestavenĂ­ textu
     */
    void storeForPlayer(PlayerEntity player, NotificationType type, Object context);

    /**
     * UloĹľĂ­ notifikaci souvisejĂ­cĂ­ s uĹľivatelem.
     *
     * Typicky se pouĹľĂ­vĂˇ z notifyUser a vytvĂˇĹ™Ă­ notifikaci
     * pĹ™Ă­mo pro danĂ©ho uĹľivatele.
     *
     * @param user    uĹľivatel, kterĂ©ho se notifikace tĂ˝kĂˇ
     * @param type    typ notifikace
     * @param context volitelnĂ˝ kontext pro sestavenĂ­ textu
     */
    void storeForUser(AppUserEntity user, NotificationType type, Object context);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\InAppNotificationServiceImpl.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.NotificationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.data.repositories.NotificationRepository;
import cz.phsoft.hokej.models.services.email.EmailMessageBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.time.Clock;
import java.time.Instant;

/**
 * Implementace sluĹľby pro uklĂˇdĂˇnĂ­ aplikaÄŤnĂ­ch notifikacĂ­.
 *
 * TĹ™Ă­da neĹ™eĹˇĂ­ odesĂ­lĂˇnĂ­ e-mailĹŻ ani SMS. VytvĂˇĹ™Ă­ pouze
 * zjednoduĹˇenĂ© notifikace v databĂˇzi pro zobrazenĂ­ v UI.
 */
@Service
public class InAppNotificationServiceImpl implements InAppNotificationService {

    private static final Logger log = LoggerFactory.getLogger(InAppNotificationServiceImpl.class);

    private final NotificationRepository notificationRepository;
    private final EmailMessageBuilder emailMessageBuilder;
    private final Clock clock;

    public InAppNotificationServiceImpl(NotificationRepository notificationRepository,
                                        EmailMessageBuilder emailMessageBuilder,
                                        Clock clock) {
        this.notificationRepository = notificationRepository;
        this.emailMessageBuilder = emailMessageBuilder;
        this.clock = clock;
    }

    @Override
    public void storeForPlayer(PlayerEntity player,
                               NotificationType type,
                               Object context) {

        if (player == null) {
            log.debug("InAppNotificationService.storeForPlayer: player is null, nic se neuklĂˇdĂˇ");
            return;
        }

        AppUserEntity owner = player.getUser();
        if (owner == null) {
            log.debug("InAppNotificationService.storeForPlayer: player {} nemĂˇ pĹ™iĹ™azenĂ©ho uĹľivatele, nic se neuklĂˇdĂˇ",
                    player.getId());
            return;
        }

        String messageShort = buildShortMessageForPlayer(type, player, context);
        String messageFull = null; // lze doplnit pozdÄ›ji, pokud bude potĹ™eba

        NotificationEntity entity = new NotificationEntity();
        entity.setUser(owner);
        entity.setPlayer(player);
        entity.setType(type);
        entity.setMessageShort(messageShort);
        entity.setMessageFull(messageFull);
        entity.setCreatedAt(Instant.now(clock));

        notificationRepository.save(entity);

        log.debug("InAppNotificationService.storeForPlayer: uloĹľena notifikace type={} userId={} playerId={}",
                type, owner.getId(), player.getId());
    }

    @Override
    public void storeForUser(AppUserEntity user,
                             NotificationType type,
                             Object context) {

        if (user == null) {
            log.debug("InAppNotificationService.storeForUser: user is null, nic se neuklĂˇdĂˇ");
            return;
        }

        String messageShort = buildShortMessageForUser(type, user, context);
        String messageFull = null;

        NotificationEntity entity = new NotificationEntity();
        entity.setUser(user);
        entity.setType(type);
        entity.setMessageShort(messageShort);
        entity.setMessageFull(messageFull);
        entity.setCreatedAt(Instant.now(clock));

        notificationRepository.save(entity);

        log.debug("InAppNotificationService.storeForUser: uloĹľena notifikace type={} userId={}",
                type, user.getId());
    }

    /**
     * VytvĂˇĹ™Ă­ struÄŤnĂ˝ text notifikace pro hrĂˇÄŤe.
     *
     * PrimĂˇrnÄ› se pouĹľĂ­vĂˇ pĹ™edmÄ›t e-mailu. Pokud nenĂ­ k dispozici,
     * pouĹľije se fallback s nĂˇzvem typu.
     */
    private String buildShortMessageForPlayer(NotificationType type,
                                              PlayerEntity player,
                                              Object context) {
        try {
            // E-mail nepotĹ™ebujeme odeslat, staÄŤĂ­ pouĹľĂ­t Ĺˇablonu pro subject.
            EmailMessageBuilder.EmailContent content =
                    emailMessageBuilder.buildForPlayer(type, player, null, context);

            if (content != null && content.subject() != null && !content.subject().isBlank()) {
                return content.subject();
            }
        } catch (Exception ex) {
            log.debug("buildShortMessageForPlayer: chyba pĹ™i sestavovĂˇnĂ­ subjectu pro type {}: {}",
                    type, ex.getMessage());
        }

        return type.name();
    }

    /**
     * VytvĂˇĹ™Ă­ struÄŤnĂ˝ text notifikace pro uĹľivatele.
     *
     * PrimĂˇrnÄ› se pouĹľĂ­vĂˇ pĹ™edmÄ›t e-mailu. Pokud nenĂ­ k dispozici,
     * pouĹľije se fallback s nĂˇzvem typu.
     */
    private String buildShortMessageForUser(NotificationType type,
                                            AppUserEntity user,
                                            Object context) {
        try {
            String email = user.getEmail();
            EmailMessageBuilder.EmailContent content =
                    emailMessageBuilder.buildForUser(type, null, email, context);

            if (content != null && content.subject() != null && !content.subject().isBlank()) {
                return content.subject();
            }
        } catch (Exception ex) {
            log.debug("buildShortMessageForUser: chyba pĹ™i sestavovĂˇnĂ­ subjectu pro type {}: {}",
                    type, ex.getMessage());
        }

        return type.name();
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\MatchTimeChangeContext.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.MatchEntity;

import java.time.LocalDateTime;

/**
 * Kontext pro notifikace souvisejĂ­cĂ­ se zmÄ›nou termĂ­nu zĂˇpasu.
 *
 * OdpovÄ›dnost:
 * Tento kontext se pouĹľĂ­vĂˇ pĹ™i vytvĂˇĹ™enĂ­ notifikacĂ­, kterĂ© informujĂ­ hrĂˇÄŤe
 * o zmÄ›nÄ› ÄŤasu konĂˇnĂ­ konkrĂ©tnĂ­ho zĂˇpasu. UchovĂˇvĂˇ odkaz na danĂ˝ zĂˇpas
 * a pĹŻvodnĂ­ ÄŤas zahĂˇjenĂ­, aby mohla bĂ˝t v notifikaÄŤnĂ­ch textech
 * srozumitelnÄ› popsĂˇna zmÄ›na termĂ­nu.
 *
 * Vazby:
 * Kontext se pouĹľĂ­vĂˇ v notifikaÄŤnĂ­m subsystĂ©mu pĹ™i generovĂˇnĂ­ textĹŻ
 * emailovĂ˝ch nebo SMS zprĂˇv.
 *
 * @param match ZĂˇpas, jehoĹľ termĂ­n se mÄ›nĂ­.
 * @param oldDateTime PĹŻvodnĂ­ datum a ÄŤas konĂˇnĂ­ zĂˇpasu pĹ™ed zmÄ›nou.
 */
public record MatchTimeChangeContext(
        MatchEntity match,
        LocalDateTime oldDateTime
) {
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\NotificationCleanupService.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.NotificationEntity;
import cz.phsoft.hokej.data.repositories.NotificationRepository;
import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.time.Clock;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;

@Service
public class NotificationCleanupService {

    private final NotificationRepository notificationRepository;
    private final Clock clock;

    @Value("${app.notifications.retention-days:14}")
    private long retentionDays;

    @Value("${app.notifications.min-per-user:10}")
    private int minPerUser;

    public NotificationCleanupService(NotificationRepository notificationRepository,
                                      Clock clock) {
        this.notificationRepository = notificationRepository;
        this.clock = clock;
    }

    @Scheduled(cron = "0 30 3 * * *")
    @Transactional
    public void cleanupOldNotifications() {

        Instant cutoff = Instant.now(clock)
                .minus(retentionDays, ChronoUnit.DAYS);

        List<NotificationEntity> oldNotifications =
                notificationRepository
                        .findByCreatedAtBeforeOrderByUserIdAscCreatedAtDesc(cutoff);

        if (oldNotifications.isEmpty()) {
            return;
        }

        Long currentUserId = null;
        int counterForUser = 0;

        List<NotificationEntity> toDelete = new ArrayList<>();

        for (NotificationEntity n : oldNotifications) {

            Long userId = n.getUser().getId();

            // novĂ˝ uĹľivatel
            if (!userId.equals(currentUserId)) {
                currentUserId = userId;
                counterForUser = 0;
            }

            counterForUser++;

            // pokud jsme nad limitem â†’ oznaÄŤĂ­me ke smazĂˇnĂ­
            if (counterForUser > minPerUser) {
                toDelete.add(n);
            }
        }

        if (!toDelete.isEmpty()) {
            notificationRepository.deleteAll(toDelete);
        }
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\NotificationContext.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;

/**
 * TypovĂ˝ kontejner pro notifikaÄŤnĂ­ data.
 *
 * SlouĹľĂ­ k pĹ™edĂˇnĂ­ vĹˇech relevantnĂ­ch dat do builderĹŻ notifikacĂ­
 * (email a SMS). UmoĹľĹuje sjednotit vstupnĂ­ parametry tak,
 * aby jednotlivĂ© buildery nemusely pracovat s mnoĹľstvĂ­m
 * volnĂ˝ch parametrĹŻ.
 *
 * Typicky obsahuje:
 * - hrĂˇÄŤe, kterĂ©ho se notifikace tĂ˝kĂˇ,
 * - uĹľivatele, ke kterĂ©mu hrĂˇÄŤ patĹ™Ă­,
 * - zĂˇpas, k nÄ›muĹľ se udĂˇlost vztahuje,
 * - konkrĂ©tnĂ­ registraci, pokud je relevantnĂ­.
 */
public class NotificationContext {

    private final PlayerEntity player;
    private final AppUserEntity user;
    private final MatchEntity match;
    private final MatchRegistrationEntity registration;

    private NotificationContext(Builder b) {
        this.player = b.player;
        this.user = b.user;
        this.match = b.match;
        this.registration = b.registration;
    }

    public PlayerEntity getPlayer() {
        return player;
    }

    public AppUserEntity getUser() {
        return user;
    }

    public MatchEntity getMatch() {
        return match;
    }

    public MatchRegistrationEntity getRegistration() {
        return registration;
    }

    // Builder tĹ™Ă­dy

    /**
     * Builder pro vytvoĹ™enĂ­ instance NotificationContext.
     *
     * UmoĹľĹuje postupnĂ© sklĂˇdĂˇnĂ­ kontextu podle potĹ™eby
     * konkrĂ©tnĂ­ notifikace.
     */
    public static class Builder {
        private PlayerEntity player;
        private AppUserEntity user;
        private MatchEntity match;
        private MatchRegistrationEntity registration;

        public Builder player(PlayerEntity player) {
            this.player = player;
            return this;
        }

        public Builder user(AppUserEntity user) {
            this.user = user;
            return this;
        }

        public Builder match(MatchEntity match) {
            this.match = match;
            return this;
        }

        public Builder registration(MatchRegistrationEntity registration) {
            this.registration = registration;
            return this;
        }

        public NotificationContext build() {
            return new NotificationContext(this);
        }
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\NotificationPreferencesService.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.models.services.NotificationDecision;

/**
 * SluĹľba pro vyhodnocenĂ­ notifikaÄŤnĂ­ch preferencĂ­.
 *
 * Na zĂˇkladÄ›:
 * - nastavenĂ­ uĹľivatele (AppUserSettings),
 * - nastavenĂ­ hrĂˇÄŤe (PlayerSettings),
 * - typu notifikace (NotificationType)
 *
 * rozhoduje, komu a jak mĂˇ bĂ˝t notifikace doruÄŤena.
 * NemĂˇ na starosti samotnĂ© odesĂ­lĂˇnĂ­ e-mailĹŻ nebo SMS,
 * pouze dodĂˇvĂˇ rozhodnutĂ­ pro dalĹˇĂ­ notifikaÄŤnĂ­ logiku.
 */
public interface NotificationPreferencesService {

    /**
     * Na zĂˇkladÄ› hrĂˇÄŤe a typu notifikace rozhodne,
     * kam mĂˇ bĂ˝t zprĂˇva poslĂˇna.
     *
     * VĂ˝stupem je objekt NotificationDecision, kterĂ˝ urÄŤuje,
     * zda se mĂˇ poslat e-mail hrĂˇÄŤi, e-mail uĹľivateli,
     * SMS hrĂˇÄŤi a jakĂ© kontakty se majĂ­ pouĹľĂ­t.
     *
     * @param player hrĂˇÄŤ, kterĂ©ho se notifikace tĂ˝kĂˇ
     * @param type   typ notifikace
     * @return rozhodnutĂ­, komu a kam poslat
     */
    NotificationDecision evaluate(PlayerEntity player,
                                  NotificationType type);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\NotificationPreferencesServiceImpl.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.AppUserSettingsEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerSettingsEntity;
import cz.phsoft.hokej.data.enums.GlobalNotificationLevel;
import cz.phsoft.hokej.data.enums.NotificationCategory;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.models.services.NotificationDecision;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

/**
 * Implementace NotificationPreferencesService.
 *
 * SluĹľba vyhodnocuje:
 * - nastavenĂ­ hrĂˇÄŤe (PlayerSettingsEntity),
 * - nastavenĂ­ uĹľivatele (AppUserSettingsEntity),
 * - globĂˇlnĂ­ ĂşroveĹ notifikacĂ­ uĹľivatele (GlobalNotificationLevel),
 * - kategorii a dĹŻleĹľitost notifikace (NotificationCategory, NotificationType).
 *
 * VĂ˝sledkem je NotificationDecision, kterĂ© definuje,
 * komu a jakĂ˝mi kanĂˇly bude notifikace doruÄŤena.
 */
@Service
public class NotificationPreferencesServiceImpl implements NotificationPreferencesService {

    @Override
    public NotificationDecision evaluate(PlayerEntity player,
                                         NotificationType type) {

        NotificationDecision decision = new NotificationDecision();

        if (player == null || type == null) {
            return decision;
        }

        PlayerSettingsEntity playerSettings = player.getSettings();
        AppUserEntity user = player.getUser();
        AppUserSettingsEntity userSettings = (user != null ? user.getSettings() : null);

        // ZdrojovĂ© kontakty

        // Email hrĂˇÄŤe â€“ preferuje se PlayerSettings.contactEmail,
        // pĹ™Ă­padnÄ› se pouĹľije email uĹľivatele, pokud je to vhodnĂ©.
        String playerEmail = null;
        if (playerSettings != null && StringUtils.hasText(playerSettings.getContactEmail())) {
            playerEmail = playerSettings.getContactEmail();
        } else if (user != null && StringUtils.hasText(user.getEmail())) {
            // Fallback: pokud hrĂˇÄŤ nemĂˇ vlastnĂ­ e-mail, lze pouĹľĂ­t e-mail uĹľivatele.
            playerEmail = user.getEmail();
        }

        // Email uĹľivatele (ĂşÄŤtu).
        String userEmail = (user != null ? user.getEmail() : null);

        // Telefon hrĂˇÄŤe â€“ preferuje se PlayerSettings.contactPhone,
        // fallback je pĹ™Ă­padnĂ˝ phoneNumber na PlayerEntity.
        String playerPhone = null;
        if (playerSettings != null && StringUtils.hasText(playerSettings.getContactPhone())) {
            playerPhone = playerSettings.getContactPhone();
        } else if (StringUtils.hasText(player.getPhoneNumber())) {
            playerPhone = player.getPhoneNumber();
        }

        // GlobĂˇlnĂ­ nastavenĂ­ uĹľivatele

        GlobalNotificationLevel globalLevel =
                (userSettings != null && userSettings.getGlobalNotificationLevel() != null)
                        ? userSettings.getGlobalNotificationLevel()
                        : GlobalNotificationLevel.ALL;

        // Zda globĂˇlnĂ­ ĂşroveĹ vĹŻbec povoluje tento konkrĂ©tnĂ­ NotificationType.
        boolean userGlobalAllowsThisType = isGloballyEnabledForType(type, globalLevel);

        boolean copyAllToUserEmail =
                userSettings == null || userSettings.isCopyAllPlayerNotificationsToUserEmail();

        boolean includePlayersWithOwnEmail =
                userSettings != null && userSettings.isReceiveNotificationsForPlayersWithOwnEmail();

        // NastavenĂ­ hrĂˇÄŤe â€“ povolenĂ© kanĂˇly a kategorie

        boolean emailChannelEnabled = (playerSettings == null) || playerSettings.isEmailEnabled();
        boolean smsChannelEnabled = (playerSettings != null) && playerSettings.isSmsEnabled();

        // Zda je kategorie notifikace povolena pro hrĂˇÄŤe.
        boolean categoryEnabledForPlayer = isCategoryEnabledForPlayer(type, playerSettings);

        // RozhodovĂˇnĂ­ podle kategorie notifikace

        NotificationCategory category = type.getCategory();

        switch (category) {

            // SystĂ©movĂ© typy â€“ primĂˇrnÄ› smÄ›Ĺ™ujĂ­ na ĂşÄŤet (user.email).
            case SYSTEM -> {
                if (user != null
                        && StringUtils.hasText(userEmail)
                        && userGlobalAllowsThisType) {

                    decision.setSendEmailToUser(true);
                    decision.setUserEmail(userEmail);
                }
            }

            // Registrace, omluvy, zĂˇpasovĂ© informace.
            case REGISTRATION, MATCH_INFO -> {

                // E-mail hrĂˇÄŤi.
                if (emailChannelEnabled
                        && categoryEnabledForPlayer
                        && StringUtils.hasText(playerEmail)) {

                    decision.setSendEmailToPlayer(true);
                    decision.setPlayerEmail(playerEmail);
                }

                // SMS hrĂˇÄŤi.
                if (smsChannelEnabled
                        && categoryEnabledForPlayer
                        && StringUtils.hasText(playerPhone)) {

                    decision.setSendSmsToPlayer(true);
                    decision.setPlayerPhone(playerPhone);
                }

                // E-mail uĹľivateli jako kopie.
                if (user != null
                        && StringUtils.hasText(userEmail)
                        && userGlobalAllowsThisType
                        && copyAllToUserEmail
                        && (includePlayersWithOwnEmail || !hasOwnPlayerEmail(playerSettings))) {

                    // UĹľivatel dostane kopii, pokud:
                    // - chce kopie (copyAllToUserEmail),
                    // - globĂˇlnĂ­ ĂşroveĹ mu tento typ neblokuje,
                    // - a buÄŹ hrĂˇÄŤ nemĂˇ vlastnĂ­ e-mail,
                    //   nebo uĹľivatel vĂ˝slovnÄ› chce kopie i pro hrĂˇÄŤe s vlastnĂ­m e-mailem.
                    decision.setSendEmailToUser(true);
                    decision.setUserEmail(userEmail);
                }
            }

            // OstatnĂ­ kategorie se explicitnÄ› nezpracovĂˇvajĂ­.
            default -> {
                // NezpracovanĂˇ kategorie â€“ radÄ›ji neposĂ­lat nic.
            }
        }

        return decision;
    }

    /**
     * UrÄŤuje, zda globĂˇlnĂ­ nastavenĂ­ uĹľivatele povoluje danĂ˝ NotificationType.
     *
     * NONE           -> nepovoluje ĹľĂˇdnĂ© notifikace
     * ALL            -> povoluje vĹˇechny notifikace
     * IMPORTANT_ONLY -> povoluje pouze typy oznaÄŤenĂ© jako dĹŻleĹľitĂ©
     */
    private boolean isGloballyEnabledForType(NotificationType type,
                                             GlobalNotificationLevel level) {

        return switch (level) {
            case NONE -> false;
            case ALL -> true;
            case IMPORTANT_ONLY -> type.isImportant();
        };
    }

    /**
     * ZjistĂ­, zda je kategorie notifikace povolena pro danĂ©ho hrĂˇÄŤe.
     *
     * Pokud playerSettings == null, bere se vĂ˝chozĂ­ chovĂˇnĂ­:
     * vĹˇechny kategorie jsou povoleny.
     */
    private boolean isCategoryEnabledForPlayer(NotificationType type,
                                               PlayerSettingsEntity playerSettings) {

        if (playerSettings == null) {
            return true;
        }

        return switch (type.getCategory()) {
            case REGISTRATION -> playerSettings.isRegistrationNotificationsEnabled();
            case MATCH_INFO   -> playerSettings.isMatchInfoNotificationsEnabled();
            case SYSTEM       -> playerSettings.isSystemNotificationsEnabled();
        };
    }

    /**
     * ZjistĂ­, zda mĂˇ hrĂˇÄŤ vlastnĂ­ e-mail v PlayerSettings (contactEmail).
     *
     * PouĹľĂ­vĂˇ se pĹ™i rozhodovĂˇnĂ­, zda posĂ­lat kopii na e-mail uĹľivatele.
     */
    private boolean hasOwnPlayerEmail(PlayerSettingsEntity playerSettings) {
        return playerSettings != null && StringUtils.hasText(playerSettings.getContactEmail());
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\NotificationService.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.NotificationType;

/**
 * RozhranĂ­ pro odesĂ­lĂˇnĂ­ notifikacĂ­ hrĂˇÄŤĹŻm a uĹľivatelĹŻm.
 *
 * Definuje jednotnĂ˝ vstupnĂ­ bod pro notifikaÄŤnĂ­ logiku v aplikaci.
 * Implementace na zĂˇkladÄ› typu notifikace a kontextu rozhoduje,
 * jakĂ˝m kanĂˇlem a s jakĂ˝m obsahem bude pĹ™Ă­jemce informovĂˇn.
 *
 * ĂšÄŤel:
 * - centralizovat notifikaÄŤnĂ­ logiku do jednoho mĂ­sta,
 * - oddÄ›lit business udĂˇlosti od konkrĂ©tnĂ­ formy notifikace,
 * - umoĹľnit snadnĂ© rozĹˇĂ­Ĺ™enĂ­ o dalĹˇĂ­ typy notifikacĂ­ a kanĂˇly.
 *
 * Metody tohoto rozhranĂ­ se typicky volajĂ­ z business sluĹľeb
 * v reakci na konkrĂ©tnĂ­ udĂˇlosti (registrace na zĂˇpas, zmÄ›na hesla,
 * aktivace ĂşÄŤtu a podobnÄ›).
 */
public interface NotificationService {

    /**
     * OdeĹˇle notifikaci konkrĂ©tnĂ­mu hrĂˇÄŤi.
     *
     * Parametr context nese dodateÄŤnĂ© informace potĹ™ebnĂ©
     * pro sestavenĂ­ obsahu notifikace. Typicky se jednĂˇ
     * o domĂ©novou entitu nebo kontextovĂ˝ objekt souvisejĂ­cĂ­
     * s danou udĂˇlostĂ­. MĹŻĹľe bĂ˝t null u jednoduĹˇĹˇĂ­ch notifikacĂ­.
     *
     * PĹ™Ă­klady:
     * - MatchRegistrationEntity pro registraci, odhlĂˇĹˇenĂ­ a omluvu,
     * - null pro vytvoĹ™enĂ­ hrĂˇÄŤe nebo zmÄ›nu stavu.
     *
     * @param player  hrĂˇÄŤ, kterĂ©mu je notifikace urÄŤena
     * @param type    typ notifikace
     * @param context kontextovĂˇ data souvisejĂ­cĂ­ s notifikacĂ­
     */
    void notifyPlayer(PlayerEntity player, NotificationType type, Object context);

    /**
     * OdeĹˇle notifikaci konkrĂ©tnĂ­mu uĹľivateli.
     *
     * PouĹľĂ­vĂˇ se zejmĂ©na pro systĂ©movĂ© notifikace na Ăşrovni ĂşÄŤtu,
     * napĹ™Ă­klad aktivace ĂşÄŤtu, reset hesla nebo zmÄ›na hesla.
     *
     * @param user    uĹľivatel, kterĂ©mu je notifikace urÄŤena
     * @param type    typ notifikace
     * @param context kontextovĂˇ data souvisejĂ­cĂ­ s notifikacĂ­
     */
    void notifyUser(AppUserEntity user,
                    NotificationType type,
                    Object context);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\NotificationServiceImpl.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.AppUserSettingsEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.GlobalNotificationLevel;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.models.services.NotificationDecision;
import cz.phsoft.hokej.models.services.email.EmailMessageBuilder;
import cz.phsoft.hokej.models.services.email.EmailService;
import cz.phsoft.hokej.models.services.sms.SmsMessageBuilder;
import cz.phsoft.hokej.models.services.sms.SmsService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import cz.phsoft.hokej.models.services.notification.InAppNotificationService;

import java.util.EnumSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;

/**
 * Implementace NotificationService.
 *
 * ZajiĹˇĹĄuje:
 * - pouĹľitĂ­ NotificationPreferencesService pro rozhodnutĂ­, komu notifikaci poslat,
 * - sestavenĂ­ obsahu zprĂˇv pomocĂ­ EmailMessageBuilder a SmsMessageBuilder,
 * - odesĂ­lĂˇnĂ­ e-mailĹŻ pomocĂ­ EmailService,
 * - odesĂ­lĂˇnĂ­ SMS pomocĂ­ SmsService,
 * - rozesĂ­lĂˇnĂ­ kopiĂ­ vybranĂ˝ch notifikacĂ­ manaĹľerĹŻm.
 *
 * TĹ™Ă­da neĹ™eĹˇĂ­:
 * - perzistenci notifikacĂ­,
 * - detailnĂ­ business pravidla, kdy se mĂˇ notifikace vyvolat.
 */
@Service
public class NotificationServiceImpl implements NotificationService {

    private static final Logger log = LoggerFactory.getLogger(NotificationServiceImpl.class);

    private final AppUserRepository appUserRepository;
    private final EmailService emailService;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;
    private final EmailMessageBuilder emailMessageBuilder;
    private final NotificationPreferencesService notificationPreferencesService;
    private final InAppNotificationService inAppNotificationService;

    // demo reĹľim a ĂşloĹľiĹˇtÄ› notifikacĂ­ pro demo
    private final DemoModeService demoModeService;
    private final DemoNotificationStore demoNotificationStore;


    /**
     * Typy notifikacĂ­, pro kterĂ© se nemĂˇ posĂ­lat kopie manaĹľerĹŻm.
     * PlatĂ­ jak pro notifyPlayer, tak pro notifyUser.
     */
    private static final Set<NotificationType> MANAGER_COPY_BLACKLIST = EnumSet.of(
            NotificationType.MATCH_CANCELED,
            NotificationType.MATCH_TIME_CHANGED,
            NotificationType.MATCH_UNCANCELED,
            NotificationType.MATCH_REMINDER
    );

    public NotificationServiceImpl(
            AppUserRepository appUserRepository,
            EmailService emailService,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder,
            EmailMessageBuilder emailMessageBuilder,
            NotificationPreferencesService notificationPreferencesService,
            DemoModeService demoModeService,
            DemoNotificationStore demoNotificationStore,
            InAppNotificationService inAppNotificationService
    ) {
        this.appUserRepository = appUserRepository;
        this.emailService = emailService;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
        this.emailMessageBuilder = emailMessageBuilder;
        this.notificationPreferencesService = notificationPreferencesService;
        this.demoModeService = demoModeService;
        this.demoNotificationStore = demoNotificationStore;
        this.inAppNotificationService = inAppNotificationService;
    }

    @Override
    public void notifyPlayer(PlayerEntity player,
                             NotificationType type,
                             Object context) {

        if (player == null) {
            log.warn("notifyPlayer() called with null player for type {}", type);
            return;
        }

        NotificationDecision decision = notificationPreferencesService.evaluate(player, type);
        log.info("notifyPlayer decision: type={}, playerId={}, sendUserEmail={}, sendPlayerEmail={}, sendSms={}",
                type, player.getId(),
                decision.isSendEmailToUser(),
                decision.isSendEmailToPlayer(),
                decision.isSendSmsToPlayer()
        );

        // E-mail pro uĹľivatele (AppUser).
        if (decision.isSendEmailToUser() && decision.getUserEmail() != null) {
            sendEmailToUser(decision.getUserEmail(), player, type, context);
        }

        // E-mail pro hrĂˇÄŤe.
        if (decision.isSendEmailToPlayer() && decision.getPlayerEmail() != null) {
            sendEmailToPlayer(decision.getPlayerEmail(), player, type, context);
        }

        // SMS pro hrĂˇÄŤe.
        if (decision.isSendSmsToPlayer() && decision.getPlayerPhone() != null) {
            sendSmsToPhone(decision.getPlayerPhone(), player, type, context);
        }

        // E-mail pro manaĹľery (kopie zprĂˇv pro hrĂˇÄŤe), pokud typ nenĂ­ v blacklistu.
        if (shouldSendManagerCopy(type)) {

            List<AppUserEntity> managers = appUserRepository.findAll().stream()
                    .filter(m -> m.getRole() == Role.ROLE_MANAGER)
                    .toList();

            AppUserEntity owner = player.getUser(); // uĹľivatel, kterĂ©mu hrĂˇÄŤ patĹ™Ă­

            for (AppUserEntity manager : managers) {
                if (manager == null || manager.getEmail() == null || manager.getEmail().isBlank()) {
                    continue;
                }

                // NeposĂ­lat, pokud je manaĹľer zĂˇroveĹ vlastnĂ­kem hrĂˇÄŤe.
                if (owner != null && owner.getId() != null
                        && Objects.equals(manager.getId(), owner.getId())) {
                    log.debug("Manager {} je zĂˇroveĹ vlastnĂ­kem hrĂˇÄŤe {} â€“ kopie se neposĂ­lĂˇ (notifyPlayer).",
                            manager.getId(), player.getId());
                    continue;
                }

                String managerEmail = manager.getEmail();

                // NeposĂ­lat, pokud manaĹľer uĹľ dostane e-mail jako USER nebo PLAYER (stejnĂ˝ e-mail).
                if (Objects.equals(managerEmail, decision.getUserEmail())
                        || Objects.equals(managerEmail, decision.getPlayerEmail())) {
                    log.debug("Manager {} mĂˇ stejnĂ˝ e-mail jako pĹ™Ă­jemce (USER/PLAYER) â€“ kopie se neposĂ­lĂˇ (notifyPlayer).",
                            manager.getId());
                    continue;
                }

                // FiltrovĂˇnĂ­ podle manaĹľerskĂ©ho nastavenĂ­ notifikacĂ­.
                if (!isManagerCopyAllowedForManager(type, manager)) {
                    log.debug("Manager {} mĂˇ nastavenou ĂşroveĹ manaĹľerskĂ˝ch notifikacĂ­, pro typ {} se kopie neposĂ­lĂˇ (notifyPlayer).",
                            manager.getId(), type);
                    continue;
                }

                sendEmailToManager(manager, player, type, context);
            }
        } else {
            log.debug("Typ {} je v MANAGER_COPY_BLACKLIST â€“ kopie manaĹľerĹŻm se neposĂ­lĂˇ (notifyPlayer).", type);
        }
        inAppNotificationService.storeForPlayer(player, type, context);
    }

    @Override
    public void notifyUser(AppUserEntity user,
                           NotificationType type,
                           Object context) {

        if (user == null) {
            log.warn("notifyUser() called with null user for type {}", type);
            return;
        }

        Object effectiveContext = (context != null) ? context : user;

        // E-mail pro uĹľivatele.
        String userEmail = user.getEmail();

        if (userEmail != null && !userEmail.isBlank()) {

            // Player je null, user se pĹ™Ă­padnÄ› pĹ™edĂˇ v kontextu.
            EmailMessageBuilder.EmailContent content =
                    emailMessageBuilder.buildForUser(type, null, userEmail, effectiveContext);

            if (content != null) {
                // DEMO reĹľim â€“ mĂ­sto odeslĂˇnĂ­ uloĹľĂ­me do DemoNotificationStore
                if (demoModeService.isDemoMode()) {
                    // DEMO CHANGED: pouĹľĂ­vĂˇme novou signaturu addEmail(...)
                    demoNotificationStore.addEmail(
                            userEmail,
                            content.subject(),
                            content.body(),
                            content.html(),
                            type,
                            "USER"
                    );
                    log.debug("DEMO MODE: notifyUser e-mail USER uloĹľen do DemoNotificationStore, nic se neodesĂ­lĂˇ");
                    // KONEC DEMO
                } else {
                    if (content.html()) {
                        emailService.sendHtmlEmail(userEmail, content.subject(), content.body());
                    } else {
                        emailService.sendSimpleEmail(userEmail, content.subject(), content.body());
                    }
                }

            } else {
                log.debug("Typ {} nemĂˇ definovanou e-mailovou Ĺˇablonu pro uĹľivatele (USER), nic se neposĂ­lĂˇ", type);
            }
        } else {
            log.debug("notifyUser: uĹľivatel {} nemĂˇ e-mail, nic se neposĂ­lĂˇ", user.getId());
        }

        // E-mail pro manaĹľery.
        if (shouldSendManagerCopy(type)) {

            List<AppUserEntity> managers = appUserRepository.findAll().stream()
                    .filter(m -> m.getRole() == Role.ROLE_MANAGER)
                    .toList();

            for (AppUserEntity manager : managers) {
                if (manager == null || manager.getEmail() == null || manager.getEmail().isBlank()) {
                    continue;
                }

                // NeposĂ­lat, pokud je manaĹľer zĂˇroveĹ tento uĹľivatel.
                if (user.getId() != null && Objects.equals(manager.getId(), user.getId())) {
                    log.debug("Manager {} je zĂˇroveĹ adresĂˇtem (USER) â€“ kopie se neposĂ­lĂˇ (notifyUser).",
                            manager.getId());
                    continue;
                }

                String managerEmail = manager.getEmail();

                // NeposĂ­lat, pokud mĂˇ manaĹľer stejnĂ˝ e-mail jako uĹľivatel.
                if (Objects.equals(managerEmail, userEmail)) {
                    log.debug("Manager {} mĂˇ stejnĂ˝ e-mail jako uĹľivatel â€“ kopie se neposĂ­lĂˇ (notifyUser).",
                            manager.getId());
                    continue;
                }

                // FiltrovĂˇnĂ­ podle manaĹľerskĂ©ho nastavenĂ­ notifikacĂ­.
                if (!isManagerCopyAllowedForManager(type, manager)) {
                    log.debug("Manager {} mĂˇ nastavenou ĂşroveĹ manaĹľerskĂ˝ch notifikacĂ­, pro typ {} se kopie neposĂ­lĂˇ (notifyUser).",
                            manager.getId(), type);
                    continue;
                }

                EmailMessageBuilder.EmailContent managerContent =
                        emailMessageBuilder.buildForManager(type, null, manager, effectiveContext);

                if (managerContent == null) {
                    log.debug("Typ {} nemĂˇ definovanou e-mailovou Ĺˇablonu pro manaĹľera (USER), nic se neposĂ­lĂˇ", type);
                    continue;
                }


                if (demoModeService.isDemoMode()) {

                    demoNotificationStore.addEmail(
                            managerEmail,
                            managerContent.subject(),
                            managerContent.body(),
                            managerContent.html(),
                            type,
                            "MANAGER"
                    );
                    log.debug("DEMO MODE: notifyUser e-mail MANAGER uloĹľen do DemoNotificationStore, nic se neodesĂ­lĂˇ");
                } else {
                    if (managerContent.html()) {
                        emailService.sendHtmlEmail(managerEmail, managerContent.subject(), managerContent.body());
                    } else {
                        emailService.sendSimpleEmail(managerEmail, managerContent.subject(), managerContent.body());
                    }
                }

            }
        } else {
            log.debug("Typ {} je v MANAGER_COPY_BLACKLIST â€“ kopie manaĹľerĹŻm se neposĂ­lĂˇ (notifyUser).", type);
        }
        inAppNotificationService.storeForUser(user, type, context);
    }

    // PomocnĂ© metody pro e-mail

    private void sendEmailToManager(AppUserEntity manager,
                                    PlayerEntity player,
                                    NotificationType type,
                                    Object context) {

        if (manager == null || manager.getEmail() == null || manager.getEmail().isBlank()) {
            log.debug("sendEmailToManager: prĂˇzdnĂ˝ manager nebo e-mail, nic se neposĂ­lĂˇ");
            return;
        }

        String email = manager.getEmail();

        EmailMessageBuilder.EmailContent content =
                emailMessageBuilder.buildForManager(type, player, manager, context);

        if (content == null) {
            log.debug("Typ {} nemĂˇ definovanou e-mailovou Ĺˇablonu pro manaĹľera, nic se neposĂ­lĂˇ", type);
            return;
        }

        // DEMO reĹľim â€“ uloĹľenĂ­ do DemoNotificationStore
        if (demoModeService.isDemoMode()) {
            // DEMO CHANGED: pouĹľĂ­vĂˇme novou signaturu addEmail(...)
            demoNotificationStore.addEmail(
                    email,
                    content.subject(),
                    content.body(),
                    content.html(),
                    type,
                    "MANAGER"
            );
            log.debug("DEMO MODE: sendEmailToManager â€“ e-mail uloĹľen do DemoNotificationStore, nic se neodesĂ­lĂˇ");
            return;
        }
        // KONEC DEMO

        if (content.html()) {
            emailService.sendHtmlEmail(email, content.subject(), content.body());
        } else {
            emailService.sendSimpleEmail(email, content.subject(), content.body());
        }
    }

    private void sendEmailToUser(String email,
                                 PlayerEntity player,
                                 NotificationType type,
                                 Object context) {

        if (email == null || email.isBlank()) {
            log.debug("sendEmailToUser: prĂˇzdnĂ˝ e-mail, nic se neposĂ­lĂˇ");
            return;
        }

        EmailMessageBuilder.EmailContent content =
                emailMessageBuilder.buildForUser(type, player, email, context);

        if (content == null) {
            log.debug("Typ {} nemĂˇ definovanou e-mailovou Ĺˇablonu pro uĹľivatele, nic se neposĂ­lĂˇ", type);
            return;
        }

        // DEMO reĹľim â€“ uloĹľenĂ­ do DemoNotificationStore
        if (demoModeService.isDemoMode()) {
            // DEMO CHANGED: pouĹľĂ­vĂˇme novou signaturu addEmail(...)
            demoNotificationStore.addEmail(
                    email,
                    content.subject(),
                    content.body(),
                    content.html(),
                    type,
                    "USER"
            );
            log.debug("DEMO MODE: sendEmailToUser â€“ e-mail uloĹľen do DemoNotificationStore, nic se neodesĂ­lĂˇ");
            return;
        }
        // KONEC DEMO

        if (content.html()) {
            emailService.sendHtmlEmail(email, content.subject(), content.body());
        } else {
            emailService.sendSimpleEmail(email, content.subject(), content.body());
        }
    }

    private void sendEmailToPlayer(String email,
                                   PlayerEntity player,
                                   NotificationType type,
                                   Object context) {

        if (email == null || email.isBlank()) {
            log.debug("sendEmailToPlayer: prĂˇzdnĂ˝ e-mail, nic se neposĂ­lĂˇ");
            return;
        }

        EmailMessageBuilder.EmailContent content =
                emailMessageBuilder.buildForPlayer(type, player, email, context);

        if (content == null) {
            log.debug("Typ {} nemĂˇ definovanou e-mailovou Ĺˇablonu pro hrĂˇÄŤe, nic se neposĂ­lĂˇ", type);
            return;
        }

        // DEMO reĹľim â€“ uloĹľenĂ­ do DemoNotificationStore
        if (demoModeService.isDemoMode()) {
            // DEMO CHANGED: pouĹľĂ­vĂˇme novou signaturu addEmail(...)
            demoNotificationStore.addEmail(
                    email,
                    content.subject(),
                    content.body(),
                    content.html(),
                    type,
                    "PLAYER"
            );
            log.debug("DEMO MODE: sendEmailToPlayer â€“ e-mail uloĹľen do DemoNotificationStore, nic se neodesĂ­lĂˇ");
            return;
        }
        // KONEC DEMO

        if (content.html()) {
            emailService.sendHtmlEmail(email, content.subject(), content.body());
        } else {
            emailService.sendSimpleEmail(email, content.subject(), content.body());
        }
    }

    // SMS pomocnĂˇ metoda

    private void sendSmsToPhone(String phone,
                                PlayerEntity player,
                                NotificationType type,
                                Object context) {

        if (phone == null || phone.isBlank()) {
            log.debug("sendSmsToPhone: prĂˇzdnĂ˝ telefon â€“ SMS se nepoĹˇle (player {})", player != null ? player.getId() : null);
            return;
        }

        String msg = smsMessageBuilder.buildForNotification(type, player, context);

        if (msg == null || msg.isBlank()) {
            log.debug("Typ {} nemĂˇ definovanou SMS Ĺˇablonu nebo chybĂ­ context â€“ SMS se neposĂ­lĂˇ", type);
            return;
        }

        // DEMO reĹľim â€“ uloĹľenĂ­ do DemoNotificationStore
        if (demoModeService.isDemoMode()) {
            // DEMO CHANGED: pouĹľĂ­vĂˇme novou signaturu addSms(...)
            demoNotificationStore.addSms(
                    phone,
                    msg,
                    type
            );
            log.debug("DEMO MODE: sendSmsToPhone â€“ SMS uloĹľena do DemoNotificationStore, nic se neodesĂ­lĂˇ");
            return;
        }
        // KONEC DEMO

        smsService.sendSms(phone, msg);
    }

    /**
     * UrÄŤuje, zda se pro danĂ˝ typ notifikace majĂ­ posĂ­lat kopie manaĹľerĹŻm.
     *
     * Pokud je typ uveden v MANAGER_COPY_BLACKLIST, kopie se neposĂ­lajĂ­.
     */
    private boolean shouldSendManagerCopy(NotificationType type) {
        return !MANAGER_COPY_BLACKLIST.contains(type);
    }

    /**
     * UrÄŤuje, zda mĂˇ konkrĂ©tnĂ­ manaĹľer dostat kopii danĂ©ho typu notifikace.
     *
     * Vyhodnocuje nastavenĂ­ managerNotificationLevel na AppUserSettingsEntity.
     * Pokud nenĂ­ nastaveno, pouĹľĂ­vĂˇ se globalNotificationLevel. Pokud nenĂ­
     * k dispozici ani globĂˇlnĂ­ ĂşroveĹ, pouĹľĂ­vĂˇ se vĂ˝chozĂ­ ALL.
     */
    private boolean isManagerCopyAllowedForManager(NotificationType type,
                                                   AppUserEntity manager) {
        if (manager == null) {
            return false;
        }

        AppUserSettingsEntity settings = manager.getSettings();
        GlobalNotificationLevel level;

        if (settings == null) {
            level = GlobalNotificationLevel.ALL;
        } else if (settings.getManagerNotificationLevel() != null) {
            level = settings.getManagerNotificationLevel();
        } else if (settings.getGlobalNotificationLevel() != null) {
            level = settings.getGlobalNotificationLevel();
        } else {
            level = GlobalNotificationLevel.ALL;
        }

        return isEnabledForType(type, level);
    }

    /**
     * VyhodnotĂ­, zda je danĂ˝ typ notifikace povolen pro zvolenou ĂşroveĹ.
     *
     * NONE           znamenĂˇ, Ĺľe se notifikace neposĂ­lajĂ­.
     * ALL            znamenĂˇ, Ĺľe se posĂ­lajĂ­ vĹˇechny typy.
     * IMPORTANT_ONLY znamenĂˇ, Ĺľe se posĂ­lajĂ­ pouze dĹŻleĹľitĂ© typy.
     */
    private boolean isEnabledForType(NotificationType type,
                                     GlobalNotificationLevel level) {
        return switch (level) {
            case NONE -> false;
            case ALL -> true;
            case IMPORTANT_ONLY -> type.isImportant();
        };
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\package-info.java
-----
/**
 * NotifikaÄŤnĂ­ subsystĂ©m aplikace.
 *
 * ZajiĹˇĹĄuje rozhodovĂˇnĂ­ o odesĂ­lĂˇnĂ­ notifikacĂ­
 * a pĹ™Ă­pravu kontextu pro emailovĂ© a SMS zprĂˇvy.
 *
 * Obsahuje:
 * - rozhodovacĂ­ logiku podle typu udĂˇlosti,
 * - kontextovĂ© objekty pro generovĂˇnĂ­ zprĂˇv,
 * - vazby na emailovĂ© a SMS sluĹľby.
 *
 * NeĹ™eĹˇĂ­ samotnĂ© odesĂ­lĂˇnĂ­ zprĂˇv.
 */
package cz.phsoft.hokej.models.services.notification;

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\UserActivationContext.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.AppUserEntity;

/**
 * Kontext pro notifikace souvisejĂ­cĂ­ s aktivacĂ­ uĹľivatelskĂ©ho ĂşÄŤtu.
 *
 * Obsahuje:
 * - uĹľivatele, kterĂ˝ mĂˇ bĂ˝t aktivovĂˇn,
 * - aktivaÄŤnĂ­ odkaz pouĹľitĂ˝ v e-mailu.
 *
 * SlouĹľĂ­ k oddÄ›lenĂ­ domĂ©novĂ˝ch entit od dat potĹ™ebnĂ˝ch
 * pro sestavenĂ­ aktivaÄŤnĂ­ch notifikacĂ­.
 * @param user UĹľivatel, kterĂ©mu je aktivaÄŤnĂ­ odkaz urÄŤen.
 * @param activationLink JednorĂˇzovĂ˝ odkaz pro aktivaci ĂşÄŤtu.
 */
public record UserActivationContext(
        AppUserEntity user,
        String activationLink
) {
}
