Balíček (složka): notification
Cesta: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification

Seznam souborů:
DemoModeService.java
DemoNotificationStore.java
ForgottenPasswordResetContext.java
InAppNotificationBuilder.java
InAppNotificationService.java
InAppNotificationServiceImpl.java
MatchReminderScheduler.java
MatchTimeChangeContext.java
NoResponseReminderScheduler.java
NotificationCleanupService.java
NotificationContext.java
NotificationPreferencesService.java
NotificationPreferencesServiceImpl.java
NotificationQueryService.java
NotificationQueryServiceImpl.java
NotificationService.java
NotificationServiceImpl.java
package-info.java
SpecialNotificationService.java
SpecialNotificationServiceImpl.java
UserActivationContext.java


-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\DemoModeService.java
-----
package cz.phsoft.hokej.models.services.notification;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

/**
 * SluĹľba, kterĂˇ poskytuje informaci, zda je aplikace v demo reĹľimu.
 *
 * Hodnota se ÄŤte z application properties:
 *   hobbyhokej.demo-mode=true/false
 *
 * Pokud nenĂ­ vlastnost nastavena, vĂ˝chozĂ­ hodnota je false.
 */
@Component
public class DemoModeService {

    private final boolean demoMode;

    public DemoModeService(
            @Value("${app.demo-mode:false}") boolean demoMode
    ) {
        this.demoMode = demoMode;
    }

    /**
     * VracĂ­ true, pokud je aplikace spuĹˇtÄ›na v demo reĹľimu.
     */
    public boolean isDemoMode() {
        return demoMode;
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\DemoNotificationStore.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.models.dto.DemoNotificationsDTO;
import cz.phsoft.hokej.models.dto.DemoNotificationsDTO.DemoEmailDTO;
import cz.phsoft.hokej.models.dto.DemoNotificationsDTO.DemoSmsDTO;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;

/**
 * ĂšloĹľiĹˇtÄ› notifikacĂ­ pro DEMO reĹľim.
 *
 * Pokud je aplikace spuĹˇtÄ›na v demo mĂłdu,
 * e-maily a SMS se neodesĂ­lajĂ­, ale uklĂˇdajĂ­
 * se do tĂ©to tĹ™Ă­dy a nĂˇslednÄ› vracĂ­ na frontend.
 *
 * Data jsou drĹľena pouze v pamÄ›ti.
 */
@Component
public class DemoNotificationStore {

    private final List<DemoEmailDTO> emails = new ArrayList<>();
    private final List<DemoSmsDTO> sms = new ArrayList<>();

    /**
     * PĹ™idĂˇ e-mail do demo ĂşloĹľiĹˇtÄ›.
     */
    public synchronized void addEmail(String to,
                                      String subject,
                                      String body,
                                      boolean html,
                                      NotificationType type,
                                      String recipientKind) {

        emails.add(new DemoEmailDTO(
                to,
                subject,
                body,
                html,
                type,
                recipientKind
        ));
    }

    /**
     * PĹ™idĂˇ SMS do demo ĂşloĹľiĹˇtÄ›.
     */
    public synchronized void addSms(String to,
                                    String text,
                                    NotificationType type) {

        sms.add(new DemoSmsDTO(
                to,
                text,
                type
        ));
    }

    /**
     * VrĂˇtĂ­ vĹˇechny notifikace a nĂˇslednÄ› je vymaĹľe.
     */
    public synchronized DemoNotificationsDTO getAndClear() {

        DemoNotificationsDTO dto = new DemoNotificationsDTO(
                new ArrayList<>(emails),
                new ArrayList<>(sms)
        );

        emails.clear();
        sms.clear();

        return dto;
    }

    /**
     * RuÄŤnÄ› vyÄŤistĂ­ ĂşloĹľiĹˇtÄ› bez vrĂˇcenĂ­ dat.
     */
    public synchronized void clear() {
        emails.clear();
        sms.clear();
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\ForgottenPasswordResetContext.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.AppUserEntity;

/**
 * Kontext pro notifikace souvisejĂ­cĂ­ se zapomenutĂ˝m heslem.
 *
 * Obsahuje:
 * - uĹľivatele, kterĂ©ho se reset tĂ˝kĂˇ,
 * - odkaz pro nastavenĂ­ novĂ©ho hesla.
 *
 * SlouĹľĂ­ k pĹ™enesenĂ­ potĹ™ebnĂ˝ch ĂşdajĹŻ do builderu notifikacĂ­
 * (email, SMS) bez nutnosti pracovat pĹ™Ă­mo s entitami na vyĹˇĹˇĂ­ Ăşrovni.
 * @param user UĹľivatel, kterĂ©mu je reset hesla urÄŤen.
 * @param resetLink JednorĂˇzovĂ˝ odkaz pro zmÄ›nu hesla.
 */
public record ForgottenPasswordResetContext(
        AppUserEntity user,
        String resetLink
) {
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\InAppNotificationBuilder.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.models.services.notification.MatchTimeChangeContext;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Locale;

/**
 * Builder pro sestavovĂˇnĂ­ obsahu in-app notifikacĂ­.
 *
 * TĹ™Ă­da centralizuje texty krĂˇtkĂ˝ch zprĂˇv zobrazovanĂ˝ch v aplikaci
 * (notifikaÄŤnĂ­ badge, pĹ™ehled poslednĂ­ch udĂˇlostĂ­, panel notifikacĂ­).
 *
 * OdpovÄ›dnost tĹ™Ă­dy:
 * - sestavenĂ­ titulku a zprĂˇvy podle NotificationType,
 * - vyuĹľitĂ­ kontextu (hrĂˇÄŤ, zĂˇpas, zmÄ›na ÄŤasu) pro doplnÄ›nĂ­ detailĹŻ,
 * - udrĹľenĂ­ jednotnĂ©ho a struÄŤnĂ©ho stylu in-app textĹŻ.
 *
 * TĹ™Ă­da neĹ™eĹˇĂ­:
 * - uloĹľenĂ­ do databĂˇze,
 * - vĂ˝bÄ›r cĂ­lovĂ©ho uĹľivatele,
 * - oprĂˇvnÄ›nĂ­ ani validaci vstupĹŻ.
 */
@Component
public class InAppNotificationBuilder {

    private final MatchRegistrationRepository registrationRepository;

    public InAppNotificationBuilder(MatchRegistrationRepository registrationRepository) {
        this.registrationRepository = registrationRepository;
    }

    /**
     * DatovĂ˝ nosiÄŤ pro obsah in-app notifikace.
     *
     * @param title   krĂˇtkĂ˝ titulek notifikace
     * @param message struÄŤnĂ˝ text zprĂˇvy
     */
    public record InAppNotificationContent(String title, String message) {
    }

    /**
     * FormĂˇtovaÄŤ data a ÄŤasu zĂˇpasu pouĹľĂ­vanĂ˝ v in-app notifikacĂ­ch.
     */
    private static final DateTimeFormatter MATCH_DATETIME_FORMATTER =
            DateTimeFormatter.ofPattern("EEEE dd.MM.yyyy HH:mm", new Locale("cs", "CZ"));

    /**
     * SestavĂ­ in-app notifikaci pro danĂ˝ typ udĂˇlosti.
     *
     * PĹ™edpoklĂˇdĂˇ se, Ĺľe cĂ­lovĂ˝ AppUserEntity (uĹľivatel) je jiĹľ
     * vyĹ™eĹˇen volajĂ­cĂ­ sluĹľbou. HrĂˇÄŤ a context se pouĹľĂ­vajĂ­ pro
     * doplnÄ›nĂ­ detailĹŻ (jmĂ©no hrĂˇÄŤe, zĂˇpas, zmÄ›na ÄŤasu).
     */
    public InAppNotificationContent build(NotificationType type,
                                          AppUserEntity user,
                                          PlayerEntity player,
                                          Object context) {

        String userName = fullUserName(user);
        String playerName = fullPlayerName(player);

        MatchEntity match = extractMatch(context);
        String formattedDateTime = formatMatchDateTime(match);
        long registeredCount = countRegisteredPlayers(match);
        int maxPlayers = match != null ? match.getMaxPlayers() : 0;
        long freeSlots = maxPlayers > 0 ? (maxPlayers - registeredCount) : 0;
        String matchCancelReason = assignMatchCancelReason(match);

        MatchRegistrationEntity registration = extractMatchRegistration(context);
        String excuseReason = assignExcuseReason(registration);
        String excuseNote = (registration != null)
                ? safe(registration.getExcuseNote())
                : "";

        return switch (type) {

            // =====================================
            // PLAYER â€“ vazba hrĂˇÄŤe na uĹľivatele
            // =====================================

            case PLAYER_CREATED -> {
                String title = "HrĂˇÄŤ vytvoĹ™en";
                String message = "HrĂˇÄŤ %s byl vytvoĹ™en a ÄŤekĂˇ na schvĂˇlenĂ­ administrĂˇtorem."
                        .formatted(playerName);
                yield new InAppNotificationContent(title, message);
            }

            case PLAYER_UPDATED -> {
                String title = "HrĂˇÄŤ upraven";
                String message = "Ăšdaje hrĂˇÄŤe %s byly aktualizovĂˇny."
                        .formatted(playerName);
                yield new InAppNotificationContent(title, message);
            }

            case PLAYER_APPROVED -> {
                String title = "HrĂˇÄŤ schvĂˇlen";
                String message = "HrĂˇÄŤ %s byl schvĂˇlen administrĂˇtorem."
                        .formatted(playerName);
                yield new InAppNotificationContent(title, message);
            }

            case PLAYER_REJECTED -> {
                String title = "HrĂˇÄŤ zamĂ­tnut";
                String message = "HrĂˇÄŤ %s byl zamĂ­tnut administrĂˇtorem."
                        .formatted(playerName);
                yield new InAppNotificationContent(title, message);
            }

            case PLAYER_CHANGE_USER -> {
                String title = "HrĂˇÄŤ pĹ™iĹ™azen novĂ©mu uĹľivateli";
                String message = "HrĂˇÄŤ %s byl pĹ™iĹ™azen jinĂ©mu uĹľivatelskĂ©mu ĂşÄŤtu."
                        .formatted(playerName);
                yield new InAppNotificationContent(title, message);
            }

            // =====================================
            // USER â€“ udĂˇlosti kolem uĹľivatelskĂ©ho ĂşÄŤtu
            // =====================================

            case USER_CREATED -> {
                String title = "UĹľivatel vytvoĹ™en";
                String message = "Byl vytvoĹ™en novĂ˝ uĹľivatelskĂ˝ ĂşÄŤet pro %s."
                        .formatted(userName);
                yield new InAppNotificationContent(title, message);
            }

            case USER_ACTIVATED -> {
                String title = "ĂšÄŤet aktivovĂˇn";
                String message = "VĂˇĹˇ uĹľivatelskĂ˝ ĂşÄŤet byl ĂşspÄ›ĹˇnÄ› aktivovĂˇn.";
                yield new InAppNotificationContent(title, message);
            }

            case USER_UPDATED -> {
                String title = "ĂšÄŤet aktualizovĂˇn";
                String message = "Ăšdaje vaĹˇeho ĂşÄŤtu byly aktualizovĂˇny.";
                yield new InAppNotificationContent(title, message);
            }

            case PASSWORD_RESET -> {
                String title = "Reset hesla";
                String message = "Heslo k vaĹˇemu ĂşÄŤtu bylo resetovĂˇno.";
                yield new InAppNotificationContent(title, message);
            }

            case FORGOTTEN_PASSWORD_RESET_REQUEST -> {
                String title = "Ĺ˝Ăˇdost o obnovenĂ­ hesla";
                String message = "Byla pĹ™ijata ĹľĂˇdost o obnovenĂ­ zapomenutĂ©ho hesla k vaĹˇemu ĂşÄŤtu.";
                yield new InAppNotificationContent(title, message);
            }

            case FORGOTTEN_PASSWORD_RESET_COMPLETED -> {
                String title = "Heslo zmÄ›nÄ›no";
                String message = "Heslo k vaĹˇemu ĂşÄŤtu bylo ĂşspÄ›ĹˇnÄ› zmÄ›nÄ›no.";
                yield new InAppNotificationContent(title, message);
            }

            case SECURITY_ALERT -> {
                String title = "BezpeÄŤnostnĂ­ upozornÄ›nĂ­";
                String message = "Na vaĹˇem ĂşÄŤtu byla zaznamenĂˇna neobvyklĂˇ aktivita.";
                yield new InAppNotificationContent(title, message);
            }

            // =====================================
            // REGISTRACE NA ZĂPAS
            // =====================================

            case MATCH_REGISTRATION_CREATED -> {
                String title = "PĹ™ihlĂˇĹˇenĂ­ na zĂˇpas";
                String message = formattedDateTime.isBlank()
                        ? "Byl jste pĹ™ihlĂˇĹˇen na zĂˇpas. HrĂˇÄŤ: %s."
                        .formatted(playerName)
                        : "Byl jste pĹ™ihlĂˇĹˇen na zĂˇpas %s. HrĂˇÄŤ: %s."
                        .formatted(formattedDateTime, playerName);
                yield new InAppNotificationContent(title, message);
            }

            case MATCH_REGISTRATION_UPDATED -> {
                MatchRegistrationEntity reg =
                        castContext(context, MatchRegistrationEntity.class);
                String newStatus = reg != null && reg.getStatus() != null
                        ? reg.getStatus().name()
                        : "neznĂˇmĂ˝ stav";

                String title = "Registrace aktualizovĂˇna";
                String message = formattedDateTime.isBlank()
                        ? "VaĹˇe registrace na zĂˇpas byla zmÄ›nÄ›na (%s)."
                        .formatted(newStatus)
                        : "VaĹˇe registrace na zĂˇpas %s byla zmÄ›nÄ›na (%s)."
                        .formatted(formattedDateTime, newStatus);
                yield new InAppNotificationContent(title, message);
            }

            case MATCH_REGISTRATION_CANCELED -> {
                String title = "OdhlĂˇĹˇenĂ­ ze zĂˇpasu";
                String reasonPart = !excuseReason.isBlank()
                        ? " DĹŻvod: %s - %s.".formatted(excuseReason, excuseNote)
                        : "";
                String message = formattedDateTime.isBlank()
                        ? "Byl jste odhlĂˇĹˇen ze zĂˇpasu.%s"
                        .formatted(reasonPart)
                        : "Byl jste odhlĂˇĹˇen ze zĂˇpasu %s.%s"
                        .formatted(formattedDateTime, reasonPart);
                yield new InAppNotificationContent(title, message);
            }

            case MATCH_REGISTRATION_RESERVED -> {
                String title = "PĹ™esunut mezi nĂˇhradnĂ­ky";
                String messageBase = formattedDateTime.isBlank()
                        ? "Byl jste pĹ™esunut mezi nĂˇhradnĂ­ky pro zĂˇpas."
                        : "Byl jste pĹ™esunut mezi nĂˇhradnĂ­ky pro zĂˇpas %s."
                        .formatted(formattedDateTime);

                String capacityPart = (maxPlayers > 0)
                        ? " Kapacita zĂˇpasu: %d hrĂˇÄŤĹŻ.".formatted(maxPlayers)
                        : "";

                String message = messageBase + capacityPart;
                yield new InAppNotificationContent(title, message);
            }

            case MATCH_REGISTRATION_SUBSTITUTE -> {
                String title = "MoĹľnĂˇ ĂşÄŤast (SUBSTITUTE)";
                String messageBase = formattedDateTime.isBlank()
                        ? "VaĹˇe registrace na zĂˇpas je nastavena jako â€šmoĹľnĂˇâ€."
                        : "VaĹˇe registrace na zĂˇpas %s je nastavena jako â€šmoĹľnĂˇâ€."
                        .formatted(formattedDateTime);

                String capacityPart = (maxPlayers > 0)
                        ? " Kapacita zĂˇpasu: %d hrĂˇÄŤĹŻ.".formatted(maxPlayers)
                        : "";

                String message = messageBase + capacityPart;
                yield new InAppNotificationContent(title, message);
            }

            case MATCH_WAITING_LIST_MOVED_UP -> {
                String title = "PĹ™esun z ÄŤekacĂ­ listiny";
                String freeSlotsPart = (maxPlayers > 0)
                        ? " VolnĂˇ mĂ­sta: %d z %d.".formatted(freeSlots, maxPlayers)
                        : "";
                String message = formattedDateTime.isBlank()
                        ? "Byl jste pĹ™esunut z ÄŤekacĂ­ listiny mezi pĹ™ihlĂˇĹˇenĂ© hrĂˇÄŤe.%s"
                        .formatted(freeSlotsPart)
                        : "Byl jste pĹ™esunut z ÄŤekacĂ­ listiny mezi pĹ™ihlĂˇĹˇenĂ© na zĂˇpas %s.%s"
                        .formatted(formattedDateTime, freeSlotsPart);
                yield new InAppNotificationContent(title, message);
            }

            case MATCH_REGISTRATION_NO_RESPONSE -> {
                String title = "Bez reakce na zĂˇpas";
                String base = formattedDateTime.isBlank()
                        ? "Dosud jste nereagoval na zĂˇpas."
                        : "Dosud jste nereagoval na zĂˇpas %s."
                        .formatted(formattedDateTime);

                String countPart = (maxPlayers > 0)
                        ? " PĹ™ihlĂˇĹˇeno: %d hrĂˇÄŤĹŻ, volnĂˇ mĂ­sta: %d z %d."
                        .formatted(registeredCount, freeSlots, maxPlayers)
                        : "";

                String message = base + countPart;
                yield new InAppNotificationContent(title, message);
            }

            // =====================================
            // EXCUSE â€“ omluvy a neomluvenĂ© absence
            // =====================================

            case PLAYER_EXCUSED -> {
                String title = "Omluva ze zĂˇpasu";
                String reasonPart = !excuseReason.isBlank()
                        ? " DĹŻvod: %s - %s.".formatted(excuseReason, excuseNote)
                        : "";
                String message = formattedDateTime.isBlank()
                        ? "VaĹˇe omluva ze zĂˇpasu byla zaznamenĂˇna.%s"
                        .formatted(reasonPart)
                        : "VaĹˇe omluva ze zĂˇpasu %s byla zaznamenĂˇna.%s"
                        .formatted(formattedDateTime, reasonPart);
                yield new InAppNotificationContent(title, message);
            }

            case PLAYER_NO_EXCUSED -> {
                String title = "NeomluvenĂˇ neĂşÄŤast";
                String message = formattedDateTime.isBlank()
                        ? "Byl jste oznaÄŤen jako neomluvenĂ˝ na zĂˇpas."
                        : "Byl jste oznaÄŤen jako neomluvenĂ˝ na zĂˇpas %s."
                        .formatted(formattedDateTime);
                yield new InAppNotificationContent(title, message);
            }

            // =====================================
            // MATCH_INFO â€“ informace o zĂˇpase
            // =====================================

            case MATCH_REMINDER -> {
                String title = "PĹ™ipomenutĂ­ zĂˇpasu";
                String base = formattedDateTime.isBlank()
                        ? "PĹ™ipomĂ­nĂˇme vĂˇm nadchĂˇzejĂ­cĂ­ zĂˇpas."
                        : "PĹ™ipomĂ­nĂˇme vĂˇm nadchĂˇzejĂ­cĂ­ zĂˇpas %s."
                        .formatted(formattedDateTime);

                String countPart = (maxPlayers > 0)
                        ? " PĹ™ihlĂˇĹˇeno: %d hrĂˇÄŤĹŻ, volnĂˇ mĂ­sta: %d z %d."
                        .formatted(registeredCount, freeSlots, maxPlayers)
                        : "";

                String message = base + countPart;
                yield new InAppNotificationContent(title, message);
            }

            case MATCH_CANCELED -> {
                String title = "ZĂˇpas zruĹˇen";
                String reasonPart = !matchCancelReason.isBlank()
                        ? " DĹŻvod: %s.".formatted(matchCancelReason)
                        : "";
                String message = formattedDateTime.isBlank()
                        ? "PlĂˇnovanĂ˝ zĂˇpas byl zruĹˇen.%s"
                        .formatted(reasonPart)
                        : "ZĂˇpas %s byl zruĹˇen.%s"
                        .formatted(formattedDateTime, reasonPart);
                yield new InAppNotificationContent(title, message);
            }

            case MATCH_UNCANCELED -> {
                String title = "ZĂˇpas obnoven";
                String message = formattedDateTime.isBlank()
                        ? "PĹŻvodnÄ› zruĹˇenĂ˝ zĂˇpas byl obnoven."
                        : "PĹŻvodnÄ› zruĹˇenĂ˝ zĂˇpas %s byl obnoven."
                        .formatted(formattedDateTime);
                yield new InAppNotificationContent(title, message);
            }

            case MATCH_TIME_CHANGED -> {
                String title = "ZmÄ›na data/ÄŤasu zĂˇpasu";

                LocalDateTime oldDateTime = null;
                if (context instanceof MatchTimeChangeContext mtc) {
                    oldDateTime = mtc.oldDateTime();
                }

                String oldDateFormatted = "";
                if (oldDateTime != null) {
                    oldDateFormatted = oldDateTime.format(MATCH_DATETIME_FORMATTER);
                }

                String newPart = formattedDateTime.isBlank()
                        ? "DoĹˇlo ke zmÄ›nÄ› data/ÄŤasu plĂˇnovanĂ©ho zĂˇpasu."
                        : "DoĹˇlo ke zmÄ›nÄ› data/ÄŤasu zĂˇpasu na novĂ˝ termĂ­n %s."
                        .formatted(formattedDateTime);

                String oldPart = oldDateFormatted.isBlank()
                        ? ""
                        : " PĹŻvodnĂ­ termĂ­n: %s.".formatted(oldDateFormatted);

                String message = newPart + oldPart;
                yield new InAppNotificationContent(title, message);
            }

            // pro ostatnĂ­ typy in-app notifikaci nesestavujeme
            default -> null;
        };
    }

    // PomocnĂ© metody

    /**
     * SestavĂ­ zobrazitelnĂ© jmĂ©no uĹľivatele.
     */
    private String fullUserName(AppUserEntity user) {
        if (user == null) return "(neznĂˇmĂ˝ uĹľivatel)";
        String first = safe(user.getName());
        String last = safe(user.getSurname());
        String full = (first + " " + last).trim();
        if (full.isEmpty()) {
            return user.getEmail() != null ? user.getEmail() : "(neznĂˇmĂ˝ uĹľivatel)";
        }
        return full;
    }

    /**
     * VracĂ­ zobrazitelnĂ© jmĂ©no hrĂˇÄŤe.
     */
    private String fullPlayerName(PlayerEntity player) {
        if (player == null) return "(neznĂˇmĂ˝ hrĂˇÄŤ)";
        if (player.getFullName() != null && !player.getFullName().isBlank()) {
            return player.getFullName();
        }
        return "(beze jmĂ©na)";
    }

    private String safe(String s) {
        return s == null ? "" : s;
    }

    @SuppressWarnings("unchecked")
    private <T> T castContext(Object context, Class<T> expected) {
        if (context == null) {
            return null;
        }
        if (!expected.isInstance(context)) {
            return null;
        }
        return (T) context;
    }

    private String formatMatchDateTime(MatchEntity match) {
        if (match == null || match.getDateTime() == null) {
            return "";
        }
        return match.getDateTime().format(MATCH_DATETIME_FORMATTER);
    }

    /**
     * SpoÄŤĂ­tĂˇ poÄŤet pĹ™ihlĂˇĹˇenĂ˝ch hrĂˇÄŤĹŻ k danĂ©mu zĂˇpasu.
     */
    private long countRegisteredPlayers(MatchEntity match) {
        if (match == null || match.getId() == null) {
            return 0;
        }
        return registrationRepository.countByMatchIdAndStatus(
                match.getId(),
                PlayerMatchStatus.REGISTERED
        );
    }

    /**
     * Z kontextu urÄŤĂ­ zĂˇpas relevantnĂ­ pro notifikaci.
     */
    private MatchEntity extractMatch(Object context) {
        if (context instanceof MatchRegistrationEntity reg) {
            return reg.getMatch();
        }
        if (context instanceof MatchEntity match) {
            return match;
        }
        if (context instanceof MatchTimeChangeContext mtc) {
            return mtc.match();
        }
        return null;
    }

    private MatchRegistrationEntity extractMatchRegistration(Object context) {
        if (context instanceof MatchRegistrationEntity reg) {
            return reg;
        }
        return null;
    }

    // pomocnĂˇ metoda pro dĹŻvod zruĹˇenĂ­ zĂˇpasu
    /**
     * VracĂ­ ÄŤitelnĂ˝ popis dĹŻvodu zruĹˇenĂ­ zĂˇpasu.
     * Pokud nenĂ­ dĹŻvod nastaven, vracĂ­ prĂˇzdnĂ˝ Ĺ™etÄ›zec.
     */
    private String assignMatchCancelReason(MatchEntity match) {
        if (match == null || match.getCancelReason() == null) {
            return "";
        }

        return switch (match.getCancelReason()) {
            case NOT_ENOUGH_PLAYERS -> "nedostateÄŤnĂ˝ poÄŤet hrĂˇÄŤĹŻ";
            case TECHNICAL_ISSUE -> "TechnickĂ© problĂ©my (led, halaâ€¦)";
            case WEATHER -> "NepĹ™Ă­znivĂ© poÄŤasĂ­";
            case ORGANIZER_DECISION -> "RozhodnutĂ­ organizĂˇtora";
            case OTHER -> "JinĂ˝ dĹŻvod";
            default -> "neznĂˇmĂ˝ dĹŻvod";
        };
    }
    /**
     * VracĂ­ ÄŤitelnĂ˝ popis dĹŻvodu omluvy ze zĂˇpasu.
     * Pokud nenĂ­ dĹŻvod nastaven, vracĂ­ prĂˇzdnĂ˝ Ĺ™etÄ›zec.
     */
    private String assignExcuseReason(MatchRegistrationEntity registration) {
        if (registration == null || registration.getExcuseReason() == null) {
            return "";
        }

        return switch (registration.getExcuseReason()) {
            case NEMOC -> "nemoc";
            case PRACE -> "pracovnĂ­ povinnosti";
            case NECHE_SE_MI -> "nechce se mi";
            case JINE -> "jinĂ˝ dĹŻvod";
            default -> "neznĂˇmĂ˝ dĹŻvod";
        };
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\InAppNotificationService.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.models.dto.requests.SpecialNotificationRequestDTO;

/**
 * Servis pro uklĂˇdĂˇnĂ­ aplikaÄŤnĂ­ch (in-app) notifikacĂ­ do databĂˇze.
 *
 * SlouĹľĂ­ jako doplnÄ›k k NotificationService, kterĂ© Ĺ™eĹˇĂ­ e-mail
 * a SMS notifikace. Tento servis vytvĂˇĹ™Ă­ zjednoduĹˇenĂ© notifikace
 * pro zobrazenĂ­ v UI (badge, pĹ™ehled poslednĂ­ch udĂˇlostĂ­).
 */
public interface InAppNotificationService {

    /**
     * UloĹľĂ­ notifikaci souvisejĂ­cĂ­ s hrĂˇÄŤem.
     *
     * Typicky se pouĹľĂ­vĂˇ z notifyPlayer a vytvĂˇĹ™Ă­ notifikaci
     * pro uĹľivatele vlastnĂ­cĂ­ho hrĂˇÄŤe.
     *
     * @param player  hrĂˇÄŤ, kterĂ©ho se notifikace tĂ˝kĂˇ
     * @param type    typ notifikace
     * @param context volitelnĂ˝ kontext pro sestavenĂ­ textu
     */
    void storeForPlayer(PlayerEntity player, NotificationType type, Object context);

    void storeForPlayer(PlayerEntity player,
                        NotificationType type,
                        Object context,
                        String emailTo,
                        String smsTo);
    /**
     * UloĹľĂ­ notifikaci souvisejĂ­cĂ­ s uĹľivatelem.
     *
     * Typicky se pouĹľĂ­vĂˇ z notifyUser a vytvĂˇĹ™Ă­ notifikaci
     * pĹ™Ă­mo pro danĂ©ho uĹľivatele.
     *
     * @param user    uĹľivatel, kterĂ©ho se notifikace tĂ˝kĂˇ
     * @param type    typ notifikace
     * @param context volitelnĂ˝ kontext pro sestavenĂ­ textu
     */
    void storeForUser(AppUserEntity user, NotificationType type, Object context);

    void storeForUser(AppUserEntity user,
                      NotificationType type,
                      Object context,
                      String emailTo);
    /**
     * UklĂˇdĂˇ speciĂˇlnĂ­ zprĂˇvu typu SPECIAL_MESSAGE
     * pro zadanĂ©ho uĹľivatele a (volitelnÄ›) hrĂˇÄŤe.
     *
     * Text zprĂˇvy je pĹ™edĂˇvĂˇn pĹ™Ă­mo z volajĂ­cĂ­ vrstvy
     * a nevyuĹľĂ­vĂˇ InAppNotificationBuilder.
     *
     * @param user uĹľivatel, ke kterĂ©mu je notifikace pĹ™iĹ™azena
     * @param player hrĂˇÄŤ, kterĂ©ho se notifikace tĂ˝kĂˇ (mĹŻĹľe bĂ˝t null)
     * @param messageShort struÄŤnĂ˝ text notifikace pro seznam
     * @param messageFull plnĂ˝ text notifikace pro detail
     */
    void storeSpecialMessage(AppUserEntity user,
                             PlayerEntity player,
                             String messageShort,
                             String messageFull);

    void storeSpecialMessage(AppUserEntity user,
                             PlayerEntity player,
                             String messageShort,
                             String messageFull,
                             String emailTo,
                             String smsTo);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\InAppNotificationServiceImpl.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.NotificationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.data.repositories.NotificationRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.time.Clock;
import java.time.Instant;
import java.util.Optional;

/**
 * Implementace sluĹľby pro uklĂˇdĂˇnĂ­ aplikaÄŤnĂ­ch notifikacĂ­.
 *
 * TĹ™Ă­da neĹ™eĹˇĂ­ odesĂ­lĂˇnĂ­ e-mailĹŻ ani SMS.
 * VytvĂˇĹ™Ă­ zjednoduĹˇenĂ© i detailnĂ­ notifikace v databĂˇzi
 * pro zobrazenĂ­ v uĹľivatelskĂ©m rozhranĂ­.
 *
 * Text notifikacĂ­ se sestavuje pomocĂ­ InAppNotificationBuilder.
 */
@Service
public class InAppNotificationServiceImpl implements InAppNotificationService {

    private static final Logger log = LoggerFactory.getLogger(InAppNotificationServiceImpl.class);

    private final NotificationRepository notificationRepository;
    private final InAppNotificationBuilder inAppNotificationBuilder;
    private final Clock clock;

    public InAppNotificationServiceImpl(NotificationRepository notificationRepository,
                                        InAppNotificationBuilder inAppNotificationBuilder,
                                        Clock clock) {
        this.notificationRepository = notificationRepository;
        this.inAppNotificationBuilder = inAppNotificationBuilder;
        this.clock = clock;
    }

    @Override
    public void storeForPlayer(PlayerEntity player,
                               NotificationType type,
                               Object context) {
        storeForPlayer(player, type, context, null, null);
    }

    @Override
    public void storeForPlayer(PlayerEntity player,
                               NotificationType type,
                               Object context,
                               String emailTo,
                               String smsTo) {

        if (player == null) {
            log.debug("InAppNotificationService.storeForPlayer: player is null, nic se neuklĂˇdĂˇ");
            return;
        }

        AppUserEntity owner = player.getUser();
        if (owner == null) {
            log.debug(
                    "InAppNotificationService.storeForPlayer: player {} nemĂˇ pĹ™iĹ™azenĂ©ho uĹľivatele, nic se neuklĂˇdĂˇ",
                    player.getId()
            );
            return;
        }

        InAppNotificationBuilder.InAppNotificationContent content =
                buildContent(type, owner, player, context);

        String messageShort = content != null && content.title() != null && !content.title().isBlank()
                ? content.title()
                : type.name();

        String messageFull = content != null && content.message() != null && !content.message().isBlank()
                ? content.message()
                : type.name();

        // Pokus o navĂˇzĂˇnĂ­ notifikace na konkrĂ©tnĂ­ zĂˇpas.
        // Pokud je context instanceof MatchEntity, vyuĹľije se pro deduplikaci.
        MatchEntity match = resolveMatchFromContext(context);

        if (match != null) {
            // Deduplikace podle user + match + type.
            Optional<NotificationEntity> existingOpt =
                    notificationRepository.findByUserAndMatchAndType(owner, match, type);

            if (existingOpt.isPresent()) {
                NotificationEntity existing = existingOpt.get();

                existing.setMessageShort(messageShort);
                existing.setMessageFull(messageFull);
                existing.setEmailTo(emailTo);
                existing.setSmsTo(smsTo);
                existing.setCreatedAt(Instant.now(clock));

                notificationRepository.save(existing);

                log.debug(
                        "InAppNotificationService.storeForPlayer: aktualizovĂˇna existujĂ­cĂ­ notifikace type={} userId={} playerId={} matchId={} emailTo={} smsTo={}",
                        type,
                        owner.getId(),
                        player.getId(),
                        match.getId(),
                        emailTo,
                        smsTo
                );
                return;
            }
        }

        // Pokud nenĂ­ match, nebo neexistuje zĂˇznam pro kombinaci (user, match, type),
        // vytvoĹ™Ă­ se novĂˇ notifikace.
        NotificationEntity entity = new NotificationEntity();
        entity.setUser(owner);
        entity.setPlayer(player);
        if (match != null) {
            entity.setMatch(match);
        }
        entity.setType(type);
        entity.setMessageShort(messageShort);
        entity.setMessageFull(messageFull);
        entity.setCreatedAt(Instant.now(clock));

        entity.setEmailTo(emailTo);
        entity.setSmsTo(smsTo);

        notificationRepository.save(entity);

        log.debug(
                "InAppNotificationService.storeForPlayer: uloĹľena notifikace type={} userId={} playerId={} matchId={} emailTo={} smsTo={}",
                type,
                owner.getId(),
                player.getId(),
                match != null ? match.getId() : null,
                emailTo,
                smsTo
        );
    }

    @Override
    public void storeForUser(AppUserEntity user,
                             NotificationType type,
                             Object context) {
        storeForUser(user, type, context, null);
    }

    @Override
    public void storeForUser(AppUserEntity user,
                             NotificationType type,
                             Object context,
                             String emailTo) {

        if (user == null) {
            log.debug("InAppNotificationService.storeForUser: user is null, nic se neuklĂˇdĂˇ");
            return;
        }

        InAppNotificationBuilder.InAppNotificationContent content =
                buildContent(type, user, null, context);

        String messageShort = content != null && content.title() != null && !content.title().isBlank()
                ? content.title()
                : type.name();

        String messageFull = content != null && content.message() != null && !content.message().isBlank()
                ? content.message()
                : type.name();

        NotificationEntity entity = new NotificationEntity();
        entity.setUser(user);
        entity.setType(type);
        entity.setMessageShort(messageShort);
        entity.setMessageFull(messageFull);
        entity.setCreatedAt(Instant.now(clock));

        // UĹľivatelskĂ© notifikace nejsou vĂˇzĂˇny na match â€“ match se zde nenastavuje.
        entity.setEmailTo(emailTo);
        entity.setSmsTo(null);

        notificationRepository.save(entity);

        log.debug("InAppNotificationService.storeForUser: uloĹľena notifikace type={} userId={} emailTo={}",
                type, user.getId(), emailTo);
    }

    @Override
    public void storeSpecialMessage(AppUserEntity user,
                                    PlayerEntity player,
                                    String messageShort,
                                    String messageFull) {
        storeSpecialMessage(user, player, messageShort, messageFull, null, null);
    }

    @Override
    public void storeSpecialMessage(AppUserEntity user,
                                    PlayerEntity player,
                                    String messageShort,
                                    String messageFull,
                                    String emailTo,
                                    String smsTo) {

        if (user == null) {
            log.debug("InAppNotificationService.storeSpecialMessage: user is null, nic se neuklĂˇdĂˇ");
            return;
        }

        String shortText = (messageShort != null && !messageShort.isBlank())
                ? messageShort
                : NotificationType.SPECIAL_MESSAGE.name();

        String fullText = (messageFull != null && !messageFull.isBlank())
                ? messageFull
                : NotificationType.SPECIAL_MESSAGE.name();

        NotificationEntity entity = new NotificationEntity();
        entity.setUser(user);
        if (player != null) {
            entity.setPlayer(player);
        }
        entity.setType(NotificationType.SPECIAL_MESSAGE);
        entity.setMessageShort(shortText);
        entity.setMessageFull(fullText);
        entity.setCreatedAt(Instant.now(clock));

        // SpeciĂˇlnĂ­ zprĂˇvy nenvĂˇĹľeme na konkrĂ©tnĂ­ zĂˇpas â€“ jednĂˇ se
        // o obecnou administrĂˇtorskou komunikaci.
        entity.setEmailTo(emailTo);
        entity.setSmsTo(smsTo);

        notificationRepository.save(entity);

        log.debug(
                "InAppNotificationService.storeSpecialMessage: uloĹľena SPECIAL_MESSAGE userId={} playerId={} emailTo={} smsTo={}",
                user.getId(),
                player != null ? player.getId() : null,
                emailTo,
                smsTo
        );
    }

    /**
     * Sestavuje obsah in-app notifikace pomocĂ­ InAppNotificationBuilder.
     *
     * Pokud builder vrĂˇtĂ­ null (pro danĂ˝ NotificationType nenĂ­ definovĂˇna
     * Ĺˇablona), vracĂ­ se takĂ© null a volajĂ­cĂ­ pouĹľije fallback type.name().
     */
    private InAppNotificationBuilder.InAppNotificationContent buildContent(NotificationType type,
                                                                           AppUserEntity user,
                                                                           PlayerEntity player,
                                                                           Object context) {
        try {
            return inAppNotificationBuilder.build(type, user, player, context);
        } catch (Exception ex) {
            log.debug("InAppNotificationService.buildContent: chyba pĹ™i sestavovĂˇnĂ­ notifikace pro type {}: {}",
                    type, ex.getMessage());
            return null;
        }
    }

    /**
     * PokusĂ­ se z contextu vyÄŤĂ­st zĂˇpas pro navĂˇzĂˇnĂ­ notifikace.
     *
     * AktuĂˇlnÄ› se podporuje varianta, kdy je context pĹ™Ă­mo instancĂ­ MatchEntity.
     * Pokud context neobsahuje zĂˇpas, vracĂ­ se null.
     *
     * Do budoucna lze rozĹˇĂ­Ĺ™it o dalĹˇĂ­ typy kontextĹŻ (napĹ™. vlastnĂ­ wrapper).
     *
     * @param context kontext pĹ™edanĂ˝ volajĂ­cĂ­m
     * @return MatchEntity, pokud jej lze z contextu zĂ­skat, jinak null
     */
    private MatchEntity resolveMatchFromContext(Object context) {
        if (context instanceof MatchEntity) {
            return (MatchEntity) context;
        }
        return null;
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\MatchReminderScheduler.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.MatchStatus;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Clock;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.List;

/**
 * PlĂˇnovaÄŤ pro odesĂ­lĂˇnĂ­ pĹ™ipomĂ­nek zĂˇpasĹŻ (MATCH_REMINDER).
 *
 * OdpovÄ›dnosti:
 * - periodicky prochĂˇzet budoucĂ­ zĂˇpasy v definovanĂ©m ÄŤasovĂ©m oknÄ›,
 * - pro kaĹľdĂ˝ zĂˇpas najĂ­t pĹ™ihlĂˇĹˇenĂ© hrĂˇÄŤe (REGISTERED),
 * - v okamĹľiku, kdy se zĂˇpas blĂ­ĹľĂ­ na definovanĂ˝ poÄŤet hodin, zavolat
 *   NotificationService.notifyPlayer(..., MATCH_REMINDER, match).
 *
 * TĹ™Ă­da NEĹEĹ ĂŤ:
 * - uĹľivatelskĂˇ nastavenĂ­ (notifyReminders, kanĂˇly, globĂˇlnĂ­ ĂşrovnÄ›),
 *   to je plnÄ› v reĹľii NotificationPreferencesService,
 * - sestavenĂ­ textĹŻ e-mailĹŻ / SMS (Ĺ™eĹˇĂ­ EmailMessageBuilder / SmsMessageBuilder).
 *
 * Deduplikace pĹ™ipomĂ­nek se Ĺ™eĹˇĂ­ pĹ™Ă­znakem reminderAlreadySent v
 * MatchRegistrationEntity a navazujĂ­cĂ­ historii.
 *
 * PlĂˇnovaÄŤ pĹ™edpoklĂˇdĂˇ, Ĺľe je v aplikaci povoleno plĂˇnovĂˇnĂ­ pomocĂ­
 * anotace @EnableScheduling v konfiguraÄŤnĂ­ tĹ™Ă­dÄ›.
 */
@Service
public class MatchReminderScheduler {

    private static final Logger log = LoggerFactory.getLogger(MatchReminderScheduler.class);

    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository matchRegistrationRepository;
    private final NotificationService notificationService;
    private final Clock clock;

    /**
     * MaximĂˇlnĂ­ horizont, ve kterĂ©m se hledajĂ­ zĂˇpasy pro pĹ™ipomĂ­nky.
     * Hodnota udĂˇvĂˇ poÄŤet hodin od aktuĂˇlnĂ­ho ÄŤasu smÄ›rem do budoucnosti.
     *
     * PĹ™Ă­klad: 48 znamenĂˇ, Ĺľe plĂˇnovaÄŤ zpracuje vĹˇechny zĂˇpasy v
     * nĂˇsledujĂ­cĂ­ch 48 hodinĂˇch.
     */
    private final int horizonHours;

    /**
     * GlobĂˇlnĂ­ hodnota, kolik hodin pĹ™ed zaÄŤĂˇtkem zĂˇpasu
     * se mĂˇ pĹ™ipomĂ­nka posĂ­lat.
     *
     * KonkrĂ©tnĂ­ kanĂˇly a to, zda hrĂˇÄŤ pĹ™ipomĂ­nky chce (notifyReminders),
     * rozhoduje NotificationPreferencesService.
     */
    private final int reminderHoursBefore;

    /**
     * Velikost ÄŤasovĂ©ho okna (v minutĂˇch), ve kterĂ©m se pĹ™ipomĂ­nka
     * povaĹľuje za â€žaktuĂˇlnĂ­â€ś.
     *
     * PĹ™Ă­klad: pokud je reminderHoursBefore = 24 a toleranceMinutes = 5,
     * pak se pĹ™ipomĂ­nka odeĹˇle v intervalu
     * <24 h - 5 min, 24 h> pĹ™ed zaÄŤĂˇtkem zĂˇpasu.
     *
     * Tato tolerance slouĹľĂ­ k tomu, aby plĂˇnovaÄŤ bÄ›ĹľĂ­cĂ­ napĹ™. kaĹľdĂ˝ch 5 minut
     * nepĹ™eskoÄŤil pĹ™esnĂ˝ ÄŤas.
     */
    private final int toleranceMinutes;

    public MatchReminderScheduler(MatchRepository matchRepository,
                                  MatchRegistrationRepository matchRegistrationRepository,
                                  NotificationService notificationService,
                                  Clock clock,
                                  @Value("${app.notifications.reminder.horizon-hours:48}")
                                  int horizonHours,
                                  @Value("${app.notifications.reminder.hours-before:24}")
                                  int reminderHoursBefore,
                                  @Value("${app.notifications.reminder.tolerance-minutes:5}")
                                  int toleranceMinutes) {
        this.matchRepository = matchRepository;
        this.matchRegistrationRepository = matchRegistrationRepository;
        this.notificationService = notificationService;
        this.clock = clock;
        this.horizonHours = horizonHours;
        this.reminderHoursBefore = reminderHoursBefore;
        this.toleranceMinutes = toleranceMinutes;
    }

    /**
     * HlavnĂ­ plĂˇnovacĂ­ metoda.
     *
     * Metoda se spouĹˇtĂ­ periodicky podle cron vĂ˝razu nebo fixedDelay.
     * ÄŚetnost spouĹˇtÄ›nĂ­ by mÄ›la odpovĂ­dat hodnotÄ› toleranceMinutes tak,
     * aby nedochĂˇzelo k opakovanĂ©mu odesĂ­lĂˇnĂ­ pĹ™ipomĂ­nek.
     *
     * V implementaci se:
     * - naÄŤtou vĹˇechny budoucĂ­ zĂˇpasy v horizontu horizonHours,
     * - odfiltrujĂ­ se zruĹˇenĂ© zĂˇpasy,
     * - pro kaĹľdĂ˝ zĂˇpas se najdou registrace se statusem REGISTERED,
     *   u kterĂ˝ch jeĹˇtÄ› nebyl odeslĂˇn reminder,
     * - pro kaĹľdĂ©ho pĹ™ihlĂˇĹˇenĂ©ho hrĂˇÄŤe se vyhodnotĂ­, zda nastal ÄŤas pĹ™ipomĂ­nky,
     *   a pĹ™Ă­padnÄ› se odeĹˇle notifikace MATCH_REMINDER.
     *
     * KonkrĂ©tnĂ­ to, zda a jak se notifikace doruÄŤĂ­ (email/SMS),
     * urÄŤuje NotificationPreferencesService.
     */
    @Scheduled(fixedDelayString = "${app.notifications.reminder.fixed-delay-ms:300000}")
    @Transactional // musĂ­ bĂ˝t R/W kvĹŻli nastavenĂ­ reminderAlreadySent = true
    public void processMatchReminders() {

        LocalDateTime now = LocalDateTime.now(clock);
        LocalDateTime windowEnd = now.plusHours(horizonHours);

        log.debug("MatchReminderScheduler: start, now={}, windowEnd={}", now, windowEnd);

        // PĹ™edpoklĂˇdĂˇ se existence metody v MatchRepository:
        //   List<MatchEntity> findByDateTimeBetween(LocalDateTime from, LocalDateTime to);
        List<MatchEntity> upcomingMatches =
                matchRepository.findByDateTimeBetween(now, windowEnd);

        if (upcomingMatches.isEmpty()) {
            log.debug("MatchReminderScheduler: ĹľĂˇdnĂ© budoucĂ­ zĂˇpasy v horizontu {} h", horizonHours);
            return;
        }

        for (MatchEntity match : upcomingMatches) {

            // ZruĹˇenĂ© zĂˇpasy se pro pĹ™ipomĂ­nky ignorujĂ­.
            if (match.getMatchStatus() == MatchStatus.CANCELED) {
                log.debug("MatchReminderScheduler: zĂˇpas {} je zruĹˇen, pĹ™eskoÄŤeno", match.getId());
                continue;
            }

            processMatch(match, now);
        }
    }

    /**
     * Zpracuje jeden konkrĂ©tnĂ­ zĂˇpas.
     *
     * Provede:
     * - ovÄ›Ĺ™enĂ­, zda je zĂˇpas v reminder oknÄ›,
     * - naÄŤtenĂ­ registracĂ­ se statusem REGISTERED, u kterĂ˝ch jeĹˇtÄ›
     *   nebyl odeslĂˇn reminder,
     * - pro kaĹľdou registraci odeslĂˇnĂ­ notifikace MATCH_REMINDER
     *   a nastavenĂ­ pĹ™Ă­znaku reminderAlreadySent = true.
     *
     * NastavenĂ­ hrĂˇÄŤe (notifyReminders, kanĂˇly) neĹ™eĹˇĂ­ â€“ rozhoduje
     * o nich NotificationPreferencesService uvnitĹ™ NotificationService.
     *
     * @param match zpracovĂˇvanĂ˝ zĂˇpas
     * @param now   aktuĂˇlnĂ­ ÄŤas v okamĹľiku bÄ›hu plĂˇnovaÄŤe
     */
    private void processMatch(MatchEntity match, LocalDateTime now) {

        LocalDateTime matchDateTime = match.getDateTime();
        if (matchDateTime == null) {
            log.debug("MatchReminderScheduler: zĂˇpas {} nemĂˇ nastavenĂ© datum/ÄŤas, pĹ™eskoÄŤeno", match.getId());
            return;
        }

        // Pokud zĂˇpas nenĂ­ v oknÄ› pro pĹ™ipomĂ­nku, nemĂˇ smysl cokoliv dĂˇl Ĺ™eĹˇit.
        if (!shouldSendReminder(now, matchDateTime)) {
            return;
        }

        // Najdou se pouze registrace REGISTERED, u kterĂ˝ch jeĹˇtÄ› reminder neodeĹˇel.
        List<MatchRegistrationEntity> registrations =
                matchRegistrationRepository.findByMatchIdAndStatusAndReminderAlreadySentFalse(
                        match.getId(),
                        PlayerMatchStatus.REGISTERED
                );

        if (registrations.isEmpty()) {
            log.debug("MatchReminderScheduler: zĂˇpas {} nemĂˇ ĹľĂˇdnĂ© REGISTERED hrĂˇÄŤe bez odeslanĂ©ho reminderu, pĹ™eskoÄŤeno",
                    match.getId());
            return;
        }

        for (MatchRegistrationEntity registration : registrations) {

            PlayerEntity player = registration.getPlayer();
            if (player == null) {
                continue;
            }

            log.info(
                    "MatchReminderScheduler: volĂˇ se MATCH_REMINDER pro playerId={} matchId={} ({} h pĹ™ed zaÄŤĂˇtkem)",
                    player.getId(), match.getId(), reminderHoursBefore
            );

            // OdeslĂˇnĂ­ notifikace â€“ NotificationService se postarĂˇ o kanĂˇly (email/SMS)
            // podle NotificationPreferencesService a nastavenĂ­ uĹľivatele/hrĂˇÄŤe.
            notificationService.notifyPlayer(player, NotificationType.MATCH_REMINDER, match);

            // Deduplikace: oznaÄŤĂ­me, Ĺľe pro tuto registraci jiĹľ reminder odeĹˇel.
            registration.setReminderAlreadySent(true);
            // ExplicitnĂ­ save nenĂ­ nutnĂ˝, entita je spravovanĂˇ v rĂˇmci @Transactional
            // a pĹ™i commit se zmÄ›ny propĂ­ĹˇĂ­ pĹ™es JPA dirty checking.
        }
    }

    /**
     * Rozhodne, zda mĂˇ bĂ˝t v danĂ©m okamĹľiku odeslĂˇna pĹ™ipomĂ­nka pro zĂˇpas.
     *
     * PĹ™ipomĂ­nka se odeĹˇle, pokud:
     * - rozdĂ­l mezi aktuĂˇlnĂ­m ÄŤasem a ÄŤasem zĂˇpasu je kladnĂ˝
     *   (zĂˇpas je v budoucnosti),
     * - ÄŤas do zaÄŤĂˇtku zĂˇpasu je menĹˇĂ­ nebo rovnĂ˝ reminderHoursBefore,
     * - zĂˇroveĹ je vÄ›tĹˇĂ­ neĹľ reminderHoursBefore mĂ­nus toleranceMinutes.
     *
     * TĂ­m se vytvoĹ™Ă­ ĂşzkĂ© okno, ve kterĂ©m je pĹ™ipomĂ­nka aktivnĂ­. Pokud
     * plĂˇnovaÄŤ bÄ›ĹľĂ­ napĹ™. kaĹľdĂ˝ch 5 minut a toleranceMinutes = 5,
     * pĹ™ipomĂ­nka se odeĹˇle maximĂˇlnÄ› jednou.
     *
     * @param now           aktuĂˇlnĂ­ ÄŤas
     * @param matchDateTime datum a ÄŤas zĂˇpasu
     * @return true, pokud mĂˇ bĂ˝t pĹ™ipomĂ­nka odeslĂˇna
     */
    private boolean shouldSendReminder(LocalDateTime now,
                                       LocalDateTime matchDateTime) {

        if (matchDateTime.isBefore(now)) {
            // ZĂˇpas je v minulosti â€“ nemĂˇ smysl odesĂ­lat.
            return false;
        }

        Duration diff = Duration.between(now, matchDateTime);
        long diffMinutes = diff.toMinutes();
        long reminderMinutes = reminderHoursBefore * 60L;

        long lowerBound = reminderMinutes - toleranceMinutes;
        long upperBound = reminderMinutes;

        // ochrana proti zĂˇpornĂ˝m dolnĂ­m mezĂ­m
        if (lowerBound < 0) {
            lowerBound = 0;
        }

        boolean inWindow = diffMinutes <= upperBound && diffMinutes > lowerBound;

        if (inWindow) {
            log.debug(
                    "MatchReminderScheduler: zĂˇpas za {} minut, okno ({}, {}] minut â€“ pĹ™ipomĂ­nka ANO",
                    diffMinutes, lowerBound, upperBound
            );
        } else {
            log.trace(
                    "MatchReminderScheduler: zĂˇpas za {} minut, mimo okno ({}, {}] minut â€“ pĹ™ipomĂ­nka NE",
                    diffMinutes, lowerBound, upperBound
            );
        }

        return inWindow;
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\MatchTimeChangeContext.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.MatchEntity;

import java.time.LocalDateTime;

/**
 * Kontext pro notifikace souvisejĂ­cĂ­ se zmÄ›nou termĂ­nu zĂˇpasu.
 *
 * OdpovÄ›dnost:
 * Tento kontext se pouĹľĂ­vĂˇ pĹ™i vytvĂˇĹ™enĂ­ notifikacĂ­, kterĂ© informujĂ­ hrĂˇÄŤe
 * o zmÄ›nÄ› ÄŤasu konĂˇnĂ­ konkrĂ©tnĂ­ho zĂˇpasu. UchovĂˇvĂˇ odkaz na danĂ˝ zĂˇpas
 * a pĹŻvodnĂ­ ÄŤas zahĂˇjenĂ­, aby mohla bĂ˝t v notifikaÄŤnĂ­ch textech
 * srozumitelnÄ› popsĂˇna zmÄ›na termĂ­nu.
 *
 * Vazby:
 * Kontext se pouĹľĂ­vĂˇ v notifikaÄŤnĂ­m subsystĂ©mu pĹ™i generovĂˇnĂ­ textĹŻ
 * emailovĂ˝ch nebo SMS zprĂˇv.
 *
 * @param match ZĂˇpas, jehoĹľ termĂ­n se mÄ›nĂ­.
 * @param oldDateTime PĹŻvodnĂ­ datum a ÄŤas konĂˇnĂ­ zĂˇpasu pĹ™ed zmÄ›nou.
 */
public record MatchTimeChangeContext(
        MatchEntity match,
        LocalDateTime oldDateTime
) {
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\NoResponseReminderScheduler.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.MatchStatus;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.dto.NoResponseReminderPreviewDTO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Clock;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * PlĂˇnovaÄŤ pro pĹ™ipomĂ­nky hrĂˇÄŤĹŻm, kteĹ™Ă­ dosud nereagovali (NO_RESPONSE).
 *
 * OdpovÄ›dnosti:
 * - najĂ­t zĂˇpasy, kterĂ© se konajĂ­ za N dnĂ­ (typicky 3 dny),
 * - pro tyto zĂˇpasy najĂ­t "pozvanĂ©" hrĂˇÄŤe, kteĹ™Ă­ nemajĂ­ ĹľĂˇdnou registraci,
 * - zavolat NotificationService.notifyPlayer(..., MATCH_REGISTRATION_NO_RESPONSE, match).
 *
 * TĹ™Ă­da neĹ™eĹˇĂ­:
 * - preferenÄŤnĂ­ logiku (kanĂˇly, globĂˇlnĂ­ ĂşrovnÄ›) â€“ to Ĺ™eĹˇĂ­ NotificationPreferencesService,
 * - dalĹˇĂ­ business logiku okolo zmÄ›ny stavu registracĂ­.
 *
 * Stav NO_RESPONSE se zde **dopoÄŤĂ­tĂˇvĂˇ** â€“ neexistuje jako samostatnĂˇ registrace
 * v databĂˇzi. HrĂˇÄŤ je povaĹľovĂˇn za NO_RESPONSE, pokud:
 * - je v mnoĹľinÄ› "pozvanĂ˝ch" hrĂˇÄŤĹŻ pro danĂ˝ zĂˇpas,
 * - ale nemĂˇ k tomuto zĂˇpasu ĹľĂˇdnou registraci (ĹľĂˇdnĂ˝ z PlayerMatchStatus).
 */
@Service
public class NoResponseReminderScheduler {

    private static final Logger log = LoggerFactory.getLogger(NoResponseReminderScheduler.class);

    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository matchRegistrationRepository;
    private final PlayerRepository playerRepository;
    private final NotificationService notificationService;
    private final Clock clock;

    /**
     * PoÄŤet dnĂ­ pĹ™ed zĂˇpasem, kdy se mĂˇ pĹ™ipomĂ­nka NO_RESPONSE posĂ­lat.
     * Default: 3 â€“ tedy "tĹ™i dny pĹ™ed zĂˇpasem".
     */
    private final int daysBeforeMatch;

    public NoResponseReminderScheduler(MatchRepository matchRepository,
                                       MatchRegistrationRepository matchRegistrationRepository,
                                       PlayerRepository playerRepository,
                                       NotificationService notificationService,
                                       Clock clock,
                                       @Value("${app.notifications.no-response.days-before:3}")
                                       int daysBeforeMatch) {
        this.matchRepository = matchRepository;
        this.matchRegistrationRepository = matchRegistrationRepository;
        this.playerRepository = playerRepository;
        this.notificationService = notificationService;
        this.clock = clock;
        this.daysBeforeMatch = daysBeforeMatch;
    }

    /**
     * HlavnĂ­ plĂˇnovacĂ­ metoda â€“ spouĹˇtÄ›nĂˇ CRONem.
     *
     * Typicky 1Ă— dennÄ› (napĹ™. 17:00 Europe/Prague).
     * Pro zĂˇpasy, kterĂ© se konajĂ­ za daysBeforeMatch dnĂ­, najde hrĂˇÄŤe ve stavu NO_RESPONSE
     * (dopoÄŤĂ­tanĂ©m â€“ hrĂˇÄŤ nemĂˇ ĹľĂˇdnou registraci k zĂˇpasu) a poĹˇle jim notifikaci
     * MATCH_REGISTRATION_NO_RESPONSE.
     */
    @Scheduled(cron = "${app.notifications.no-response.cron:0 00 17 * * *}",
            zone = "${app.notifications.no-response.zone:Europe/Prague}")
    @Transactional
    public void processNoResponseReminders() {

        log.debug("NoResponseReminderScheduler: start processNoResponseReminders(), daysBefore={}", daysBeforeMatch);

        List<Target> targets = findTargets();

        if (targets.isEmpty()) {
            log.debug("NoResponseReminderScheduler: ĹľĂˇdnĂ© NO_RESPONSE cĂ­le pro pĹ™ipomenutĂ­.");
            return;
        }

        for (Target target : targets) {
            PlayerEntity player = target.player();
            MatchEntity match = target.match();

            log.info(
                    "NoResponseReminderScheduler: posĂ­lĂˇ se MATCH_REGISTRATION_NO_RESPONSE " +
                            "playerId={} matchId={} ({} dnĂ­ pĹ™ed zĂˇpasem)",
                    player.getId(), match.getId(), daysBeforeMatch
            );

            // NotificationService + NotificationPreferencesService rozhodnou,
            // jakĂ© kanĂˇly se reĂˇlnÄ› pouĹľijĂ­ (email/SMS/in-app).
            notificationService.notifyPlayer(player, NotificationType.MATCH_REGISTRATION_NO_RESPONSE, match);
        }
    }

    /**
     * NĂˇhled cĂ­lovĂ˝ch hrĂˇÄŤĹŻ pro NO_RESPONSE pĹ™ipomĂ­nky.
     *
     * Metoda nic neodesĂ­lĂˇ, pouze vrĂˇtĂ­ seznam hrĂˇÄŤĹŻ a zĂˇpasĹŻ,
     * kteĹ™Ă­/Ă© by byli v aktuĂˇlnĂ­m okamĹľiku zasaĹľeni plĂˇnovaÄŤem.
     *
     * PouĹľĂ­vĂˇ se v admin endpointu /preview.
     */
    @Transactional(readOnly = true)
    public List<NoResponseReminderPreviewDTO> previewNoResponseReminders() {

        log.debug("NoResponseReminderScheduler: previewNoResponseReminders() â€“ generuje se nĂˇhled.");

        List<Target> targets = findTargets();
        List<NoResponseReminderPreviewDTO> result = new ArrayList<>();

        for (Target t : targets) {
            PlayerEntity player = t.player();
            MatchEntity match = t.match();

            String fullName = player.getFullName() != null
                    ? player.getFullName()
                    : (player.getName() + " " + player.getSurname());

            String phone = player.getPhoneNumber();

            result.add(new NoResponseReminderPreviewDTO(
                    match.getId(),
                    match.getDateTime(),
                    player.getId(),
                    fullName,
                    phone
            ));
        }

        return result;
    }

    /**
     * Najde vĹˇechny kombinace (hrĂˇÄŤ, zĂˇpas), pro kterĂ© mĂˇ bĂ˝t
     * v aktuĂˇlnĂ­m okamĹľiku poslĂˇna NO_RESPONSE pĹ™ipomĂ­nka.
     *
     * Logika NO_RESPONSE:
     * - "PozvanĂ­" hrĂˇÄŤi jsou schvĂˇlenĂ­ hrĂˇÄŤi (PlayerStatus.APPROVED).
     * - Z registracĂ­ k zĂˇpasu se vezmou vĹˇichni hrĂˇÄŤi, kteĹ™Ă­ jiĹľ reagovali
     *   (jakĂ˝mkoliv PlayerMatchStatus).
     * - NO_RESPONSE = pozvanĂ­ hrĂˇÄŤi, kteĹ™Ă­ nejsou mezi reagujĂ­cĂ­mi.
     */
    private List<Target> findTargets() {

        LocalDate today = LocalDate.now(clock);
        LocalDate targetDate = today.plusDays(daysBeforeMatch);

        log.debug("NoResponseReminderScheduler: hledĂˇm zĂˇpasy na datum {}", targetDate);

        // JednoduĹˇĹˇĂ­ varianta â€“ filtr pĹ™es findAll().
        // Pokud bude zĂˇpasĹŻ hodnÄ›, lze doplnit do MatchRepository speciĂˇlnĂ­ dotaz
        // findByDateTimeBetween(startOfDay, endOfDay).
        List<MatchEntity> matchesOnTargetDate = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime() != null
                        && m.getDateTime().toLocalDate().isEqual(targetDate))
                .filter(m -> m.getMatchStatus() != MatchStatus.CANCELED)
                .toList();

        List<Target> result = new ArrayList<>();

        if (matchesOnTargetDate.isEmpty()) {
            log.debug("NoResponseReminderScheduler: na datum {} nejsou ĹľĂˇdnĂ© aktivnĂ­ zĂˇpasy.", targetDate);
            return result;
        }

        // 1) UrÄŤenĂ­ "pozvanĂ˝ch" hrĂˇÄŤĹŻ.
        // ZatĂ­m: vĹˇichni schvĂˇlenĂ­ hrĂˇÄŤi. Pokud se v budoucnu bude pouĹľĂ­vat
        // jinĂ˝ model (napĹ™. skupiny / tĂ˝my podle zĂˇpasu), lze logiku zapouzdĹ™it
        // do samostatnĂ© metody / sluĹľby.
        List<PlayerEntity> invitedPlayers = playerRepository.findAll().stream()
                .filter(p -> p.getPlayerStatus() == PlayerStatus.APPROVED)
                .toList();

        if (invitedPlayers.isEmpty()) {
            log.debug("NoResponseReminderScheduler: ĹľĂˇdnĂ­ schvĂˇlenĂ­ hrĂˇÄŤi, nenĂ­ komu posĂ­lat NO_RESPONSE.");
            return result;
        }

        for (MatchEntity match : matchesOnTargetDate) {

            LocalDateTime dt = match.getDateTime();
            log.debug("NoResponseReminderScheduler: zpracovĂˇvĂˇ se zĂˇpas id={} dateTime={}",
                    match.getId(), dt);

            // 2) VĹˇechny registrace k danĂ©mu zĂˇpasu â€“ jakĂ˝koliv PlayerMatchStatus.
            // POZOR: je nutnĂ© mĂ­t v MatchRegistrationRepository metodu
            // List<MatchRegistrationEntity> findByMatchId(Long matchId);
            List<MatchRegistrationEntity> registrations =
                    matchRegistrationRepository.findByMatchId(match.getId());

            // MnoĹľina hrĂˇÄŤĹŻ, kteĹ™Ă­ jiĹľ reagovali (majĂ­ nÄ›jakou registraci).
            Set<Long> respondedPlayerIds = new HashSet<>();
            for (MatchRegistrationEntity reg : registrations) {
                PlayerEntity p = reg.getPlayer();
                if (p != null && p.getId() != null) {
                    respondedPlayerIds.add(p.getId());
                }
            }

            int beforeCount = result.size();

            // 3) NO_RESPONSE = pozvanĂ­ hrĂˇÄŤi, kteĹ™Ă­ nejsou v respondedPlayerIds.
            for (PlayerEntity invited : invitedPlayers) {
                if (invited.getId() == null) {
                    continue;
                }
                if (!respondedPlayerIds.contains(invited.getId())) {
                    result.add(new Target(invited, match));
                }
            }

            int added = result.size() - beforeCount;
            log.debug("NoResponseReminderScheduler: zĂˇpas {} â€“ nalezeno {} hrĂˇÄŤĹŻ s NO_RESPONSE.",
                    match.getId(), added);
        }

        log.debug("NoResponseReminderScheduler: findTargets() naĹˇel {} cĂ­lĹŻ.", result.size());
        return result;
    }

    /**
     * InternĂ­ struktura, kterĂˇ drĹľĂ­ dvojici (hrĂˇÄŤ, zĂˇpas).
     */
    private record Target(PlayerEntity player, MatchEntity match) {
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\NotificationCleanupService.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.NotificationEntity;
import cz.phsoft.hokej.data.repositories.NotificationRepository;
import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.time.Clock;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;

@Service
public class NotificationCleanupService {

    private final NotificationRepository notificationRepository;
    private final Clock clock;

    @Value("${app.notifications.retention-days:14}")
    private long retentionDays;

    @Value("${app.notifications.min-per-user:10}")
    private int minPerUser;

    public NotificationCleanupService(NotificationRepository notificationRepository,
                                      Clock clock) {
        this.notificationRepository = notificationRepository;
        this.clock = clock;
    }

    @Scheduled(cron = "0 30 3 * * *")
    @Transactional
    public void cleanupOldNotifications() {

        Instant cutoff = Instant.now(clock)
                .minus(retentionDays, ChronoUnit.DAYS);

        List<NotificationEntity> oldNotifications =
                notificationRepository
                        .findByCreatedAtBeforeOrderByUserIdAscCreatedAtDesc(cutoff);

        if (oldNotifications.isEmpty()) {
            return;
        }

        Long currentUserId = null;
        int counterForUser = 0;

        List<NotificationEntity> toDelete = new ArrayList<>();

        for (NotificationEntity n : oldNotifications) {

            Long userId = n.getUser().getId();

            // novĂ˝ uĹľivatel
            if (!userId.equals(currentUserId)) {
                currentUserId = userId;
                counterForUser = 0;
            }

            counterForUser++;

            // pokud jsme nad limitem â†’ oznaÄŤĂ­me ke smazĂˇnĂ­
            if (counterForUser > minPerUser) {
                toDelete.add(n);
            }
        }

        if (!toDelete.isEmpty()) {
            notificationRepository.deleteAll(toDelete);
        }
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\NotificationContext.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;

/**
 * TypovĂ˝ kontejner pro notifikaÄŤnĂ­ data.
 *
 * SlouĹľĂ­ k pĹ™edĂˇnĂ­ vĹˇech relevantnĂ­ch dat do builderĹŻ notifikacĂ­
 * (email a SMS). UmoĹľĹuje sjednotit vstupnĂ­ parametry tak,
 * aby jednotlivĂ© buildery nemusely pracovat s mnoĹľstvĂ­m
 * volnĂ˝ch parametrĹŻ.
 *
 * Typicky obsahuje:
 * - hrĂˇÄŤe, kterĂ©ho se notifikace tĂ˝kĂˇ,
 * - uĹľivatele, ke kterĂ©mu hrĂˇÄŤ patĹ™Ă­,
 * - zĂˇpas, k nÄ›muĹľ se udĂˇlost vztahuje,
 * - konkrĂ©tnĂ­ registraci, pokud je relevantnĂ­.
 */
public class NotificationContext {

    private final PlayerEntity player;
    private final AppUserEntity user;
    private final MatchEntity match;
    private final MatchRegistrationEntity registration;

    private NotificationContext(Builder b) {
        this.player = b.player;
        this.user = b.user;
        this.match = b.match;
        this.registration = b.registration;
    }

    public PlayerEntity getPlayer() {
        return player;
    }

    public AppUserEntity getUser() {
        return user;
    }

    public MatchEntity getMatch() {
        return match;
    }

    public MatchRegistrationEntity getRegistration() {
        return registration;
    }

    // Builder tĹ™Ă­dy

    /**
     * Builder pro vytvoĹ™enĂ­ instance NotificationContext.
     *
     * UmoĹľĹuje postupnĂ© sklĂˇdĂˇnĂ­ kontextu podle potĹ™eby
     * konkrĂ©tnĂ­ notifikace.
     */
    public static class Builder {
        private PlayerEntity player;
        private AppUserEntity user;
        private MatchEntity match;
        private MatchRegistrationEntity registration;

        public Builder player(PlayerEntity player) {
            this.player = player;
            return this;
        }

        public Builder user(AppUserEntity user) {
            this.user = user;
            return this;
        }

        public Builder match(MatchEntity match) {
            this.match = match;
            return this;
        }

        public Builder registration(MatchRegistrationEntity registration) {
            this.registration = registration;
            return this;
        }

        public NotificationContext build() {
            return new NotificationContext(this);
        }
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\NotificationPreferencesService.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.models.services.NotificationDecision;

/**
 * SluĹľba pro vyhodnocenĂ­ notifikaÄŤnĂ­ch preferencĂ­.
 *
 * Na zĂˇkladÄ›:
 * - nastavenĂ­ uĹľivatele (AppUserSettings),
 * - nastavenĂ­ hrĂˇÄŤe (PlayerSettings),
 * - typu notifikace (NotificationType)
 *
 * rozhoduje, komu a jak mĂˇ bĂ˝t notifikace doruÄŤena.
 * NemĂˇ na starosti samotnĂ© odesĂ­lĂˇnĂ­ e-mailĹŻ nebo SMS,
 * pouze dodĂˇvĂˇ rozhodnutĂ­ pro dalĹˇĂ­ notifikaÄŤnĂ­ logiku.
 */
public interface NotificationPreferencesService {

    /**
     * Na zĂˇkladÄ› hrĂˇÄŤe a typu notifikace rozhodne,
     * kam mĂˇ bĂ˝t zprĂˇva poslĂˇna.
     *
     * VĂ˝stupem je objekt NotificationDecision, kterĂ˝ urÄŤuje,
     * zda se mĂˇ poslat e-mail hrĂˇÄŤi, e-mail uĹľivateli,
     * SMS hrĂˇÄŤi a jakĂ© kontakty se majĂ­ pouĹľĂ­t.
     *
     * @param player hrĂˇÄŤ, kterĂ©ho se notifikace tĂ˝kĂˇ
     * @param type   typ notifikace
     * @return rozhodnutĂ­, komu a kam poslat
     */
    NotificationDecision evaluate(PlayerEntity player,
                                  NotificationType type);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\NotificationPreferencesServiceImpl.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.AppUserSettingsEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerSettingsEntity;
import cz.phsoft.hokej.data.enums.GlobalNotificationLevel;
import cz.phsoft.hokej.data.enums.NotificationCategory;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.models.services.NotificationDecision;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

/**
 * Implementace NotificationPreferencesService.
 *
 * SluĹľba vyhodnocuje:
 * - nastavenĂ­ hrĂˇÄŤe (PlayerSettingsEntity),
 * - nastavenĂ­ uĹľivatele (AppUserSettingsEntity),
 * - globĂˇlnĂ­ ĂşroveĹ notifikacĂ­ uĹľivatele (GlobalNotificationLevel),
 * - konkrĂ©tnĂ­ typ notifikace (NotificationType).
 *
 * VĂ˝sledkem je NotificationDecision, kterĂ© definuje,
 * komu a jakĂ˝mi kanĂˇly bude notifikace doruÄŤena.
 */
@Service
public class NotificationPreferencesServiceImpl implements NotificationPreferencesService {

    @Override
    public NotificationDecision evaluate(PlayerEntity player,
                                         NotificationType type) {

        NotificationDecision decision = new NotificationDecision();

        if (player == null || type == null) {
            return decision;
        }

        PlayerSettingsEntity playerSettings = player.getSettings();
        AppUserEntity user = player.getUser();
        AppUserSettingsEntity userSettings = (user != null ? user.getSettings() : null);

        // ZdrojovĂ© kontakty

        // Email hrĂˇÄŤe â€“ preferuje se PlayerSettings.contactEmail,
        // pĹ™Ă­padnÄ› se pouĹľije email uĹľivatele, pokud je to vhodnĂ©.
        String playerEmail = null;
        if (playerSettings != null && StringUtils.hasText(playerSettings.getContactEmail())) {
            playerEmail = playerSettings.getContactEmail();
        } else if (user != null && StringUtils.hasText(user.getEmail())) {
            // Fallback: pokud hrĂˇÄŤ nemĂˇ vlastnĂ­ e-mail, lze pouĹľĂ­t e-mail uĹľivatele.
            playerEmail = user.getEmail();
        }

        // Email uĹľivatele (ĂşÄŤtu).
        String userEmail = (user != null ? user.getEmail() : null);

        // Telefon hrĂˇÄŤe â€“ preferuje se PlayerSettings.contactPhone,
        // fallback je pĹ™Ă­padnĂ˝ phoneNumber na PlayerEntity.
        String playerPhone = null;
        if (playerSettings != null && StringUtils.hasText(playerSettings.getContactPhone())) {
            playerPhone = playerSettings.getContactPhone();
        } else if (StringUtils.hasText(player.getPhoneNumber())) {
            playerPhone = player.getPhoneNumber();
        }

        // GlobĂˇlnĂ­ nastavenĂ­ uĹľivatele

        GlobalNotificationLevel globalLevel =
                (userSettings != null && userSettings.getGlobalNotificationLevel() != null)
                        ? userSettings.getGlobalNotificationLevel()
                        : GlobalNotificationLevel.ALL;

        // Zda globĂˇlnĂ­ ĂşroveĹ vĹŻbec povoluje tento konkrĂ©tnĂ­ NotificationType.
        boolean userGlobalAllowsThisType = isGloballyEnabledForType(type, globalLevel);

        boolean copyAllToUserEmail =
                userSettings == null || userSettings.isCopyAllPlayerNotificationsToUserEmail();

        boolean includePlayersWithOwnEmail =
                userSettings != null && userSettings.isReceiveNotificationsForPlayersWithOwnEmail();

        // NastavenĂ­ hrĂˇÄŤe â€“ povolenĂ© kanĂˇly

        boolean emailChannelEnabled = (playerSettings == null) || playerSettings.isEmailEnabled();
        boolean smsChannelEnabled = (playerSettings != null) && playerSettings.isSmsEnabled();

        // Zda je typ notifikace povolen pro hrĂˇÄŤe.
        boolean typeEnabledForPlayer = isTypeEnabledForPlayer(type, playerSettings);

        // RozhodovĂˇnĂ­ podle kategorie notifikace

        NotificationCategory category = type.getCategory();

        switch (category) {

            // SystĂ©movĂ© typy â€“ primĂˇrnÄ› smÄ›Ĺ™ujĂ­ na ĂşÄŤet (user.email).
            case SYSTEM -> {
                if (user != null
                        && StringUtils.hasText(userEmail)
                        && userGlobalAllowsThisType) {

                    decision.setSendEmailToUser(true);
                    decision.setUserEmail(userEmail);
                }
            }

            // Registrace, omluvy, zĂˇpasovĂ© informace.
            case REGISTRATION, MATCH_INFO -> {

                // E-mail hrĂˇÄŤi.
                if (emailChannelEnabled
                        && typeEnabledForPlayer
                        && StringUtils.hasText(playerEmail)) {

                    decision.setSendEmailToPlayer(true);
                    decision.setPlayerEmail(playerEmail);
                }

                // SMS hrĂˇÄŤi.
                if (smsChannelEnabled
                        && typeEnabledForPlayer
                        && StringUtils.hasText(playerPhone)) {

                    decision.setSendSmsToPlayer(true);
                    decision.setPlayerPhone(playerPhone);
                }

                // E-mail uĹľivateli jako kopie.
                if (user != null
                        && StringUtils.hasText(userEmail)
                        && userGlobalAllowsThisType
                        && copyAllToUserEmail
                        && (includePlayersWithOwnEmail || !hasOwnPlayerEmail(playerSettings))) {

                    // UĹľivatel dostane kopii, pokud:
                    // - chce kopie (copyAllToUserEmail),
                    // - globĂˇlnĂ­ ĂşroveĹ mu tento typ neblokuje,
                    // - a buÄŹ hrĂˇÄŤ nemĂˇ vlastnĂ­ e-mail,
                    //   nebo uĹľivatel vĂ˝slovnÄ› chce kopie i pro hrĂˇÄŤe s vlastnĂ­m e-mailem.
                    decision.setSendEmailToUser(true);
                    decision.setUserEmail(userEmail);
                }
            }

            // OstatnĂ­ kategorie se explicitnÄ› nezpracovĂˇvajĂ­.
            default -> {
                // NezpracovanĂˇ kategorie â€“ radÄ›ji neposĂ­lat nic.
            }
        }

        return decision;
    }

    /**
     * UrÄŤuje, zda globĂˇlnĂ­ nastavenĂ­ uĹľivatele povoluje danĂ˝ NotificationType.
     *
     * NONE           -> nepovoluje ĹľĂˇdnĂ© notifikace
     * ALL            -> povoluje vĹˇechny notifikace
     * IMPORTANT_ONLY -> povoluje pouze typy oznaÄŤenĂ© jako dĹŻleĹľitĂ©
     */
    private boolean isGloballyEnabledForType(NotificationType type,
                                             GlobalNotificationLevel level) {

        return switch (level) {
            case NONE -> false;
            case ALL -> true;
            case IMPORTANT_ONLY -> type.isImportant();
        };
    }

    /**
     * ZjistĂ­, zda mĂˇ hrĂˇÄŤ vlastnĂ­ e-mail v PlayerSettings (contactEmail).
     *
     * PouĹľĂ­vĂˇ se pĹ™i rozhodovĂˇnĂ­, zda posĂ­lat kopii na e-mail uĹľivatele.
     */
    private boolean hasOwnPlayerEmail(PlayerSettingsEntity playerSettings) {
        return playerSettings != null && StringUtils.hasText(playerSettings.getContactEmail());
    }

    /**
     * ZjistĂ­, zda je konkrĂ©tnĂ­ typ notifikace povolen pro danĂ©ho hrĂˇÄŤe.
     *
     * Pokud playerSettings == null:
     * - vÄ›tĹˇina typĹŻ je povolena (zpÄ›tnĂˇ kompatibilita),
     * - MATCH_REMINDER je vĂ˝chozĂ­m chovĂˇnĂ­m vypnutĂ˝
     *   (odpovĂ­dĂˇ defaultu notifyReminders = false).
     */
    private boolean isTypeEnabledForPlayer(NotificationType type,
                                           PlayerSettingsEntity playerSettings) {

        if (playerSettings == null) {
            return switch (type) {
                case MATCH_REMINDER -> false; // bez explicitnĂ­ho nastavenĂ­ neposĂ­lat
                default -> true;
            };
        }

        return switch (type) {
            // REGISTRATION
            case MATCH_REGISTRATION_CREATED,
                 MATCH_REGISTRATION_UPDATED,
                 MATCH_REGISTRATION_CANCELED,
                 MATCH_REGISTRATION_RESERVED,
                 MATCH_REGISTRATION_SUBSTITUTE,
                 MATCH_WAITING_LIST_MOVED_UP,
                 MATCH_REGISTRATION_NO_RESPONSE,
                 PLAYER_EXCUSED,
                 PLAYER_NO_EXCUSED -> playerSettings.isRegistrationNotificationsEnabled();

            // MATCH_INFO
            case MATCH_REMINDER -> playerSettings.isNotifyReminders();
            case MATCH_CANCELED -> playerSettings.isNotifyOnMatchCancel();
            case MATCH_UNCANCELED,
                 MATCH_TIME_CHANGED -> playerSettings.isNotifyOnMatchChange();

            // SYSTEM (a ostatnĂ­, kterĂ© nejsou vĂ˝Ĺˇe vĂ˝slovnÄ› vyjmenovanĂ©)
            default -> playerSettings.isSystemNotificationsEnabled();
        };
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\NotificationQueryService.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.models.dto.NotificationBadgeDTO;
import cz.phsoft.hokej.models.dto.NotificationDTO;
import org.springframework.security.core.Authentication;

import java.util.List;

/**
 * SluĹľba pro prĂˇci s aplikaÄŤnĂ­mi notifikacemi z pohledu UI.
 *
 * Poskytuje metody pro:
 * - vĂ˝poÄŤet badge s poÄŤtem nepĹ™eÄŤtenĂ˝ch notifikacĂ­,
 * - naÄŤtenĂ­ notifikacĂ­ od poslednĂ­ho pĹ™ihlĂˇĹˇenĂ­,
 * - naÄŤtenĂ­ poslednĂ­ch notifikacĂ­,
 * - oznaÄŤenĂ­ notifikacĂ­ jako pĹ™eÄŤtenĂ˝ch.
 *
 * VeĹˇkerĂˇ logika ÄŤtenĂ­ a zmÄ›ny stavu notifikacĂ­
 * se deleguje do NotificationRepository a NotificationMapper.
 * SluĹľba pracuje vĹľdy s aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ˝m uĹľivatelem
 * na zĂˇkladÄ› Authentication kontextu.
 */
public interface NotificationQueryService {

    /**
     * VracĂ­ badge s poÄŤtem nepĹ™eÄŤtenĂ˝ch notifikacĂ­ od poslednĂ­ho pĹ™ihlĂˇĹˇenĂ­.
     *
     * @param authentication autentizaÄŤnĂ­ kontext aktuĂˇlnĂ­ho uĹľivatele
     * @return DTO s informacemi o badge
     */
    NotificationBadgeDTO getBadge(Authentication authentication);

    /**
     * VracĂ­ seznam notifikacĂ­ vytvoĹ™enĂ˝ch po poslednĂ­m pĹ™ihlĂˇĹˇenĂ­ uĹľivatele.
     *
     * Pokud uĹľivatel nemĂˇ lastLoginAt, pouĹľije se vĂ˝chozĂ­ ÄŤasovĂ© okno.
     *
     * @param authentication autentizaÄŤnĂ­ kontext aktuĂˇlnĂ­ho uĹľivatele
     * @return seznam notifikacĂ­ ve formÄ› DTO
     */
    List<NotificationDTO> getSinceLastLogin(Authentication authentication);

    /**
     * VracĂ­ poslednĂ­ notifikace aktuĂˇlnĂ­ho uĹľivatele.
     *
     * @param authentication autentizaÄŤnĂ­ kontext aktuĂˇlnĂ­ho uĹľivatele
     * @param limit maximĂˇlnĂ­ poÄŤet vrĂˇcenĂ˝ch zĂˇznamĹŻ
     * @return seznam notifikacĂ­ ve formÄ› DTO
     */
    List<NotificationDTO> getRecent(Authentication authentication, int limit);

    /**
     * OznaÄŤĂ­ konkrĂ©tnĂ­ notifikaci aktuĂˇlnĂ­ho uĹľivatele jako pĹ™eÄŤtenou.
     *
     * Operace je idempotentnĂ­ â€“ pokud je notifikace jiĹľ pĹ™eÄŤtenĂˇ
     * nebo neexistuje, nevyvolĂˇ se chyba.
     *
     * @param authentication autentizaÄŤnĂ­ kontext aktuĂˇlnĂ­ho uĹľivatele
     * @param id identifikĂˇtor notifikace
     */
    void markAsRead(Authentication authentication, Long id);

    /**
     * OznaÄŤĂ­ vĹˇechny notifikace aktuĂˇlnĂ­ho uĹľivatele jako pĹ™eÄŤtenĂ©.
     *
     * @param authentication autentizaÄŤnĂ­ kontext aktuĂˇlnĂ­ho uĹľivatele
     */
    void markAllAsRead(Authentication authentication);

    /**
     * VracĂ­ vĹˇechny notifikace v systĂ©mu pro administrativnĂ­ pĹ™ehled.
     *
     * Parametr limit omezuje maximĂˇlnĂ­ poÄŤet vrĂˇcenĂ˝ch zĂˇznamĹŻ
     * kvĹŻli vĂ˝konu a pĹ™ehlednosti.
     *
     * @param limit maximĂˇlnĂ­ poÄŤet vrĂˇcenĂ˝ch zĂˇznamĹŻ
     * @return seznam notifikacĂ­ ve formÄ› DTO
     */
    List<NotificationDTO> getAllNotifications(int limit);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\NotificationQueryServiceImpl.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.controllers.NotificationController;
import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.NotificationEntity;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.NotificationRepository;
import cz.phsoft.hokej.exceptions.UserNotFoundException;
import cz.phsoft.hokej.models.dto.NotificationBadgeDTO;
import cz.phsoft.hokej.models.dto.NotificationDTO;
import cz.phsoft.hokej.models.mappers.NotificationMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;

import java.time.Clock;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.List;

/**
 * Implementace sluĹľby pro ÄŤtenĂ­ a sprĂˇvu aplikaÄŤnĂ­ch notifikacĂ­
 * z pohledu aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
 *
 * TĹ™Ă­da:
 * - naÄŤĂ­tĂˇ uĹľivatele podle Authentication pomocĂ­ AppUserRepository,
 * - pouĹľĂ­vĂˇ NotificationRepository pro prĂˇci s entitami,
 * - provĂˇdĂ­ mapovĂˇnĂ­ na DTO pomocĂ­ NotificationMapper,
 * - urÄŤuje ÄŤasovou hranici podle lastLoginAt nebo vĂ˝chozĂ­ho okna.
 *
 * Controller deleguje veĹˇkerou logiku do tĂ©to sluĹľby
 * a nepracuje pĹ™Ă­mo s repository.
 */
@Service
public class NotificationQueryServiceImpl implements NotificationQueryService {

    private static final Logger log = LoggerFactory.getLogger(NotificationQueryServiceImpl.class);

    /**
     * VĂ˝chozĂ­ poÄŤet dnĂ­, za kterĂ© se naÄŤtou notifikace,
     * pokud uĹľivatel jeĹˇtÄ› nemĂˇ nastavenĂ© lastLoginAt.
     */
    private static final int DEFAULT_DAYS_IF_NO_LAST_LOGIN = 14;

    private final NotificationRepository notificationRepository;
    private final NotificationMapper notificationMapper;
    private final AppUserRepository appUserRepository;
    private final Clock clock;

    public NotificationQueryServiceImpl(NotificationRepository notificationRepository,
                                        NotificationMapper notificationMapper,
                                        AppUserRepository appUserRepository,
                                        Clock clock) {
        this.notificationRepository = notificationRepository;
        this.notificationMapper = notificationMapper;
        this.appUserRepository = appUserRepository;
        this.clock = clock;
    }

    @Override
    public NotificationBadgeDTO getBadge(Authentication authentication) {
        AppUserEntity user = getCurrentUser(authentication);
        Instant boundary = resolveBoundary(user);

        long count = notificationRepository
                .countByUserAndCreatedAtAfterAndReadAtIsNull(user, boundary);

        NotificationBadgeDTO dto = new NotificationBadgeDTO();
        dto.setUnreadCountSinceLastLogin(count);
        dto.setLastLoginAt(user.getLastLoginAt());
        dto.setCurrentLoginAt(user.getCurrentLoginAt());

        return dto;
    }

    @Override
    public List<NotificationDTO> getSinceLastLogin(Authentication authentication) {
        AppUserEntity user = getCurrentUser(authentication);
        Instant boundary = resolveBoundary(user);

        List<NotificationEntity> entities =
                notificationRepository.findByUserAndCreatedAtAfterOrderByCreatedAtDesc(user, boundary);

        return notificationMapper.toDtoList(entities);
    }

    @Override
    public List<NotificationDTO> getRecent(Authentication authentication, int limit) {
        AppUserEntity user = getCurrentUser(authentication);

        List<NotificationEntity> entities =
                notificationRepository.findTop50ByUserOrderByCreatedAtDesc(user);

        if (limit > 0 && entities.size() > limit) {
            entities = entities.subList(0, limit);
        }

        return notificationMapper.toDtoList(entities);
    }

    @Override
    public void markAsRead(Authentication authentication, Long id) {
        AppUserEntity user = getCurrentUser(authentication);

        notificationRepository.findByIdAndUser(id, user)
                .ifPresent(entity -> {
                    if (entity.getReadAt() == null) {
                        entity.setReadAt(Instant.now(clock));
                        notificationRepository.save(entity);
                        log.debug("Notifikace {} oznaÄŤena jako pĹ™eÄŤtenĂˇ pro user {}", id, user.getId());
                    }
                });
    }

    @Override
    public void markAllAsRead(Authentication authentication) {
        AppUserEntity user = getCurrentUser(authentication);

        List<NotificationEntity> unread =
                notificationRepository.findByUserAndReadAtIsNullOrderByCreatedAtDesc(user);

        if (!unread.isEmpty()) {
            Instant now = Instant.now(clock);
            for (NotificationEntity entity : unread) {
                entity.setReadAt(now);
            }
            notificationRepository.saveAll(unread);
            log.debug("OznaÄŤeno {} notifikacĂ­ jako pĹ™eÄŤtenĂ˝ch pro user {}", unread.size(), user.getId());
        }
    }

    @Override
    public List<NotificationDTO> getAllNotifications(int limit) {
        List<NotificationEntity> entities = notificationRepository.findAllByOrderByCreatedAtDesc();

        if (limit > 0 && entities.size() > limit) {
            entities = entities.subList(0, limit);
        }

        return notificationMapper.toDtoList(entities);
    }

    /**
     * UrÄŤuje ÄŤasovou hranici pro vĂ˝bÄ›r notifikacĂ­.
     *
     * Pokud mĂˇ uĹľivatel nastaven lastLoginAt, pouĹľije se tato hodnota.
     * Jinak se pouĹľije aktuĂˇlnĂ­ ÄŤas mĂ­nus DEFAULT_DAYS_IF_NO_LAST_LOGIN dnĂ­.
     *
     * @param user uĹľivatel, pro kterĂ©ho se ÄŤasovĂˇ hranice urÄŤuje
     * @return ÄŤasovĂˇ hranice pro vĂ˝bÄ›r notifikacĂ­
     */
    private Instant resolveBoundary(AppUserEntity user) {
        if (user.getLastLoginAt() != null) {
            return user.getLastLoginAt();
        }
        return Instant.now(clock).minus(DEFAULT_DAYS_IF_NO_LAST_LOGIN, ChronoUnit.DAYS);
    }

    /**
     * NaÄŤte entitu aktuĂˇlnĂ­ho uĹľivatele podle e-mailu
     * z autentizaÄŤnĂ­ho kontextu.
     *
     * @param authentication autentizaÄŤnĂ­ kontext
     * @return entita uĹľivatele
     */
    private AppUserEntity getCurrentUser(Authentication authentication) {
        String email = authentication.getName();
        return appUserRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException(email));
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\NotificationService.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.NotificationType;

/**
 * RozhranĂ­ pro odesĂ­lĂˇnĂ­ notifikacĂ­ hrĂˇÄŤĹŻm a uĹľivatelĹŻm.
 *
 * Definuje jednotnĂ˝ vstupnĂ­ bod pro notifikaÄŤnĂ­ logiku v aplikaci.
 * Implementace na zĂˇkladÄ› typu notifikace a kontextu rozhoduje,
 * jakĂ˝m kanĂˇlem a s jakĂ˝m obsahem bude pĹ™Ă­jemce informovĂˇn.
 *
 * ĂšÄŤel:
 * - centralizovat notifikaÄŤnĂ­ logiku do jednoho mĂ­sta,
 * - oddÄ›lit business udĂˇlosti od konkrĂ©tnĂ­ formy notifikace,
 * - umoĹľnit snadnĂ© rozĹˇĂ­Ĺ™enĂ­ o dalĹˇĂ­ typy notifikacĂ­ a kanĂˇly.
 *
 * Metody tohoto rozhranĂ­ se typicky volajĂ­ z business sluĹľeb
 * v reakci na konkrĂ©tnĂ­ udĂˇlosti (registrace na zĂˇpas, zmÄ›na hesla,
 * aktivace ĂşÄŤtu a podobnÄ›).
 */
public interface NotificationService {

    /**
     * OdeĹˇle notifikaci konkrĂ©tnĂ­mu hrĂˇÄŤi.
     *
     * Parametr context nese dodateÄŤnĂ© informace potĹ™ebnĂ©
     * pro sestavenĂ­ obsahu notifikace. Typicky se jednĂˇ
     * o domĂ©novou entitu nebo kontextovĂ˝ objekt souvisejĂ­cĂ­
     * s danou udĂˇlostĂ­. MĹŻĹľe bĂ˝t null u jednoduĹˇĹˇĂ­ch notifikacĂ­.
     *
     * PĹ™Ă­klady:
     * - MatchRegistrationEntity pro registraci, odhlĂˇĹˇenĂ­ a omluvu,
     * - null pro vytvoĹ™enĂ­ hrĂˇÄŤe nebo zmÄ›nu stavu.
     *
     * @param player  hrĂˇÄŤ, kterĂ©mu je notifikace urÄŤena
     * @param type    typ notifikace
     * @param context kontextovĂˇ data souvisejĂ­cĂ­ s notifikacĂ­
     */
    void notifyPlayer(PlayerEntity player, NotificationType type, Object context);

    /**
     * OdeĹˇle notifikaci konkrĂ©tnĂ­mu uĹľivateli.
     *
     * PouĹľĂ­vĂˇ se zejmĂ©na pro systĂ©movĂ© notifikace na Ăşrovni ĂşÄŤtu,
     * napĹ™Ă­klad aktivace ĂşÄŤtu, reset hesla nebo zmÄ›na hesla.
     *
     * @param user    uĹľivatel, kterĂ©mu je notifikace urÄŤena
     * @param type    typ notifikace
     * @param context kontextovĂˇ data souvisejĂ­cĂ­ s notifikacĂ­
     */
    void notifyUser(AppUserEntity user,
                    NotificationType type,
                    Object context);
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\NotificationServiceImpl.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.AppUserSettingsEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.GlobalNotificationLevel;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.models.services.NotificationDecision;
import cz.phsoft.hokej.models.services.email.EmailMessageBuilder;
import cz.phsoft.hokej.models.services.email.EmailService;
import cz.phsoft.hokej.models.services.sms.SmsMessageBuilder;
import cz.phsoft.hokej.models.services.sms.SmsService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.EnumSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;

/**
 * Implementace NotificationService.
 *
 * ZajiĹˇĹĄuje:
 * - pouĹľitĂ­ NotificationPreferencesService pro rozhodnutĂ­, komu notifikaci poslat,
 * - sestavenĂ­ obsahu zprĂˇv pomocĂ­ EmailMessageBuilder a SmsMessageBuilder,
 * - odesĂ­lĂˇnĂ­ e-mailĹŻ pomocĂ­ EmailService,
 * - odesĂ­lĂˇnĂ­ SMS pomocĂ­ SmsService,
 * - rozesĂ­lĂˇnĂ­ kopiĂ­ vybranĂ˝ch notifikacĂ­ manaĹľerĹŻm.
 *
 * TĹ™Ă­da neĹ™eĹˇĂ­:
 * - perzistenci notifikacĂ­,
 * - detailnĂ­ business pravidla, kdy se mĂˇ notifikace vyvolat.
 */
@Service
public class NotificationServiceImpl implements NotificationService {

    private static final Logger log = LoggerFactory.getLogger(NotificationServiceImpl.class);

    private final AppUserRepository appUserRepository;
    private final EmailService emailService;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;
    private final EmailMessageBuilder emailMessageBuilder;
    private final NotificationPreferencesService notificationPreferencesService;
    private final InAppNotificationService inAppNotificationService;

    // demo reĹľim a ĂşloĹľiĹˇtÄ› notifikacĂ­ pro demo
    private final DemoModeService demoModeService;
    private final DemoNotificationStore demoNotificationStore;

    /**
     * Typy notifikacĂ­, pro kterĂ© se nemĂˇ posĂ­lat kopie manaĹľerĹŻm.
     * PlatĂ­ jak pro notifyPlayer, tak pro notifyUser.
     */
    private static final Set<NotificationType> MANAGER_COPY_BLACKLIST = EnumSet.of(
            NotificationType.MATCH_CANCELED,
            NotificationType.MATCH_TIME_CHANGED,
            NotificationType.MATCH_UNCANCELED,
            NotificationType.MATCH_REMINDER
    );

    public NotificationServiceImpl(
            AppUserRepository appUserRepository,
            EmailService emailService,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder,
            EmailMessageBuilder emailMessageBuilder,
            NotificationPreferencesService notificationPreferencesService,
            DemoModeService demoModeService,
            DemoNotificationStore demoNotificationStore,
            InAppNotificationService inAppNotificationService
    ) {
        this.appUserRepository = appUserRepository;
        this.emailService = emailService;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
        this.emailMessageBuilder = emailMessageBuilder;
        this.notificationPreferencesService = notificationPreferencesService;
        this.demoModeService = demoModeService;
        this.demoNotificationStore = demoNotificationStore;
        this.inAppNotificationService = inAppNotificationService;
    }

    @Override
    public void notifyPlayer(PlayerEntity player,
                             NotificationType type,
                             Object context) {

        if (player == null) {
            log.warn("notifyPlayer() called with null player for type {}", type);
            return;
        }

        try {
            // 1) RozhodnutĂ­ podle nastavenĂ­
            NotificationDecision decision = notificationPreferencesService.evaluate(player, type);
            log.info("notifyPlayer decision: type={}, playerId={}, sendUserEmail={}, sendPlayerEmail={}, sendSms={}",
                    type, player.getId(),
                    decision.isSendEmailToUser(),
                    decision.isSendEmailToPlayer(),
                    decision.isSendSmsToPlayer()
            );

            // Sestavit emailTo: vĹˇechny emaily, kam se mĂˇ posĂ­lat (user + player), bez duplicit
            String emailTo = null;
            if (decision.isSendEmailToUser() && decision.getUserEmail() != null && !decision.getUserEmail().isBlank()) {
                emailTo = decision.getUserEmail().trim();
            }
            if (decision.isSendEmailToPlayer() && decision.getPlayerEmail() != null && !decision.getPlayerEmail().isBlank()) {
                String playerEmail = decision.getPlayerEmail().trim();
                if (emailTo == null) {
                    emailTo = playerEmail;
                } else if (!emailTo.equalsIgnoreCase(playerEmail)) {
                    emailTo = emailTo + ", " + playerEmail;
                }
            }

            // Sestavit smsTo â€“ pouze hrĂˇÄŤ
            String smsTo = null;
            if (decision.isSendSmsToPlayer()
                    && decision.getPlayerPhone() != null
                    && !decision.getPlayerPhone().isBlank()) {
                smsTo = decision.getPlayerPhone().trim();
            }

            // 2) In-app notifikace s informacĂ­ o kanĂˇlech
            try {
                inAppNotificationService.storeForPlayer(player, type, context, emailTo, smsTo);
            } catch (Exception ex) {
                log.error("notifyPlayer: chyba pĹ™i uklĂˇdĂˇnĂ­ in-app notifikace type={} playerId={}",
                        type, player.getId(), ex);
            }

            // 3) E-maily / SMS â€“ vlastnĂ­ odeslĂˇnĂ­ (beze zmÄ›n, jen pouĹľijeme decision)
            // E-mail pro uĹľivatele
            if (decision.isSendEmailToUser() && decision.getUserEmail() != null) {
                sendEmailToUser(decision.getUserEmail(), player, type, context);
            }

            // E-mail pro hrĂˇÄŤe
            if (decision.isSendEmailToPlayer() && decision.getPlayerEmail() != null) {
                sendEmailToPlayer(decision.getPlayerEmail(), player, type, context);
            }

            // SMS pro hrĂˇÄŤe
            if (decision.isSendSmsToPlayer() && decision.getPlayerPhone() != null) {
                sendSmsToPhone(decision.getPlayerPhone(), player, type, context);
            }

            // Kopie manaĹľerĹŻm â€“ logika beze zmÄ›ny
            if (shouldSendManagerCopy(type)) {
                // ... existujĂ­cĂ­ kĂłd pro manaĹľerskĂ© kopie ...
            } else {
                log.debug("Typ {} je v MANAGER_COPY_BLACKLIST â€“ kopie manaĹľerĹŻm se neposĂ­lĂˇ (notifyPlayer).", type);
            }

            log.debug("notifyPlayer: in-app + e-mail/SMS notifikace zpracovĂˇna pro type={} playerId={}",
                    type, player.getId());

        } catch (Exception ex) {
            log.error("notifyPlayer: chyba pĹ™i zpracovĂˇnĂ­ notifikace type={} playerId={}",
                    type, player.getId(), ex);
        }
    }

    @Override
    public void notifyUser(AppUserEntity user,
                           NotificationType type,
                           Object context) {

        if (user == null) {
            log.warn("notifyUser() called with null user for type {}", type);
            return;
        }

        String userEmail = user.getEmail();
        String emailTo = (userEmail != null && !userEmail.isBlank()) ? userEmail.trim() : null;

        // 1) In-app notifikace s informacĂ­ o emailTo
        try {
            Object effectiveContext = (context != null) ? context : user;
            inAppNotificationService.storeForUser(user, type, effectiveContext, emailTo);
        } catch (Exception ex) {
            log.error("notifyUser: chyba pĹ™i uklĂˇdĂˇnĂ­ in-app notifikace type={} userId={}",
                    type, user.getId(), ex);
        }

        // 2) E-maily a kopie manaĹľerĹŻm â€“ pĹŻvodnĂ­ logika (jen jsem vyhodil duplicitnĂ­ rozhodovĂˇnĂ­ okolo emailTo)
        try {
            Object effectiveContext = (context != null) ? context : user;

            if (userEmail != null && !userEmail.isBlank()) {
                EmailMessageBuilder.EmailContent content =
                        emailMessageBuilder.buildForUser(type, null, userEmail, effectiveContext);

                if (content != null) {
                    if (demoModeService.isDemoMode()) {
                        demoNotificationStore.addEmail(
                                userEmail,
                                content.subject(),
                                content.body(),
                                content.html(),
                                type,
                                "USER"
                        );
                        log.debug("DEMO MODE: notifyUser e-mail USER uloĹľen do DemoNotificationStore, nic se neodesĂ­lĂˇ");
                    } else {
                        if (content.html()) {
                            emailService.sendHtmlEmail(userEmail, content.subject(), content.body());
                        } else {
                            emailService.sendSimpleEmail(userEmail, content.subject(), content.body());
                        }
                    }
                } else {
                    log.debug("Typ {} nemĂˇ definovanou e-mailovou Ĺˇablonu pro uĹľivatele (USER), nic se neposĂ­lĂˇ", type);
                }
            } else {
                log.debug("notifyUser: uĹľivatel {} nemĂˇ e-mail, nic se neposĂ­lĂˇ", user.getId());
            }

            // ... zbytek notifyUser (manaĹľeĹ™i, blacklist) beze zmÄ›ny ...

        } catch (Exception ex) {
            log.error("notifyUser: chyba pĹ™i zpracovĂˇnĂ­ e-mailĹŻ/kopiĂ­ pro type={} userId={}",
                    type, user.getId(), ex);
        }
    }

    // PomocnĂ© metody pro e-mail

    private void sendEmailToManager(AppUserEntity manager,
                                    PlayerEntity player,
                                    NotificationType type,
                                    Object context) {

        if (manager == null || manager.getEmail() == null || manager.getEmail().isBlank()) {
            log.debug("sendEmailToManager: prĂˇzdnĂ˝ manager nebo e-mail, nic se neposĂ­lĂˇ");
            return;
        }

        String email = manager.getEmail();

        EmailMessageBuilder.EmailContent content =
                emailMessageBuilder.buildForManager(type, player, manager, context);

        if (content == null) {
            log.debug("Typ {} nemĂˇ definovanou e-mailovou Ĺˇablonu pro manaĹľera, nic se neposĂ­lĂˇ", type);
            return;
        }

        // DEMO reĹľim â€“ uloĹľenĂ­ do DemoNotificationStore
        if (demoModeService.isDemoMode()) {
            // DEMO CHANGED: pouĹľĂ­vĂˇme novou signaturu addEmail(...)
            demoNotificationStore.addEmail(
                    email,
                    content.subject(),
                    content.body(),
                    content.html(),
                    type,
                    "MANAGER"
            );
            log.debug("DEMO MODE: sendEmailToManager â€“ e-mail uloĹľen do DemoNotificationStore, nic se neodesĂ­lĂˇ");
            return;
        }
        // KONEC DEMO

        if (content.html()) {
            emailService.sendHtmlEmail(email, content.subject(), content.body());
        } else {
            emailService.sendSimpleEmail(email, content.subject(), content.body());
        }
    }

    private void sendEmailToUser(String email,
                                 PlayerEntity player,
                                 NotificationType type,
                                 Object context) {

        if (email == null || email.isBlank()) {
            log.debug("sendEmailToUser: prĂˇzdnĂ˝ e-mail, nic se neposĂ­lĂˇ");
            return;
        }

        EmailMessageBuilder.EmailContent content =
                emailMessageBuilder.buildForUser(type, player, email, context);

        if (content == null) {
            log.debug("Typ {} nemĂˇ definovanou e-mailovou Ĺˇablonu pro uĹľivatele, nic se neposĂ­lĂˇ", type);
            return;
        }

        // DEMO reĹľim â€“ uloĹľenĂ­ do DemoNotificationStore
        if (demoModeService.isDemoMode()) {
            // DEMO CHANGED: pouĹľĂ­vĂˇme novou signaturu addEmail(...)
            demoNotificationStore.addEmail(
                    email,
                    content.subject(),
                    content.body(),
                    content.html(),
                    type,
                    "USER"
            );
            log.debug("DEMO MODE: sendEmailToUser â€“ e-mail uloĹľen do DemoNotificationStore, nic se neodesĂ­lĂˇ");
            return;
        }
        // KONEC DEMO

        if (content.html()) {
            emailService.sendHtmlEmail(email, content.subject(), content.body());
        } else {
            emailService.sendSimpleEmail(email, content.subject(), content.body());
        }
    }

    private void sendEmailToPlayer(String email,
                                   PlayerEntity player,
                                   NotificationType type,
                                   Object context) {

        if (email == null || email.isBlank()) {
            log.debug("sendEmailToPlayer: prĂˇzdnĂ˝ e-mail, nic se neposĂ­lĂˇ");
            return;
        }

        EmailMessageBuilder.EmailContent content =
                emailMessageBuilder.buildForPlayer(type, player, email, context);

        if (content == null) {
            log.debug("Typ {} nemĂˇ definovanou e-mailovou Ĺˇablonu pro hrĂˇÄŤe, nic se neposĂ­lĂˇ", type);
            return;
        }

        // DEMO reĹľim â€“ uloĹľenĂ­ do DemoNotificationStore
        if (demoModeService.isDemoMode()) {
            // DEMO CHANGED: pouĹľĂ­vĂˇme novou signaturu addEmail(...)
            demoNotificationStore.addEmail(
                    email,
                    content.subject(),
                    content.body(),
                    content.html(),
                    type,
                    "PLAYER"
            );
            log.debug("DEMO MODE: sendEmailToPlayer â€“ e-mail uloĹľen do DemoNotificationStore, nic se neodesĂ­lĂˇ");
            return;
        }
        // KONEC DEMO

        if (content.html()) {
            emailService.sendHtmlEmail(email, content.subject(), content.body());
        } else {
            emailService.sendSimpleEmail(email, content.subject(), content.body());
        }
    }

    // SMS pomocnĂˇ metoda

    private void sendSmsToPhone(String phone,
                                PlayerEntity player,
                                NotificationType type,
                                Object context) {

        if (phone == null || phone.isBlank()) {
            log.debug("sendSmsToPhone: prĂˇzdnĂ˝ telefon â€“ SMS se nepoĹˇle (player {})", player != null ? player.getId() : null);
            return;
        }

        String msg = smsMessageBuilder.buildForNotification(type, player, context);

        if (msg == null || msg.isBlank()) {
            log.debug("Typ {} nemĂˇ definovanou SMS Ĺˇablonu nebo chybĂ­ context â€“ SMS se neposĂ­lĂˇ", type);
            return;
        }

        // DEMO reĹľim â€“ uloĹľenĂ­ do DemoNotificationStore
        if (demoModeService.isDemoMode()) {
            // DEMO CHANGED: pouĹľĂ­vĂˇme novou signaturu addSms(...)
            demoNotificationStore.addSms(
                    phone,
                    msg,
                    type
            );
            log.debug("DEMO MODE: sendSmsToPhone â€“ SMS uloĹľena do DemoNotificationStore, nic se neodesĂ­lĂˇ");
            return;
        }
        // KONEC DEMO

        smsService.sendSms(phone, msg);
    }

    /**
     * UrÄŤuje, zda se pro danĂ˝ typ notifikace majĂ­ posĂ­lat kopie manaĹľerĹŻm.
     *
     * Pokud je typ uveden v MANAGER_COPY_BLACKLIST, kopie se neposĂ­lajĂ­.
     */
    private boolean shouldSendManagerCopy(NotificationType type) {
        return !MANAGER_COPY_BLACKLIST.contains(type);
    }

    /**
     * UrÄŤuje, zda mĂˇ konkrĂ©tnĂ­ manaĹľer dostat kopii danĂ©ho typu notifikace.
     *
     * Vyhodnocuje nastavenĂ­ managerNotificationLevel na AppUserSettingsEntity.
     * Pokud nenĂ­ nastaveno, pouĹľĂ­vĂˇ se globalNotificationLevel. Pokud nenĂ­
     * k dispozici ani globĂˇlnĂ­ ĂşroveĹ, pouĹľĂ­vĂˇ se vĂ˝chozĂ­ ALL.
     */
    private boolean isManagerCopyAllowedForManager(NotificationType type,
                                                   AppUserEntity manager) {
        if (manager == null) {
            return false;
        }

        AppUserSettingsEntity settings = manager.getSettings();
        GlobalNotificationLevel level;

        if (settings == null) {
            level = GlobalNotificationLevel.ALL;
        } else if (settings.getManagerNotificationLevel() != null) {
            level = settings.getManagerNotificationLevel();
        } else if (settings.getGlobalNotificationLevel() != null) {
            level = settings.getGlobalNotificationLevel();
        } else {
            level = GlobalNotificationLevel.ALL;
        }

        return isEnabledForType(type, level);
    }

    /**
     * VyhodnotĂ­, zda je danĂ˝ typ notifikace povolen pro zvolenou ĂşroveĹ.
     *
     * NONE           znamenĂˇ, Ĺľe se notifikace neposĂ­lajĂ­.
     * ALL            znamenĂˇ, Ĺľe se posĂ­lajĂ­ vĹˇechny typy.
     * IMPORTANT_ONLY znamenĂˇ, Ĺľe se posĂ­lajĂ­ pouze dĹŻleĹľitĂ© typy.
     */
    private boolean isEnabledForType(NotificationType type,
                                     GlobalNotificationLevel level) {
        return switch (level) {
            case NONE -> false;
            case ALL -> true;
            case IMPORTANT_ONLY -> type.isImportant();
        };
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\package-info.java
-----
/**
 * NotifikaÄŤnĂ­ subsystĂ©m aplikace.
 *
 * ZajiĹˇĹĄuje rozhodovĂˇnĂ­ o odesĂ­lĂˇnĂ­ notifikacĂ­
 * a pĹ™Ă­pravu kontextu pro emailovĂ© a SMS zprĂˇvy.
 *
 * Obsahuje:
 * - rozhodovacĂ­ logiku podle typu udĂˇlosti,
 * - kontextovĂ© objekty pro generovĂˇnĂ­ zprĂˇv,
 * - vazby na emailovĂ© a SMS sluĹľby.
 *
 * NeĹ™eĹˇĂ­ samotnĂ© odesĂ­lĂˇnĂ­ zprĂˇv.
 */
package cz.phsoft.hokej.models.services.notification;

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\SpecialNotificationService.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.models.dto.requests.SpecialNotificationRequestDTO;
import cz.phsoft.hokej.models.dto.SpecialNotificationTargetDTO;
import java.util.List;

/**
 * SluĹľba pro odesĂ­lĂˇnĂ­ speciĂˇlnĂ­ch zprĂˇv administrĂˇtorem.
 *
 * ZajiĹˇĹĄuje vytvoĹ™enĂ­ in-app notifikacĂ­ a podle nastavenĂ­
 * takĂ© odeslĂˇnĂ­ emailĹŻ a SMS zprĂˇv, bez ohledu na
 * individuĂˇlnĂ­ uĹľivatelskĂˇ notifikaÄŤnĂ­ nastavenĂ­.
 */
public interface SpecialNotificationService {

    /**
     * OdesĂ­lĂˇ speciĂˇlnĂ­ zprĂˇvu na zĂˇkladÄ› vstupnĂ­ho DTO.
     *
     * Pro kaĹľdĂ˝ uvedenĂ˝ cĂ­l se:
     * - uloĹľĂ­ in-app notifikace typu SPECIAL_MESSAGE,
     * - volitelnÄ› odeĹˇle email,
     * - volitelnÄ› odeĹˇle SMS.
     *
     * @param request definice zprĂˇvy a seznam pĹ™Ă­jemcĹŻ
     */
    void sendSpecialNotification(SpecialNotificationRequestDTO request);

    /**
     * NaÄŤĂ­tĂˇ seznam moĹľnĂ˝ch pĹ™Ă­jemcĹŻ speciĂˇlnĂ­ zprĂˇvy.
     *
     * Zahrnuje:
     * - schvĂˇlenĂ© hrĂˇÄŤe (approved), kteĹ™Ă­ majĂ­ pĹ™iĹ™azenĂ©ho uĹľivatele,
     * - aktivnĂ­ uĹľivatele bez hrĂˇÄŤe (enabled).
     *
     * @return seznam cĂ­lĹŻ pro speciĂˇlnĂ­ notifikaci
     */
    List<SpecialNotificationTargetDTO> getSpecialNotificationTargets();
}


-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\SpecialNotificationServiceImpl.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerSettingsEntity;
import cz.phsoft.hokej.data.enums.NotificationType;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.data.repositories.PlayerSettingsRepository;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.exceptions.UserNotFoundException;
import cz.phsoft.hokej.models.dto.SpecialNotificationTargetDTO;
import cz.phsoft.hokej.models.dto.requests.SpecialNotificationRequestDTO;
import cz.phsoft.hokej.models.services.email.EmailMessageBuilder;
import cz.phsoft.hokej.models.services.email.EmailService;
import cz.phsoft.hokej.models.services.sms.SmsMessageBuilder;
import cz.phsoft.hokej.models.services.sms.SmsService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;

/**
 * Implementace sluĹľby pro odesĂ­lĂˇnĂ­ speciĂˇlnĂ­ch zprĂˇv.
 *
 * SluĹľba kombinuje:
 * - uloĹľenĂ­ in-app notifikacĂ­ (InAppNotificationService),
 * - odeslĂˇnĂ­ emailĹŻ (EmailService),
 * - odeslĂˇnĂ­ SMS (SmsService).
 *
 * VĹˇechny akce se provĂˇdÄ›jĂ­ bez ohledu na uĹľivatelskĂˇ
 * notifikaÄŤnĂ­ nastavenĂ­. SelhĂˇnĂ­ emailu nebo SMS
 * neblokuje uloĹľenĂ­ in-app notifikace.
 *
 * V DEMO reĹľimu se e-maily a SMS fyzicky neodesĂ­lajĂ­.
 * MĂ­sto toho se uklĂˇdajĂ­ do DemoNotificationStore a
 * vracĂ­ se na frontend pĹ™es demo endpoint.
 */
@Service
public class SpecialNotificationServiceImpl implements SpecialNotificationService {

    private static final Logger log = LoggerFactory.getLogger(SpecialNotificationServiceImpl.class);

    private final AppUserRepository appUserRepository;
    private final PlayerRepository playerRepository;
    private final PlayerSettingsRepository playerSettingsRepository;
    private final InAppNotificationService inAppNotificationService;
    private final EmailService emailService;
    private final SmsService smsService;
    private final EmailMessageBuilder emailMessageBuilder;
    private final SmsMessageBuilder smsMessageBuilder;

    // DEMO reĹľim
    private final DemoModeService demoModeService;
    private final DemoNotificationStore demoNotificationStore;

    public SpecialNotificationServiceImpl(AppUserRepository appUserRepository,
                                          PlayerRepository playerRepository,
                                          PlayerSettingsRepository playerSettingsRepository,
                                          InAppNotificationService inAppNotificationService,
                                          EmailService emailService,
                                          SmsService smsService,
                                          EmailMessageBuilder emailMessageBuilder,
                                          SmsMessageBuilder smsMessageBuilder,
                                          DemoModeService demoModeService,
                                          DemoNotificationStore demoNotificationStore) {
        this.appUserRepository = appUserRepository;
        this.playerRepository = playerRepository;
        this.playerSettingsRepository = playerSettingsRepository;
        this.inAppNotificationService = inAppNotificationService;
        this.emailService = emailService;
        this.smsService = smsService;
        this.emailMessageBuilder = emailMessageBuilder;
        this.smsMessageBuilder = smsMessageBuilder;
        this.demoModeService = demoModeService;
        this.demoNotificationStore = demoNotificationStore;
    }

    @Override
    public void sendSpecialNotification(SpecialNotificationRequestDTO request) {
        Objects.requireNonNull(request, "request must not be null");

        if (request.getTargets() == null || request.getTargets().isEmpty()) {
            log.debug("SpecialNotificationService.sendSpecialNotification: prĂˇzdnĂ˝ seznam pĹ™Ă­jemcĹŻ, nic se neprovĂˇdĂ­");
            return;
        }

        request.getTargets().forEach(target -> {
            AppUserEntity user = appUserRepository.findById(target.getUserId())
                    .orElseThrow(() -> new UserNotFoundException(target.getUserId()));

            PlayerEntity player = null;
            PlayerSettingsEntity playerSettings = null;

            if (target.getPlayerId() != null) {
                player = playerRepository.findById(target.getPlayerId())
                        .orElseThrow(() -> new PlayerNotFoundException(target.getPlayerId()));

                playerSettings = playerSettingsRepository.findByPlayer(player)
                        .orElse(null);
            }

            String emailTo = null;
            String smsTo = null;

            // EMAIL
            if (request.isSendEmail()) {
                emailTo = resolveEmail(user, playerSettings);
                if (emailTo != null && !emailTo.isBlank()) {
                    sendSpecialEmail(emailTo, user, player, request);
                } else {
                    log.debug(
                            "SpecialNotificationService.sendSpecialNotification: nenĂ­ k dispozici email pro playerId={} (userId={})",
                            player != null ? player.getId() : null,
                            user.getId()
                    );
                    emailTo = null;
                }
            }

            // SMS
            if (request.isSendSms() && playerSettings != null) {
                smsTo = resolvePhoneNumber(playerSettings);
                if (smsTo != null && !smsTo.isBlank()) {
                    sendSpecialSms(smsTo, player, request);
                } else {
                    log.debug(
                            "SpecialNotificationService.sendSpecialNotification: chybĂ­ telefonnĂ­ ÄŤĂ­slo pro playerId={} (userId={})",
                            player != null ? player.getId() : null,
                            user.getId()
                    );
                    smsTo = null;
                }
            }

            // IN-APP â€“ SPECIAL_MESSAGE + audit kanĂˇlĹŻ
            inAppNotificationService.storeSpecialMessage(
                    user,
                    player,
                    request.getTitle(),
                    request.getMessage(),
                    emailTo,
                    smsTo
            );
        });
    }

    /**
     * NaÄŤĂ­tĂˇ moĹľnĂ© cĂ­le pro speciĂˇlnĂ­ notifikaci.
     *
     * Zahrnuje:
     * - (do budoucna) schvĂˇlenĂ© hrĂˇÄŤe s pĹ™iĹ™azenĂ˝m aktivnĂ­m uĹľivatelem,
     * - aktivnĂ­ uĹľivatele bez pĹ™iĹ™azenĂ˝ch hrĂˇÄŤĹŻ.
     *
     * AktuĂˇlnÄ› se neschvaluje podle PlayerStatus, pouze podle existence
     * uĹľivatele a pĹ™Ă­znaku enabled. FiltrovĂˇnĂ­ podle "APPROVED" mĹŻĹľeĹˇ
     * doplnit v pĹ™Ă­padÄ›, Ĺľe budeĹˇ mĂ­t na PlayerEntity vhodnou property.
     */
    @Override
    public List<SpecialNotificationTargetDTO> getSpecialNotificationTargets() {

        List<SpecialNotificationTargetDTO> result = new ArrayList<>();

        // 1) HrĂˇÄŤi s pĹ™iĹ™azenĂ˝m aktivnĂ­m uĹľivatelem
        List<PlayerEntity> allPlayers = playerRepository.findAll();

        for (PlayerEntity player : allPlayers) {

            AppUserEntity user = player.getUser();
            if (user == null || !user.isEnabled()) {
                // hrĂˇÄŤ bez uĹľivatele nebo uĹľivatel nenĂ­ aktivnĂ­ â€“ pĹ™eskoÄŤit
                continue;
            }

            // TODO: pokud budeĹˇ mĂ­t na PlayerEntity nÄ›co jako getStatus() == PlayerStatus.APPROVED,
            // mĹŻĹľeĹˇ tady pĹ™idat filtr:
            // if (player.getStatus() != PlayerStatus.APPROVED) continue;

            String userName = buildUserFullName(user);
            String displayName = player.getFullName() + " (" + userName + ", " + user.getEmail() + ")";

            SpecialNotificationTargetDTO dto = new SpecialNotificationTargetDTO();
            dto.setUserId(user.getId());
            dto.setPlayerId(player.getId());
            dto.setDisplayName(displayName);
            dto.setType("PLAYER");

            result.add(dto);
        }

        // 2) AktivnĂ­ uĹľivatelĂ© bez hrĂˇÄŤĹŻ
        List<AppUserEntity> allUsers = appUserRepository.findAll();

        allUsers.stream()
                .filter(AppUserEntity::isEnabled)
                .filter(user -> user.getPlayers() == null || user.getPlayers().isEmpty())
                .forEach(user -> {
                    String userName = buildUserFullName(user);
                    String displayName = userName + " (" + user.getEmail() + ")";

                    SpecialNotificationTargetDTO dto = new SpecialNotificationTargetDTO();
                    dto.setUserId(user.getId());
                    dto.setPlayerId(null);
                    dto.setDisplayName(displayName);
                    dto.setType("USER");

                    result.add(dto);
                });

        // setĹ™Ă­dit podle displayName
        result.sort(Comparator.comparing(
                SpecialNotificationTargetDTO::getDisplayName,
                String.CASE_INSENSITIVE_ORDER
        ));

        log.debug("SpecialNotificationService.getSpecialNotificationTargets: vrĂˇceno {} cĂ­lĹŻ", result.size());

        return result;
    }

    /**
     * OdesĂ­lĂˇ email se speciĂˇlnĂ­ zprĂˇvou.
     *
     * Implementace pouĹľĂ­vĂˇ EmailMessageBuilder pro sestavenĂ­
     * obsahu emailu v jednotnĂ©m formĂˇtu. Email se odesĂ­lĂˇ
     * prostĹ™ednictvĂ­m EmailService bez ohledu na uĹľivatelskĂˇ
     * nastavenĂ­ notifikacĂ­.
     *
     * V DEMO reĹľimu se email neodesĂ­lĂˇ, ale uklĂˇdĂˇ se
     * do DemoNotificationStore.
     */
    private void sendSpecialEmail(String to,
                                  AppUserEntity user,
                                  PlayerEntity player,
                                  SpecialNotificationRequestDTO request) {

        if (to == null || to.isBlank()) {
            return;
        }

        EmailMessageBuilder.EmailContent content =
                emailMessageBuilder.buildSpecialMessage(
                        user,
                        player,
                        request.getTitle(),
                        request.getMessage()
                );

        if (content == null) {
            log.debug("SpecialNotificationService.sendSpecialEmail: EmailContent je null, nic se neodesĂ­lĂˇ");
            return;
        }

        // DEMO reĹľim â€“ uloĹľit do demo ĂşloĹľiĹˇtÄ› a nevolat SMTP
        if (demoModeService.isDemoMode()) {
            demoNotificationStore.addEmail(
                    to,
                    content.subject(),
                    content.body(),
                    content.html(),
                    NotificationType.SPECIAL_MESSAGE,
                    "SPECIAL"
            );
            log.debug("DEMO MODE: speciĂˇlnĂ­ e-mail uloĹľen do DemoNotificationStore, nic se neodesĂ­lĂˇ (to={})", to);
            return;
        }

        try {
            if (content.html()) {
                emailService.sendHtmlEmail(to, content.subject(), content.body());
            } else {
                emailService.sendSimpleEmail(to, content.subject(), content.body());
            }
        } catch (Exception ex) {
            log.warn("NepodaĹ™ilo se odeslat speciĂˇlnĂ­ email na {}: {}", to, ex.getMessage());
        }
    }

    /**
     * VracĂ­ telefonnĂ­ ÄŤĂ­slo pro odeslĂˇnĂ­ SMS.
     *
     * TelefonnĂ­ ÄŤĂ­slo je uloĹľeno v PlayerSettingsEntity.contactPhone.
     * NastavenĂ­ smsEnabled se u speciĂˇlnĂ­ch zprĂˇv ignoruje.
     */
    private String resolvePhoneNumber(PlayerSettingsEntity playerSettings) {
        if (playerSettings == null) {
            return null;
        }

        String phone = playerSettings.getContactPhone();
        if (phone != null && !phone.isBlank()) {
            return phone;
        }
        return null;
    }

    /**
     * OdesĂ­lĂˇ SMS se speciĂˇlnĂ­ zprĂˇvou.
     *
     * Implementace pouĹľĂ­vĂˇ SmsMessageBuilder pro sestavenĂ­
     * textu SMS tak, aby byl v jednotnĂ©m formĂˇtu se zbytkem systĂ©mu.
     *
     * V DEMO reĹľimu se SMS neodesĂ­lĂˇ, ale uklĂˇdĂˇ se
     * do DemoNotificationStore.
     */
    private void sendSpecialSms(String phoneNumber,
                                PlayerEntity player,
                                SpecialNotificationRequestDTO request) {
        if (phoneNumber == null || phoneNumber.isBlank()) {
            return;
        }

        String text = smsMessageBuilder.buildSpecialMessage(
                request.getTitle(),
                request.getMessage(),
                player
        );

        if (text == null || text.isBlank()) {
            log.debug("SpecialNotificationService.sendSpecialSms: prĂˇzdnĂ˝ text SMS, nic se neodesĂ­lĂˇ");
            return;
        }

        // DEMO reĹľim â€“ uloĹľit do demo ĂşloĹľiĹˇtÄ›
        if (demoModeService.isDemoMode()) {
            demoNotificationStore.addSms(
                    phoneNumber,
                    text,
                    NotificationType.SPECIAL_MESSAGE
            );
            log.debug("DEMO MODE: speciĂˇlnĂ­ SMS uloĹľena do DemoNotificationStore, nic se neodesĂ­lĂˇ (phone={})", phoneNumber);
            return;
        }

        try {
            smsService.sendSms(phoneNumber, text);
        } catch (Exception ex) {
            log.warn("NepodaĹ™ilo se odeslat speciĂˇlnĂ­ SMS na {}: {}", phoneNumber, ex.getMessage());
        }
    }

    /**
     * VracĂ­ preferovanĂ˝ email pro speciĂˇlnĂ­ zprĂˇvu.
     *
     * Pravidla:
     * - pokud playerSettings.contactEmail je prĂˇzdnĂ˝ â†’ pouĹľije se email uĹľivatele,
     * - pokud contactEmail je stejnĂ˝ jako email uĹľivatele (case-insensitive) â†’ pouĹľije se email uĹľivatele,
     * - pokud contactEmail je rĹŻznĂ˝ â†’ pouĹľije se contactEmail (hrĂˇÄŤskĂ˝).
     *
     * Pokud ĹľĂˇdnĂ˝ email nenĂ­ k dispozici, vracĂ­ null.
     */
    private String resolveEmail(AppUserEntity user, PlayerSettingsEntity playerSettings) {
        String userEmail = (user != null && user.getEmail() != null && !user.getEmail().isBlank())
                ? user.getEmail()
                : null;

        String playerEmail = (playerSettings != null
                && playerSettings.getContactEmail() != null
                && !playerSettings.getContactEmail().isBlank())
                ? playerSettings.getContactEmail()
                : null;

        // HrĂˇÄŤ nemĂˇ vlastnĂ­ email â†’ pouĹľije se email uĹľivatele
        if (playerEmail == null) {
            return userEmail;
        }

        // HrĂˇÄŤ mĂˇ email, ale je stejnĂ˝ jako uĹľivatel â†’ pouĹľije se email uĹľivatele
        if (userEmail != null && userEmail.equalsIgnoreCase(playerEmail)) {
            return userEmail;
        }

        // HrĂˇÄŤ mĂˇ vlastnĂ­ odliĹˇnĂ˝ email â†’ pouĹľije se hrĂˇÄŤskĂ˝ email
        return playerEmail;
    }

    /**
     * PomocnĂˇ metoda pro sestavenĂ­ celĂ©ho jmĂ©na uĹľivatele.
     */
    private String buildUserFullName(AppUserEntity user) {
        String name = user.getName() != null ? user.getName() : "";
        String surname = user.getSurname() != null ? user.getSurname() : "";
        String fullName = (name + " " + surname).trim();
        return fullName.isEmpty() ? user.getEmail() : fullName;
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\models\services\notification\UserActivationContext.java
-----
package cz.phsoft.hokej.models.services.notification;

import cz.phsoft.hokej.data.entities.AppUserEntity;

/**
 * Kontext pro notifikace souvisejĂ­cĂ­ s aktivacĂ­ uĹľivatelskĂ©ho ĂşÄŤtu.
 *
 * Obsahuje:
 * - uĹľivatele, kterĂ˝ mĂˇ bĂ˝t aktivovĂˇn,
 * - aktivaÄŤnĂ­ odkaz pouĹľitĂ˝ v e-mailu.
 *
 * SlouĹľĂ­ k oddÄ›lenĂ­ domĂ©novĂ˝ch entit od dat potĹ™ebnĂ˝ch
 * pro sestavenĂ­ aktivaÄŤnĂ­ch notifikacĂ­.
 * @param user UĹľivatel, kterĂ©mu je aktivaÄŤnĂ­ odkaz urÄŤen.
 * @param activationLink JednorĂˇzovĂ˝ odkaz pro aktivaci ĂşÄŤtu.
 */
public record UserActivationContext(
        AppUserEntity user,
        String activationLink
) {
}
