Balíček (složka): controllers
Cesta: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers

Seznam souborů:
AppModeController.java
AppUserController.java
AppUserSettingsController.java
AuthController.java
CurrentPlayerController.java
DebugController.java
DemoNotificationController.java
MatchController.java
MatchRegistrationController.java
MatchRegistrationHistoryController.java
MeController.java
package-info.java
PlayerController.java
PlayerInactivityPeriodController.java
PlayerSettingsController.java
SeasonController.java
TestController.java
TestEmailController.java
TestSmsController.java



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\AppModeController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.services.notification.DemoModeService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Map;

/**
 * REST controller, který se používá pro poskytování informací o aktuálním režimu aplikace.
 *
 * Slouží k informování frontendové části o tom, zda je aplikace spuštěna
 * v demo režimu nebo ve standardním produkčním režimu. Na základě této
 * informace může frontend podmíněně zobrazovat nebo omezovat určitou
 * funkcionalitu.
 *
 * Veškerá logika vyhodnocení režimu aplikace se deleguje na {@link DemoModeService}.
 */
@RestController
@RequestMapping("/api/public")
public class AppModeController {

    private final DemoModeService demoModeService;

    public AppModeController(DemoModeService demoModeService) {
        this.demoModeService = demoModeService;
    }

    /**
     * Vrací informaci o aktuálním režimu aplikace.
     *
     * Hodnota je určena zejména pro frontendovou část systému,
     * která na jejím základě upravuje chování uživatelského rozhraní.
     *
     * @return mapování obsahující příznak demo režimu aplikace
     */
    @GetMapping("/app-mode")
    public Map<String, Object> getAppMode() {
        return Map.of(
                "demoMode", demoModeService.isDemoMode()
        );
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\AppUserController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.AppUserHistoryDTO;
import cz.phsoft.hokej.models.dto.ChangePasswordDTO;
import cz.phsoft.hokej.models.services.AppUserHistoryService;
import cz.phsoft.hokej.models.services.AppUserService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller, který se používá pro správu uživatelských účtů.
 *
 * Zajišťuje práci s přihlášeným uživatelem, včetně zobrazení profilu, historie změn
 * a změny hesla, a také administrativní správu uživatelů, která je vyhrazena roli
 * ADMIN/MANAGER.
 *
 *
 * Veškerá business logika se předává do {@link AppUserService}.
 */
@RestController
@RequestMapping("/api/users")
public class AppUserController {

    private final AppUserService appUserService;
    private final AppUserHistoryService appUserHistoryService;

    public AppUserController(AppUserService appUserService,
                             AppUserHistoryService appUserHistoryService) {
        this.appUserService = appUserService;
        this.appUserHistoryService = appUserHistoryService;
    }

    /**
     * Vrací detail aktuálně přihlášeného uživatele.
     *
     * Identifikace uživatele se provádí podle e-mailu (username),
     * který je získán z objektu {@link Authentication}.
     *
     * @param authentication autentizační kontext přihlášeného uživatele
     * @return DTO s detaily přihlášeného uživatele
     */
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public AppUserDTO getCurrentUser(Authentication authentication) {
        return appUserService.getCurrentUser(authentication.getName());
    }

    /**
     * Aktualizuje údaje aktuálně přihlášeného uživatele.
     *
     * @param authentication autentizační kontext přihlášeného uživatele
     * @param dto            DTO s aktualizovanými údaji uživatele
     * @return HTTP odpověď s informací o úspěšné aktualizaci
     */
    @PutMapping("/me/update")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> updateUser(
            Authentication authentication,
            @Valid @RequestBody AppUserDTO dto) {

        String email = authentication.getName();
        appUserService.updateUser(email, dto);
        return ResponseEntity.ok("Uživatel byl změněn");
    }

    /**
     * Mění heslo aktuálně přihlášeného uživatele.
     *
     * Staré heslo, nové heslo a potvrzení nového hesla se předává
     * prostřednictvím DTO {@link ChangePasswordDTO}.
     *
     * @param authentication autentizační kontext přihlášeného uživatele
     * @param dto            DTO obsahující staré a nové heslo
     * @return HTTP odpověď s informací o úspěšné změně hesla
     */
    @PostMapping("/me/change-password")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> changePassword(
            Authentication authentication,
            @Valid @RequestBody ChangePasswordDTO dto) {

        String email = authentication.getName();
        appUserService.changePassword(
                email,
                dto.getOldPassword(),
                dto.getNewPassword(),
                dto.getNewPasswordConfirm()
        );
        return ResponseEntity.ok("Heslo úspěšně změněno");
    }

    // ADMIN

    /**
     * Vrací seznam všech uživatelů v systému.
     *
     * Endpoint je dostupný pouze pro roli ADMIN.
     *
     * @return seznam uživatelů jako {@link AppUserDTO}
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<AppUserDTO> getAllUsers() {
        return appUserService.getAllUsers();
    }

    /**
     * Vrací detail uživatele podle jeho ID.
     *
     * Endpoint je dostupný pouze pro roli ADMIN.
     *
     * @param id ID uživatele
     * @return DTO s detaily vybraného uživatele
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public AppUserDTO getUserById(@PathVariable Long id) {
        return appUserService.getUserById(id);
    }

    /**
     * Resetuje heslo uživatele na výchozí hodnotu.
     *
     * Operace je vyhrazena pouze pro roli ADMIN.
     *
     * @param id ID uživatele, kterému se má heslo resetovat
     * @return HTTP odpověď s informací o úspěšném resetu hesla
     */
    @PostMapping("/{id}/reset-password")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<String> resetPassword(@PathVariable Long id) {
        appUserService.resetPassword(id);
        return ResponseEntity.ok("Heslo resetováno na 'Player123'");
    }

    /**
     * Aktivuje účet uživatele.
     *
     * Operace je vyhrazena pouze pro roli ADMIN.
     *
     * @param id ID uživatele, který má být aktivován
     * @return HTTP odpověď s informací o úspěšné aktivaci
     */
    @PatchMapping("/{id}/activate")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<String> activateUserByAdmin(@PathVariable Long id) {
        appUserService.activateUserByAdmin(id);
        return ResponseEntity.ok("Uživatel byl úspěšně aktivován");
    }

    /**
     * Deaktivuje účet uživatele.
     *
     * Operace je vyhrazena pouze pro roli ADMIN.
     *
     * @param id ID uživatele, který má být deaktivován
     * @return HTTP odpověď s informací o úspěšné deaktivaci
     */
    @PatchMapping("/{id}/deactivate")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<String> deactivateUserByAdmin(@PathVariable Long id) {
        appUserService.deactivateUserByAdmin(id);
        return ResponseEntity.ok("Uživatel byl úspěšně deaktivován");
    }

    /**
     * Vrací historii uživatele dle id.
     *
     * Operace je vyhrazena pouze pro roli ADMIN.
     *
     * @param id ID uživatele
     * @return historie uživatele jako {@link List<AppUserHistoryDTO>}
     */
    @GetMapping("/{id}/history")
    @PreAuthorize("hasRole('ADMIN')")
    public List<AppUserHistoryDTO> getUserHistory(@PathVariable Long id
            ) {
        return appUserHistoryService.getHistoryForUser(id);
    }

    /**
     * Vrací historii aktuálně přihlášeného uživatele.
     *
     * @param authentication autentizační kontext přihlášeného uživatele
     * @return historie uživatele jako {@link List<AppUserHistoryDTO>}
     */
    @GetMapping("/me/history")
    @PreAuthorize("isAuthenticated()")
    public List<AppUserHistoryDTO> getMyUserHistory(
            Authentication authentication
            ) {

        String email = authentication.getName();
        return appUserHistoryService.getHistoryForUser(email);

    }

}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\AppUserSettingsController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.AppUserSettingsDTO;
import cz.phsoft.hokej.models.services.AppUserSettingsService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

/**
 * REST controller, který se používá pro správu nastavení uživatele
 * na úrovni aplikačního účtu (AppUser).
 *
 * Pracuje s nastavením navázaným na účet uživatele, nikoli na aktuálního
 * hráče. Slouží například pro nastavení preferencí uživatele a režimu
 * výběru hráče po přihlášení.
 *
 * Veškerá business logika se předává do {@link AppUserSettingsService}.
 */
@RestController
@RequestMapping("/api/user")
public class AppUserSettingsController {

    private final AppUserSettingsService appUserSettingsService;

    public AppUserSettingsController(AppUserSettingsService appUserSettingsService) {
        this.appUserSettingsService = appUserSettingsService;
    }

    /**
     * Vrací nastavení aktuálně přihlášeného uživatele.
     *
     * Uživatel se identifikuje pomocí e-mailu získaného z objektu
     * {@link Authentication}.
     *
     * @param auth autentizační kontext přihlášeného uživatele
     * @return DTO s nastavením uživatele
     */
    @GetMapping("/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<AppUserSettingsDTO> getCurrentUserSettings(Authentication auth) {
        String userEmail = auth.getName();
        AppUserSettingsDTO dto = appUserSettingsService.getSettingsForUser(userEmail);
        return ResponseEntity.ok(dto);
    }

    /**
     * Aktualizuje nastavení aktuálně přihlášeného uživatele.
     *
     * Očekává se, že frontend předá kompletní stav nastavení, který se
     * aplikuje na účet uživatele.
     *
     * @param auth       autentizační kontext přihlášeného uživatele
     * @param requestDto DTO s novým nastavením uživatele
     * @return DTO s aktualizovaným nastavením uživatele
     */
    @PatchMapping("/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<AppUserSettingsDTO> updateCurrentUserSettings(
            Authentication auth,
            @RequestBody AppUserSettingsDTO requestDto
    ) {
        String userEmail = auth.getName();
        AppUserSettingsDTO updated = appUserSettingsService.updateSettingsForUser(userEmail, requestDto);
        return ResponseEntity.ok(updated);
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\AuthController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.EmailDTO;
import cz.phsoft.hokej.models.dto.ForgottenPasswordResetDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;
import cz.phsoft.hokej.models.services.AppUserService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

/**
 * REST controller, který se používá pro autentizaci a registraci uživatelů.
 *
 * Zajišťuje registraci nových uživatelů, aktivaci účtů pomocí ověřovacího
 * tokenu, práci s přihlášeným uživatelem a proces zapomenutého hesla
 * včetně vystavení tokenu a nastavení nového hesla.
 *
 * Veškerá business logika se předává do {@link AppUserService}.
 */
@RestController
@RequestMapping("/api/auth")
public class AuthController {

    private final AppUserService appUserService;

    /**
     * Základní URL frontendové SPA aplikace (React/Vite).
     *
     * Tato hodnota se používá pro přesměrování uživatele při procesu
     * resetu hesla, aby mohl být otevřen správný route na frontend aplikaci.
     */
    @Value("${app.frontend-base-url}")
    private String frontendBaseUrl;

    public AuthController(AppUserService appUserService) {
        this.appUserService = appUserService;
    }

    /**
     * Registruje nového uživatele.
     *
     * Po úspěšné registraci se vytváří aktivační token a odesílá se
     * aktivační e-mail s odkazem na aktivaci účtu.
     *
     * @param dto registrační údaje nového uživatele
     * @return HTTP odpověď s informací o úspěšné registraci
     */
    @PostMapping("/register")
    public ResponseEntity<?> register(@Valid @RequestBody RegisterUserDTO dto) {
        appUserService.register(dto);
        return ResponseEntity.ok(
                Map.of(
                        "status", "ok",
                        "message", "Registrace úspěšná. Zkontrolujte email pro aktivaci účtu."
                )
        );
    }

    /**
     * Vrací informace o aktuálně přihlášeném uživateli.
     *
     * @param authentication autentizační kontext přihlášeného uživatele
     * @return DTO s detaily přihlášeného uživatele
     */
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<AppUserDTO> getCurrentUser(Authentication authentication) {
        AppUserDTO dto = appUserService.getCurrentUser(authentication.getName());
        return ResponseEntity.ok(dto);
    }

    /**
     * Aktivuje uživatelský účet na základě ověřovacího tokenu.
     *
     * Token se získává z aktivačního odkazu zaslaného po registraci
     * a má omezenou platnost. V případě neplatného nebo expirovaného
     * tokenu se vrací chyba 400.
     *
     * @param token aktivační token
     * @return textová informace o výsledku aktivace účtu
     */
    @GetMapping("/verify")
    public ResponseEntity<String> verifyEmail(@RequestParam String token) {
        boolean activated = appUserService.activateUser(token);

        if (!activated) {
            return ResponseEntity
                    .badRequest()
                    .body("Neplatný nebo expirovaný aktivační odkaz.");
        }

        return ResponseEntity.ok("Účet byl úspěšně aktivován.");
    }

    /**
     * Přesměrovává uživatele z odkazu v e-mailu na frontendovou stránku
     * pro nastavení nového hesla.
     *
     * Backend provádí redirect na odpovídající route frontendové SPA
     * a předává reset token jako query parametr. Samotná změna hesla
     * se následně provádí pomocí REST endpointů pro zapomenuté heslo.
     *
     * @param token reset token pro zapomenuté heslo
     * @return HTTP 302 s hlavičkou Location na frontendovou URL
     */
    @GetMapping("/reset-password")
    public ResponseEntity<Void> redirectResetPassword(@RequestParam String token) {
        String targetUrl = frontendBaseUrl + "/reset-password?token=" + token;

        return ResponseEntity
                .status(HttpStatus.FOUND)
                .header("Location", targetUrl)
                .build();
    }

    /**
     * Vytváří požadavek na reset zapomenutého hesla.
     *
     * Na základě zadané e-mailové adresy se vytvoří reset token
     * a odešle se e-mail s odkazem pro nastavení nového hesla.
     *
     * @param dto DTO s e-mailovou adresou uživatele
     * @return HTTP odpověď 200 v případě úspěchu
     */
    @PostMapping("/forgotten-password")
    public ResponseEntity<Void> requestForgottenPassword(@RequestBody @Valid EmailDTO dto) {
        appUserService.requestForgottenPasswordReset(dto.getEmail());
        return ResponseEntity.ok().build();
    }

    /**
     * Vrací informaci o e-mailu, ke kterému přísluší daný reset token.
     *
     * Endpoint se používá například pro zobrazení e-mailové adresy
     * na frontendové stránce pro reset hesla.
     *
     * @param token reset token
     * @return mapování obsahující e-mail navázaný na token
     */
    @GetMapping("/forgotten-password/info")
    public ResponseEntity<Map<String, String>> getForgottenPasswordInfo(@RequestParam String token) {
        String email = appUserService.getForgottenPasswordResetEmail(token);
        return ResponseEntity.ok(Map.of("email", email));
    }

    /**
     * Provádí nastavení nového hesla na základě reset tokenu.
     *
     * Informace o tokenu, novém hesle a jeho potvrzení se předává
     * prostřednictvím {@link ForgottenPasswordResetDTO}.
     *
     * @param dto DTO obsahující token a nové heslo
     * @return HTTP odpověď 200 v případě úspěchu
     */
    @PostMapping("/forgotten-password/reset")
    public ResponseEntity<Void> forgottenPasswordReset(@RequestBody @Valid ForgottenPasswordResetDTO dto) {
        appUserService.forgottenPasswordReset(dto);
        return ResponseEntity.ok().build();
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\CurrentPlayerController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.services.PlayerService;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller, který se používá pro práci s aktuálním hráčem
 * přihlášeného uživatele.
 *
 * Aktuální hráč představuje kontext, ve kterém uživatel pracuje
 * například při registraci na zápasy nebo při zobrazení statistik.
 * Controller umožňuje nastavení aktuálního hráče, automatický výběr
 * hráče po přihlášení a získání aktuálně zvoleného hráče.
 *
 * Veškerá business logika se předává do {@link PlayerService}
 * a {@link CurrentPlayerService}.
 */
@RestController
@RequestMapping("/api/current-player")
public class CurrentPlayerController {

    private final CurrentPlayerService currentPlayerService;
    private final PlayerService playerService;

    public CurrentPlayerController(CurrentPlayerService currentPlayerService,
                                   PlayerService playerService) {
        this.currentPlayerService = currentPlayerService;
        this.playerService = playerService;
    }

    /**
     * Nastavuje aktuálního hráče pro přihlášeného uživatele.
     *
     * Metoda se používá zejména v případech, kdy má uživatel přiřazeno
     * více hráčů a potřebuje mezi nimi ručně přepínat.
     *
     * @param playerId ID hráče, který má být nastaven jako aktuální
     * @param auth     autentizační kontext přihlášeného uživatele
     * @return DTO {@link SuccessResponseDTO} s informací o provedené změně
     */
    @PostMapping("/{playerId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<SuccessResponseDTO> setCurrentPlayer(
            @PathVariable Long playerId,
            Authentication auth) {

        SuccessResponseDTO response =
                playerService.setCurrentPlayerForUser(auth.getName(), playerId);

        return ResponseEntity.ok(response);
    }

    /**
     * Provádí automatický výběr aktuálního hráče pro přihlášeného
     * uživatele podle nastavení v AppUserSettings.
     *
     * Například může být vybrán první hráč podle ID nebo může být
     * ponechán stav bez vybraného hráče, aby si uživatel vybral hráče
     * ručně na frontendu.
     *
     * @param auth autentizační kontext přihlášeného uživatele
     * @return DTO {@link SuccessResponseDTO} s výsledkem automatického výběru
     */
    @PostMapping("/auto-select")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<SuccessResponseDTO> autoSelectCurrentPlayer(Authentication auth) {
        SuccessResponseDTO response =
                playerService.autoSelectCurrentPlayerForUser(auth.getName());

        return ResponseEntity.ok(response);
    }

    /**
     * Vrací aktuálně zvoleného hráče přihlášeného uživatele.
     *
     * Pokud není aktuální hráč nastaven, vrací se hodnota null.
     *
     * @return DTO {@link PlayerDTO} s detaily hráče nebo null
     */
    @GetMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<PlayerDTO> getCurrentPlayer() {

        Long playerId = currentPlayerService.getCurrentPlayerId();
        if (playerId == null) {
            return ResponseEntity.ok(null);
        }

        PlayerDTO player = playerService.getPlayerById(playerId);
        return ResponseEntity.ok(player);
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\DebugController.java
-----

package cz.phsoft.hokej.controllers;

import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * REST controller, který se používá pro ladění bezpečnostního kontextu.
 *
 * Umožňuje ověřit, zda je uživatel autentizován a jaké informace
 * jsou dostupné v objektu {@link Authentication}. Controller je určen
 * pouze pro vývojové prostředí a neměl by být vystaven v produkci.
 */
@RestController
public class DebugController {

    /**
     * Vrací aktuální objekt {@link Authentication}.
     *
     * Metoda se používá výhradně pro ladění a diagnostiku
     * bezpečnostního kontextu.
     *
     * @param auth autentizační kontext aktuálního uživatele
     * @return objekt {@link Authentication} s informacemi o uživateli
     */
    @GetMapping("/api/debug/me")
    public Object me(Authentication auth) {
        return auth;
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\DemoNotificationController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.DemoNotificationsDTO;
import cz.phsoft.hokej.models.services.notification.DemoNotificationStore;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

/**
 * REST controller, který se používá pro práci s demo notifikacemi.
 *
 * Controller je registrován pouze v demo režimu. Pokud demo režim není aktivní,
 * endpointy nejsou součástí aplikace a vrací se odpověď 404.
 *
 * Práce s dočasným úložištěm notifikací se deleguje na {@link DemoNotificationStore}.
 */
@RestController
@RequestMapping("/api/demo/notifications")
@ConditionalOnProperty(name = "app.demo-mode", havingValue = "true")
public class DemoNotificationController {

    private final DemoNotificationStore demoNotificationStore;

    public DemoNotificationController(DemoNotificationStore demoNotificationStore) {
        this.demoNotificationStore = demoNotificationStore;
    }

    /**
     * Vrací všechny zachycené demo notifikace a následně je vymaže z úložiště.
     *
     * Endpoint slouží zejména pro frontendovou část aplikace,
     * která zobrazuje simulované odeslané e-maily a SMS zprávy v demo režimu.
     *
     * @return DTO obsahující seznam zachycených e-mailů a SMS zpráv
     */
    @GetMapping
    public ResponseEntity<DemoNotificationsDTO> getDemoNotifications() {
        DemoNotificationsDTO dto = demoNotificationStore.getAndClear();
        return ResponseEntity.ok(dto);
    }

    /**
     * Provede vyčištění zachycených demo notifikací bez jejich vrácení.
     *
     * Endpoint umožňuje explicitní smazání obsahu úložiště
     * například při resetu demo prostředí.
     *
     * @return HTTP odpověď 204 No Content v případě úspěchu
     */
    @DeleteMapping
    public ResponseEntity<Void> clearDemoNotifications() {
        demoNotificationStore.getAndClear();
        return ResponseEntity.noContent().build();
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\MatchController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.enums.MatchCancelReason;
import cz.phsoft.hokej.models.dto.*;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import cz.phsoft.hokej.models.services.MatchHistoryService;
import cz.phsoft.hokej.models.services.MatchService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller, který se používá pro správu zápasů.
 *
 * Zajišťuje administrativní operace nad zápasy pro role ADMIN a MANAGER,
 * včetně vytváření, aktualizace, mazání, zrušení a obnovení zápasů.
 * Zároveň poskytuje pohled na zápasy z perspektivy aktuálního hráče
 * a detail zápasu včetně informací o registracích.
 *
 * Veškerá business logika se deleguje do {@link MatchService},
 * práce s historií zápasů do {@link MatchHistoryService} a práce
 * s aktuálním hráčem do {@link CurrentPlayerService}.
 */
@RestController
@RequestMapping("/api/matches")
public class MatchController {

    private final MatchService matchService;
    private final CurrentPlayerService currentPlayerService;
    private final MatchHistoryService matchHistoryService;

    public MatchController(MatchService matchService,
                           CurrentPlayerService currentPlayerService,
                           MatchHistoryService matchHistoryService) {
        this.matchService = matchService;
        this.currentPlayerService = currentPlayerService;
        this.matchHistoryService = matchHistoryService;
    }

    // ADMIN / MANAGER – globální správa zápasů

    /**
     * Vrací seznam všech zápasů v systému.
     *
     * Endpoint je určen pro administrativní přehled zápasů a
     * je dostupný pro role ADMIN a MANAGER.
     *
     * @return seznam všech zápasů jako {@link MatchDTO}
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getAllMatches() {
        return matchService.getAllMatches();
    }

    /**
     * Vrací seznam všech nadcházejících zápasů.
     *
     * Endpoint je dostupný pro role ADMIN a MANAGER a slouží
     * k přehledu budoucích zápasů v systému.
     *
     * @return seznam nadcházejících zápasů jako {@link MatchDTO}
     */
    @GetMapping("/upcoming")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getUpcomingMatches() {
        return matchService.getUpcomingMatches();
    }

    /**
     * Vrací seznam všech již odehraných zápasů.
     *
     * Endpoint je dostupný pro role ADMIN a MANAGER a používá se
     * pro přehled historicky odehraných zápasů.
     *
     * @return seznam odehraných zápasů jako {@link MatchDTO}
     */
    @GetMapping("/past")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getPastMatches() {
        return matchService.getPastMatches();
    }

    /**
     * Vytváří nový zápas.
     *
     * Vstupní data jsou validována pomocí bean validation a
     * vlastní uložení zápasu se deleguje do servisní vrstvy.
     * Operace je vyhrazena roli ADMIN.
     *
     * @param matchDTO DTO s daty nového zápasu
     * @return vytvořený zápas jako {@link MatchDTO}
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO createMatch(@Valid @RequestBody MatchDTO matchDTO) {
        return matchService.createMatch(matchDTO);
    }

    /**
     * Vrací detail zápasu podle jeho ID v administrativním pohledu.
     *
     * Jedná se o pohled pro administrátora nebo manažera bez vazby
     * na konkrétního hráče. Endpoint je vhodný pro editaci zápasu
     * nebo pro jeho detailní kontrolu.
     *
     * @param id ID zápasu
     * @return {@link MatchDTO} s detaily zápasu
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO getMatch(@PathVariable Long id) {
        return matchService.getMatchById(id);
    }

    /**
     * Vrací historii změn daného zápasu.
     *
     * Historie slouží pro auditní účely a sledování průběžných
     * úprav parametrů zápasu. Záznamy jsou získávány ze servisní
     * vrstvy, která čte historii z databáze.
     *
     * @param id ID zápasu
     * @return seznam {@link MatchHistoryDTO} představujících historii zápasu
     */
    @GetMapping("/{id}/history")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchHistoryDTO> getMatchHistory(@PathVariable Long id) {
        return matchHistoryService.getHistoryForMatch(id);
    }

    /**
     * Aktualizuje existující zápas.
     *
     * Vstupní data jsou validována a následná aktualizace se
     * deleguje do servisní vrstvy. Endpoint je dostupný pro role
     * ADMIN a MANAGER.
     *
     * @param id  ID zápasu, který má být aktualizován
     * @param dto DTO s aktualizovanými daty zápasu
     * @return {@link MatchDTO} s uloženými změnami
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO updateMatch(@PathVariable Long id,
                                @Valid @RequestBody MatchDTO dto) {
        return matchService.updateMatch(id, dto);
    }

    /**
     * Odstraňuje zápas ze systému.
     *
     * Odstranění zápasu se používá výjimečně, například při
     * chybně zadaném zápasu. Operace je vyhrazena pouze pro roli ADMIN
     * a je realizována prostřednictvím servisní vrstvy.
     *
     * @param id ID zápasu, který má být odstraněn
     * @return {@link SuccessResponseDTO} s výsledkem operace
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SuccessResponseDTO> deleteMatch(@PathVariable Long id) {
        SuccessResponseDTO response = matchService.deleteMatch(id);
        return ResponseEntity.ok(response);
    }

    /**
     * Vrací seznam zápasů, které jsou dostupné pro konkrétního hráče.
     *
     * Dostupnost zápasů je určována na základě doménových pravidel,
     * například podle kapacity nebo stavu zápasu. Endpoint je dostupný
     * pro role ADMIN a MANAGER a slouží zejména pro administrativní práci
     * s registracemi konkrétního hráče.
     *
     * @param playerId ID hráče
     * @return seznam dostupných zápasů pro daného hráče jako {@link MatchDTO}
     */
    @GetMapping("/available-for-player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getAvailableMatchesForPlayer(@PathVariable Long playerId) {
        return matchService.getAvailableMatchesForPlayer(playerId);
    }

    /**
     * Ruší zápas a ukládá důvod zrušení.
     *
     * Operace je dostupná pro role ADMIN a MANAGER a typicky
     * spouští navazující proces notifikací pro dotčené hráče.
     * Důvod zrušení je předáván jako enum {@link MatchCancelReason}.
     *
     * @param matchId ID zápasu, který má být zrušen
     * @param reason  důvod zrušení zápasu
     * @return {@link SuccessResponseDTO} s výsledkem operace
     */
    @PatchMapping("/{matchId}/cancel")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SuccessResponseDTO> cancelMatch(
            @PathVariable Long matchId,
            @RequestParam MatchCancelReason reason
    ) {
        SuccessResponseDTO response = matchService.cancelMatch(matchId, reason);
        return ResponseEntity.ok(response);
    }

    /**
     * Obnovuje dříve zrušený zápas.
     *
     * Obnovení zápasu vrací zápas do aktivního stavu a umožňuje
     * další práci s registracemi hráčů. Operace je dostupná pro
     * role ADMIN a MANAGER a zpracování je delegováno na servisní vrstvu.
     *
     * @param matchId ID zápasu, který má být obnoven
     * @return {@link SuccessResponseDTO} s výsledkem operace
     */
    @PatchMapping("/{matchId}/uncancel")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SuccessResponseDTO> unCancelMatch(@PathVariable Long matchId) {
        SuccessResponseDTO response = matchService.unCancelMatch(matchId);
        return ResponseEntity.ok(response);
    }

    // Hráč – endpointy v kontextu aktuálního hráče

    /**
     * Vrací detail konkrétního zápasu z pohledu hráče.
     *
     * Detail obsahuje informace o registracích, volných místech
     * a možnostech úprav registrace pro aktuálního hráče. Endpoint
     * je dostupný pro přihlášené uživatele.
     *
     * @param id ID zápasu
     * @return {@link MatchDetailDTO} s detailem zápasu pro hráče
     */
    @GetMapping("/{id}/detail")
    @PreAuthorize("isAuthenticated()")
    public MatchDetailDTO getMatchDetail(@PathVariable Long id) {
        return matchService.getMatchDetail(id);
    }

    /**
     * Vrací nejbližší nadcházející zápas v systému.
     *
     * Endpoint se používá například pro zobrazení nejbližšího
     * zápasu na úvodní stránce aplikace pro přihlášeného uživatele.
     *
     * @return {@link MatchDTO} s nejbližším zápasem nebo null, pokud žádný neexistuje
     */
    @GetMapping("/next")
    @PreAuthorize("isAuthenticated()")
    public MatchDTO getNextMatch() {
        return matchService.getNextMatch();
    }

    /**
     * Vrací seznam nadcházejících zápasů pro aktuálně zvoleného hráče.
     *
     * Před voláním služby se vyžaduje, aby byl nastaven aktuální hráč.
     * Samotné zjištění ID aktuálního hráče se zajišťuje pomocí
     * {@link CurrentPlayerService}. Endpoint je dostupný pro
     * přihlášené uživatele.
     *
     * @param authentication autentizační kontext přihlášeného uživatele
     * @return seznam nadcházejících zápasů pro aktuálního hráče jako {@link MatchDTO}
     */
    @GetMapping("/me/upcoming")
    @PreAuthorize("isAuthenticated()")
    public List<MatchDTO> getUpcomingMatchesForMe(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getUpcomingMatchesForPlayer(currentPlayerId);
    }

    /**
     * Vrací přehled nadcházejících zápasů pro aktuálního hráče.
     *
     * Přehled je určen zejména pro kompaktní zobrazení zápasů
     * v uživatelském rozhraní, například v podobě karet. Skutečné
     * načtení dat se deleguje na servisní vrstvu.
     *
     * @param authentication autentizační kontext přihlášeného uživatele
     * @return seznam {@link MatchOverviewDTO} s nadcházejícími zápasy pro hráče
     */
    @GetMapping("/me/upcoming-overview")
    @PreAuthorize("isAuthenticated()")
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForMe(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getUpcomingMatchesOverviewForPlayer(currentPlayerId);
    }

    /**
     * Vrací seznam všech již odehraných zápasů pro aktuálního hráče.
     *
     * Seznam slouží pro zobrazení historie zápasů daného hráče
     * v uživatelském rozhraní. Endpoint je dostupný pro přihlášené
     * uživatele a identita hráče se určuje pomocí {@link CurrentPlayerService}.
     *
     * @param authentication autentizační kontext přihlášeného uživatele
     * @return seznam {@link MatchOverviewDTO} pro odehrané zápasy aktuálního hráče
     */
    // TODO - JEN ZÁPASY OD VYTVOŘENÍ HRÁČE
    @GetMapping("/me/all-passed")
    @PreAuthorize("isAuthenticated()")
    public List<MatchOverviewDTO> getAllMatchesForPlayer(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getAllPassedMatchesForPlayer(currentPlayerId);
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\MatchRegistrationController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.exceptions.CurrentPlayerNotSelectedException;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import cz.phsoft.hokej.models.services.MatchService;
import jakarta.validation.Valid;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller, který se používá pro správu registrací hráčů na zápasy.
 *
 * Zajišťuje administrativní správu registrací pro role ADMIN a MANAGER
 * a správu registrací pro aktuálního hráče pod endpointy s prefixem /me.
 * Umožňuje registraci, odhlášení, evidenci omluv a neomluvené neúčasti
 * a také přehled registrací napříč zápasy.
 *
 * Veškerá business logika se deleguje do {@link MatchRegistrationService},
 * informace o aktuálním hráči se získávají z {@link CurrentPlayerService}
 * a související doménová logika může být částečně řešena také v {@link MatchService}.
 */
@RestController
@RequestMapping("/api/registrations")
public class MatchRegistrationController {

    private final MatchRegistrationService matchRegistrationService;
    private final CurrentPlayerService currentPlayerService;
    private final MatchService matchService;

    public MatchRegistrationController(MatchRegistrationService matchRegistrationService,
                                       CurrentPlayerService currentPlayerService,
                                       MatchService matchService) {
        this.matchRegistrationService = matchRegistrationService;
        this.currentPlayerService = currentPlayerService;
        this.matchService = matchService;
    }

    // ADMIN / MANAGER – globální správa registrací

    /**
     * Vrací seznam všech registrací na všechny zápasy.
     *
     * Endpoint je dostupný pro role ADMIN a MANAGER a slouží
     * k přehledové správě registrací napříč celým systémem.
     *
     * @return seznam všech registrací jako {@link MatchRegistrationDTO}
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> getAllRegistrations() {
        return matchRegistrationService.getAllRegistrations();
    }

    /**
     * Vrací všechny registrace hráčů pro konkrétní zápas.
     *
     * Endpoint se používá například při kontrole obsazenosti zápasu
     * nebo při ruční úpravě registrací ze strany administrátora či manažera.
     *
     * @param matchId ID zápasu
     * @return seznam registrací pro daný zápas jako {@link MatchRegistrationDTO}
     */
    @GetMapping("/match/{matchId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> getRegistrationsForMatch(@PathVariable Long matchId) {
        return matchRegistrationService.getRegistrationsForMatch(matchId);
    }

    /**
     * Vrací všechny registrace konkrétního hráče napříč zápasy.
     *
     * Endpoint se používá pro přehled účasti hráče v jednotlivých zápasech,
     * typicky v administrativním rozhraní.
     *
     * @param playerId ID hráče
     * @return seznam registrací daného hráče jako {@link MatchRegistrationDTO}
     */
    @GetMapping("/player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> getRegistrationsForPlayer(@PathVariable Long playerId) {
        return matchRegistrationService.getRegistrationsForPlayer(playerId);
    }

    /**
     * Vrací seznam hráčů, kteří na pozvánku k danému zápasu zatím nereagovali.
     *
     * Informace se používá například pro přehled hráčů, kteří se ještě
     * nepřihlásili ani neomluvili, a může sloužit jako podklad pro
     * následnou komunikaci ze strany manažera.
     *
     * @param matchId ID zápasu
     * @return seznam hráčů bez reakce jako {@link PlayerDTO}
     */
    @GetMapping("/match/{matchId}/no-response")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getNoResponsePlayers(@PathVariable Long matchId) {
        return matchRegistrationService.getNoResponsePlayers(matchId);
    }

    /**
     * Vytváří nebo aktualizuje registraci za konkrétního hráče.
     *
     * Endpoint se používá administrátorem nebo manažerem v situacích,
     * kdy je potřeba hráče ručně zaregistrovat, odhlásit nebo změnit
     * typ jeho účasti. Vstupní požadavek určuje cílový stav registrace.
     *
     * @param playerId ID hráče, za kterého se operace provádí
     * @param request  požadavek na změnu registrace
     * @return {@link MatchRegistrationDTO} s výsledným stavem registrace
     */
    @PostMapping("/upsert/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchRegistrationDTO upsertForPlayer(
            @PathVariable Long playerId,
            @Valid @RequestBody MatchRegistrationRequest request
    ) {
        return matchRegistrationService.upsertRegistration(playerId, request);
    }

    /**
     * Označuje hráče v konkrétním zápase jako neomluveně nepřítomného.
     *
     * Slouží k zaznamenání neomluvené absence hráče. Pro záznam může být
     * doplněna interní poznámka administrátora nebo manažera.
     *
     * @param matchId   ID zápasu
     * @param playerId  ID hráče
     * @param adminNote volitelná interní poznámka k záznamu
     * @return {@link MatchRegistrationDTO} s aktualizovaným stavem registrace
     */
    @PatchMapping("/match/{matchId}/players/{playerId}/no-excused")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchRegistrationDTO markNoExcused(
            @PathVariable Long matchId,
            @PathVariable Long playerId,
            @RequestParam(name = "adminNote", required = false) String adminNote
    ) {
        return matchRegistrationService.markNoExcused(matchId, playerId, adminNote);
    }

    /**
     * Ruší označení neomluvené absence hráče v konkrétním zápase a nastavuje omluvu.
     *
     * Slouží pro opravu dříve uložené neomluvené absence, například pokud
     * byla absence vyhodnocena dodatečně jako omluvená. Důvod omluvy a poznámka
     * se ukládají spolu s registrací.
     *
     * @param matchId      ID zápasu
     * @param playerId     ID hráče
     * @param excuseReason důvod omluvy
     * @param excuseNote   poznámka k omluvě
     * @return {@link MatchRegistrationDTO} s aktualizovaným stavem registrace
     */
    @PatchMapping("/match/{matchId}/players/{playerId}/cancel-no-excused")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchRegistrationDTO cancelNoExcused(
            @PathVariable Long matchId,
            @PathVariable Long playerId,
            @RequestParam ExcuseReason excuseReason,
            @RequestParam String excuseNote
    ) {
        return matchRegistrationService.cancelNoExcused(matchId, playerId, excuseReason, excuseNote);
    }

    // Uživatelská správa registrací pro aktuálního hráče

    /**
     * Spravuje registraci aktuálního hráče na zápas.
     *
     * Podle obsahu {@link MatchRegistrationRequest} se provádí registrace,
     * odhlášení, omluva nebo nastavení náhradníka. Aktuální hráč se získává
     * z {@link CurrentPlayerService}. V případě, že aktuální hráč není zvolen,
     * vyhazuje se {@link CurrentPlayerNotSelectedException}.
     *
     * @param request požadavek na změnu registrace
     * @return {@link MatchRegistrationDTO} s výsledným stavem registrace
     */
    @PostMapping("/me/upsert")
    @PreAuthorize("isAuthenticated()")
    public MatchRegistrationDTO upsertForCurrentPlayer(
            @Valid @RequestBody MatchRegistrationRequest request
    ) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        if (currentPlayerId == null) {
            throw new CurrentPlayerNotSelectedException();
        }

        return matchRegistrationService.upsertRegistration(currentPlayerId, request);
    }

    /**
     * Vrací všechny registrace aktuálně zvoleného hráče.
     *
     * Endpoint se používá pro uživatelské zobrazení historie a stavu
     * registrací hráče napříč zápasy. Identita hráče se získává z
     * {@link CurrentPlayerService}.
     *
     * @return seznam {@link MatchRegistrationDTO} pro aktuálního hráče
     */
    @GetMapping("/me/for-current-player")
    @PreAuthorize("isAuthenticated()")
    public List<MatchRegistrationDTO> getRegistrationsForCurrentPlayer() {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchRegistrationService.getRegistrationsForPlayer(currentPlayerId);
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\MatchRegistrationHistoryController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchRegistrationHistoryDTO;
import cz.phsoft.hokej.models.services.MatchRegistrationHistoryService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * REST controller, který se používá pro práci s historií registrací
 * hráčů k zápasům.
 *
 * Controller poskytuje uživatelský pohled na historii registrace
 * aktuálního hráče a administrativní audit historie registrací
 * konkrétního hráče. Controller je read-only a slouží pouze ke čtení
 * z tabulky historie registrací.
 *
 * Veškerá business logika se předává do
 * {@link MatchRegistrationHistoryService}.
 */
@RestController
@RequestMapping("/api/registrations/history")
public class MatchRegistrationHistoryController {

    private final MatchRegistrationHistoryService historyService;

    public MatchRegistrationHistoryController(MatchRegistrationHistoryService historyService) {
        this.historyService = historyService;
    }

    // Uživatelský přístup – aktuální hráč

    /**
     * Vrací historii všech změn registrace aktuálně přihlášeného
     * hráče pro daný zápas.
     *
     * Metoda se používá například pro zobrazení historie registrace
     * na detailu zápasu v uživatelském rozhraní.
     *
     * @param matchId ID zápasu
     * @return seznam záznamů historie seřazených od nejnovějšího
     */
    @GetMapping("/me/matches/{matchId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<MatchRegistrationHistoryDTO>> getMyHistoryForMatch(
            @PathVariable Long matchId
    ) {
        List<MatchRegistrationHistoryDTO> history =
                historyService.getHistoryForCurrentPlayerAndMatch(matchId);

        return ResponseEntity.ok(history);
    }

    /**
     * Vrací historii všech změn registrace konkrétního hráče pro daný zápas.
     *
     * Metoda se používá pro administrativní audit, analýzu změn registrací
     * a řešení případných sporů.
     *
     * @param matchId  ID zápasu
     * @param playerId ID hráče
     * @return seznam záznamů historie seřazených od nejnovějšího
     */
    @GetMapping("/admin/matches/{matchId}/players/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<List<MatchRegistrationHistoryDTO>> getPlayerHistoryForMatch(
            @PathVariable Long matchId,
            @PathVariable Long playerId
    ) {
        List<MatchRegistrationHistoryDTO> history =
                historyService.getHistoryForPlayerAndMatch(matchId, playerId);

        return ResponseEntity.ok(history);
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\MeController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.dto.ImpersonationInfoDTO;
import cz.phsoft.hokej.security.impersonation.ImpersonationContext;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Optional;

/**
 * REST controller poskytující informace o aktuálním uživatelském kontextu.
 *
 * Obsahuje endpointy typu /api/me, které vrací informace
 * o aktuálním přihlášeném uživateli nebo režimu zastoupení.
 */
@RestController
@RequestMapping("/api/me")
public class MeController {

    private final PlayerRepository playerRepository;

    public MeController(PlayerRepository playerRepository) {
        this.playerRepository = playerRepository;
    }

    /**
     * Vrátí informaci o aktuálním režimu zastoupení.
     *
     * Pokud je aktivní impersonace, vrátí identifikátor a jméno
     * zastupovaného hráče. Pokud není aktivní, vrátí pouze příznak false.
     *
     * Endpoint vyžaduje přihlášení.
     *
     * @return informace o zastoupení
     */
    @GetMapping("/impersonation")
    public ResponseEntity<ImpersonationInfoDTO> getImpersonationInfo() {

        Long playerId = ImpersonationContext.getImpersonatedPlayerId();

        if (playerId == null) {
            return ResponseEntity.ok(
                    new ImpersonationInfoDTO(false, null, null)
            );
        }

        Optional<PlayerEntity> playerOpt = playerRepository.findById(playerId);

        if (playerOpt.isEmpty()) {
            return ResponseEntity.ok(
                    new ImpersonationInfoDTO(false, null, null)
            );
        }

        PlayerEntity player = playerOpt.get();

        String playerName = player.getName() + " " + player.getSurname();

        return ResponseEntity.ok(
                new ImpersonationInfoDTO(true, player.getId(), playerName)
        );
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\package-info.java
-----

/**
 * Controllerová vrstva aplikace.
 *
 * Obsahuje REST kontrolery odpovědné za:
 * - příjem HTTP požadavků z frontend aplikace,
 * - validaci vstupních dat,
 * - mapování requestů na service vrstvu,
 * - návrat standardizovaných API odpovědí.
 *
 * Tato vrstva:
 * - neobsahuje business logiku,
 * - nepracuje přímo s databází,
 * - deleguje veškerou aplikační logiku na service třídy.
 */

package cz.phsoft.hokej.controllers;


-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.PlayerHistoryDTO;
import cz.phsoft.hokej.models.dto.PlayerStatsDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.dto.requests.ChangePlayerUserRequest;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import cz.phsoft.hokej.models.services.PlayerHistoryService;
import cz.phsoft.hokej.models.services.PlayerService;
import cz.phsoft.hokej.models.services.PlayerStatsService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller, který se používá pro správu hráčů.
 *
 * Zajišťuje administrativní správu hráčů pro role ADMIN a MANAGER,
 * včetně vytváření, aktualizace, mazání a schvalování hráčů, a také
 * správu hráčů z pohledu přihlášeného uživatele pod endpointy s prefixem /me.
 *
 * Veškerá business logika se deleguje do {@link PlayerService}.
 * Historie změn hráčů se získává pomocí {@link PlayerHistoryService}
 * a práce s aktuálním hráčem se zajišťuje přes {@link CurrentPlayerService}.
 */
@RestController
@RequestMapping("/api/players")
public class PlayerController {

    private final PlayerService playerService;
    private final CurrentPlayerService currentPlayerService;
    private final PlayerHistoryService playerHistoryService;
    private final PlayerStatsService playerStatsService;

    public PlayerController(PlayerService playerService,
                            CurrentPlayerService currentPlayerService,
                            PlayerHistoryService playerHistoryService,
                            PlayerStatsService playerStatsService) {
        this.playerService = playerService;
        this.currentPlayerService = currentPlayerService;
        this.playerHistoryService = playerHistoryService;
        this.playerStatsService = playerStatsService;
    }

    // ADMIN / MANAGER – globální správa hráčů

    /**
     * Vrací seznam všech hráčů v systému.
     *
     * Endpoint je dostupný pro role ADMIN a MANAGER a slouží
     * pro přehledovou správu hráčů v administraci.
     *
     * @return seznam všech hráčů jako {@link PlayerDTO}
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getAllPlayers() {
        return playerService.getAllPlayers();
    }

    /**
     * Vrací detail hráče podle jeho ID.
     *
     * Endpoint je určen pro administrativní pohled na hráče,
     * například pro úpravu jeho údajů.
     *
     * @param id ID hráče
     * @return {@link PlayerDTO} s detailem hráče
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public PlayerDTO getPlayerById(@PathVariable Long id) {
        return playerService.getPlayerById(id);
    }

    /**
     * Vrací historii hráče podle jeho ID.
     *
     * Historie obsahuje záznamy o změnách provedených nad daným hráčem
     * a slouží pro auditní a přehledové účely.
     *
     * @param id ID hráče
     * @return seznam {@link PlayerHistoryDTO} představujících historii hráče
     */
    @GetMapping("/{id}/history")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerHistoryDTO> getPlayerHistoryById(@PathVariable Long id) {
        return playerHistoryService.getHistoryForPlayer(id);
    }

    /**
     * Vytváří nového hráče administrátorem nebo manažerem.
     *
     * Operace se používá při ručním zakládání hráče v systému,
     * typicky pro dodatečné doplnění hráčů mimo uživatelské rozhraní.
     *
     * @param playerDTO DTO s daty nového hráče
     * @return vytvořený hráč jako {@link PlayerDTO}
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public PlayerDTO createPlayer(@Valid @RequestBody PlayerDTO playerDTO) {
        return playerService.createPlayer(playerDTO);
    }

    /**
     * Aktualizuje údaje hráče v administrativním rozhraní.
     *
     * Endpoint je dostupný pro role ADMIN a MANAGER a slouží
     * k úpravě existujících údajů hráče.
     *
     * @param id  ID hráče
     * @param dto DTO s aktualizovanými daty hráče
     * @return aktualizovaný hráč jako {@link PlayerDTO}
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public PlayerDTO updatePlayerAdmin(@PathVariable Long id,
                                       @Valid @RequestBody PlayerDTO dto) {
        return playerService.updatePlayer(id, dto);
    }

    /**
     * Odstraňuje hráče ze systému.
     *
     * Operace je dostupná pro role ADMIN a MANAGER a používá se
     * pouze ve výjimečných situacích, například při chybném založení
     * hráče. Samotné odstranění se provádí v servisní vrstvě.
     *
     * @param id ID hráče
     * @return {@link SuccessResponseDTO} s výsledkem operace
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SuccessResponseDTO> deletePlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.deletePlayer(id);
        return ResponseEntity.ok(response);
    }

    /**
     * Schvaluje hráče a nastavuje jeho stav na APPROVED.
     *
     * Endpoint se používá po kontrole údajů hráče administrátorem
     * nebo manažerem. Schválení umožňuje hráči plnohodnotné využití
     * systému.
     *
     * @param id ID hráče
     * @return {@link SuccessResponseDTO} s výsledkem operace
     */
    @PutMapping("/{id}/approve")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SuccessResponseDTO> approvePlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.approvePlayer(id);
        return ResponseEntity.ok(response);
    }

    /**
     * Zamítá hráče a nastavuje jeho stav na REJECTED.
     *
     * Endpoint se používá v situacích, kdy hráč nesplňuje podmínky
     * pro schválení, například z hlediska validity údajů.
     *
     * @param id ID hráče
     * @return {@link SuccessResponseDTO} s výsledkem operace
     */
    @PutMapping("/{id}/reject")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SuccessResponseDTO> rejectPlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.rejectPlayer(id);
        return ResponseEntity.ok(response);
    }

    /**
     * Mění přiřazení hráče k aplikačnímu uživateli.
     *
     * Operace je určena pro roli ADMIN nebo MANAGER a používá se,
     * pokud je potřeba hráče převést k jinému uživateli, například
     * při změně vlastníka účtu.
     *
     * @param playerId ID hráče
     * @param request  požadavek obsahující ID nového uživatele
     * @return textová zpráva o úspěšné změně přiřazení
     */
    @PostMapping("/{playerId}/change-user")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<String> changePlayerUser(
            @PathVariable Long playerId,
            @RequestBody ChangePlayerUserRequest request
    ) {
        playerService.changePlayerUser(playerId, request.getNewUserId());
        return ResponseEntity.ok(
                "Hráč s id: " + playerId + " byl úspěšně přiřazen uživateli s ID: " + request.getNewUserId()
        );
    }

    // Uživatelská správa hráčů přihlášeného uživatele

    /**
     * Vytváří nového hráče pro přihlášeného uživatele.
     *
     * Nový hráč se automaticky přiřazuje k uživatelskému účtu
     * odvozenému z e-mailové adresy v objektu {@link Authentication}.
     *
     * @param playerDTO      DTO s daty nového hráče
     * @param authentication autentizační kontext přihlášeného uživatele
     * @return vytvořený hráč jako {@link PlayerDTO}
     */
    @PostMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public PlayerDTO createMyPlayer(
            @Valid @RequestBody PlayerDTO playerDTO,
            Authentication authentication
    ) {
        String email = authentication.getName();
        return playerService.createPlayerForUser(playerDTO, email);
    }

    /**
     * Vrací seznam všech hráčů patřících přihlášenému uživateli.
     *
     * Hráči se identifikují na základě e-mailové adresy uživatele
     * získané z autentizačního kontextu.
     *
     * @param authentication autentizační kontext přihlášeného uživatele
     * @return seznam {@link PlayerDTO} patřících danému uživateli
     */
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public List<PlayerDTO> getMyPlayers(Authentication authentication) {
        String email = authentication.getName();
        return playerService.getPlayersByUser(email);
    }

    /**
     * Aktualizuje údaje aktuálně zvoleného hráče.
     *
     * Před provedením aktualizace se vyžaduje, aby byl nastaven
     * aktuální hráč v {@link CurrentPlayerService}. Aktualizace
     * se následně deleguje do {@link PlayerService}.
     *
     * @param dto DTO s aktualizovanými daty hráče
     * @return aktualizovaný hráč jako {@link PlayerDTO}
     */
    @PutMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public PlayerDTO updateMyCurrentPlayer(@Valid @RequestBody PlayerDTO dto) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return playerService.updatePlayer(currentPlayerId, dto);
    }

    /**
     * Vrací historii pro aktuálně zvoleného hráče přihlášeného uživatele.
     *
     * Identita hráče se získává z {@link CurrentPlayerService}. Endpoint
     * je určen pro uživatelské zobrazení historie změn nad vlastním hráčem.
     *
     * @return seznam {@link PlayerHistoryDTO} představujících historii aktuálního hráče
     */
    @GetMapping("/me/history")
    @PreAuthorize("isAuthenticated()")
    public List<PlayerHistoryDTO> getMyPlayerHistory() {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return playerHistoryService.getHistoryForPlayer(currentPlayerId);
    }


    /**
     * Vrací statistiky pro aktuálně zvoleného hráče přihlášeného uživatele.
     *
     * Identita hráče se získává z {@link CurrentPlayerService}. Endpoint
     * je určen pro zobrazení statistik k zápasům vlastním hráčem.
     *
     * @return seznam {@link PlayerStatsDTO} představujících statistiky aktuálního hráče
     */
    @GetMapping("/me/stats")
    @PreAuthorize("isAuthenticated()")
    public PlayerStatsDTO getMyPlayerStats() {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return playerStatsService.getPlayerStats(currentPlayerId);
    }

    /**
     * Vrací statistiky pro aktuálně zvoleného hráče přihlášeného uživatele.
     *
     * je určen pro zobrazení statistik k zápasům hráče dle jeho ide.
     * @param playerId ID hráče
     * @return seznam {@link PlayerStatsDTO} představujících statistiky hráče dle id
     */
    @GetMapping("/{playerId}/stats")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public PlayerStatsDTO getPlayerStats(@PathVariable Long playerId) {
        return playerStatsService.getPlayerStats(playerId);
    }



}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerInactivityPeriodController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import cz.phsoft.hokej.models.services.PlayerInactivityPeriodService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller, který se používá pro administraci období neaktivity hráčů.
 *
 * Období neaktivity slouží k evidenci časových úseků, ve kterých se hráč
 * neúčastní zápasů, například z důvodu zranění nebo dovolené. Endpointy jsou
 * určeny pro role ADMIN a MANAGER a umožňují úplnou správu záznamů o neaktivitě.
 *
 * Veškerá business logika se deleguje do {@link PlayerInactivityPeriodService}.
 * Informace o aktuálním hráči se získávají pomocí {@link CurrentPlayerService}.
 */
@RestController
@RequestMapping("/api/inactivity/admin")
public class PlayerInactivityPeriodController {

    private final PlayerInactivityPeriodService service;
    private final CurrentPlayerService currentPlayerService;

    public PlayerInactivityPeriodController(PlayerInactivityPeriodService service,
                                            CurrentPlayerService currentPlayerService) {
        this.service = service;
        this.currentPlayerService = currentPlayerService;
    }

    /**
     * Vrací seznam všech záznamů o neaktivitě hráčů.
     *
     * Endpoint je dostupný pro role ADMIN a MANAGER a slouží
     * k přehledové správě všech evidovaných období neaktivity.
     *
     * @return seznam období neaktivity jako {@link PlayerInactivityPeriodDTO}
     */
    @GetMapping("/all")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getAll() {
        return service.getAll();
    }

    /**
     * Vrací detail záznamu o neaktivitě podle jeho ID.
     *
     * Endpoint se používá pro zobrazení nebo kontrolu konkrétního
     * záznamu před jeho úpravou či smazáním.
     *
     * @param id ID záznamu o neaktivitě
     * @return {@link PlayerInactivityPeriodDTO} s detailem období neaktivity
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<PlayerInactivityPeriodDTO> getById(@PathVariable Long id) {
        PlayerInactivityPeriodDTO dto = service.getById(id);
        return ResponseEntity.ok(dto);
    }

    /**
     * Vrací všechna období neaktivity pro konkrétního hráče.
     *
     * Endpoint je vhodný například pro kontrolu dlouhodobé absence
     * hráče nebo pro plánování jeho účasti na zápasech.
     *
     * @param playerId ID hráče
     * @return seznam období neaktivity pro daného hráče jako {@link PlayerInactivityPeriodDTO}
     */
    @GetMapping("/player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getByPlayer(@PathVariable Long playerId) {
        return service.getByPlayer(playerId);
    }

    /**
     * Vytváří nový záznam o neaktivitě hráče.
     *
     * Vstupní data jsou validována pomocí bean validation a vlastní
     * uložení záznamu se deleguje do servisní vrstvy. Operace je
     * dostupná pro role ADMIN a MANAGER.
     *
     * @param dto DTO s daty období neaktivity
     * @return vytvořený záznam jako {@link PlayerInactivityPeriodDTO}
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<PlayerInactivityPeriodDTO> create(
            @Valid @RequestBody PlayerInactivityPeriodDTO dto) {

        PlayerInactivityPeriodDTO created = service.create(dto);
        return ResponseEntity.ok(created);
    }

    /**
     * Aktualizuje existující záznam o neaktivitě hráče.
     *
     * Endpoint je dostupný pro role ADMIN a MANAGER. Aktualizace
     * probíhá prostřednictvím servisní vrstvy a slouží k opravám
     * nebo úpravám dříve zadaných údajů.
     *
     * @param id  ID záznamu o neaktivitě
     * @param dto DTO s aktualizovanými daty období neaktivity
     * @return aktualizovaný záznam jako {@link PlayerInactivityPeriodDTO}
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<PlayerInactivityPeriodDTO> update(
            @PathVariable Long id,
            @Valid @RequestBody PlayerInactivityPeriodDTO dto) {

        PlayerInactivityPeriodDTO updated = service.update(id, dto);
        return ResponseEntity.ok(updated);
    }

    /**
     * Odstraňuje záznam o neaktivitě hráče.
     *
     * Operace je vyhrazena pouze pro roli ADMIN a používá se
     * například při chybném zadání období neaktivity.
     *
     * @param id ID záznamu o neaktivitě
     * @return HTTP odpověď 204 No Content v případě úspěchu
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        service.delete(id);
        return ResponseEntity.noContent().build();
    }

    /**
     * Vrací seznam období neaktivity aktuálně zvoleného hráče.
     *
     * Před voláním služby se vyžaduje, aby byl nastaven aktuální hráč
     * v {@link CurrentPlayerService}. Endpoint je určen pro uživatelské
     * zobrazení vlastních období neaktivity v rozhraní hráče.
     *
     * @param authentication autentizační kontext přihlášeného uživatele
     * @return seznam období neaktivity pro aktuálního hráče jako {@link PlayerInactivityPeriodDTO}
     */
    @GetMapping("/me/all")
    @PreAuthorize("isAuthenticated()")
    public List<PlayerInactivityPeriodDTO> getMyInactivity(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return service.getByPlayer(currentPlayerId);
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerSettingsController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerSettingsDTO;
import cz.phsoft.hokej.models.services.PlayerSettingsService;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

/**
 * REST controller, který se používá pro správu nastavení hráče.
 *
 * Pracuje s nastavením navázaným na konkrétního hráče a na aktuálního
 * hráče (currentPlayer). Umožňuje načítat a aktualizovat nastavení
 * pro libovolného hráče podle ID a pro hráče, který je aktuálně
 * vybrán v kontextu přihlášeného uživatele.
 *
 * Veškerá business logika se předává do {@link PlayerSettingsService}.
 */
@RestController
@RequestMapping("/api")
public class PlayerSettingsController {

    private final PlayerSettingsService playerSettingsService;
    private final CurrentPlayerService currentPlayerService;

    public PlayerSettingsController(PlayerSettingsService playerSettingsService,
                                    CurrentPlayerService currentPlayerService) {
        this.playerSettingsService = playerSettingsService;
        this.currentPlayerService = currentPlayerService;
    }

    // Nastavení libovolného hráče podle ID

    /**
     * Vrací nastavení konkrétního hráče podle jeho ID.
     *
     * Ověření, zda hráč patří přihlášenému uživateli nebo zda má
     * uživatel roli ADMIN či MANAGER, může být prováděno v této
     * vrstvě nebo v service vrstvě.
     *
     * @param playerId ID hráče
     * @param auth     autentizační kontext přihlášeného uživatele
     * @return DTO {@link PlayerSettingsDTO} s nastavením hráče
     */
    @GetMapping("/players/{playerId}/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<PlayerSettingsDTO> getPlayerSettings(
            @PathVariable Long playerId,
            Authentication auth
    ) {
        PlayerSettingsDTO dto = playerSettingsService.getSettingsForPlayer(playerId);
        return ResponseEntity.ok(dto);
    }

    /**
     * Aktualizuje nastavení konkrétního hráče podle jeho ID.
     *
     * Kontrola vlastnictví hráče a oprávnění může být doplněna
     * podle potřeb aplikace.
     *
     * @param playerId   ID hráče
     * @param requestDto DTO s novým nastavením hráče
     * @param auth       autentizační kontext přihlášeného uživatele
     * @return DTO {@link PlayerSettingsDTO} s aktualizovaným nastavením
     */
    @PatchMapping("/players/{playerId}/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<PlayerSettingsDTO> updatePlayerSettings(
            @PathVariable Long playerId,
            @RequestBody PlayerSettingsDTO requestDto,
            Authentication auth
    ) {
        // TODO: případná kontrola vlastnictví hráče

        PlayerSettingsDTO updated = playerSettingsService.updateSettingsForPlayer(playerId, requestDto);
        return ResponseEntity.ok(updated);
    }

    // Nastavení aktuálního hráče (currentPlayer)

    /**
     * Vrací nastavení aktuálně vybraného hráče.
     *
     * Před čtením nastavení se vyžaduje, aby byl v kontextu
     * nastaven aktuální hráč.
     *
     * @return DTO {@link PlayerSettingsDTO} s nastavením aktuálního hráče
     */
    @GetMapping("/me/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<PlayerSettingsDTO> getCurrentPlayerSettings() {

        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        PlayerSettingsDTO dto = playerSettingsService.getSettingsForPlayer(currentPlayerId);

        return ResponseEntity.ok(dto);
    }

    /**
     * Aktualizuje nastavení aktuálně vybraného hráče.
     *
     * Informace o tom, který hráč je aktuální, se získává z
     * {@link CurrentPlayerService}. Endpoint se používá například
     * pro nastavení preferencí přímo z kontextu aktuálního hráče.
     *
     * @param requestDto DTO s novým nastavením aktuálního hráče
     * @return DTO {@link PlayerSettingsDTO} s aktualizovaným nastavením
     */
    @PatchMapping("/me/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<PlayerSettingsDTO> updateCurrentPlayerSettings(
            @RequestBody PlayerSettingsDTO requestDto
    ) {

        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        PlayerSettingsDTO updated = playerSettingsService.updateSettingsForPlayer(currentPlayerId, requestDto);

        return ResponseEntity.ok(updated);
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\SeasonController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.SeasonDTO;
import cz.phsoft.hokej.models.dto.SeasonHistoryDTO;
import cz.phsoft.hokej.models.mappers.SeasonMapper;
import cz.phsoft.hokej.models.services.CurrentSeasonService;
import cz.phsoft.hokej.models.services.SeasonHistoryService;
import cz.phsoft.hokej.models.services.SeasonService;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller, který se používá pro správu sezón.
 *
 * Zajišťuje administrativní správu sezón pro roli ADMIN včetně
 * vytváření, aktualizace a nastavení globálně aktivní sezóny.
 * Dále poskytuje endpointy pro práci s aktuální sezónou uživatele
 * pod prefixem /me.
 *
 * Veškerá business logika se předává do {@link SeasonService}
 * a {@link CurrentSeasonService}.
 */
@RestController
@RequestMapping("/api/seasons")
public class SeasonController {

    private final SeasonService seasonService;
    private final SeasonMapper seasonMapper;
    private final CurrentSeasonService currentSeasonService;
    private final SeasonHistoryService seasonHistoryService;

    public SeasonController(SeasonService seasonService,
                            SeasonMapper seasonMapper,
                            CurrentSeasonService currentSeasonService,
                            SeasonHistoryService seasonHistoryService) {
        this.seasonService = seasonService;
        this.seasonMapper = seasonMapper;
        this.currentSeasonService = currentSeasonService;
        this.seasonHistoryService = seasonHistoryService;
    }

    // ADMIN – globální správa sezón

    /**
     * Vytváří novou sezónu.
     *
     * @param seasonDTO DTO s daty nové sezóny
     * @return vytvořená sezóna jako {@link SeasonDTO}
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SeasonDTO> createSeason(
            @Valid @RequestBody SeasonDTO seasonDTO) {

        SeasonDTO created = seasonService.createSeason(seasonDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    }

    /**
     * Aktualizuje existující sezónu.
     *
     * @param id        ID sezóny
     * @param seasonDTO DTO s aktualizovanými daty sezóny
     * @return aktualizovaná sezóna jako {@link SeasonDTO}
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SeasonDTO> updateSeason(
            @PathVariable Long id,
            @Valid @RequestBody SeasonDTO seasonDTO
    ) {
        SeasonDTO updated = seasonService.updateSeason(id, seasonDTO);
        return ResponseEntity.ok(updated);
    }

    /**
     * Vrací historii sezóny dle id.
     *
     * @param id ID sezóny
     * @return historie sezony jako {@link List<SeasonHistoryDTO>}
     */
    @GetMapping("/{id}/history")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<SeasonHistoryDTO> getSeasonHistory(
            @PathVariable Long id
    ) {
        return seasonHistoryService.getHistoryForSeason(id);
    }

    /**
     * Vrací seznam všech sezón v systému.
     *
     * Endpoint je v tuto chvíli omezen na roli ADMIN. Podle potřeby
     * může být v budoucnu zpřístupněn širšímu okruhu uživatelů.
     *
     * @return seznam sezón jako {@link SeasonDTO}
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<List<SeasonDTO>> getAllSeasonsAdmin() {
        List<SeasonDTO> seasons = seasonService.getAllSeasons();
        return ResponseEntity.ok(seasons);
    }

    /**
     * Vrací aktuálně globálně aktivní sezónu.
     *
     * Aktivní sezóna představuje výchozí období pro systémové operace,
     * které nejsou vázány na konkrétní volbu uživatele.
     *
     * @return aktivní sezóna jako {@link SeasonDTO}
     */
    @GetMapping("/active")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SeasonDTO> getActiveSeason() {
        SeasonDTO dto = seasonMapper.toDTO(seasonService.getActiveSeason());
        return ResponseEntity.ok(dto);
    }

    /**
     * Nastavuje zadanou sezónu jako globálně aktivní.
     *
     * Po nastavení se informace o aktivní sezóně používá v dalších
     * částech systému jako výchozí sezóna.
     *
     * @param id ID sezóny, která má být nastavena jako aktivní
     * @return nově aktivní sezóna jako {@link SeasonDTO}
     */
    @PutMapping("/{id}/active")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SeasonDTO> setActiveSeason(@PathVariable Long id) {
        seasonService.setActiveSeason(id);
        SeasonDTO active = seasonMapper.toDTO(seasonService.getActiveSeason());
        return ResponseEntity.ok(active);
    }

    // Uživatelská práce s „mojí“ sezónou

    /**
     * Vrací seznam všech sezón pro účely výběru na frontendu.
     *
     * Jedná se o uživatelskou variantu endpointu, která se používá
     * například pro zobrazení seznamu sezón v nabídce.
     *
     * @return seznam sezón jako {@link SeasonDTO}
     */
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public List<SeasonDTO> getAllSeasonsForUser() {
        return seasonService.getAllSeasons();
    }

    /**
     * Vrací sezónu, která je aktuálně vybraná pro přihlášeného uživatele.
     *
     * Pokud uživatel nemá explicitně vybranou sezónu, může být vrácena
     * výchozí hodnota podle implementace {@link CurrentSeasonService}.
     *
     * @return aktuální sezóna pro uživatele nebo null
     */
    @GetMapping("/me/current")
    @PreAuthorize("isAuthenticated()")
    public SeasonDTO getCurrentSeasonForUser() {
        Long id = currentSeasonService.getCurrentSeasonIdOrDefault();
        return (id != null) ? seasonService.getSeasonById(id) : null;
    }

    /**
     * Nastavuje aktuální sezónu pro přihlášeného uživatele.
     *
     * Před nastavením se ověřuje, že sezóna existuje. Id sezóny
     * se následně ukládá do kontextu aktuální sezóny uživatele.
     *
     * @param seasonId ID sezóny, která má být nastavena jako aktuální
     */
    @PostMapping("/me/current/{seasonId}")
    @PreAuthorize("isAuthenticated()")
    public void setCurrentSeasonForUser(@PathVariable Long seasonId) {
        seasonService.getSeasonById(seasonId);
        currentSeasonService.setCurrentSeasonId(seasonId);
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\TestController.java
-----

package cz.phsoft.hokej.controllers;

import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * Jednoduchý testovací REST controller.
 *
 * Slouží k ověření, že backend aplikace běží a že funguje
 * zabezpečení pro roli ADMIN.
 */
@RestController
@RequestMapping("/api/test")
@PreAuthorize("hasRole('ADMIN')")
public class TestController {

    /**
     * Vrací jednoduchou textovou zprávu pro ověření, že backend je online.
     *
     * @return textová zpráva potvrzující běh backendu
     */
    @GetMapping
    public String hello() {
        return "Backend je online!";
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\TestEmailController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.services.email.EmailService;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * Testovací REST controller pro odeslání e-mailu.
 *
 * Slouží k ověření konfigurace e-mailové služby v prostředí,
 * například při vývoji nebo testování.
 *
 * Veškerá logika odesílání e-mailů se předává do {@link EmailService}.
 */
@RestController
@RequestMapping("/api/email/test")
public class TestEmailController {

    private final EmailService emailService;

    public TestEmailController(EmailService emailService) {
        this.emailService = emailService;
    }

    /**
     * Odesílá testovací e-mail na pevně danou adresu.
     *
     * Endpoint se používá pro ověření, že e-mailová služba je správně
     * nakonfigurována a že lze e-maily z backendu odesílat.
     *
     * @return textová zpráva o odeslání e-mailu
     */
    @PostMapping("/send-mail")
    public String sendTestMail() {
        emailService.sendSimpleEmail(
                "petrhlista@seznam.cz",
                "APP - Testovací email",
                "Ahoj, toto je test z backendu."
        );
        return "Email odeslán";
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\TestSmsController.java
-----

/*
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.services.sms.SmsTextBeeService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * Testovací REST controller pro odeslání SMS.
 *
 * Slouží k ověření, že integrace se službou SmsTextBee funguje
 * správně v daném prostředí.
 */
/*
@RestController
public class TestSmsController {

    private final SmsTextBeeService smsTextBeeService;

    public TestSmsController(SmsTextBeeService smsTextBeeService) {
        this.smsTextBeeService = smsTextBeeService;
    }

    /**
     * Odesílá testovací SMS na testovací telefonní číslo.
     *
     * Endpoint se používá pro ověření funkčnosti SMS integrace.
     */
    /*
    @GetMapping("/api/test-sms")
    public String sendTestSms() {
        smsTextBeeService.sendSms("+420776609956", "testovací sms app-sg");
        return "SMS byla odeslána na testovací číslo +420776609956";
    }
}
*/


