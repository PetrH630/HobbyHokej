Balíček (složka): controllers
Cesta: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers

Seznam souborů:
AppModeController.java
AppUserController.java
AppUserSettingsController.java
AuthController.java
CurrentPlayerController.java
DebugController.java
DemoNotificationController.java
MatchController.java
MatchRegistrationController.java
MatchRegistrationHistoryController.java
MeController.java
NotificationController.java
package-info.java
PlayerController.java
PlayerInactivityPeriodController.java
PlayerSettingsController.java
SeasonController.java
TestController.java
TestEmailController.java
TestSmsController.java


-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\AppModeController.java
-----
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.services.notification.DemoModeService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Map;

/**
 * REST controller, kterĂ˝ se pouĹľĂ­vĂˇ pro poskytovĂˇnĂ­ informacĂ­ o aktuĂˇlnĂ­m reĹľimu aplikace.
 *
 * SlouĹľĂ­ k informovĂˇnĂ­ frontendovĂ© ÄŤĂˇsti o tom, zda je aplikace spuĹˇtÄ›na
 * v demo reĹľimu nebo ve standardnĂ­m produkÄŤnĂ­m reĹľimu. Na zĂˇkladÄ› tĂ©to
 * informace mĹŻĹľe frontend podmĂ­nÄ›nÄ› zobrazovat nebo omezovat urÄŤitou
 * funkcionalitu.
 *
 * VeĹˇkerĂˇ logika vyhodnocenĂ­ reĹľimu aplikace se deleguje na {@link DemoModeService}.
 */
@RestController
@RequestMapping("/api/public")
public class AppModeController {

    private final DemoModeService demoModeService;

    public AppModeController(DemoModeService demoModeService) {
        this.demoModeService = demoModeService;
    }

    /**
     * VracĂ­ informaci o aktuĂˇlnĂ­m reĹľimu aplikace.
     *
     * Hodnota je urÄŤena zejmĂ©na pro frontendovou ÄŤĂˇst systĂ©mu,
     * kterĂˇ na jejĂ­m zĂˇkladÄ› upravuje chovĂˇnĂ­ uĹľivatelskĂ©ho rozhranĂ­.
     *
     * @return mapovĂˇnĂ­ obsahujĂ­cĂ­ pĹ™Ă­znak demo reĹľimu aplikace
     */
    @GetMapping("/app-mode")
    public Map<String, Object> getAppMode() {
        return Map.of(
                "demoMode", demoModeService.isDemoMode()
        );
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\AppUserController.java
-----
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.AppUserHistoryDTO;
import cz.phsoft.hokej.models.dto.ChangePasswordDTO;
import cz.phsoft.hokej.models.services.AppUserHistoryService;
import cz.phsoft.hokej.models.services.AppUserService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller, kterĂ˝ se pouĹľĂ­vĂˇ pro sprĂˇvu uĹľivatelskĂ˝ch ĂşÄŤtĹŻ.
 *
 * ZajiĹˇĹĄuje prĂˇci s pĹ™ihlĂˇĹˇenĂ˝m uĹľivatelem, vÄŤetnÄ› zobrazenĂ­ profilu, historie zmÄ›n
 * a zmÄ›ny hesla, a takĂ© administrativnĂ­ sprĂˇvu uĹľivatelĹŻ, kterĂˇ je vyhrazena roli
 * ADMIN/MANAGER.
 *
 *
 * VeĹˇkerĂˇ business logika se pĹ™edĂˇvĂˇ do {@link AppUserService}.
 */
@RestController
@RequestMapping("/api/users")
public class AppUserController {

    private final AppUserService appUserService;
    private final AppUserHistoryService appUserHistoryService;

    public AppUserController(AppUserService appUserService,
                             AppUserHistoryService appUserHistoryService) {
        this.appUserService = appUserService;
        this.appUserHistoryService = appUserHistoryService;
    }

    /**
     * VracĂ­ detail aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * Identifikace uĹľivatele se provĂˇdĂ­ podle e-mailu (username),
     * kterĂ˝ je zĂ­skĂˇn z objektu {@link Authentication}.
     *
     * @param authentication autentizaÄŤnĂ­ kontext pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @return DTO s detaily pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     */
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public AppUserDTO getCurrentUser(Authentication authentication) {
        return appUserService.getCurrentUser(authentication.getName());
    }

    /**
     * Aktualizuje Ăşdaje aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * @param authentication autentizaÄŤnĂ­ kontext pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @param dto            DTO s aktualizovanĂ˝mi Ăşdaji uĹľivatele
     * @return HTTP odpovÄ›ÄŹ s informacĂ­ o ĂşspÄ›ĹˇnĂ© aktualizaci
     */
    @PutMapping("/me/update")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> updateUser(
            Authentication authentication,
            @Valid @RequestBody AppUserDTO dto) {

        String email = authentication.getName();
        appUserService.updateUser(email, dto);
        return ResponseEntity.ok("UĹľivatel byl zmÄ›nÄ›n");
    }

    /**
     * MÄ›nĂ­ heslo aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * StarĂ© heslo, novĂ© heslo a potvrzenĂ­ novĂ©ho hesla se pĹ™edĂˇvĂˇ
     * prostĹ™ednictvĂ­m DTO {@link ChangePasswordDTO}.
     *
     * @param authentication autentizaÄŤnĂ­ kontext pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @param dto            DTO obsahujĂ­cĂ­ starĂ© a novĂ© heslo
     * @return HTTP odpovÄ›ÄŹ s informacĂ­ o ĂşspÄ›ĹˇnĂ© zmÄ›nÄ› hesla
     */
    @PostMapping("/me/change-password")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> changePassword(
            Authentication authentication,
            @Valid @RequestBody ChangePasswordDTO dto) {

        String email = authentication.getName();
        appUserService.changePassword(
                email,
                dto.getOldPassword(),
                dto.getNewPassword(),
                dto.getNewPasswordConfirm()
        );
        return ResponseEntity.ok("Heslo ĂşspÄ›ĹˇnÄ› zmÄ›nÄ›no");
    }

    // ADMIN

    /**
     * VracĂ­ seznam vĹˇech uĹľivatelĹŻ v systĂ©mu.
     *
     * Endpoint je dostupnĂ˝ pouze pro roli ADMIN.
     *
     * @return seznam uĹľivatelĹŻ jako {@link AppUserDTO}
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<AppUserDTO> getAllUsers() {
        return appUserService.getAllUsers();
    }

    /**
     * VracĂ­ detail uĹľivatele podle jeho ID.
     *
     * Endpoint je dostupnĂ˝ pouze pro roli ADMIN.
     *
     * @param id ID uĹľivatele
     * @return DTO s detaily vybranĂ©ho uĹľivatele
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public AppUserDTO getUserById(@PathVariable Long id) {
        return appUserService.getUserById(id);
    }

    /**
     * Resetuje heslo uĹľivatele na vĂ˝chozĂ­ hodnotu.
     *
     * Operace je vyhrazena pouze pro roli ADMIN.
     *
     * @param id ID uĹľivatele, kterĂ©mu se mĂˇ heslo resetovat
     * @return HTTP odpovÄ›ÄŹ s informacĂ­ o ĂşspÄ›ĹˇnĂ©m resetu hesla
     */
    @PostMapping("/{id}/reset-password")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<String> resetPassword(@PathVariable Long id) {
        appUserService.resetPassword(id);
        return ResponseEntity.ok("Heslo resetovĂˇno na 'Player123'");
    }

    /**
     * Aktivuje ĂşÄŤet uĹľivatele.
     *
     * Operace je vyhrazena pouze pro roli ADMIN.
     *
     * @param id ID uĹľivatele, kterĂ˝ mĂˇ bĂ˝t aktivovĂˇn
     * @return HTTP odpovÄ›ÄŹ s informacĂ­ o ĂşspÄ›ĹˇnĂ© aktivaci
     */
    @PatchMapping("/{id}/activate")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<String> activateUserByAdmin(@PathVariable Long id) {
        appUserService.activateUserByAdmin(id);
        return ResponseEntity.ok("UĹľivatel byl ĂşspÄ›ĹˇnÄ› aktivovĂˇn");
    }

    /**
     * Deaktivuje ĂşÄŤet uĹľivatele.
     *
     * Operace je vyhrazena pouze pro roli ADMIN.
     *
     * @param id ID uĹľivatele, kterĂ˝ mĂˇ bĂ˝t deaktivovĂˇn
     * @return HTTP odpovÄ›ÄŹ s informacĂ­ o ĂşspÄ›ĹˇnĂ© deaktivaci
     */
    @PatchMapping("/{id}/deactivate")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<String> deactivateUserByAdmin(@PathVariable Long id) {
        appUserService.deactivateUserByAdmin(id);
        return ResponseEntity.ok("UĹľivatel byl ĂşspÄ›ĹˇnÄ› deaktivovĂˇn");
    }

    /**
     * VracĂ­ historii uĹľivatele dle id.
     *
     * Operace je vyhrazena pouze pro roli ADMIN.
     *
     * @param id ID uĹľivatele
     * @return historie uĹľivatele jako {@link List<AppUserHistoryDTO>}
     */
    @GetMapping("/{id}/history")
    @PreAuthorize("hasRole('ADMIN')")
    public List<AppUserHistoryDTO> getUserHistory(@PathVariable Long id
            ) {
        return appUserHistoryService.getHistoryForUser(id);
    }

    /**
     * VracĂ­ historii aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * @param authentication autentizaÄŤnĂ­ kontext pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @return historie uĹľivatele jako {@link List<AppUserHistoryDTO>}
     */
    @GetMapping("/me/history")
    @PreAuthorize("isAuthenticated()")
    public List<AppUserHistoryDTO> getMyUserHistory(
            Authentication authentication
            ) {

        String email = authentication.getName();
        return appUserHistoryService.getHistoryForUser(email);

    }

}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\AppUserSettingsController.java
-----
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.AppUserSettingsDTO;
import cz.phsoft.hokej.models.services.AppUserSettingsService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

/**
 * REST controller, kterĂ˝ se pouĹľĂ­vĂˇ pro sprĂˇvu nastavenĂ­ uĹľivatele
 * na Ăşrovni aplikaÄŤnĂ­ho ĂşÄŤtu (AppUser).
 *
 * Pracuje s nastavenĂ­m navĂˇzanĂ˝m na ĂşÄŤet uĹľivatele, nikoli na aktuĂˇlnĂ­ho
 * hrĂˇÄŤe. SlouĹľĂ­ napĹ™Ă­klad pro nastavenĂ­ preferencĂ­ uĹľivatele a reĹľimu
 * vĂ˝bÄ›ru hrĂˇÄŤe po pĹ™ihlĂˇĹˇenĂ­.
 *
 * VeĹˇkerĂˇ business logika se pĹ™edĂˇvĂˇ do {@link AppUserSettingsService}.
 */
@RestController
@RequestMapping("/api/user")
public class AppUserSettingsController {

    private final AppUserSettingsService appUserSettingsService;

    public AppUserSettingsController(AppUserSettingsService appUserSettingsService) {
        this.appUserSettingsService = appUserSettingsService;
    }

    /**
     * VracĂ­ nastavenĂ­ aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * UĹľivatel se identifikuje pomocĂ­ e-mailu zĂ­skanĂ©ho z objektu
     * {@link Authentication}.
     *
     * @param auth autentizaÄŤnĂ­ kontext pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @return DTO s nastavenĂ­m uĹľivatele
     */
    @GetMapping("/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<AppUserSettingsDTO> getCurrentUserSettings(Authentication auth) {
        String userEmail = auth.getName();
        AppUserSettingsDTO dto = appUserSettingsService.getSettingsForUser(userEmail);
        return ResponseEntity.ok(dto);
    }

    /**
     * Aktualizuje nastavenĂ­ aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * OÄŤekĂˇvĂˇ se, Ĺľe frontend pĹ™edĂˇ kompletnĂ­ stav nastavenĂ­, kterĂ˝ se
     * aplikuje na ĂşÄŤet uĹľivatele.
     *
     * @param auth       autentizaÄŤnĂ­ kontext pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @param requestDto DTO s novĂ˝m nastavenĂ­m uĹľivatele
     * @return DTO s aktualizovanĂ˝m nastavenĂ­m uĹľivatele
     */
    @PatchMapping("/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<AppUserSettingsDTO> updateCurrentUserSettings(
            Authentication auth,
            @RequestBody AppUserSettingsDTO requestDto
    ) {
        String userEmail = auth.getName();
        AppUserSettingsDTO updated = appUserSettingsService.updateSettingsForUser(userEmail, requestDto);
        return ResponseEntity.ok(updated);
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\AuthController.java
-----
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.EmailDTO;
import cz.phsoft.hokej.models.dto.ForgottenPasswordResetDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;
import cz.phsoft.hokej.models.services.AppUserService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

/**
 * REST controller, kterĂ˝ se pouĹľĂ­vĂˇ pro autentizaci a registraci uĹľivatelĹŻ.
 *
 * ZajiĹˇĹĄuje registraci novĂ˝ch uĹľivatelĹŻ, aktivaci ĂşÄŤtĹŻ pomocĂ­ ovÄ›Ĺ™ovacĂ­ho
 * tokenu, prĂˇci s pĹ™ihlĂˇĹˇenĂ˝m uĹľivatelem a proces zapomenutĂ©ho hesla
 * vÄŤetnÄ› vystavenĂ­ tokenu a nastavenĂ­ novĂ©ho hesla.
 *
 * VeĹˇkerĂˇ business logika se pĹ™edĂˇvĂˇ do {@link AppUserService}.
 */
@RestController
@RequestMapping("/api/auth")
public class AuthController {

    private final AppUserService appUserService;

    /**
     * ZĂˇkladnĂ­ URL frontendovĂ© SPA aplikace (React/Vite).
     *
     * Tato hodnota se pouĹľĂ­vĂˇ pro pĹ™esmÄ›rovĂˇnĂ­ uĹľivatele pĹ™i procesu
     * resetu hesla, aby mohl bĂ˝t otevĹ™en sprĂˇvnĂ˝ route na frontend aplikaci.
     */
    @Value("${app.frontend-base-url}")
    private String frontendBaseUrl;

    public AuthController(AppUserService appUserService) {
        this.appUserService = appUserService;
    }

    /**
     * Registruje novĂ©ho uĹľivatele.
     *
     * Po ĂşspÄ›ĹˇnĂ© registraci se vytvĂˇĹ™Ă­ aktivaÄŤnĂ­ token a odesĂ­lĂˇ se
     * aktivaÄŤnĂ­ e-mail s odkazem na aktivaci ĂşÄŤtu.
     *
     * @param dto registraÄŤnĂ­ Ăşdaje novĂ©ho uĹľivatele
     * @return HTTP odpovÄ›ÄŹ s informacĂ­ o ĂşspÄ›ĹˇnĂ© registraci
     */
    @PostMapping("/register")
    public ResponseEntity<?> register(@Valid @RequestBody RegisterUserDTO dto) {
        appUserService.register(dto);
        return ResponseEntity.ok(
                Map.of(
                        "status", "ok",
                        "message", "Registrace ĂşspÄ›ĹˇnĂˇ. Zkontrolujte email pro aktivaci ĂşÄŤtu."
                )
        );
    }

    /**
     * VracĂ­ informace o aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©m uĹľivateli.
     *
     * @param authentication autentizaÄŤnĂ­ kontext pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @return DTO s detaily pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     */
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<AppUserDTO> getCurrentUser(Authentication authentication) {
        AppUserDTO dto = appUserService.getCurrentUser(authentication.getName());
        return ResponseEntity.ok(dto);
    }

    /**
     * Aktivuje uĹľivatelskĂ˝ ĂşÄŤet na zĂˇkladÄ› ovÄ›Ĺ™ovacĂ­ho tokenu.
     *
     * Token se zĂ­skĂˇvĂˇ z aktivaÄŤnĂ­ho odkazu zaslanĂ©ho po registraci
     * a mĂˇ omezenou platnost. V pĹ™Ă­padÄ› neplatnĂ©ho nebo expirovanĂ©ho
     * tokenu se vracĂ­ chyba 400.
     *
     * @param token aktivaÄŤnĂ­ token
     * @return textovĂˇ informace o vĂ˝sledku aktivace ĂşÄŤtu
     */
    @GetMapping("/verify")
    public ResponseEntity<String> verifyEmail(@RequestParam String token) {
        boolean activated = appUserService.activateUser(token);

        if (!activated) {
            return ResponseEntity
                    .badRequest()
                    .body("NeplatnĂ˝ nebo expirovanĂ˝ aktivaÄŤnĂ­ odkaz.");
        }

        return ResponseEntity.ok("ĂšÄŤet byl ĂşspÄ›ĹˇnÄ› aktivovĂˇn.");
    }

    /**
     * PĹ™esmÄ›rovĂˇvĂˇ uĹľivatele z odkazu v e-mailu na frontendovou strĂˇnku
     * pro nastavenĂ­ novĂ©ho hesla.
     *
     * Backend provĂˇdĂ­ redirect na odpovĂ­dajĂ­cĂ­ route frontendovĂ© SPA
     * a pĹ™edĂˇvĂˇ reset token jako query parametr. SamotnĂˇ zmÄ›na hesla
     * se nĂˇslednÄ› provĂˇdĂ­ pomocĂ­ REST endpointĹŻ pro zapomenutĂ© heslo.
     *
     * @param token reset token pro zapomenutĂ© heslo
     * @return HTTP 302 s hlaviÄŤkou Location na frontendovou URL
     */
    @GetMapping("/reset-password")
    public ResponseEntity<Void> redirectResetPassword(@RequestParam String token) {
        String targetUrl = frontendBaseUrl + "/reset-password?token=" + token;

        return ResponseEntity
                .status(HttpStatus.FOUND)
                .header("Location", targetUrl)
                .build();
    }

    /**
     * VytvĂˇĹ™Ă­ poĹľadavek na reset zapomenutĂ©ho hesla.
     *
     * Na zĂˇkladÄ› zadanĂ© e-mailovĂ© adresy se vytvoĹ™Ă­ reset token
     * a odeĹˇle se e-mail s odkazem pro nastavenĂ­ novĂ©ho hesla.
     *
     * @param dto DTO s e-mailovou adresou uĹľivatele
     * @return HTTP odpovÄ›ÄŹ 200 v pĹ™Ă­padÄ› ĂşspÄ›chu
     */
    @PostMapping("/forgotten-password")
    public ResponseEntity<Void> requestForgottenPassword(@RequestBody @Valid EmailDTO dto) {
        appUserService.requestForgottenPasswordReset(dto.getEmail());
        return ResponseEntity.ok().build();
    }

    /**
     * VracĂ­ informaci o e-mailu, ke kterĂ©mu pĹ™Ă­sluĹˇĂ­ danĂ˝ reset token.
     *
     * Endpoint se pouĹľĂ­vĂˇ napĹ™Ă­klad pro zobrazenĂ­ e-mailovĂ© adresy
     * na frontendovĂ© strĂˇnce pro reset hesla.
     *
     * @param token reset token
     * @return mapovĂˇnĂ­ obsahujĂ­cĂ­ e-mail navĂˇzanĂ˝ na token
     */
    @GetMapping("/forgotten-password/info")
    public ResponseEntity<Map<String, String>> getForgottenPasswordInfo(@RequestParam String token) {
        String email = appUserService.getForgottenPasswordResetEmail(token);
        return ResponseEntity.ok(Map.of("email", email));
    }

    /**
     * ProvĂˇdĂ­ nastavenĂ­ novĂ©ho hesla na zĂˇkladÄ› reset tokenu.
     *
     * Informace o tokenu, novĂ©m hesle a jeho potvrzenĂ­ se pĹ™edĂˇvĂˇ
     * prostĹ™ednictvĂ­m {@link ForgottenPasswordResetDTO}.
     *
     * @param dto DTO obsahujĂ­cĂ­ token a novĂ© heslo
     * @return HTTP odpovÄ›ÄŹ 200 v pĹ™Ă­padÄ› ĂşspÄ›chu
     */
    @PostMapping("/forgotten-password/reset")
    public ResponseEntity<Void> forgottenPasswordReset(@RequestBody @Valid ForgottenPasswordResetDTO dto) {
        appUserService.forgottenPasswordReset(dto);
        return ResponseEntity.ok().build();
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\CurrentPlayerController.java
-----
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.services.PlayerService;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller, kterĂ˝ se pouĹľĂ­vĂˇ pro prĂˇci s aktuĂˇlnĂ­m hrĂˇÄŤem
 * pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
 *
 * AktuĂˇlnĂ­ hrĂˇÄŤ pĹ™edstavuje kontext, ve kterĂ©m uĹľivatel pracuje
 * napĹ™Ă­klad pĹ™i registraci na zĂˇpasy nebo pĹ™i zobrazenĂ­ statistik.
 * Controller umoĹľĹuje nastavenĂ­ aktuĂˇlnĂ­ho hrĂˇÄŤe, automatickĂ˝ vĂ˝bÄ›r
 * hrĂˇÄŤe po pĹ™ihlĂˇĹˇenĂ­ a zĂ­skĂˇnĂ­ aktuĂˇlnÄ› zvolenĂ©ho hrĂˇÄŤe.
 *
 * VeĹˇkerĂˇ business logika se pĹ™edĂˇvĂˇ do {@link PlayerService}
 * a {@link CurrentPlayerService}.
 */
@RestController
@RequestMapping("/api/current-player")
public class CurrentPlayerController {

    private final CurrentPlayerService currentPlayerService;
    private final PlayerService playerService;

    public CurrentPlayerController(CurrentPlayerService currentPlayerService,
                                   PlayerService playerService) {
        this.currentPlayerService = currentPlayerService;
        this.playerService = playerService;
    }

    /**
     * Nastavuje aktuĂˇlnĂ­ho hrĂˇÄŤe pro pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * Metoda se pouĹľĂ­vĂˇ zejmĂ©na v pĹ™Ă­padech, kdy mĂˇ uĹľivatel pĹ™iĹ™azeno
     * vĂ­ce hrĂˇÄŤĹŻ a potĹ™ebuje mezi nimi ruÄŤnÄ› pĹ™epĂ­nat.
     *
     * @param playerId ID hrĂˇÄŤe, kterĂ˝ mĂˇ bĂ˝t nastaven jako aktuĂˇlnĂ­
     * @param auth     autentizaÄŤnĂ­ kontext pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @return DTO {@link SuccessResponseDTO} s informacĂ­ o provedenĂ© zmÄ›nÄ›
     */
    @PostMapping("/{playerId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<SuccessResponseDTO> setCurrentPlayer(
            @PathVariable Long playerId,
            Authentication auth) {

        SuccessResponseDTO response =
                playerService.setCurrentPlayerForUser(auth.getName(), playerId);

        return ResponseEntity.ok(response);
    }

    /**
     * ProvĂˇdĂ­ automatickĂ˝ vĂ˝bÄ›r aktuĂˇlnĂ­ho hrĂˇÄŤe pro pĹ™ihlĂˇĹˇenĂ©ho
     * uĹľivatele podle nastavenĂ­ v AppUserSettings.
     *
     * NapĹ™Ă­klad mĹŻĹľe bĂ˝t vybrĂˇn prvnĂ­ hrĂˇÄŤ podle ID nebo mĹŻĹľe bĂ˝t
     * ponechĂˇn stav bez vybranĂ©ho hrĂˇÄŤe, aby si uĹľivatel vybral hrĂˇÄŤe
     * ruÄŤnÄ› na frontendu.
     *
     * @param auth autentizaÄŤnĂ­ kontext pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @return DTO {@link SuccessResponseDTO} s vĂ˝sledkem automatickĂ©ho vĂ˝bÄ›ru
     */
    @PostMapping("/auto-select")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<SuccessResponseDTO> autoSelectCurrentPlayer(Authentication auth) {
        SuccessResponseDTO response =
                playerService.autoSelectCurrentPlayerForUser(auth.getName());

        return ResponseEntity.ok(response);
    }

    /**
     * VracĂ­ aktuĂˇlnÄ› zvolenĂ©ho hrĂˇÄŤe pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * Pokud nenĂ­ aktuĂˇlnĂ­ hrĂˇÄŤ nastaven, vracĂ­ se hodnota null.
     *
     * @return DTO {@link PlayerDTO} s detaily hrĂˇÄŤe nebo null
     */
    @GetMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<PlayerDTO> getCurrentPlayer() {

        Long playerId = currentPlayerService.getCurrentPlayerId();
        if (playerId == null) {
            return ResponseEntity.ok(null);
        }

        PlayerDTO player = playerService.getPlayerById(playerId);
        return ResponseEntity.ok(player);
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\DebugController.java
-----
package cz.phsoft.hokej.controllers;

import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * REST controller, kterĂ˝ se pouĹľĂ­vĂˇ pro ladÄ›nĂ­ bezpeÄŤnostnĂ­ho kontextu.
 *
 * UmoĹľĹuje ovÄ›Ĺ™it, zda je uĹľivatel autentizovĂˇn a jakĂ© informace
 * jsou dostupnĂ© v objektu {@link Authentication}. Controller je urÄŤen
 * pouze pro vĂ˝vojovĂ© prostĹ™edĂ­ a nemÄ›l by bĂ˝t vystaven v produkci.
 */
@RestController
public class DebugController {

    /**
     * VracĂ­ aktuĂˇlnĂ­ objekt {@link Authentication}.
     *
     * Metoda se pouĹľĂ­vĂˇ vĂ˝hradnÄ› pro ladÄ›nĂ­ a diagnostiku
     * bezpeÄŤnostnĂ­ho kontextu.
     *
     * @param auth autentizaÄŤnĂ­ kontext aktuĂˇlnĂ­ho uĹľivatele
     * @return objekt {@link Authentication} s informacemi o uĹľivateli
     */
    @GetMapping("/api/debug/me")
    public Object me(Authentication auth) {
        return auth;
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\DemoNotificationController.java
-----
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.DemoNotificationsDTO;
import cz.phsoft.hokej.models.services.notification.DemoNotificationStore;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

/**
 * REST controller, kterĂ˝ se pouĹľĂ­vĂˇ pro prĂˇci s demo notifikacemi.
 *
 * Controller je registrovĂˇn pouze v demo reĹľimu. Pokud demo reĹľim nenĂ­ aktivnĂ­,
 * endpointy nejsou souÄŤĂˇstĂ­ aplikace a vracĂ­ se odpovÄ›ÄŹ 404.
 *
 * PrĂˇce s doÄŤasnĂ˝m ĂşloĹľiĹˇtÄ›m notifikacĂ­ se deleguje na {@link DemoNotificationStore}.
 */
@RestController
@RequestMapping("/api/demo/notifications")
@ConditionalOnProperty(name = "app.demo-mode", havingValue = "true")
public class DemoNotificationController {

    private final DemoNotificationStore demoNotificationStore;

    public DemoNotificationController(DemoNotificationStore demoNotificationStore) {
        this.demoNotificationStore = demoNotificationStore;
    }

    /**
     * VracĂ­ vĹˇechny zachycenĂ© demo notifikace a nĂˇslednÄ› je vymaĹľe z ĂşloĹľiĹˇtÄ›.
     *
     * Endpoint slouĹľĂ­ zejmĂ©na pro frontendovou ÄŤĂˇst aplikace,
     * kterĂˇ zobrazuje simulovanĂ© odeslanĂ© e-maily a SMS zprĂˇvy v demo reĹľimu.
     *
     * @return DTO obsahujĂ­cĂ­ seznam zachycenĂ˝ch e-mailĹŻ a SMS zprĂˇv
     */
    @GetMapping
    public ResponseEntity<DemoNotificationsDTO> getDemoNotifications() {
        DemoNotificationsDTO dto = demoNotificationStore.getAndClear();
        return ResponseEntity.ok(dto);
    }

    /**
     * Provede vyÄŤiĹˇtÄ›nĂ­ zachycenĂ˝ch demo notifikacĂ­ bez jejich vrĂˇcenĂ­.
     *
     * Endpoint umoĹľĹuje explicitnĂ­ smazĂˇnĂ­ obsahu ĂşloĹľiĹˇtÄ›
     * napĹ™Ă­klad pĹ™i resetu demo prostĹ™edĂ­.
     *
     * @return HTTP odpovÄ›ÄŹ 204 No Content v pĹ™Ă­padÄ› ĂşspÄ›chu
     */
    @DeleteMapping
    public ResponseEntity<Void> clearDemoNotifications() {
        demoNotificationStore.getAndClear();
        return ResponseEntity.noContent().build();
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\MatchController.java
-----
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.enums.MatchCancelReason;
import cz.phsoft.hokej.models.dto.*;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import cz.phsoft.hokej.models.services.MatchHistoryService;
import cz.phsoft.hokej.models.services.MatchService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller, kterĂ˝ se pouĹľĂ­vĂˇ pro sprĂˇvu zĂˇpasĹŻ.
 *
 * ZajiĹˇĹĄuje administrativnĂ­ operace nad zĂˇpasy pro role ADMIN a MANAGER,
 * vÄŤetnÄ› vytvĂˇĹ™enĂ­, aktualizace, mazĂˇnĂ­, zruĹˇenĂ­ a obnovenĂ­ zĂˇpasĹŻ.
 * ZĂˇroveĹ poskytuje pohled na zĂˇpasy z perspektivy aktuĂˇlnĂ­ho hrĂˇÄŤe
 * a detail zĂˇpasu vÄŤetnÄ› informacĂ­ o registracĂ­ch.
 *
 * VeĹˇkerĂˇ business logika se deleguje do {@link MatchService},
 * prĂˇce s historiĂ­ zĂˇpasĹŻ do {@link MatchHistoryService} a prĂˇce
 * s aktuĂˇlnĂ­m hrĂˇÄŤem do {@link CurrentPlayerService}.
 */
@RestController
@RequestMapping("/api/matches")
public class MatchController {

    private final MatchService matchService;
    private final CurrentPlayerService currentPlayerService;
    private final MatchHistoryService matchHistoryService;

    public MatchController(MatchService matchService,
                           CurrentPlayerService currentPlayerService,
                           MatchHistoryService matchHistoryService) {
        this.matchService = matchService;
        this.currentPlayerService = currentPlayerService;
        this.matchHistoryService = matchHistoryService;
    }

    // ADMIN / MANAGER â€“ globĂˇlnĂ­ sprĂˇva zĂˇpasĹŻ

    /**
     * VracĂ­ seznam vĹˇech zĂˇpasĹŻ v systĂ©mu.
     *
     * Endpoint je urÄŤen pro administrativnĂ­ pĹ™ehled zĂˇpasĹŻ a
     * je dostupnĂ˝ pro role ADMIN a MANAGER.
     *
     * @return seznam vĹˇech zĂˇpasĹŻ jako {@link MatchDTO}
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getAllMatches() {
        return matchService.getAllMatches();
    }

    /**
     * VracĂ­ seznam vĹˇech nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ.
     *
     * Endpoint je dostupnĂ˝ pro role ADMIN a MANAGER a slouĹľĂ­
     * k pĹ™ehledu budoucĂ­ch zĂˇpasĹŻ v systĂ©mu.
     *
     * @return seznam nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ jako {@link MatchDTO}
     */
    @GetMapping("/upcoming")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getUpcomingMatches() {
        return matchService.getUpcomingMatches();
    }

    /**
     * VracĂ­ seznam vĹˇech jiĹľ odehranĂ˝ch zĂˇpasĹŻ.
     *
     * Endpoint je dostupnĂ˝ pro role ADMIN a MANAGER a pouĹľĂ­vĂˇ se
     * pro pĹ™ehled historicky odehranĂ˝ch zĂˇpasĹŻ.
     *
     * @return seznam odehranĂ˝ch zĂˇpasĹŻ jako {@link MatchDTO}
     */
    @GetMapping("/past")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getPastMatches() {
        return matchService.getPastMatches();
    }

    /**
     * VytvĂˇĹ™Ă­ novĂ˝ zĂˇpas.
     *
     * VstupnĂ­ data jsou validovĂˇna pomocĂ­ bean validation a
     * vlastnĂ­ uloĹľenĂ­ zĂˇpasu se deleguje do servisnĂ­ vrstvy.
     * Operace je vyhrazena roli ADMIN.
     *
     * @param matchDTO DTO s daty novĂ©ho zĂˇpasu
     * @return vytvoĹ™enĂ˝ zĂˇpas jako {@link MatchDTO}
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO createMatch(@Valid @RequestBody MatchDTO matchDTO) {
        return matchService.createMatch(matchDTO);
    }

    /**
     * VracĂ­ detail zĂˇpasu podle jeho ID v administrativnĂ­m pohledu.
     *
     * JednĂˇ se o pohled pro administrĂˇtora nebo manaĹľera bez vazby
     * na konkrĂ©tnĂ­ho hrĂˇÄŤe. Endpoint je vhodnĂ˝ pro editaci zĂˇpasu
     * nebo pro jeho detailnĂ­ kontrolu.
     *
     * @param id ID zĂˇpasu
     * @return {@link MatchDTO} s detaily zĂˇpasu
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO getMatch(@PathVariable Long id) {
        return matchService.getMatchById(id);
    }

    /**
     * VracĂ­ historii zmÄ›n danĂ©ho zĂˇpasu.
     *
     * Historie slouĹľĂ­ pro auditnĂ­ ĂşÄŤely a sledovĂˇnĂ­ prĹŻbÄ›ĹľnĂ˝ch
     * Ăşprav parametrĹŻ zĂˇpasu. ZĂˇznamy jsou zĂ­skĂˇvĂˇny ze servisnĂ­
     * vrstvy, kterĂˇ ÄŤte historii z databĂˇze.
     *
     * @param id ID zĂˇpasu
     * @return seznam {@link MatchHistoryDTO} pĹ™edstavujĂ­cĂ­ch historii zĂˇpasu
     */
    @GetMapping("/{id}/history")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchHistoryDTO> getMatchHistory(@PathVariable Long id) {
        return matchHistoryService.getHistoryForMatch(id);
    }

    /**
     * Aktualizuje existujĂ­cĂ­ zĂˇpas.
     *
     * VstupnĂ­ data jsou validovĂˇna a nĂˇslednĂˇ aktualizace se
     * deleguje do servisnĂ­ vrstvy. Endpoint je dostupnĂ˝ pro role
     * ADMIN a MANAGER.
     *
     * @param id  ID zĂˇpasu, kterĂ˝ mĂˇ bĂ˝t aktualizovĂˇn
     * @param dto DTO s aktualizovanĂ˝mi daty zĂˇpasu
     * @return {@link MatchDTO} s uloĹľenĂ˝mi zmÄ›nami
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO updateMatch(@PathVariable Long id,
                                @Valid @RequestBody MatchDTO dto) {
        return matchService.updateMatch(id, dto);
    }

    /**
     * OdstraĹuje zĂˇpas ze systĂ©mu.
     *
     * OdstranÄ›nĂ­ zĂˇpasu se pouĹľĂ­vĂˇ vĂ˝jimeÄŤnÄ›, napĹ™Ă­klad pĹ™i
     * chybnÄ› zadanĂ©m zĂˇpasu. Operace je vyhrazena pouze pro roli ADMIN
     * a je realizovĂˇna prostĹ™ednictvĂ­m servisnĂ­ vrstvy.
     *
     * @param id ID zĂˇpasu, kterĂ˝ mĂˇ bĂ˝t odstranÄ›n
     * @return {@link SuccessResponseDTO} s vĂ˝sledkem operace
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SuccessResponseDTO> deleteMatch(@PathVariable Long id) {
        SuccessResponseDTO response = matchService.deleteMatch(id);
        return ResponseEntity.ok(response);
    }

    /**
     * VracĂ­ seznam zĂˇpasĹŻ, kterĂ© jsou dostupnĂ© pro konkrĂ©tnĂ­ho hrĂˇÄŤe.
     *
     * Dostupnost zĂˇpasĹŻ je urÄŤovĂˇna na zĂˇkladÄ› domĂ©novĂ˝ch pravidel,
     * napĹ™Ă­klad podle kapacity nebo stavu zĂˇpasu. Endpoint je dostupnĂ˝
     * pro role ADMIN a MANAGER a slouĹľĂ­ zejmĂ©na pro administrativnĂ­ prĂˇci
     * s registracemi konkrĂ©tnĂ­ho hrĂˇÄŤe.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return seznam dostupnĂ˝ch zĂˇpasĹŻ pro danĂ©ho hrĂˇÄŤe jako {@link MatchDTO}
     */
    @GetMapping("/available-for-player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getAvailableMatchesForPlayer(@PathVariable Long playerId) {
        return matchService.getAvailableMatchesForPlayer(playerId);
    }

    /**
     * RuĹˇĂ­ zĂˇpas a uklĂˇdĂˇ dĹŻvod zruĹˇenĂ­.
     *
     * Operace je dostupnĂˇ pro role ADMIN a MANAGER a typicky
     * spouĹˇtĂ­ navazujĂ­cĂ­ proces notifikacĂ­ pro dotÄŤenĂ© hrĂˇÄŤe.
     * DĹŻvod zruĹˇenĂ­ je pĹ™edĂˇvĂˇn jako enum {@link MatchCancelReason}.
     *
     * @param matchId ID zĂˇpasu, kterĂ˝ mĂˇ bĂ˝t zruĹˇen
     * @param reason  dĹŻvod zruĹˇenĂ­ zĂˇpasu
     * @return {@link SuccessResponseDTO} s vĂ˝sledkem operace
     */
    @PatchMapping("/{matchId}/cancel")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SuccessResponseDTO> cancelMatch(
            @PathVariable Long matchId,
            @RequestParam MatchCancelReason reason
    ) {
        SuccessResponseDTO response = matchService.cancelMatch(matchId, reason);
        return ResponseEntity.ok(response);
    }

    /**
     * Obnovuje dĹ™Ă­ve zruĹˇenĂ˝ zĂˇpas.
     *
     * ObnovenĂ­ zĂˇpasu vracĂ­ zĂˇpas do aktivnĂ­ho stavu a umoĹľĹuje
     * dalĹˇĂ­ prĂˇci s registracemi hrĂˇÄŤĹŻ. Operace je dostupnĂˇ pro
     * role ADMIN a MANAGER a zpracovĂˇnĂ­ je delegovĂˇno na servisnĂ­ vrstvu.
     *
     * @param matchId ID zĂˇpasu, kterĂ˝ mĂˇ bĂ˝t obnoven
     * @return {@link SuccessResponseDTO} s vĂ˝sledkem operace
     */
    @PatchMapping("/{matchId}/uncancel")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SuccessResponseDTO> unCancelMatch(@PathVariable Long matchId) {
        SuccessResponseDTO response = matchService.unCancelMatch(matchId);
        return ResponseEntity.ok(response);
    }

    // HrĂˇÄŤ â€“ endpointy v kontextu aktuĂˇlnĂ­ho hrĂˇÄŤe

    /**
     * VracĂ­ detail konkrĂ©tnĂ­ho zĂˇpasu z pohledu hrĂˇÄŤe.
     *
     * Detail obsahuje informace o registracĂ­ch, volnĂ˝ch mĂ­stech
     * a moĹľnostech Ăşprav registrace pro aktuĂˇlnĂ­ho hrĂˇÄŤe. Endpoint
     * je dostupnĂ˝ pro pĹ™ihlĂˇĹˇenĂ© uĹľivatele.
     *
     * @param id ID zĂˇpasu
     * @return {@link MatchDetailDTO} s detailem zĂˇpasu pro hrĂˇÄŤe
     */
    @GetMapping("/{id}/detail")
    @PreAuthorize("isAuthenticated()")
    public MatchDetailDTO getMatchDetail(@PathVariable Long id) {
        return matchService.getMatchDetail(id);
    }

    /**
     * VracĂ­ nejbliĹľĹˇĂ­ nadchĂˇzejĂ­cĂ­ zĂˇpas v systĂ©mu.
     *
     * Endpoint se pouĹľĂ­vĂˇ napĹ™Ă­klad pro zobrazenĂ­ nejbliĹľĹˇĂ­ho
     * zĂˇpasu na ĂşvodnĂ­ strĂˇnce aplikace pro pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * @return {@link MatchDTO} s nejbliĹľĹˇĂ­m zĂˇpasem nebo null, pokud ĹľĂˇdnĂ˝ neexistuje
     */
    @GetMapping("/next")
    @PreAuthorize("isAuthenticated()")
    public MatchDTO getNextMatch() {
        return matchService.getNextMatch();
    }

    /**
     * VracĂ­ seznam nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ pro aktuĂˇlnÄ› zvolenĂ©ho hrĂˇÄŤe.
     *
     * PĹ™ed volĂˇnĂ­m sluĹľby se vyĹľaduje, aby byl nastaven aktuĂˇlnĂ­ hrĂˇÄŤ.
     * SamotnĂ© zjiĹˇtÄ›nĂ­ ID aktuĂˇlnĂ­ho hrĂˇÄŤe se zajiĹˇĹĄuje pomocĂ­
     * {@link CurrentPlayerService}. Endpoint je dostupnĂ˝ pro
     * pĹ™ihlĂˇĹˇenĂ© uĹľivatele.
     *
     * @param authentication autentizaÄŤnĂ­ kontext pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @return seznam nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ pro aktuĂˇlnĂ­ho hrĂˇÄŤe jako {@link MatchDTO}
     */
    @GetMapping("/me/upcoming")
    @PreAuthorize("isAuthenticated()")
    public List<MatchDTO> getUpcomingMatchesForMe(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getUpcomingMatchesForPlayer(currentPlayerId);
    }

    /**
     * VracĂ­ pĹ™ehled nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ pro aktuĂˇlnĂ­ho hrĂˇÄŤe.
     *
     * PĹ™ehled je urÄŤen zejmĂ©na pro kompaktnĂ­ zobrazenĂ­ zĂˇpasĹŻ
     * v uĹľivatelskĂ©m rozhranĂ­, napĹ™Ă­klad v podobÄ› karet. SkuteÄŤnĂ©
     * naÄŤtenĂ­ dat se deleguje na servisnĂ­ vrstvu.
     *
     * @param authentication autentizaÄŤnĂ­ kontext pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @return seznam {@link MatchOverviewDTO} s nadchĂˇzejĂ­cĂ­mi zĂˇpasy pro hrĂˇÄŤe
     */
    @GetMapping("/me/upcoming-overview")
    @PreAuthorize("isAuthenticated()")
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForMe(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getUpcomingMatchesOverviewForPlayer(currentPlayerId);
    }

    /**
     * VracĂ­ seznam vĹˇech jiĹľ odehranĂ˝ch zĂˇpasĹŻ pro aktuĂˇlnĂ­ho hrĂˇÄŤe.
     *
     * Seznam slouĹľĂ­ pro zobrazenĂ­ historie zĂˇpasĹŻ danĂ©ho hrĂˇÄŤe
     * v uĹľivatelskĂ©m rozhranĂ­. Endpoint je dostupnĂ˝ pro pĹ™ihlĂˇĹˇenĂ©
     * uĹľivatele a identita hrĂˇÄŤe se urÄŤuje pomocĂ­ {@link CurrentPlayerService}.
     *
     * @param authentication autentizaÄŤnĂ­ kontext pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @return seznam {@link MatchOverviewDTO} pro odehranĂ© zĂˇpasy aktuĂˇlnĂ­ho hrĂˇÄŤe
     */
    // TODO - JEN ZĂPASY OD VYTVOĹENĂŤ HRĂÄŚE
    @GetMapping("/me/all-passed")
    @PreAuthorize("isAuthenticated()")
    public List<MatchOverviewDTO> getAllMatchesForPlayer(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getAllPassedMatchesForPlayer(currentPlayerId);
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\MatchRegistrationController.java
-----
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.exceptions.CurrentPlayerNotSelectedException;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import cz.phsoft.hokej.models.services.MatchService;
import jakarta.validation.Valid;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller, kterĂ˝ se pouĹľĂ­vĂˇ pro sprĂˇvu registracĂ­ hrĂˇÄŤĹŻ na zĂˇpasy.
 *
 * ZajiĹˇĹĄuje administrativnĂ­ sprĂˇvu registracĂ­ pro role ADMIN a MANAGER
 * a sprĂˇvu registracĂ­ pro aktuĂˇlnĂ­ho hrĂˇÄŤe pod endpointy s prefixem /me.
 * UmoĹľĹuje registraci, odhlĂˇĹˇenĂ­, evidenci omluv a neomluvenĂ© neĂşÄŤasti
 * a takĂ© pĹ™ehled registracĂ­ napĹ™Ă­ÄŤ zĂˇpasy.
 *
 * VeĹˇkerĂˇ business logika se deleguje do {@link MatchRegistrationService},
 * informace o aktuĂˇlnĂ­m hrĂˇÄŤi se zĂ­skĂˇvajĂ­ z {@link CurrentPlayerService}
 * a souvisejĂ­cĂ­ domĂ©novĂˇ logika mĹŻĹľe bĂ˝t ÄŤĂˇsteÄŤnÄ› Ĺ™eĹˇena takĂ© v {@link MatchService}.
 */
@RestController
@RequestMapping("/api/registrations")
public class MatchRegistrationController {

    private final MatchRegistrationService matchRegistrationService;
    private final CurrentPlayerService currentPlayerService;
    private final MatchService matchService;

    public MatchRegistrationController(MatchRegistrationService matchRegistrationService,
                                       CurrentPlayerService currentPlayerService,
                                       MatchService matchService) {
        this.matchRegistrationService = matchRegistrationService;
        this.currentPlayerService = currentPlayerService;
        this.matchService = matchService;
    }

    // ADMIN / MANAGER â€“ globĂˇlnĂ­ sprĂˇva registracĂ­

    /**
     * VracĂ­ seznam vĹˇech registracĂ­ na vĹˇechny zĂˇpasy.
     *
     * Endpoint je dostupnĂ˝ pro role ADMIN a MANAGER a slouĹľĂ­
     * k pĹ™ehledovĂ© sprĂˇvÄ› registracĂ­ napĹ™Ă­ÄŤ celĂ˝m systĂ©mem.
     *
     * @return seznam vĹˇech registracĂ­ jako {@link MatchRegistrationDTO}
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> getAllRegistrations() {
        return matchRegistrationService.getAllRegistrations();
    }

    /**
     * VracĂ­ vĹˇechny registrace hrĂˇÄŤĹŻ pro konkrĂ©tnĂ­ zĂˇpas.
     *
     * Endpoint se pouĹľĂ­vĂˇ napĹ™Ă­klad pĹ™i kontrole obsazenosti zĂˇpasu
     * nebo pĹ™i ruÄŤnĂ­ ĂşpravÄ› registracĂ­ ze strany administrĂˇtora ÄŤi manaĹľera.
     *
     * @param matchId ID zĂˇpasu
     * @return seznam registracĂ­ pro danĂ˝ zĂˇpas jako {@link MatchRegistrationDTO}
     */
    @GetMapping("/match/{matchId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> getRegistrationsForMatch(@PathVariable Long matchId) {
        return matchRegistrationService.getRegistrationsForMatch(matchId);
    }

    /**
     * VracĂ­ vĹˇechny registrace konkrĂ©tnĂ­ho hrĂˇÄŤe napĹ™Ă­ÄŤ zĂˇpasy.
     *
     * Endpoint se pouĹľĂ­vĂˇ pro pĹ™ehled ĂşÄŤasti hrĂˇÄŤe v jednotlivĂ˝ch zĂˇpasech,
     * typicky v administrativnĂ­m rozhranĂ­.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return seznam registracĂ­ danĂ©ho hrĂˇÄŤe jako {@link MatchRegistrationDTO}
     */
    @GetMapping("/player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> getRegistrationsForPlayer(@PathVariable Long playerId) {
        return matchRegistrationService.getRegistrationsForPlayer(playerId);
    }

    /**
     * VracĂ­ seznam hrĂˇÄŤĹŻ, kteĹ™Ă­ na pozvĂˇnku k danĂ©mu zĂˇpasu zatĂ­m nereagovali.
     *
     * Informace se pouĹľĂ­vĂˇ napĹ™Ă­klad pro pĹ™ehled hrĂˇÄŤĹŻ, kteĹ™Ă­ se jeĹˇtÄ›
     * nepĹ™ihlĂˇsili ani neomluvili, a mĹŻĹľe slouĹľit jako podklad pro
     * nĂˇslednou komunikaci ze strany manaĹľera.
     *
     * @param matchId ID zĂˇpasu
     * @return seznam hrĂˇÄŤĹŻ bez reakce jako {@link PlayerDTO}
     */
    @GetMapping("/match/{matchId}/no-response")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getNoResponsePlayers(@PathVariable Long matchId) {
        return matchRegistrationService.getNoResponsePlayers(matchId);
    }

    /**
     * VytvĂˇĹ™Ă­ nebo aktualizuje registraci za konkrĂ©tnĂ­ho hrĂˇÄŤe.
     *
     * Endpoint se pouĹľĂ­vĂˇ administrĂˇtorem nebo manaĹľerem v situacĂ­ch,
     * kdy je potĹ™eba hrĂˇÄŤe ruÄŤnÄ› zaregistrovat, odhlĂˇsit nebo zmÄ›nit
     * typ jeho ĂşÄŤasti. VstupnĂ­ poĹľadavek urÄŤuje cĂ­lovĂ˝ stav registrace.
     *
     * @param playerId ID hrĂˇÄŤe, za kterĂ©ho se operace provĂˇdĂ­
     * @param request  poĹľadavek na zmÄ›nu registrace
     * @return {@link MatchRegistrationDTO} s vĂ˝slednĂ˝m stavem registrace
     */
    @PostMapping("/upsert/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchRegistrationDTO upsertForPlayer(
            @PathVariable Long playerId,
            @Valid @RequestBody MatchRegistrationRequest request
    ) {
        return matchRegistrationService.upsertRegistration(playerId, request);
    }

    /**
     * OznaÄŤuje hrĂˇÄŤe v konkrĂ©tnĂ­m zĂˇpase jako neomluvenÄ› nepĹ™Ă­tomnĂ©ho.
     *
     * SlouĹľĂ­ k zaznamenĂˇnĂ­ neomluvenĂ© absence hrĂˇÄŤe. Pro zĂˇznam mĹŻĹľe bĂ˝t
     * doplnÄ›na internĂ­ poznĂˇmka administrĂˇtora nebo manaĹľera.
     *
     * @param matchId   ID zĂˇpasu
     * @param playerId  ID hrĂˇÄŤe
     * @param adminNote volitelnĂˇ internĂ­ poznĂˇmka k zĂˇznamu
     * @return {@link MatchRegistrationDTO} s aktualizovanĂ˝m stavem registrace
     */
    @PatchMapping("/match/{matchId}/players/{playerId}/no-excused")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchRegistrationDTO markNoExcused(
            @PathVariable Long matchId,
            @PathVariable Long playerId,
            @RequestParam(name = "adminNote", required = false) String adminNote
    ) {
        return matchRegistrationService.markNoExcused(matchId, playerId, adminNote);
    }

    /**
     * RuĹˇĂ­ oznaÄŤenĂ­ neomluvenĂ© absence hrĂˇÄŤe v konkrĂ©tnĂ­m zĂˇpase a nastavuje omluvu.
     *
     * SlouĹľĂ­ pro opravu dĹ™Ă­ve uloĹľenĂ© neomluvenĂ© absence, napĹ™Ă­klad pokud
     * byla absence vyhodnocena dodateÄŤnÄ› jako omluvenĂˇ. DĹŻvod omluvy a poznĂˇmka
     * se uklĂˇdajĂ­ spolu s registracĂ­.
     *
     * @param matchId      ID zĂˇpasu
     * @param playerId     ID hrĂˇÄŤe
     * @param excuseReason dĹŻvod omluvy
     * @param excuseNote   poznĂˇmka k omluvÄ›
     * @return {@link MatchRegistrationDTO} s aktualizovanĂ˝m stavem registrace
     */
    @PatchMapping("/match/{matchId}/players/{playerId}/cancel-no-excused")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchRegistrationDTO cancelNoExcused(
            @PathVariable Long matchId,
            @PathVariable Long playerId,
            @RequestParam ExcuseReason excuseReason,
            @RequestParam String excuseNote
    ) {
        return matchRegistrationService.cancelNoExcused(matchId, playerId, excuseReason, excuseNote);
    }

    /**
     * MÄ›nĂ­ team u pĹ™ihlĂˇĹˇenĂ©ho hrĂˇÄŤe ke konkrĂ©tnĂ­ registraci na opaÄŤnĂ˝ team.
     *
     *AktuĂˇlnĂ­ hrĂˇÄŤ se zĂ­skĂˇvĂˇ
     *      * z {@link CurrentPlayerService}.
     * @param matchId   ID zĂˇpasu     *
     * @return {@link MatchRegistrationDTO} s aktualizovanĂ˝m stavem registrace
     */
    @PatchMapping("/me/{matchId}/change-team")
    @PreAuthorize("isAuthenticated()")
    public MatchRegistrationDTO changeRegistrationTeam(
            @PathVariable Long matchId) {

        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchRegistrationService.changeRegistrationTeam(currentPlayerId, matchId);
    }

    /**
     * MÄ›nĂ­ team u hrĂˇÄŤe dle jeho id na opaÄŤnĂ˝ team.
     *
     * @param playerId  ID hrĂˇÄŤe
     * @param matchId   ID zĂˇpasu     *
     * @return {@link MatchRegistrationDTO} s aktualizovanĂ˝m stavem registrace
     */
    @PatchMapping("/{playerId}/{matchId}/change-team")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchRegistrationDTO changeRegistrationTeamAdmin(
            @PathVariable Long playerId,
            @PathVariable Long matchId) {

        return matchRegistrationService.changeRegistrationTeam(playerId, matchId);
    }





    // UĹľivatelskĂˇ sprĂˇva registracĂ­ pro aktuĂˇlnĂ­ho hrĂˇÄŤe

    /**
     * Spravuje registraci aktuĂˇlnĂ­ho hrĂˇÄŤe na zĂˇpas.
     *
     * Podle obsahu {@link MatchRegistrationRequest} se provĂˇdĂ­ registrace,
     * odhlĂˇĹˇenĂ­, omluva nebo nastavenĂ­ nĂˇhradnĂ­ka. AktuĂˇlnĂ­ hrĂˇÄŤ se zĂ­skĂˇvĂˇ
     * z {@link CurrentPlayerService}. V pĹ™Ă­padÄ›, Ĺľe aktuĂˇlnĂ­ hrĂˇÄŤ nenĂ­ zvolen,
     * vyhazuje se {@link CurrentPlayerNotSelectedException}.
     *
     * @param request poĹľadavek na zmÄ›nu registrace
     * @return {@link MatchRegistrationDTO} s vĂ˝slednĂ˝m stavem registrace
     */
    @PostMapping("/me/upsert")
    @PreAuthorize("isAuthenticated()")
    public MatchRegistrationDTO upsertForCurrentPlayer(
            @Valid @RequestBody MatchRegistrationRequest request
    ) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        if (currentPlayerId == null) {
            throw new CurrentPlayerNotSelectedException();
        }

        return matchRegistrationService.upsertRegistration(currentPlayerId, request);
    }

    /**
     * VracĂ­ vĹˇechny registrace aktuĂˇlnÄ› zvolenĂ©ho hrĂˇÄŤe.
     *
     * Endpoint se pouĹľĂ­vĂˇ pro uĹľivatelskĂ© zobrazenĂ­ historie a stavu
     * registracĂ­ hrĂˇÄŤe napĹ™Ă­ÄŤ zĂˇpasy. Identita hrĂˇÄŤe se zĂ­skĂˇvĂˇ z
     * {@link CurrentPlayerService}.
     *
     * @return seznam {@link MatchRegistrationDTO} pro aktuĂˇlnĂ­ho hrĂˇÄŤe
     */
    @GetMapping("/me/for-current-player")
    @PreAuthorize("isAuthenticated()")
    public List<MatchRegistrationDTO> getRegistrationsForCurrentPlayer() {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchRegistrationService.getRegistrationsForPlayer(currentPlayerId);
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\MatchRegistrationHistoryController.java
-----
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchRegistrationHistoryDTO;
import cz.phsoft.hokej.models.services.MatchRegistrationHistoryService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * REST controller, kterĂ˝ se pouĹľĂ­vĂˇ pro prĂˇci s historiĂ­ registracĂ­
 * hrĂˇÄŤĹŻ k zĂˇpasĹŻm.
 *
 * Controller poskytuje uĹľivatelskĂ˝ pohled na historii registrace
 * aktuĂˇlnĂ­ho hrĂˇÄŤe a administrativnĂ­ audit historie registracĂ­
 * konkrĂ©tnĂ­ho hrĂˇÄŤe. Controller je read-only a slouĹľĂ­ pouze ke ÄŤtenĂ­
 * z tabulky historie registracĂ­.
 *
 * VeĹˇkerĂˇ business logika se pĹ™edĂˇvĂˇ do
 * {@link MatchRegistrationHistoryService}.
 */
@RestController
@RequestMapping("/api/registrations/history")
public class MatchRegistrationHistoryController {

    private final MatchRegistrationHistoryService historyService;

    public MatchRegistrationHistoryController(MatchRegistrationHistoryService historyService) {
        this.historyService = historyService;
    }

    // UĹľivatelskĂ˝ pĹ™Ă­stup â€“ aktuĂˇlnĂ­ hrĂˇÄŤ

    /**
     * VracĂ­ historii vĹˇech zmÄ›n registrace aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ©ho
     * hrĂˇÄŤe pro danĂ˝ zĂˇpas.
     *
     * Metoda se pouĹľĂ­vĂˇ napĹ™Ă­klad pro zobrazenĂ­ historie registrace
     * na detailu zĂˇpasu v uĹľivatelskĂ©m rozhranĂ­.
     *
     * @param matchId ID zĂˇpasu
     * @return seznam zĂˇznamĹŻ historie seĹ™azenĂ˝ch od nejnovÄ›jĹˇĂ­ho
     */
    @GetMapping("/me/matches/{matchId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<MatchRegistrationHistoryDTO>> getMyHistoryForMatch(
            @PathVariable Long matchId
    ) {
        List<MatchRegistrationHistoryDTO> history =
                historyService.getHistoryForCurrentPlayerAndMatch(matchId);

        return ResponseEntity.ok(history);
    }

    /**
     * VracĂ­ historii vĹˇech zmÄ›n registrace konkrĂ©tnĂ­ho hrĂˇÄŤe pro danĂ˝ zĂˇpas.
     *
     * Metoda se pouĹľĂ­vĂˇ pro administrativnĂ­ audit, analĂ˝zu zmÄ›n registracĂ­
     * a Ĺ™eĹˇenĂ­ pĹ™Ă­padnĂ˝ch sporĹŻ.
     *
     * @param matchId  ID zĂˇpasu
     * @param playerId ID hrĂˇÄŤe
     * @return seznam zĂˇznamĹŻ historie seĹ™azenĂ˝ch od nejnovÄ›jĹˇĂ­ho
     */
    @GetMapping("/admin/matches/{matchId}/players/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<List<MatchRegistrationHistoryDTO>> getPlayerHistoryForMatch(
            @PathVariable Long matchId,
            @PathVariable Long playerId
    ) {
        List<MatchRegistrationHistoryDTO> history =
                historyService.getHistoryForPlayerAndMatch(matchId, playerId);

        return ResponseEntity.ok(history);
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\MeController.java
-----
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.dto.ImpersonationInfoDTO;
import cz.phsoft.hokej.security.impersonation.ImpersonationContext;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Optional;

/**
 * REST controller poskytujĂ­cĂ­ informace o aktuĂˇlnĂ­m uĹľivatelskĂ©m kontextu.
 *
 * Obsahuje endpointy typu /api/me, kterĂ© vracĂ­ informace
 * o aktuĂˇlnĂ­m pĹ™ihlĂˇĹˇenĂ©m uĹľivateli nebo reĹľimu zastoupenĂ­.
 */
@RestController
@RequestMapping("/api/me")
public class MeController {

    private final PlayerRepository playerRepository;

    public MeController(PlayerRepository playerRepository) {
        this.playerRepository = playerRepository;
    }

    /**
     * VrĂˇtĂ­ informaci o aktuĂˇlnĂ­m reĹľimu zastoupenĂ­.
     *
     * Pokud je aktivnĂ­ impersonace, vrĂˇtĂ­ identifikĂˇtor a jmĂ©no
     * zastupovanĂ©ho hrĂˇÄŤe. Pokud nenĂ­ aktivnĂ­, vrĂˇtĂ­ pouze pĹ™Ă­znak false.
     *
     * Endpoint vyĹľaduje pĹ™ihlĂˇĹˇenĂ­.
     *
     * @return informace o zastoupenĂ­
     */
    @GetMapping("/impersonation")
    public ResponseEntity<ImpersonationInfoDTO> getImpersonationInfo() {

        Long playerId = ImpersonationContext.getImpersonatedPlayerId();

        if (playerId == null) {
            return ResponseEntity.ok(
                    new ImpersonationInfoDTO(false, null, null)
            );
        }

        Optional<PlayerEntity> playerOpt = playerRepository.findById(playerId);

        if (playerOpt.isEmpty()) {
            return ResponseEntity.ok(
                    new ImpersonationInfoDTO(false, null, null)
            );
        }

        PlayerEntity player = playerOpt.get();

        String playerName = player.getName() + " " + player.getSurname();

        return ResponseEntity.ok(
                new ImpersonationInfoDTO(true, player.getId(), playerName)
        );
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\NotificationController.java
-----
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.NotificationEntity;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.NotificationRepository;
import cz.phsoft.hokej.exceptions.UserNotFoundException;
import cz.phsoft.hokej.models.dto.NotificationBadgeDTO;
import cz.phsoft.hokej.models.dto.NotificationDTO;
import cz.phsoft.hokej.models.mappers.NotificationMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.time.Clock;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.List;

/**
 * REST controller pro prĂˇci s aplikaÄŤnĂ­mi notifikacemi.
 *
 * Poskytuje endpointy pro:
 * - vĂ˝poÄŤet badge (poÄŤet nepĹ™eÄŤtenĂ˝ch notifikacĂ­),
 * - naÄŤtenĂ­ notifikacĂ­ od poslednĂ­ho pĹ™ihlĂˇĹˇenĂ­,
 * - naÄŤtenĂ­ poslednĂ­ch notifikacĂ­,
 * - oznaÄŤenĂ­ notifikacĂ­ jako pĹ™eÄŤtenĂ˝ch.
 *
 * VeĹˇkerĂˇ logika ÄŤtenĂ­ je delegovĂˇna do NotificationRepository
 * a mapovĂˇnĂ­ do NotificationMapper. Controller pracuje vĹľdy
 * s aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ˝m uĹľivatelem.
 */
@RestController
@RequestMapping("/api/notifications")
public class NotificationController {

    private static final Logger log = LoggerFactory.getLogger(NotificationController.class);

    /**
     * VĂ˝chozĂ­ poÄŤet dnĂ­, za kterĂ© se naÄŤtou notifikace,
     * pokud uĹľivatel jeĹˇtÄ› nemĂˇ nastavenĂ© lastLoginAt.
     */
    private static final int DEFAULT_DAYS_IF_NO_LAST_LOGIN = 14;

    private final NotificationRepository notificationRepository;
    private final NotificationMapper notificationMapper;
    private final AppUserRepository appUserRepository;
    private final Clock clock;

    public NotificationController(NotificationRepository notificationRepository,
                                  NotificationMapper notificationMapper,
                                  AppUserRepository appUserRepository,
                                  Clock clock) {
        this.notificationRepository = notificationRepository;
        this.notificationMapper = notificationMapper;
        this.appUserRepository = appUserRepository;
        this.clock = clock;
    }

    /**
     * VracĂ­ badge s poÄŤtem nepĹ™eÄŤtenĂ˝ch notifikacĂ­ od poslednĂ­ho pĹ™ihlĂˇĹˇenĂ­.
     *
     * Endpoint se pouĹľĂ­vĂˇ napĹ™Ă­klad pro zobrazenĂ­ ÄŤĂ­sla u ikony zvonku
     * v navigaci aplikace.
     *
     * @param authentication autentizaÄŤnĂ­ kontext aktuĂˇlnĂ­ho uĹľivatele
     * @return DTO s informacemi o badge
     */
    @GetMapping("/badge")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<NotificationBadgeDTO> getBadge(Authentication authentication) {
        AppUserEntity user = getCurrentUser(authentication);
        Instant boundary = resolveBoundary(user);

        long count = notificationRepository
                .countByUserAndCreatedAtAfterAndReadAtIsNull(user, boundary);

        NotificationBadgeDTO dto = new NotificationBadgeDTO();
        dto.setUnreadCountSinceLastLogin(count);
        dto.setLastLoginAt(user.getLastLoginAt());
        dto.setCurrentLoginAt(user.getCurrentLoginAt());

        return ResponseEntity.ok(dto);
    }

    /**
     * VracĂ­ seznam notifikacĂ­ vytvoĹ™enĂ˝ch po poslednĂ­m pĹ™ihlĂˇĹˇenĂ­ uĹľivatele.
     *
     * Pokud uĹľivatel nemĂˇ lastLoginAt, pouĹľije se vĂ˝chozĂ­ ÄŤasovĂ© okno
     * definovanĂ© konstantou DEFAULT_DAYS_IF_NO_LAST_LOGIN.
     *
     * @param authentication autentizaÄŤnĂ­ kontext aktuĂˇlnĂ­ho uĹľivatele
     * @return seznam notifikacĂ­ ve formÄ› DTO
     */
    @GetMapping("/since-last-login")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<NotificationDTO>> getSinceLastLogin(Authentication authentication) {
        AppUserEntity user = getCurrentUser(authentication);
        Instant boundary = resolveBoundary(user);

        List<NotificationEntity> entities =
                notificationRepository.findByUserAndCreatedAtAfterOrderByCreatedAtDesc(user, boundary);

        List<NotificationDTO> dtos = notificationMapper.toDtoList(entities);
        return ResponseEntity.ok(dtos);
    }

    /**
     * VracĂ­ poslednĂ­ notifikace aktuĂˇlnĂ­ho uĹľivatele.
     *
     * Parametr limit urÄŤuje maximĂˇlnĂ­ poÄŤet vrĂˇcenĂ˝ch zĂˇznamĹŻ.
     * Pokud nenĂ­ zadĂˇn, pouĹľije se vĂ˝chozĂ­ hodnota 50
     * (zĂˇvisĂ­ na implementaci NotificationRepository).
     *
     * @param authentication autentizaÄŤnĂ­ kontext aktuĂˇlnĂ­ho uĹľivatele
     * @param limit volitelnĂ˝ limit poÄŤtu zĂˇznamĹŻ
     * @return seznam notifikacĂ­ ve formÄ› DTO
     */
    @GetMapping("/recent")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<NotificationDTO>> getRecent(
            Authentication authentication,
            @RequestParam(name = "limit", required = false, defaultValue = "50") int limit
    ) {
        AppUserEntity user = getCurrentUser(authentication);

        List<NotificationEntity> entities =
                notificationRepository.findTop50ByUserOrderByCreatedAtDesc(user);

        if (limit > 0 && entities.size() > limit) {
            entities = entities.subList(0, limit);
        }

        List<NotificationDTO> dtos = notificationMapper.toDtoList(entities);
        return ResponseEntity.ok(dtos);
    }

    /**
     * OznaÄŤĂ­ konkrĂ©tnĂ­ notifikaci jako pĹ™eÄŤtenou.
     *
     * Operace je idempotentnĂ­ â€“ pokud je notifikace jiĹľ pĹ™eÄŤtenĂˇ
     * nebo neexistuje, nevyvolĂˇ se chyba.
     *
     * @param authentication autentizaÄŤnĂ­ kontext aktuĂˇlnĂ­ho uĹľivatele
     * @param id identifikĂˇtor notifikace
     * @return HTTP 204 v pĹ™Ă­padÄ› ĂşspÄ›chu
     */
    @PostMapping("/{id}/read")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Void> markAsRead(Authentication authentication,
                                           @PathVariable("id") Long id) {
        AppUserEntity user = getCurrentUser(authentication);

        notificationRepository.findByIdAndUser(id, user)
                .ifPresent(entity -> {
                    if (entity.getReadAt() == null) {
                        entity.setReadAt(Instant.now(clock));
                        notificationRepository.save(entity);
                        log.debug("Notifikace {} oznaÄŤena jako pĹ™eÄŤtenĂˇ pro user {}", id, user.getId());
                    }
                });

        return ResponseEntity.noContent().build();
    }

    /**
     * OznaÄŤĂ­ vĹˇechny notifikace aktuĂˇlnĂ­ho uĹľivatele jako pĹ™eÄŤtenĂ©.
     *
     * @param authentication autentizaÄŤnĂ­ kontext aktuĂˇlnĂ­ho uĹľivatele
     * @return HTTP 204 v pĹ™Ă­padÄ› ĂşspÄ›chu
     */
    @PostMapping("/read-all")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Void> markAllAsRead(Authentication authentication) {
        AppUserEntity user = getCurrentUser(authentication);

        List<NotificationEntity> unread =
                notificationRepository.findByUserAndReadAtIsNullOrderByCreatedAtDesc(user);

        if (!unread.isEmpty()) {
            Instant now = Instant.now(clock);
            for (NotificationEntity entity : unread) {
                entity.setReadAt(now);
            }
            notificationRepository.saveAll(unread);
            log.debug("OznaÄŤeno {} notifikacĂ­ jako pĹ™eÄŤtenĂ˝ch pro user {}", unread.size(), user.getId());
        }

        return ResponseEntity.noContent().build();
    }

    /**
     * UrÄŤuje ÄŤasovou hranici pro vĂ˝bÄ›r notifikacĂ­.
     *
     * Pokud mĂˇ uĹľivatel nastaven lastLoginAt, pouĹľije se tato hodnota.
     * Jinak se pouĹľije aktuĂˇlnĂ­ ÄŤas mĂ­nus DEFAULT_DAYS_IF_NO_LAST_LOGIN dnĂ­.
     */
    private Instant resolveBoundary(AppUserEntity user) {
        if (user.getLastLoginAt() != null) {
            return user.getLastLoginAt();
        }
        return Instant.now(clock).minus(DEFAULT_DAYS_IF_NO_LAST_LOGIN, ChronoUnit.DAYS);
    }

    /**
     * NaÄŤte entitu aktuĂˇlnĂ­ho uĹľivatele podle e-mailu
     * z autentizaÄŤnĂ­ho kontextu.
     *
     * @param authentication autentizaÄŤnĂ­ kontext
     * @return entita uĹľivatele
     */
    private AppUserEntity getCurrentUser(Authentication authentication) {
        String email = authentication.getName();
        return appUserRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException(email));
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\package-info.java
-----
/**
 * ControllerovĂˇ vrstva aplikace.
 *
 * Obsahuje REST kontrolery odpovÄ›dnĂ© za:
 * - pĹ™Ă­jem HTTP poĹľadavkĹŻ z frontend aplikace,
 * - validaci vstupnĂ­ch dat,
 * - mapovĂˇnĂ­ requestĹŻ na service vrstvu,
 * - nĂˇvrat standardizovanĂ˝ch API odpovÄ›dĂ­.
 *
 * Tato vrstva:
 * - neobsahuje business logiku,
 * - nepracuje pĹ™Ă­mo s databĂˇzĂ­,
 * - deleguje veĹˇkerou aplikaÄŤnĂ­ logiku na service tĹ™Ă­dy.
 */

package cz.phsoft.hokej.controllers;

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerController.java
-----
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.PlayerHistoryDTO;
import cz.phsoft.hokej.models.dto.PlayerStatsDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.dto.requests.ChangePlayerUserRequest;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import cz.phsoft.hokej.models.services.PlayerHistoryService;
import cz.phsoft.hokej.models.services.PlayerService;
import cz.phsoft.hokej.models.services.PlayerStatsService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller, kterĂ˝ se pouĹľĂ­vĂˇ pro sprĂˇvu hrĂˇÄŤĹŻ.
 *
 * ZajiĹˇĹĄuje administrativnĂ­ sprĂˇvu hrĂˇÄŤĹŻ pro role ADMIN a MANAGER,
 * vÄŤetnÄ› vytvĂˇĹ™enĂ­, aktualizace, mazĂˇnĂ­ a schvalovĂˇnĂ­ hrĂˇÄŤĹŻ, a takĂ©
 * sprĂˇvu hrĂˇÄŤĹŻ z pohledu pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele pod endpointy s prefixem /me.
 *
 * VeĹˇkerĂˇ business logika se deleguje do {@link PlayerService}.
 * Historie zmÄ›n hrĂˇÄŤĹŻ se zĂ­skĂˇvĂˇ pomocĂ­ {@link PlayerHistoryService}
 * a prĂˇce s aktuĂˇlnĂ­m hrĂˇÄŤem se zajiĹˇĹĄuje pĹ™es {@link CurrentPlayerService}.
 */
@RestController
@RequestMapping("/api/players")
public class PlayerController {

    private final PlayerService playerService;
    private final CurrentPlayerService currentPlayerService;
    private final PlayerHistoryService playerHistoryService;
    private final PlayerStatsService playerStatsService;

    public PlayerController(PlayerService playerService,
                            CurrentPlayerService currentPlayerService,
                            PlayerHistoryService playerHistoryService,
                            PlayerStatsService playerStatsService) {
        this.playerService = playerService;
        this.currentPlayerService = currentPlayerService;
        this.playerHistoryService = playerHistoryService;
        this.playerStatsService = playerStatsService;
    }

    // ADMIN / MANAGER â€“ globĂˇlnĂ­ sprĂˇva hrĂˇÄŤĹŻ

    /**
     * VracĂ­ seznam vĹˇech hrĂˇÄŤĹŻ v systĂ©mu.
     *
     * Endpoint je dostupnĂ˝ pro role ADMIN a MANAGER a slouĹľĂ­
     * pro pĹ™ehledovou sprĂˇvu hrĂˇÄŤĹŻ v administraci.
     *
     * @return seznam vĹˇech hrĂˇÄŤĹŻ jako {@link PlayerDTO}
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getAllPlayers() {
        return playerService.getAllPlayers();
    }

    /**
     * VracĂ­ detail hrĂˇÄŤe podle jeho ID.
     *
     * Endpoint je urÄŤen pro administrativnĂ­ pohled na hrĂˇÄŤe,
     * napĹ™Ă­klad pro Ăşpravu jeho ĂşdajĹŻ.
     *
     * @param id ID hrĂˇÄŤe
     * @return {@link PlayerDTO} s detailem hrĂˇÄŤe
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public PlayerDTO getPlayerById(@PathVariable Long id) {
        return playerService.getPlayerById(id);
    }

    /**
     * VracĂ­ historii hrĂˇÄŤe podle jeho ID.
     *
     * Historie obsahuje zĂˇznamy o zmÄ›nĂˇch provedenĂ˝ch nad danĂ˝m hrĂˇÄŤem
     * a slouĹľĂ­ pro auditnĂ­ a pĹ™ehledovĂ© ĂşÄŤely.
     *
     * @param id ID hrĂˇÄŤe
     * @return seznam {@link PlayerHistoryDTO} pĹ™edstavujĂ­cĂ­ch historii hrĂˇÄŤe
     */
    @GetMapping("/{id}/history")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerHistoryDTO> getPlayerHistoryById(@PathVariable Long id) {
        return playerHistoryService.getHistoryForPlayer(id);
    }

    /**
     * VytvĂˇĹ™Ă­ novĂ©ho hrĂˇÄŤe administrĂˇtorem nebo manaĹľerem.
     *
     * Operace se pouĹľĂ­vĂˇ pĹ™i ruÄŤnĂ­m zaklĂˇdĂˇnĂ­ hrĂˇÄŤe v systĂ©mu,
     * typicky pro dodateÄŤnĂ© doplnÄ›nĂ­ hrĂˇÄŤĹŻ mimo uĹľivatelskĂ© rozhranĂ­.
     *
     * @param playerDTO DTO s daty novĂ©ho hrĂˇÄŤe
     * @return vytvoĹ™enĂ˝ hrĂˇÄŤ jako {@link PlayerDTO}
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public PlayerDTO createPlayer(@Valid @RequestBody PlayerDTO playerDTO) {
        return playerService.createPlayer(playerDTO);
    }

    /**
     * Aktualizuje Ăşdaje hrĂˇÄŤe v administrativnĂ­m rozhranĂ­.
     *
     * Endpoint je dostupnĂ˝ pro role ADMIN a MANAGER a slouĹľĂ­
     * k ĂşpravÄ› existujĂ­cĂ­ch ĂşdajĹŻ hrĂˇÄŤe.
     *
     * @param id  ID hrĂˇÄŤe
     * @param dto DTO s aktualizovanĂ˝mi daty hrĂˇÄŤe
     * @return aktualizovanĂ˝ hrĂˇÄŤ jako {@link PlayerDTO}
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public PlayerDTO updatePlayerAdmin(@PathVariable Long id,
                                       @Valid @RequestBody PlayerDTO dto) {
        return playerService.updatePlayer(id, dto);
    }

    /**
     * OdstraĹuje hrĂˇÄŤe ze systĂ©mu.
     *
     * Operace je dostupnĂˇ pro role ADMIN a MANAGER a pouĹľĂ­vĂˇ se
     * pouze ve vĂ˝jimeÄŤnĂ˝ch situacĂ­ch, napĹ™Ă­klad pĹ™i chybnĂ©m zaloĹľenĂ­
     * hrĂˇÄŤe. SamotnĂ© odstranÄ›nĂ­ se provĂˇdĂ­ v servisnĂ­ vrstvÄ›.
     *
     * @param id ID hrĂˇÄŤe
     * @return {@link SuccessResponseDTO} s vĂ˝sledkem operace
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SuccessResponseDTO> deletePlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.deletePlayer(id);
        return ResponseEntity.ok(response);
    }

    /**
     * Schvaluje hrĂˇÄŤe a nastavuje jeho stav na APPROVED.
     *
     * Endpoint se pouĹľĂ­vĂˇ po kontrole ĂşdajĹŻ hrĂˇÄŤe administrĂˇtorem
     * nebo manaĹľerem. SchvĂˇlenĂ­ umoĹľĹuje hrĂˇÄŤi plnohodnotnĂ© vyuĹľitĂ­
     * systĂ©mu.
     *
     * @param id ID hrĂˇÄŤe
     * @return {@link SuccessResponseDTO} s vĂ˝sledkem operace
     */
    @PutMapping("/{id}/approve")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SuccessResponseDTO> approvePlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.approvePlayer(id);
        return ResponseEntity.ok(response);
    }

    /**
     * ZamĂ­tĂˇ hrĂˇÄŤe a nastavuje jeho stav na REJECTED.
     *
     * Endpoint se pouĹľĂ­vĂˇ v situacĂ­ch, kdy hrĂˇÄŤ nesplĹuje podmĂ­nky
     * pro schvĂˇlenĂ­, napĹ™Ă­klad z hlediska validity ĂşdajĹŻ.
     *
     * @param id ID hrĂˇÄŤe
     * @return {@link SuccessResponseDTO} s vĂ˝sledkem operace
     */
    @PutMapping("/{id}/reject")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SuccessResponseDTO> rejectPlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.rejectPlayer(id);
        return ResponseEntity.ok(response);
    }

    /**
     * MÄ›nĂ­ pĹ™iĹ™azenĂ­ hrĂˇÄŤe k aplikaÄŤnĂ­mu uĹľivateli.
     *
     * Operace je urÄŤena pro roli ADMIN nebo MANAGER a pouĹľĂ­vĂˇ se,
     * pokud je potĹ™eba hrĂˇÄŤe pĹ™evĂ©st k jinĂ©mu uĹľivateli, napĹ™Ă­klad
     * pĹ™i zmÄ›nÄ› vlastnĂ­ka ĂşÄŤtu.
     *
     * @param playerId ID hrĂˇÄŤe
     * @param request  poĹľadavek obsahujĂ­cĂ­ ID novĂ©ho uĹľivatele
     * @return textovĂˇ zprĂˇva o ĂşspÄ›ĹˇnĂ© zmÄ›nÄ› pĹ™iĹ™azenĂ­
     */
    @PostMapping("/{playerId}/change-user")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<String> changePlayerUser(
            @PathVariable Long playerId,
            @RequestBody ChangePlayerUserRequest request
    ) {
        playerService.changePlayerUser(playerId, request.getNewUserId());
        return ResponseEntity.ok(
                "HrĂˇÄŤ s id: " + playerId + " byl ĂşspÄ›ĹˇnÄ› pĹ™iĹ™azen uĹľivateli s ID: " + request.getNewUserId()
        );
    }

    // UĹľivatelskĂˇ sprĂˇva hrĂˇÄŤĹŻ pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele

    /**
     * VytvĂˇĹ™Ă­ novĂ©ho hrĂˇÄŤe pro pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * NovĂ˝ hrĂˇÄŤ se automaticky pĹ™iĹ™azuje k uĹľivatelskĂ©mu ĂşÄŤtu
     * odvozenĂ©mu z e-mailovĂ© adresy v objektu {@link Authentication}.
     *
     * @param playerDTO      DTO s daty novĂ©ho hrĂˇÄŤe
     * @param authentication autentizaÄŤnĂ­ kontext pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @return vytvoĹ™enĂ˝ hrĂˇÄŤ jako {@link PlayerDTO}
     */
    @PostMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public PlayerDTO createMyPlayer(
            @Valid @RequestBody PlayerDTO playerDTO,
            Authentication authentication
    ) {
        String email = authentication.getName();
        return playerService.createPlayerForUser(playerDTO, email);
    }

    /**
     * VracĂ­ seznam vĹˇech hrĂˇÄŤĹŻ patĹ™Ă­cĂ­ch pĹ™ihlĂˇĹˇenĂ©mu uĹľivateli.
     *
     * HrĂˇÄŤi se identifikujĂ­ na zĂˇkladÄ› e-mailovĂ© adresy uĹľivatele
     * zĂ­skanĂ© z autentizaÄŤnĂ­ho kontextu.
     *
     * @param authentication autentizaÄŤnĂ­ kontext pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @return seznam {@link PlayerDTO} patĹ™Ă­cĂ­ch danĂ©mu uĹľivateli
     */
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public List<PlayerDTO> getMyPlayers(Authentication authentication) {
        String email = authentication.getName();
        return playerService.getPlayersByUser(email);
    }

    /**
     * Aktualizuje Ăşdaje aktuĂˇlnÄ› zvolenĂ©ho hrĂˇÄŤe.
     *
     * PĹ™ed provedenĂ­m aktualizace se vyĹľaduje, aby byl nastaven
     * aktuĂˇlnĂ­ hrĂˇÄŤ v {@link CurrentPlayerService}. Aktualizace
     * se nĂˇslednÄ› deleguje do {@link PlayerService}.
     *
     * @param dto DTO s aktualizovanĂ˝mi daty hrĂˇÄŤe
     * @return aktualizovanĂ˝ hrĂˇÄŤ jako {@link PlayerDTO}
     */
    @PutMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public PlayerDTO updateMyCurrentPlayer(@Valid @RequestBody PlayerDTO dto) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return playerService.updatePlayer(currentPlayerId, dto);
    }

    /**
     * VracĂ­ historii pro aktuĂˇlnÄ› zvolenĂ©ho hrĂˇÄŤe pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * Identita hrĂˇÄŤe se zĂ­skĂˇvĂˇ z {@link CurrentPlayerService}. Endpoint
     * je urÄŤen pro uĹľivatelskĂ© zobrazenĂ­ historie zmÄ›n nad vlastnĂ­m hrĂˇÄŤem.
     *
     * @return seznam {@link PlayerHistoryDTO} pĹ™edstavujĂ­cĂ­ch historii aktuĂˇlnĂ­ho hrĂˇÄŤe
     */
    @GetMapping("/me/history")
    @PreAuthorize("isAuthenticated()")
    public List<PlayerHistoryDTO> getMyPlayerHistory() {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return playerHistoryService.getHistoryForPlayer(currentPlayerId);
    }


    /**
     * VracĂ­ statistiky pro aktuĂˇlnÄ› zvolenĂ©ho hrĂˇÄŤe pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * Identita hrĂˇÄŤe se zĂ­skĂˇvĂˇ z {@link CurrentPlayerService}. Endpoint
     * je urÄŤen pro zobrazenĂ­ statistik k zĂˇpasĹŻm vlastnĂ­m hrĂˇÄŤem.
     *
     * @return seznam {@link PlayerStatsDTO} pĹ™edstavujĂ­cĂ­ch statistiky aktuĂˇlnĂ­ho hrĂˇÄŤe
     */
    @GetMapping("/me/stats")
    @PreAuthorize("isAuthenticated()")
    public PlayerStatsDTO getMyPlayerStats() {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return playerStatsService.getPlayerStats(currentPlayerId);
    }

    /**
     * VracĂ­ statistiky pro aktuĂˇlnÄ› zvolenĂ©ho hrĂˇÄŤe pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * je urÄŤen pro zobrazenĂ­ statistik k zĂˇpasĹŻm hrĂˇÄŤe dle jeho ide.
     * @param playerId ID hrĂˇÄŤe
     * @return seznam {@link PlayerStatsDTO} pĹ™edstavujĂ­cĂ­ch statistiky hrĂˇÄŤe dle id
     */
    @GetMapping("/{playerId}/stats")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public PlayerStatsDTO getPlayerStats(@PathVariable Long playerId) {
        return playerStatsService.getPlayerStats(playerId);
    }



}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerInactivityPeriodController.java
-----
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import cz.phsoft.hokej.models.services.PlayerInactivityPeriodService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller, kterĂ˝ se pouĹľĂ­vĂˇ pro administraci obdobĂ­ neaktivity hrĂˇÄŤĹŻ.
 *
 * ObdobĂ­ neaktivity slouĹľĂ­ k evidenci ÄŤasovĂ˝ch ĂşsekĹŻ, ve kterĂ˝ch se hrĂˇÄŤ
 * neĂşÄŤastnĂ­ zĂˇpasĹŻ, napĹ™Ă­klad z dĹŻvodu zranÄ›nĂ­ nebo dovolenĂ©. Endpointy jsou
 * urÄŤeny pro role ADMIN a MANAGER a umoĹľĹujĂ­ Ăşplnou sprĂˇvu zĂˇznamĹŻ o neaktivitÄ›.
 *
 * VeĹˇkerĂˇ business logika se deleguje do {@link PlayerInactivityPeriodService}.
 * Informace o aktuĂˇlnĂ­m hrĂˇÄŤi se zĂ­skĂˇvajĂ­ pomocĂ­ {@link CurrentPlayerService}.
 */
@RestController
@RequestMapping("/api/inactivity/admin")
public class PlayerInactivityPeriodController {

    private final PlayerInactivityPeriodService service;
    private final CurrentPlayerService currentPlayerService;

    public PlayerInactivityPeriodController(PlayerInactivityPeriodService service,
                                            CurrentPlayerService currentPlayerService) {
        this.service = service;
        this.currentPlayerService = currentPlayerService;
    }

    /**
     * VracĂ­ seznam vĹˇech zĂˇznamĹŻ o neaktivitÄ› hrĂˇÄŤĹŻ.
     *
     * Endpoint je dostupnĂ˝ pro role ADMIN a MANAGER a slouĹľĂ­
     * k pĹ™ehledovĂ© sprĂˇvÄ› vĹˇech evidovanĂ˝ch obdobĂ­ neaktivity.
     *
     * @return seznam obdobĂ­ neaktivity jako {@link PlayerInactivityPeriodDTO}
     */
    @GetMapping("/all")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getAll() {
        return service.getAll();
    }

    /**
     * VracĂ­ detail zĂˇznamu o neaktivitÄ› podle jeho ID.
     *
     * Endpoint se pouĹľĂ­vĂˇ pro zobrazenĂ­ nebo kontrolu konkrĂ©tnĂ­ho
     * zĂˇznamu pĹ™ed jeho Ăşpravou ÄŤi smazĂˇnĂ­m.
     *
     * @param id ID zĂˇznamu o neaktivitÄ›
     * @return {@link PlayerInactivityPeriodDTO} s detailem obdobĂ­ neaktivity
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<PlayerInactivityPeriodDTO> getById(@PathVariable Long id) {
        PlayerInactivityPeriodDTO dto = service.getById(id);
        return ResponseEntity.ok(dto);
    }

    /**
     * VracĂ­ vĹˇechna obdobĂ­ neaktivity pro konkrĂ©tnĂ­ho hrĂˇÄŤe.
     *
     * Endpoint je vhodnĂ˝ napĹ™Ă­klad pro kontrolu dlouhodobĂ© absence
     * hrĂˇÄŤe nebo pro plĂˇnovĂˇnĂ­ jeho ĂşÄŤasti na zĂˇpasech.
     *
     * @param playerId ID hrĂˇÄŤe
     * @return seznam obdobĂ­ neaktivity pro danĂ©ho hrĂˇÄŤe jako {@link PlayerInactivityPeriodDTO}
     */
    @GetMapping("/player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getByPlayer(@PathVariable Long playerId) {
        return service.getByPlayer(playerId);
    }

    /**
     * VytvĂˇĹ™Ă­ novĂ˝ zĂˇznam o neaktivitÄ› hrĂˇÄŤe.
     *
     * VstupnĂ­ data jsou validovĂˇna pomocĂ­ bean validation a vlastnĂ­
     * uloĹľenĂ­ zĂˇznamu se deleguje do servisnĂ­ vrstvy. Operace je
     * dostupnĂˇ pro role ADMIN a MANAGER.
     *
     * @param dto DTO s daty obdobĂ­ neaktivity
     * @return vytvoĹ™enĂ˝ zĂˇznam jako {@link PlayerInactivityPeriodDTO}
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<PlayerInactivityPeriodDTO> create(
            @Valid @RequestBody PlayerInactivityPeriodDTO dto) {

        PlayerInactivityPeriodDTO created = service.create(dto);
        return ResponseEntity.ok(created);
    }

    /**
     * Aktualizuje existujĂ­cĂ­ zĂˇznam o neaktivitÄ› hrĂˇÄŤe.
     *
     * Endpoint je dostupnĂ˝ pro role ADMIN a MANAGER. Aktualizace
     * probĂ­hĂˇ prostĹ™ednictvĂ­m servisnĂ­ vrstvy a slouĹľĂ­ k opravĂˇm
     * nebo ĂşpravĂˇm dĹ™Ă­ve zadanĂ˝ch ĂşdajĹŻ.
     *
     * @param id  ID zĂˇznamu o neaktivitÄ›
     * @param dto DTO s aktualizovanĂ˝mi daty obdobĂ­ neaktivity
     * @return aktualizovanĂ˝ zĂˇznam jako {@link PlayerInactivityPeriodDTO}
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<PlayerInactivityPeriodDTO> update(
            @PathVariable Long id,
            @Valid @RequestBody PlayerInactivityPeriodDTO dto) {

        PlayerInactivityPeriodDTO updated = service.update(id, dto);
        return ResponseEntity.ok(updated);
    }

    /**
     * OdstraĹuje zĂˇznam o neaktivitÄ› hrĂˇÄŤe.
     *
     * Operace je vyhrazena pouze pro roli ADMIN a pouĹľĂ­vĂˇ se
     * napĹ™Ă­klad pĹ™i chybnĂ©m zadĂˇnĂ­ obdobĂ­ neaktivity.
     *
     * @param id ID zĂˇznamu o neaktivitÄ›
     * @return HTTP odpovÄ›ÄŹ 204 No Content v pĹ™Ă­padÄ› ĂşspÄ›chu
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        service.delete(id);
        return ResponseEntity.noContent().build();
    }

    /**
     * VracĂ­ seznam obdobĂ­ neaktivity aktuĂˇlnÄ› zvolenĂ©ho hrĂˇÄŤe.
     *
     * PĹ™ed volĂˇnĂ­m sluĹľby se vyĹľaduje, aby byl nastaven aktuĂˇlnĂ­ hrĂˇÄŤ
     * v {@link CurrentPlayerService}. Endpoint je urÄŤen pro uĹľivatelskĂ©
     * zobrazenĂ­ vlastnĂ­ch obdobĂ­ neaktivity v rozhranĂ­ hrĂˇÄŤe.
     *
     * @param authentication autentizaÄŤnĂ­ kontext pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @return seznam obdobĂ­ neaktivity pro aktuĂˇlnĂ­ho hrĂˇÄŤe jako {@link PlayerInactivityPeriodDTO}
     */
    @GetMapping("/me/all")
    @PreAuthorize("isAuthenticated()")
    public List<PlayerInactivityPeriodDTO> getMyInactivity(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return service.getByPlayer(currentPlayerId);
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerSettingsController.java
-----
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerSettingsDTO;
import cz.phsoft.hokej.models.services.PlayerSettingsService;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

/**
 * REST controller, kterĂ˝ se pouĹľĂ­vĂˇ pro sprĂˇvu nastavenĂ­ hrĂˇÄŤe.
 *
 * Pracuje s nastavenĂ­m navĂˇzanĂ˝m na konkrĂ©tnĂ­ho hrĂˇÄŤe a na aktuĂˇlnĂ­ho
 * hrĂˇÄŤe (currentPlayer). UmoĹľĹuje naÄŤĂ­tat a aktualizovat nastavenĂ­
 * pro libovolnĂ©ho hrĂˇÄŤe podle ID a pro hrĂˇÄŤe, kterĂ˝ je aktuĂˇlnÄ›
 * vybrĂˇn v kontextu pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
 *
 * VeĹˇkerĂˇ business logika se pĹ™edĂˇvĂˇ do {@link PlayerSettingsService}.
 */
@RestController
@RequestMapping("/api")
public class PlayerSettingsController {

    private final PlayerSettingsService playerSettingsService;
    private final CurrentPlayerService currentPlayerService;

    public PlayerSettingsController(PlayerSettingsService playerSettingsService,
                                    CurrentPlayerService currentPlayerService) {
        this.playerSettingsService = playerSettingsService;
        this.currentPlayerService = currentPlayerService;
    }

    // NastavenĂ­ libovolnĂ©ho hrĂˇÄŤe podle ID

    /**
     * VracĂ­ nastavenĂ­ konkrĂ©tnĂ­ho hrĂˇÄŤe podle jeho ID.
     *
     * OvÄ›Ĺ™enĂ­, zda hrĂˇÄŤ patĹ™Ă­ pĹ™ihlĂˇĹˇenĂ©mu uĹľivateli nebo zda mĂˇ
     * uĹľivatel roli ADMIN ÄŤi MANAGER, mĹŻĹľe bĂ˝t provĂˇdÄ›no v tĂ©to
     * vrstvÄ› nebo v service vrstvÄ›.
     *
     * @param playerId ID hrĂˇÄŤe
     * @param auth     autentizaÄŤnĂ­ kontext pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @return DTO {@link PlayerSettingsDTO} s nastavenĂ­m hrĂˇÄŤe
     */
    @GetMapping("/players/{playerId}/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<PlayerSettingsDTO> getPlayerSettings(
            @PathVariable Long playerId,
            Authentication auth
    ) {
        PlayerSettingsDTO dto = playerSettingsService.getSettingsForPlayer(playerId);
        return ResponseEntity.ok(dto);
    }

    /**
     * Aktualizuje nastavenĂ­ konkrĂ©tnĂ­ho hrĂˇÄŤe podle jeho ID.
     *
     * Kontrola vlastnictvĂ­ hrĂˇÄŤe a oprĂˇvnÄ›nĂ­ mĹŻĹľe bĂ˝t doplnÄ›na
     * podle potĹ™eb aplikace.
     *
     * @param playerId   ID hrĂˇÄŤe
     * @param requestDto DTO s novĂ˝m nastavenĂ­m hrĂˇÄŤe
     * @param auth       autentizaÄŤnĂ­ kontext pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele
     * @return DTO {@link PlayerSettingsDTO} s aktualizovanĂ˝m nastavenĂ­m
     */
    @PatchMapping("/players/{playerId}/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<PlayerSettingsDTO> updatePlayerSettings(
            @PathVariable Long playerId,
            @RequestBody PlayerSettingsDTO requestDto,
            Authentication auth
    ) {
        // TODO: pĹ™Ă­padnĂˇ kontrola vlastnictvĂ­ hrĂˇÄŤe

        PlayerSettingsDTO updated = playerSettingsService.updateSettingsForPlayer(playerId, requestDto);
        return ResponseEntity.ok(updated);
    }

    // NastavenĂ­ aktuĂˇlnĂ­ho hrĂˇÄŤe (currentPlayer)

    /**
     * VracĂ­ nastavenĂ­ aktuĂˇlnÄ› vybranĂ©ho hrĂˇÄŤe.
     *
     * PĹ™ed ÄŤtenĂ­m nastavenĂ­ se vyĹľaduje, aby byl v kontextu
     * nastaven aktuĂˇlnĂ­ hrĂˇÄŤ.
     *
     * @return DTO {@link PlayerSettingsDTO} s nastavenĂ­m aktuĂˇlnĂ­ho hrĂˇÄŤe
     */
    @GetMapping("/me/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<PlayerSettingsDTO> getCurrentPlayerSettings() {

        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        PlayerSettingsDTO dto = playerSettingsService.getSettingsForPlayer(currentPlayerId);

        return ResponseEntity.ok(dto);
    }

    /**
     * Aktualizuje nastavenĂ­ aktuĂˇlnÄ› vybranĂ©ho hrĂˇÄŤe.
     *
     * Informace o tom, kterĂ˝ hrĂˇÄŤ je aktuĂˇlnĂ­, se zĂ­skĂˇvĂˇ z
     * {@link CurrentPlayerService}. Endpoint se pouĹľĂ­vĂˇ napĹ™Ă­klad
     * pro nastavenĂ­ preferencĂ­ pĹ™Ă­mo z kontextu aktuĂˇlnĂ­ho hrĂˇÄŤe.
     *
     * @param requestDto DTO s novĂ˝m nastavenĂ­m aktuĂˇlnĂ­ho hrĂˇÄŤe
     * @return DTO {@link PlayerSettingsDTO} s aktualizovanĂ˝m nastavenĂ­m
     */
    @PatchMapping("/me/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<PlayerSettingsDTO> updateCurrentPlayerSettings(
            @RequestBody PlayerSettingsDTO requestDto
    ) {

        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        PlayerSettingsDTO updated = playerSettingsService.updateSettingsForPlayer(currentPlayerId, requestDto);

        return ResponseEntity.ok(updated);
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\SeasonController.java
-----
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.SeasonDTO;
import cz.phsoft.hokej.models.dto.SeasonHistoryDTO;
import cz.phsoft.hokej.models.mappers.SeasonMapper;
import cz.phsoft.hokej.models.services.CurrentSeasonService;
import cz.phsoft.hokej.models.services.SeasonHistoryService;
import cz.phsoft.hokej.models.services.SeasonService;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller, kterĂ˝ se pouĹľĂ­vĂˇ pro sprĂˇvu sezĂłn.
 *
 * ZajiĹˇĹĄuje administrativnĂ­ sprĂˇvu sezĂłn pro roli ADMIN vÄŤetnÄ›
 * vytvĂˇĹ™enĂ­, aktualizace a nastavenĂ­ globĂˇlnÄ› aktivnĂ­ sezĂłny.
 * DĂˇle poskytuje endpointy pro prĂˇci s aktuĂˇlnĂ­ sezĂłnou uĹľivatele
 * pod prefixem /me.
 *
 * VeĹˇkerĂˇ business logika se pĹ™edĂˇvĂˇ do {@link SeasonService}
 * a {@link CurrentSeasonService}.
 */
@RestController
@RequestMapping("/api/seasons")
public class SeasonController {

    private final SeasonService seasonService;
    private final SeasonMapper seasonMapper;
    private final CurrentSeasonService currentSeasonService;
    private final SeasonHistoryService seasonHistoryService;

    public SeasonController(SeasonService seasonService,
                            SeasonMapper seasonMapper,
                            CurrentSeasonService currentSeasonService,
                            SeasonHistoryService seasonHistoryService) {
        this.seasonService = seasonService;
        this.seasonMapper = seasonMapper;
        this.currentSeasonService = currentSeasonService;
        this.seasonHistoryService = seasonHistoryService;
    }

    // ADMIN â€“ globĂˇlnĂ­ sprĂˇva sezĂłn

    /**
     * VytvĂˇĹ™Ă­ novou sezĂłnu.
     *
     * @param seasonDTO DTO s daty novĂ© sezĂłny
     * @return vytvoĹ™enĂˇ sezĂłna jako {@link SeasonDTO}
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SeasonDTO> createSeason(
            @Valid @RequestBody SeasonDTO seasonDTO) {

        SeasonDTO created = seasonService.createSeason(seasonDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    }

    /**
     * Aktualizuje existujĂ­cĂ­ sezĂłnu.
     *
     * @param id        ID sezĂłny
     * @param seasonDTO DTO s aktualizovanĂ˝mi daty sezĂłny
     * @return aktualizovanĂˇ sezĂłna jako {@link SeasonDTO}
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SeasonDTO> updateSeason(
            @PathVariable Long id,
            @Valid @RequestBody SeasonDTO seasonDTO
    ) {
        SeasonDTO updated = seasonService.updateSeason(id, seasonDTO);
        return ResponseEntity.ok(updated);
    }

    /**
     * VracĂ­ historii sezĂłny dle id.
     *
     * @param id ID sezĂłny
     * @return historie sezony jako {@link List<SeasonHistoryDTO>}
     */
    @GetMapping("/{id}/history")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<SeasonHistoryDTO> getSeasonHistory(
            @PathVariable Long id
    ) {
        return seasonHistoryService.getHistoryForSeason(id);
    }

    /**
     * VracĂ­ seznam vĹˇech sezĂłn v systĂ©mu.
     *
     * Endpoint je v tuto chvĂ­li omezen na roli ADMIN. Podle potĹ™eby
     * mĹŻĹľe bĂ˝t v budoucnu zpĹ™Ă­stupnÄ›n ĹˇirĹˇĂ­mu okruhu uĹľivatelĹŻ.
     *
     * @return seznam sezĂłn jako {@link SeasonDTO}
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<List<SeasonDTO>> getAllSeasonsAdmin() {
        List<SeasonDTO> seasons = seasonService.getAllSeasons();
        return ResponseEntity.ok(seasons);
    }

    /**
     * VracĂ­ aktuĂˇlnÄ› globĂˇlnÄ› aktivnĂ­ sezĂłnu.
     *
     * AktivnĂ­ sezĂłna pĹ™edstavuje vĂ˝chozĂ­ obdobĂ­ pro systĂ©movĂ© operace,
     * kterĂ© nejsou vĂˇzĂˇny na konkrĂ©tnĂ­ volbu uĹľivatele.
     *
     * @return aktivnĂ­ sezĂłna jako {@link SeasonDTO}
     */
    @GetMapping("/active")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SeasonDTO> getActiveSeason() {
        SeasonDTO dto = seasonMapper.toDTO(seasonService.getActiveSeason());
        return ResponseEntity.ok(dto);
    }

    /**
     * Nastavuje zadanou sezĂłnu jako globĂˇlnÄ› aktivnĂ­.
     *
     * Po nastavenĂ­ se informace o aktivnĂ­ sezĂłnÄ› pouĹľĂ­vĂˇ v dalĹˇĂ­ch
     * ÄŤĂˇstech systĂ©mu jako vĂ˝chozĂ­ sezĂłna.
     *
     * @param id ID sezĂłny, kterĂˇ mĂˇ bĂ˝t nastavena jako aktivnĂ­
     * @return novÄ› aktivnĂ­ sezĂłna jako {@link SeasonDTO}
     */
    @PutMapping("/{id}/active")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SeasonDTO> setActiveSeason(@PathVariable Long id) {
        seasonService.setActiveSeason(id);
        SeasonDTO active = seasonMapper.toDTO(seasonService.getActiveSeason());
        return ResponseEntity.ok(active);
    }

    // UĹľivatelskĂˇ prĂˇce s â€žmojĂ­â€ś sezĂłnou

    /**
     * VracĂ­ seznam vĹˇech sezĂłn pro ĂşÄŤely vĂ˝bÄ›ru na frontendu.
     *
     * JednĂˇ se o uĹľivatelskou variantu endpointu, kterĂˇ se pouĹľĂ­vĂˇ
     * napĹ™Ă­klad pro zobrazenĂ­ seznamu sezĂłn v nabĂ­dce.
     *
     * @return seznam sezĂłn jako {@link SeasonDTO}
     */
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public List<SeasonDTO> getAllSeasonsForUser() {
        return seasonService.getAllSeasons();
    }

    /**
     * VracĂ­ sezĂłnu, kterĂˇ je aktuĂˇlnÄ› vybranĂˇ pro pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * Pokud uĹľivatel nemĂˇ explicitnÄ› vybranou sezĂłnu, mĹŻĹľe bĂ˝t vrĂˇcena
     * vĂ˝chozĂ­ hodnota podle implementace {@link CurrentSeasonService}.
     *
     * @return aktuĂˇlnĂ­ sezĂłna pro uĹľivatele nebo null
     */
    @GetMapping("/me/current")
    @PreAuthorize("isAuthenticated()")
    public SeasonDTO getCurrentSeasonForUser() {
        Long id = currentSeasonService.getCurrentSeasonIdOrDefault();
        return (id != null) ? seasonService.getSeasonById(id) : null;
    }

    /**
     * Nastavuje aktuĂˇlnĂ­ sezĂłnu pro pĹ™ihlĂˇĹˇenĂ©ho uĹľivatele.
     *
     * PĹ™ed nastavenĂ­m se ovÄ›Ĺ™uje, Ĺľe sezĂłna existuje. Id sezĂłny
     * se nĂˇslednÄ› uklĂˇdĂˇ do kontextu aktuĂˇlnĂ­ sezĂłny uĹľivatele.
     *
     * @param seasonId ID sezĂłny, kterĂˇ mĂˇ bĂ˝t nastavena jako aktuĂˇlnĂ­
     */
    @PostMapping("/me/current/{seasonId}")
    @PreAuthorize("isAuthenticated()")
    public void setCurrentSeasonForUser(@PathVariable Long seasonId) {
        seasonService.getSeasonById(seasonId);
        currentSeasonService.setCurrentSeasonId(seasonId);
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\TestController.java
-----
package cz.phsoft.hokej.controllers;

import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * JednoduchĂ˝ testovacĂ­ REST controller.
 *
 * SlouĹľĂ­ k ovÄ›Ĺ™enĂ­, Ĺľe backend aplikace bÄ›ĹľĂ­ a Ĺľe funguje
 * zabezpeÄŤenĂ­ pro roli ADMIN.
 */
@RestController
@RequestMapping("/api/test")
@PreAuthorize("hasRole('ADMIN')")
public class TestController {

    /**
     * VracĂ­ jednoduchou textovou zprĂˇvu pro ovÄ›Ĺ™enĂ­, Ĺľe backend je online.
     *
     * @return textovĂˇ zprĂˇva potvrzujĂ­cĂ­ bÄ›h backendu
     */
    @GetMapping
    public String hello() {
        return "Backend je online!";
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\TestEmailController.java
-----
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.services.email.EmailService;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * TestovacĂ­ REST controller pro odeslĂˇnĂ­ e-mailu.
 *
 * SlouĹľĂ­ k ovÄ›Ĺ™enĂ­ konfigurace e-mailovĂ© sluĹľby v prostĹ™edĂ­,
 * napĹ™Ă­klad pĹ™i vĂ˝voji nebo testovĂˇnĂ­.
 *
 * VeĹˇkerĂˇ logika odesĂ­lĂˇnĂ­ e-mailĹŻ se pĹ™edĂˇvĂˇ do {@link EmailService}.
 */
@RestController
@RequestMapping("/api/email/test")
public class TestEmailController {

    private final EmailService emailService;

    public TestEmailController(EmailService emailService) {
        this.emailService = emailService;
    }

    /**
     * OdesĂ­lĂˇ testovacĂ­ e-mail na pevnÄ› danou adresu.
     *
     * Endpoint se pouĹľĂ­vĂˇ pro ovÄ›Ĺ™enĂ­, Ĺľe e-mailovĂˇ sluĹľba je sprĂˇvnÄ›
     * nakonfigurovĂˇna a Ĺľe lze e-maily z backendu odesĂ­lat.
     *
     * @return textovĂˇ zprĂˇva o odeslĂˇnĂ­ e-mailu
     */
    @PostMapping("/send-mail")
    public String sendTestMail() {
        emailService.sendSimpleEmail(
                "petrhlista@seznam.cz",
                "APP - TestovacĂ­ email",
                "Ahoj, toto je test z backendu."
        );
        return "Email odeslĂˇn";
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\controllers\TestSmsController.java
-----
/*
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.services.sms.SmsTextBeeService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * TestovacĂ­ REST controller pro odeslĂˇnĂ­ SMS.
 *
 * SlouĹľĂ­ k ovÄ›Ĺ™enĂ­, Ĺľe integrace se sluĹľbou SmsTextBee funguje
 * sprĂˇvnÄ› v danĂ©m prostĹ™edĂ­.
 */
/*
@RestController
public class TestSmsController {

    private final SmsTextBeeService smsTextBeeService;

    public TestSmsController(SmsTextBeeService smsTextBeeService) {
        this.smsTextBeeService = smsTextBeeService;
    }

    /**
     * OdesĂ­lĂˇ testovacĂ­ SMS na testovacĂ­ telefonnĂ­ ÄŤĂ­slo.
     *
     * Endpoint se pouĹľĂ­vĂˇ pro ovÄ›Ĺ™enĂ­ funkÄŤnosti SMS integrace.
     */
    /*
    @GetMapping("/api/test-sms")
    public String sendTestSms() {
        smsTextBeeService.sendSms("+420776609956", "testovacĂ­ sms app-sg");
        return "SMS byla odeslĂˇna na testovacĂ­ ÄŤĂ­slo +420776609956";
    }
}
*/
