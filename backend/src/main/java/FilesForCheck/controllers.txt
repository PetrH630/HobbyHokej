Balíček (složka): controllers
Cesta: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers

Seznam souborů:
AppUserController.java
AppUserSettingsController.java
AuthController.java
CurrentPlayerController.java
DebugController.java
MatchController.java
MatchRegistrationController.java
MatchRegistrationHistoryController.java
PlayerController.java
PlayerInactivityPeriodController.java
PlayerSettingsController.java
SeasonController.java
TestController.java
TestEmailController.java
TestSmsController.java



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AppUserController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.ChangePasswordDTO;
import cz.phsoft.hokej.models.services.AppUserService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller, který se používá pro správu uživatelských účtů.
 *
 * Zajišťuje práci s přihlášeným uživatelem, včetně zobrazení profilu a změny
 * hesla, a také administrativní správu uživatelů, která je vyhrazena roli ADMIN.
 *
 * Veškerá business logika se předává do {@link AppUserService}.
 */
@RestController
@RequestMapping("/api/users")
public class AppUserController {

    private final AppUserService appUserService;

    public AppUserController(AppUserService appUserService) {
        this.appUserService = appUserService;
    }

    /**
     * Vrací detail aktuálně přihlášeného uživatele.
     *
     * Identifikace uživatele se provádí podle e-mailu (username),
     * který je získán z objektu {@link Authentication}.
     *
     * @param authentication autentizační kontext přihlášeného uživatele
     * @return DTO s detaily přihlášeného uživatele
     */
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public AppUserDTO getCurrentUser(Authentication authentication) {
        return appUserService.getCurrentUser(authentication.getName());
    }

    /**
     * Aktualizuje údaje aktuálně přihlášeného uživatele.
     *
     * @param authentication autentizační kontext přihlášeného uživatele
     * @param dto            DTO s aktualizovanými údaji uživatele
     * @return HTTP odpověď s informací o úspěšné aktualizaci
     */
    @PutMapping("/me/update")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> updateUser(
            Authentication authentication,
            @Valid @RequestBody AppUserDTO dto) {

        String email = authentication.getName();
        appUserService.updateUser(email, dto);
        return ResponseEntity.ok("Uživatel byl změněn");
    }

    /**
     * Mění heslo aktuálně přihlášeného uživatele.
     *
     * Staré heslo, nové heslo a potvrzení nového hesla se předává
     * prostřednictvím DTO {@link ChangePasswordDTO}.
     *
     * @param authentication autentizační kontext přihlášeného uživatele
     * @param dto            DTO obsahující staré a nové heslo
     * @return HTTP odpověď s informací o úspěšné změně hesla
     */
    @PostMapping("/me/change-password")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> changePassword(
            Authentication authentication,
            @Valid @RequestBody ChangePasswordDTO dto) {

        String email = authentication.getName();
        appUserService.changePassword(
                email,
                dto.getOldPassword(),
                dto.getNewPassword(),
                dto.getNewPasswordConfirm()
        );
        return ResponseEntity.ok("Heslo úspěšně změněno");
    }

    // ADMIN

    /**
     * Vrací seznam všech uživatelů v systému.
     *
     * Endpoint je dostupný pouze pro roli ADMIN.
     *
     * @return seznam uživatelů jako {@link AppUserDTO}
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    public List<AppUserDTO> getAllUsers() {
        return appUserService.getAllUsers();
    }

    /**
     * Vrací detail uživatele podle jeho ID.
     *
     * Endpoint je dostupný pouze pro roli ADMIN.
     *
     * @param id ID uživatele
     * @return DTO s detaily vybraného uživatele
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public AppUserDTO getUserById(@PathVariable Long id) {
        return appUserService.getUserById(id);
    }

    /**
     * Resetuje heslo uživatele na výchozí hodnotu.
     *
     * Operace je vyhrazena pouze pro roli ADMIN.
     *
     * @param id ID uživatele, kterému se má heslo resetovat
     * @return HTTP odpověď s informací o úspěšném resetu hesla
     */
    @PostMapping("/{id}/reset-password")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<String> resetPassword(@PathVariable Long id) {
        appUserService.resetPassword(id);
        return ResponseEntity.ok("Heslo resetováno na 'Player123'");
    }

    /**
     * Aktivuje účet uživatele.
     *
     * Operace je vyhrazena pouze pro roli ADMIN.
     *
     * @param id ID uživatele, který má být aktivován
     * @return HTTP odpověď s informací o úspěšné aktivaci
     */
    @PatchMapping("/{id}/activate")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<String> activateUserByAdmin(@PathVariable Long id) {
        appUserService.activateUserByAdmin(id);
        return ResponseEntity.ok("Uživatel byl úspěšně aktivován");
    }

    /**
     * Deaktivuje účet uživatele.
     *
     * Operace je vyhrazena pouze pro roli ADMIN.
     *
     * @param id ID uživatele, který má být deaktivován
     * @return HTTP odpověď s informací o úspěšné deaktivaci
     */
    @PatchMapping("/{id}/deactivate")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<String> deactivateUserByAdmin(@PathVariable Long id) {
        appUserService.deactivateUserByAdmin(id);
        return ResponseEntity.ok("Uživatel byl úspěšně deaktivován");
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AppUserSettingsController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.AppUserSettingsDTO;
import cz.phsoft.hokej.models.services.AppUserSettingsService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

/**
 * REST controller, který se používá pro správu nastavení uživatele
 * na úrovni aplikačního účtu (AppUser).
 *
 * Pracuje s nastavením navázaným na účet uživatele, nikoli na aktuálního
 * hráče. Slouží například pro nastavení preferencí uživatele a režimu
 * výběru hráče po přihlášení.
 *
 * Veškerá business logika se předává do {@link AppUserSettingsService}.
 */
@RestController
@RequestMapping("/api/user")
public class AppUserSettingsController {

    private final AppUserSettingsService appUserSettingsService;

    public AppUserSettingsController(AppUserSettingsService appUserSettingsService) {
        this.appUserSettingsService = appUserSettingsService;
    }

    /**
     * Vrací nastavení aktuálně přihlášeného uživatele.
     *
     * Uživatel se identifikuje pomocí e-mailu získaného z objektu
     * {@link Authentication}.
     *
     * @param auth autentizační kontext přihlášeného uživatele
     * @return DTO s nastavením uživatele
     */
    @GetMapping("/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<AppUserSettingsDTO> getCurrentUserSettings(Authentication auth) {
        String userEmail = auth.getName();
        AppUserSettingsDTO dto = appUserSettingsService.getSettingsForUser(userEmail);
        return ResponseEntity.ok(dto);
    }

    /**
     * Aktualizuje nastavení aktuálně přihlášeného uživatele.
     *
     * Očekává se, že frontend předá kompletní stav nastavení, který se
     * aplikuje na účet uživatele.
     *
     * @param auth       autentizační kontext přihlášeného uživatele
     * @param requestDto DTO s novým nastavením uživatele
     * @return DTO s aktualizovaným nastavením uživatele
     */
    @PatchMapping("/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<AppUserSettingsDTO> updateCurrentUserSettings(
            Authentication auth,
            @RequestBody AppUserSettingsDTO requestDto
    ) {
        String userEmail = auth.getName();
        AppUserSettingsDTO updated = appUserSettingsService.updateSettingsForUser(userEmail, requestDto);
        return ResponseEntity.ok(updated);
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AuthController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.EmailDTO;
import cz.phsoft.hokej.models.dto.ForgottenPasswordResetDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;
import cz.phsoft.hokej.models.services.AppUserService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

/**
 * REST controller, který se používá pro autentizaci a registraci uživatelů.
 *
 * Zajišťuje registraci nových uživatelů, aktivaci účtů pomocí ověřovacího
 * tokenu, práci s přihlášeným uživatelem a proces zapomenutého hesla
 * včetně vystavení tokenu a nastavení nového hesla.
 *
 * Veškerá business logika se předává do {@link AppUserService}.
 */
@RestController
@RequestMapping("/api/auth")
public class AuthController {

    private final AppUserService appUserService;

    /**
     * Základní URL frontendové SPA aplikace (React/Vite).
     *
     * Tato hodnota se používá pro přesměrování uživatele při procesu
     * resetu hesla, aby mohl být otevřen správný route na frontend aplikaci.
     */
    @Value("${app.frontend-base-url:http://localhost:5173}")
    private String frontendBaseUrl;

    public AuthController(AppUserService appUserService) {
        this.appUserService = appUserService;
    }

    /**
     * Registruje nového uživatele.
     *
     * Po úspěšné registraci se vytváří aktivační token a odesílá se
     * aktivační e-mail s odkazem na aktivaci účtu.
     *
     * @param dto registrační údaje nového uživatele
     * @return HTTP odpověď s informací o úspěšné registraci
     */
    @PostMapping("/register")
    public ResponseEntity<?> register(@Valid @RequestBody RegisterUserDTO dto) {
        appUserService.register(dto);
        return ResponseEntity.ok(
                Map.of(
                        "status", "ok",
                        "message", "Registrace úspěšná. Zkontrolujte email pro aktivaci účtu."
                )
        );
    }

    /**
     * Vrací informace o aktuálně přihlášeném uživateli.
     *
     * @param authentication autentizační kontext přihlášeného uživatele
     * @return DTO s detaily přihlášeného uživatele
     */
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<AppUserDTO> getCurrentUser(Authentication authentication) {
        AppUserDTO dto = appUserService.getCurrentUser(authentication.getName());
        return ResponseEntity.ok(dto);
    }

    /**
     * Aktivuje uživatelský účet na základě ověřovacího tokenu.
     *
     * Token se získává z aktivačního odkazu zaslaného po registraci
     * a má omezenou platnost. V případě neplatného nebo expirovaného
     * tokenu se vrací chyba 400.
     *
     * @param token aktivační token
     * @return textová informace o výsledku aktivace účtu
     */
    @GetMapping("/verify")
    public ResponseEntity<String> verifyEmail(@RequestParam String token) {
        boolean activated = appUserService.activateUser(token);

        if (!activated) {
            return ResponseEntity
                    .badRequest()
                    .body("Neplatný nebo expirovaný aktivační odkaz.");
        }

        return ResponseEntity.ok("Účet byl úspěšně aktivován.");
    }

    /**
     * Přesměrovává uživatele z odkazu v e-mailu na frontendovou stránku
     * pro nastavení nového hesla.
     *
     * Backend provádí redirect na odpovídající route frontendové SPA
     * a předává reset token jako query parametr. Samotná změna hesla
     * se následně provádí pomocí REST endpointů pro zapomenuté heslo.
     *
     * @param token reset token pro zapomenuté heslo
     * @return HTTP 302 s hlavičkou Location na frontendovou URL
     */
    @GetMapping("/reset-password")
    public ResponseEntity<Void> redirectResetPassword(@RequestParam String token) {
        String targetUrl = frontendBaseUrl + "/reset-password?token=" + token;

        return ResponseEntity
                .status(HttpStatus.FOUND)
                .header("Location", targetUrl)
                .build();
    }

    // TODO MOŽNÁ DO APPUSERSETTINGS CONTROLLER

    /**
     * Vytváří požadavek na reset zapomenutého hesla.
     *
     * Na základě zadané e-mailové adresy se vytvoří reset token
     * a odešle se e-mail s odkazem pro nastavení nového hesla.
     *
     * @param dto DTO s e-mailovou adresou uživatele
     * @return HTTP odpověď 200 v případě úspěchu
     */
    @PostMapping("/forgotten-password")
    public ResponseEntity<Void> requestForgottenPassword(@RequestBody @Valid EmailDTO dto) {
        appUserService.requestForgottenPasswordReset(dto.getEmail());
        return ResponseEntity.ok().build();
    }

    /**
     * Vrací informaci o e-mailu, ke kterému přísluší daný reset token.
     *
     * Endpoint se používá například pro zobrazení e-mailové adresy
     * na frontendové stránce pro reset hesla.
     *
     * @param token reset token
     * @return mapování obsahující e-mail navázaný na token
     */
    @GetMapping("/forgotten-password/info")
    public ResponseEntity<Map<String, String>> getForgottenPasswordInfo(@RequestParam String token) {
        String email = appUserService.getForgottenPasswordResetEmail(token);
        return ResponseEntity.ok(Map.of("email", email));
    }

    /**
     * Provádí nastavení nového hesla na základě reset tokenu.
     *
     * Informace o tokenu, novém hesle a jeho potvrzení se předává
     * prostřednictvím {@link ForgottenPasswordResetDTO}.
     *
     * @param dto DTO obsahující token a nové heslo
     * @return HTTP odpověď 200 v případě úspěchu
     */
    @PostMapping("/forgotten-password/reset")
    public ResponseEntity<Void> forgottenPasswordReset(@RequestBody @Valid ForgottenPasswordResetDTO dto) {
        appUserService.forgottenPasswordReset(dto);
        return ResponseEntity.ok().build();
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\CurrentPlayerController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.services.PlayerService;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller, který se používá pro práci s aktuálním hráčem
 * přihlášeného uživatele.
 *
 * Aktuální hráč představuje kontext, ve kterém uživatel pracuje
 * například při registraci na zápasy nebo při zobrazení statistik.
 * Controller umožňuje nastavení aktuálního hráče, automatický výběr
 * hráče po přihlášení a získání aktuálně zvoleného hráče.
 *
 * Veškerá business logika se předává do {@link PlayerService}
 * a {@link CurrentPlayerService}.
 */
@RestController
@RequestMapping("/api/current-player")
public class CurrentPlayerController {

    private final CurrentPlayerService currentPlayerService;
    private final PlayerService playerService;

    public CurrentPlayerController(CurrentPlayerService currentPlayerService,
                                   PlayerService playerService) {
        this.currentPlayerService = currentPlayerService;
        this.playerService = playerService;
    }

    /**
     * Nastavuje aktuálního hráče pro přihlášeného uživatele.
     *
     * Metoda se používá zejména v případech, kdy má uživatel přiřazeno
     * více hráčů a potřebuje mezi nimi ručně přepínat.
     *
     * @param playerId ID hráče, který má být nastaven jako aktuální
     * @param auth     autentizační kontext přihlášeného uživatele
     * @return DTO {@link SuccessResponseDTO} s informací o provedené změně
     */
    @PostMapping("/{playerId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<SuccessResponseDTO> setCurrentPlayer(
            @PathVariable Long playerId,
            Authentication auth) {

        SuccessResponseDTO response =
                playerService.setCurrentPlayerForUser(auth.getName(), playerId);

        return ResponseEntity.ok(response);
    }

    /**
     * Provádí automatický výběr aktuálního hráče pro přihlášeného
     * uživatele podle nastavení v AppUserSettings.
     *
     * Například může být vybrán první hráč podle ID nebo může být
     * ponechán stav bez vybraného hráče, aby si uživatel vybral hráče
     * ručně na frontendu.
     *
     * @param auth autentizační kontext přihlášeného uživatele
     * @return DTO {@link SuccessResponseDTO} s výsledkem automatického výběru
     */
    @PostMapping("/auto-select")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<SuccessResponseDTO> autoSelectCurrentPlayer(Authentication auth) {
        SuccessResponseDTO response =
                playerService.autoSelectCurrentPlayerForUser(auth.getName());

        return ResponseEntity.ok(response);
    }

    /**
     * Vrací aktuálně zvoleného hráče přihlášeného uživatele.
     *
     * Pokud není aktuální hráč nastaven, vrací se hodnota null.
     *
     * @return DTO {@link PlayerDTO} s detaily hráče nebo null
     */
    @GetMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<PlayerDTO> getCurrentPlayer() {

        Long playerId = currentPlayerService.getCurrentPlayerId();
        if (playerId == null) {
            return ResponseEntity.ok(null);
        }

        PlayerDTO player = playerService.getPlayerById(playerId);
        return ResponseEntity.ok(player);
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\DebugController.java
-----

package cz.phsoft.hokej.controllers;

import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * REST controller, který se používá pro ladění bezpečnostního kontextu.
 *
 * Umožňuje ověřit, zda je uživatel autentizován a jaké informace
 * jsou dostupné v objektu {@link Authentication}. Controller je určen
 * pouze pro vývojové prostředí a neměl by být vystaven v produkci.
 */
@RestController
public class DebugController {

    /**
     * Vrací aktuální objekt {@link Authentication}.
     *
     * Metoda se používá výhradně pro ladění a diagnostiku
     * bezpečnostního kontextu.
     *
     * @param auth autentizační kontext aktuálního uživatele
     * @return objekt {@link Authentication} s informacemi o uživateli
     */
    @GetMapping("/api/debug/me")
    public Object me(Authentication auth) {
        return auth;
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\MatchController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.enums.MatchCancelReason;
import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;
import cz.phsoft.hokej.models.dto.MatchOverviewDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import cz.phsoft.hokej.models.services.MatchService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller, který se používá pro správu zápasů.
 *
 * Zajišťuje administraci zápasů pro role ADMIN a MANAGER včetně
 * vytváření, aktualizace, mazání, zrušení a obnovení zápasu. Dále
 * poskytuje pohled na zápasy z perspektivy aktuálního hráče a detail
 * zápasu včetně informací o registracích.
 *
 * Veškerá business logika se předává do {@link MatchService}.
 */
@RestController
@RequestMapping("/api/matches")
public class MatchController {

    private final MatchService matchService;
    private final CurrentPlayerService currentPlayerService;

    public MatchController(MatchService matchService,
                           CurrentPlayerService currentPlayerService) {
        this.matchService = matchService;
        this.currentPlayerService = currentPlayerService;
    }

    // ADMIN / MANAGER – globální správa zápasů

    /**
     * Vrací seznam všech zápasů v systému.
     *
     * Endpoint je dostupný pro role ADMIN a MANAGER.
     *
     * @return seznam zápasů jako {@link MatchDTO}
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getAllMatches() {
        return matchService.getAllMatches();
    }

    /**
     * Vrací seznam všech nadcházejících zápasů.
     *
     * Endpoint je dostupný pro role ADMIN a MANAGER.
     *
     * @return seznam nadcházejících zápasů
     */
    @GetMapping("/upcoming")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getUpcomingMatches() {
        return matchService.getUpcomingMatches();
    }

    /**
     * Vrací seznam všech již odehraných zápasů.
     *
     * Endpoint je dostupný pro role ADMIN a MANAGER.
     *
     * @return seznam minulých zápasů
     */
    @GetMapping("/past")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getPastMatches() {
        return matchService.getPastMatches();
    }

    /**
     * Vytváří nový zápas.
     *
     * @param matchDTO DTO s daty nového zápasu
     * @return vytvořený zápas jako {@link MatchDTO}
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public MatchDTO createMatch(@Valid @RequestBody MatchDTO matchDTO) {
        return matchService.createMatch(matchDTO);
    }

    /**
     * Vrací detail zápasu podle jeho ID.
     *
     * Jedná se o administrátorský nebo manažerský pohled bez vazby
     * na konkrétního hráče.
     *
     * @param id ID zápasu
     * @return DTO {@link MatchDTO} s detaily zápasu
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO getMatch(@PathVariable Long id) {
        return matchService.getMatchById(id);
    }

    /**
     * Aktualizuje existující zápas.
     *
     * @param id  ID zápasu, který má být aktualizován
     * @param dto DTO s aktualizovanými daty zápasu
     * @return DTO {@link MatchDTO} s uloženými změnami
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO updateMatch(@PathVariable Long id,
                                @Valid @RequestBody MatchDTO dto) {
        return matchService.updateMatch(id, dto);
    }

    /**
     * Odstraňuje zápas ze systému.
     *
     * Operace je vyhrazena pouze pro roli ADMIN.
     *
     * @param id ID zápasu, který má být odstraněn
     * @return DTO {@link SuccessResponseDTO} s výsledkem operace
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SuccessResponseDTO> deleteMatch(@PathVariable Long id) {
        SuccessResponseDTO response = matchService.deleteMatch(id);
        return ResponseEntity.ok(response);
    }

    /**
     * Vrací seznam zápasů, které jsou dostupné pro konkrétního hráče.
     *
     * Endpoint je dostupný pro role ADMIN a MANAGER.
     *
     * @param playerId ID hráče
     * @return seznam dostupných zápasů pro hráče
     */
    @GetMapping("/available-for-player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getAvailableMatchesForPlayer(@PathVariable Long playerId) {
        return matchService.getAvailableMatchesForPlayer(playerId);
    }

    /**
     * Ruší zápas a ukládá důvod zrušení.
     *
     * Operace je dostupná pro role ADMIN a MANAGER a typicky
     * spouští notifikační proces pro dotčené hráče.
     *
     * @param matchId ID zápasu
     * @param reason  důvod zrušení zápasu
     * @return DTO {@link SuccessResponseDTO} s výsledkem operace
     */
    @PatchMapping("/{matchId}/cancel")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SuccessResponseDTO> cancelMatch(
            @PathVariable Long matchId,
            @RequestParam MatchCancelReason reason
    ) {
        SuccessResponseDTO response = matchService.cancelMatch(matchId, reason);
        return ResponseEntity.ok(response);
    }

    /**
     * Obnovuje dříve zrušený zápas.
     *
     * Operace je dostupná pro role ADMIN a MANAGER.
     *
     * @param matchId ID zápasu
     * @return DTO {@link SuccessResponseDTO} s výsledkem operace
     */
    @PatchMapping("/{matchId}/uncancel")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SuccessResponseDTO> unCancelMatch(@PathVariable Long matchId) {
        SuccessResponseDTO response = matchService.unCancelMatch(matchId);
        return ResponseEntity.ok(response);
    }

    // Hráč – endpointy v kontextu aktuálního hráče

    /**
     * Vrací detail konkrétního zápasu z pohledu hráče.
     *
     * Detail zahrnuje například stav registrací, volná místa nebo
     * informace o tom, zda může hráč měnit svojí registraci.
     *
     * @param id ID zápasu
     * @return DTO {@link MatchDetailDTO} s detailem zápasu pro hráče
     */
    @GetMapping("/{id}/detail")
    @PreAuthorize("isAuthenticated()")
    public MatchDetailDTO getMatchDetail(@PathVariable Long id) {
        return matchService.getMatchDetail(id);
    }

    /**
     * Vrací nejbližší nadcházející zápas v systému.
     *
     * Endpoint se používá pro zobrazení nejbližšího zápasu
     * například na úvodní stránce.
     *
     * @return DTO {@link MatchDTO} s nejbližším zápasem nebo null
     */
    @GetMapping("/next")
    @PreAuthorize("isAuthenticated()")
    public MatchDTO getNextMatch() {
        return matchService.getNextMatch();
    }

    /**
     * Vrací seznam nadcházejících zápasů pro aktuálně zvoleného hráče.
     *
     * Před voláním služby se vyžaduje, aby byl nastaven aktuální hráč.
     *
     * @param authentication autentizační kontext přihlášeného uživatele
     * @return seznam nadcházejících zápasů pro aktuálního hráče
     */
    @GetMapping("/me/upcoming")
    @PreAuthorize("isAuthenticated()")
    public List<MatchDTO> getUpcomingMatchesForMe(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getUpcomingMatchesForPlayer(currentPlayerId);
    }

    /**
     * Vrací přehled nadcházejících zápasů pro aktuálního hráče.
     *
     * Přehled se používá například pro kompaktní zobrazení zápasů
     * v kartách na frontendu.
     *
     * @param authentication autentizační kontext přihlášeného uživatele
     * @return seznam {@link MatchOverviewDTO} pro aktuálního hráče
     */
    @GetMapping("/me/upcoming-overview")
    @PreAuthorize("isAuthenticated()")
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForMe(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getUpcomingMatchesOverviewForPlayer(currentPlayerId);
    }

    /**
     * Vrací seznam všech již odehraných zápasů pro aktuálního hráče.
     *
     * Seznam může být použit například pro zobrazení historie
     * zápasů daného hráče.
     *
     * @param authentication autentizační kontext přihlášeného uživatele
     * @return seznam {@link MatchOverviewDTO} pro odehrané zápasy hráče
     */
    @GetMapping("/me/all-passed")
    @PreAuthorize("isAuthenticated()")
    public List<MatchOverviewDTO> getAllMatchesForPlayer(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getAllPassedMatchesForPlayer(currentPlayerId);
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\MatchRegistrationController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.exceptions.CurrentPlayerNotSelectedException;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import cz.phsoft.hokej.models.services.MatchService;
import jakarta.validation.Valid;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller, který se používá pro správu registrací hráčů na zápasy.
 *
 * Zajišťuje administrativní správu registrací pro role ADMIN a MANAGER
 * a správu registrací pro aktuálního hráče pod endpointy /me.
 *
 * Veškerá business logika se předává do {@link MatchRegistrationService}
 * a částečně do {@link MatchService}.
 */
@RestController
@RequestMapping("/api/registrations")
public class MatchRegistrationController {

    private final MatchRegistrationService matchRegistrationService;
    private final CurrentPlayerService currentPlayerService;
    private final MatchService matchService;

    public MatchRegistrationController(MatchRegistrationService matchRegistrationService,
                                       CurrentPlayerService currentPlayerService,
                                       MatchService matchService) {
        this.matchRegistrationService = matchRegistrationService;
        this.currentPlayerService = currentPlayerService;
        this.matchService = matchService;
    }

    // ADMIN / MANAGER – globální správa registrací

    /**
     * Vrací seznam všech registrací na všechny zápasy.
     *
     * Endpoint je dostupný pro role ADMIN a MANAGER.
     *
     * @return seznam {@link MatchRegistrationDTO}
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> getAllRegistrations() {
        return matchRegistrationService.getAllRegistrations();
    }

    /**
     * Vrací všechny registrace hráčů pro konkrétní zápas.
     *
     * @param matchId ID zápasu
     * @return seznam registrací pro daný zápas
     */
    @GetMapping("/match/{matchId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> getRegistrationsForMatch(@PathVariable Long matchId) {
        return matchRegistrationService.getRegistrationsForMatch(matchId);
    }

    /**
     * Vrací všechny registrace konkrétního hráče napříč zápasy.
     *
     * @param playerId ID hráče
     * @return seznam registrací daného hráče
     */
    @GetMapping("/player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> getRegistrationsForPlayer(@PathVariable Long playerId) {
        return matchRegistrationService.getRegistrationsForPlayer(playerId);
    }

    /**
     * Vrací seznam hráčů, kteří na pozvánku k danému zápasu zatím nereagovali.
     *
     * Tato informace se používá například pro přehled hráčů, kteří se
     * ještě nepřihlásili ani neomluvili.
     *
     * @param matchId ID zápasu
     * @return seznam hráčů bez reakce
     */
    @GetMapping("/match/{matchId}/no-response")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getNoResponsePlayers(@PathVariable Long matchId) {
        return matchRegistrationService.getNoResponsePlayers(matchId);
    }

    /**
     * Vytváří nebo aktualizuje registraci za konkrétního hráče.
     *
     * Endpoint se používá administrátorem nebo manažerem pro scénáře,
     * kdy je potřeba registrovat nebo přehlásit hráče ručně.
     *
     * @param playerId ID hráče, za kterého se operace provádí
     * @param request  požadavek na změnu registrace
     * @return DTO {@link MatchRegistrationDTO} s výsledným stavem registrace
     */
    @PostMapping("/upsert/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchRegistrationDTO upsertForPlayer(
            @PathVariable Long playerId,
            @Valid @RequestBody MatchRegistrationRequest request
    ) {
        return matchRegistrationService.upsertRegistration(playerId, request);
    }

    /**
     * Označuje hráče v konkrétním zápase jako neomluveně nepřítomného.
     *
     * Pro záznam může být doplněna poznámka administrátora.
     *
     * @param matchId   ID zápasu
     * @param playerId  ID hráče
     * @param adminNote volitelná interní poznámka
     * @return DTO {@link MatchRegistrationDTO} s aktualizovaným stavem
     */
    @PatchMapping("/match/{matchId}/players/{playerId}/no-excused")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchRegistrationDTO markNoExcused(
            @PathVariable Long matchId,
            @PathVariable Long playerId,
            @RequestParam(required = false) String adminNote
    ) {
        return matchRegistrationService.markNoExcused(matchId, playerId, adminNote);
    }

    // Uživatelská správa registrací pro aktuálního hráče

    /**
     * Spravuje registraci aktuálního hráče na zápas.
     *
     * Podle obsahu {@link MatchRegistrationRequest} se provádí registrace,
     * odhlášení, omluva nebo nastavení náhradníka. Aktuální hráč se získává
     * z {@link CurrentPlayerService}.
     *
     * @param request požadavek na změnu registrace
     * @return DTO {@link MatchRegistrationDTO} s výsledným stavem registrace
     */
    @PostMapping("/me/upsert")
    @PreAuthorize("isAuthenticated()")
    public MatchRegistrationDTO upsertForCurrentPlayer(
            @Valid @RequestBody MatchRegistrationRequest request
    ) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        if (currentPlayerId == null) {
            throw new CurrentPlayerNotSelectedException();
        }

        return matchRegistrationService.upsertRegistration(currentPlayerId, request);
    }

    /**
     * Vrací všechny registrace aktuálně zvoleného hráče.
     *
     * @return seznam {@link MatchRegistrationDTO} pro aktuálního hráče
     */
    @GetMapping("/me/for-current-player")
    @PreAuthorize("isAuthenticated()")
    public List<MatchRegistrationDTO> getRegistrationsForCurrentPlayer() {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchRegistrationService.getRegistrationsForPlayer(currentPlayerId);
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\MatchRegistrationHistoryController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchRegistrationHistoryDTO;
import cz.phsoft.hokej.models.services.MatchRegistrationHistoryService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * REST controller, který se používá pro práci s historií registrací
 * hráčů k zápasům.
 *
 * Controller poskytuje uživatelský pohled na historii registrace
 * aktuálního hráče a administrativní audit historie registrací
 * konkrétního hráče. Controller je read-only a slouží pouze ke čtení
 * z tabulky historie registrací.
 *
 * Veškerá business logika se předává do
 * {@link MatchRegistrationHistoryService}.
 */
@RestController
@RequestMapping("/api/registrations/history")
public class MatchRegistrationHistoryController {

    private final MatchRegistrationHistoryService historyService;

    public MatchRegistrationHistoryController(MatchRegistrationHistoryService historyService) {
        this.historyService = historyService;
    }

    // Uživatelský přístup – aktuální hráč

    /**
     * Vrací historii všech změn registrace aktuálně přihlášeného
     * hráče pro daný zápas.
     *
     * Metoda se používá například pro zobrazení historie registrace
     * na detailu zápasu v uživatelském rozhraní.
     *
     * @param matchId ID zápasu
     * @return seznam záznamů historie seřazených od nejnovějšího
     */
    @GetMapping("/me/matches/{matchId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<MatchRegistrationHistoryDTO>> getMyHistoryForMatch(
            @PathVariable Long matchId
    ) {
        List<MatchRegistrationHistoryDTO> history =
                historyService.getHistoryForCurrentPlayerAndMatch(matchId);

        return ResponseEntity.ok(history);
    }


    /**
     * Vrací historii všech změn registrace konkrétního hráče pro daný zápas.
     *
     * Metoda se používá pro administrativní audit, analýzu změn registrací
     * a řešení případných sporů.
     *
     * @param matchId  ID zápasu
     * @param playerId ID hráče
     * @return seznam záznamů historie seřazených od nejnovějšího
     */
    @GetMapping("/admin/matches/{matchId}/players/{playerId}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<MatchRegistrationHistoryDTO>> getPlayerHistoryForMatch(
            @PathVariable Long matchId,
            @PathVariable Long playerId
    ) {
        List<MatchRegistrationHistoryDTO> history =
                historyService.getHistoryForPlayerAndMatch(matchId, playerId);

        return ResponseEntity.ok(history);
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.dto.requests.ChangePlayerUserRequest;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import cz.phsoft.hokej.models.services.PlayerService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller, který se používá pro správu hráčů.
 *
 * Zajišťuje administrativní správu hráčů pro role ADMIN a MANAGER,
 * včetně vytváření, aktualizace, mazání a schvalování hráčů, a také
 * správu hráčů z pohledu přihlášeného uživatele pod endpointy /me.
 *
 * Veškerá business logika se předává do {@link PlayerService}.
 */
@RestController
@RequestMapping("/api/players")
public class PlayerController {

    private final PlayerService playerService;
    private final CurrentPlayerService currentPlayerService;

    public PlayerController(PlayerService playerService,
                            CurrentPlayerService currentPlayerService) {
        this.playerService = playerService;
        this.currentPlayerService = currentPlayerService;
    }

    // ADMIN / MANAGER – globální správa hráčů

    /**
     * Vrací seznam všech hráčů v systému.
     *
     * Endpoint je dostupný pro role ADMIN a MANAGER.
     *
     * @return seznam {@link PlayerDTO}
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getAllPlayers() {
        return playerService.getAllPlayers();
    }

    /**
     * Vrací detail hráče podle jeho ID.
     *
     * @param id ID hráče
     * @return DTO {@link PlayerDTO} s detailem hráče
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public PlayerDTO getPlayerById(@PathVariable Long id) {
        return playerService.getPlayerById(id);
    }

    /**
     * Vytváří nového hráče administrátorem nebo manažerem.
     *
     * Operace se používá při ručním zakládání hráče v systému.
     *
     * @param playerDTO DTO s daty nového hráče
     * @return vytvořený hráč jako {@link PlayerDTO}
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public PlayerDTO createPlayer(@Valid @RequestBody PlayerDTO playerDTO) {
        return playerService.createPlayer(playerDTO);
    }

    /**
     * Aktualizuje údaje hráče administrátorem.
     *
     * @param id  ID hráče
     * @param dto DTO s aktualizovanými daty hráče
     * @return aktualizovaný hráč jako {@link PlayerDTO}
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public PlayerDTO updatePlayerAdmin(@PathVariable Long id,
                                       @Valid @RequestBody PlayerDTO dto) {
        return playerService.updatePlayer(id, dto);
    }

    /**
     * Odstraňuje hráče ze systému.
     *
     * Operace je vyhrazena pouze pro roli ADMIN.
     *
     * @param id ID hráče
     * @return DTO {@link SuccessResponseDTO} s výsledkem operace
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SuccessResponseDTO> deletePlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.deletePlayer(id);
        return ResponseEntity.ok(response);
    }

    /**
     * Schvaluje hráče a nastavuje jeho stav na APPROVED.
     *
     * @param id ID hráče
     * @return DTO {@link SuccessResponseDTO} s výsledkem operace
     */
    @PutMapping("/{id}/approve")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SuccessResponseDTO> approvePlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.approvePlayer(id);
        return ResponseEntity.ok(response);
    }

    /**
     * Zamítá hráče a nastavuje jeho stav na REJECTED.
     *
     * @param id ID hráče
     * @return DTO {@link SuccessResponseDTO} s výsledkem operace
     */
    @PutMapping("/{id}/reject")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SuccessResponseDTO> rejectPlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.rejectPlayer(id);
        return ResponseEntity.ok(response);
    }

    /**
     * Mění přiřazení hráče k aplikačnímu uživateli.
     *
     * Operace je určena pro roli ADMIN nebo MANAGER a používá se,
     * pokud je potřeba hráče převést k jinému uživateli.
     *
     * @param playerId ID hráče
     * @param request  request obsahující ID nového uživatele
     * @return textová zpráva o úspěšné změně přiřazení
     */
    @PostMapping("/{playerId}/change-user")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<String> changePlayerUser(
            @PathVariable Long playerId,
            @RequestBody ChangePlayerUserRequest request
    ) {
        playerService.changePlayerUser(playerId, request.getNewUserId());
        return ResponseEntity.ok(
                "Hráč s id: " + playerId + " byl úspěšně přiřazen uživateli s ID: " + request.getNewUserId()
        );
    }

    // Uživatelská správa hráčů přihlášeného uživatele

    /**
     * Vytváří nového hráče pro přihlášeného uživatele.
     *
     * Nový hráč se automaticky přiřazuje k uživatelskému účtu,
     * který vychází z e-mailu v objektu {@link Authentication}.
     *
     * @param playerDTO      DTO s daty nového hráče
     * @param authentication autentizační kontext přihlášeného uživatele
     * @return vytvořený hráč jako {@link PlayerDTO}
     */
    @PostMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public PlayerDTO createMyPlayer(
            @Valid @RequestBody PlayerDTO playerDTO,
            Authentication authentication
    ) {
        String email = authentication.getName();
        return playerService.createPlayerForUser(playerDTO, email);
    }

    /**
     * Vrací seznam všech hráčů patřících přihlášenému uživateli.
     *
     * @param authentication autentizační kontext přihlášeného uživatele
     * @return seznam {@link PlayerDTO} pro daného uživatele
     */
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public List<PlayerDTO> getMyPlayers(Authentication authentication) {
        String email = authentication.getName();
        return playerService.getPlayersByUser(email);
    }

    /**
     * Aktualizuje údaje aktuálně zvoleného hráče.
     *
     * Před provedením aktualizace se vyžaduje, aby byl nastaven
     * aktuální hráč v {@link CurrentPlayerService}.
     *
     * @param dto DTO s aktualizovanými daty hráče
     * @return aktualizovaný hráč jako {@link PlayerDTO}
     */
    @PutMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public PlayerDTO updateMyCurrentPlayer(@Valid @RequestBody PlayerDTO dto) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return playerService.updatePlayer(currentPlayerId, dto);
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerInactivityPeriodController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import cz.phsoft.hokej.models.services.PlayerInactivityPeriodService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller, který se používá pro administraci období neaktivity hráčů.
 *
 * Období neaktivity slouží k evidenci časových úseků, ve kterých se hráč
 * neúčastní zápasů, například z důvodu zranění nebo dovolené. Endpointy jsou
 * určeny pro role ADMIN a MANAGER a umožňují úplnou správu záznamů o neaktivitě.
 *
 * Veškerá business logika se předává do {@link PlayerInactivityPeriodService}.
 */
@RestController
@RequestMapping("/api/inactivity/admin")
public class PlayerInactivityPeriodController {

    private final PlayerInactivityPeriodService service;

    public PlayerInactivityPeriodController(PlayerInactivityPeriodService service) {
        this.service = service;
    }

    /**
     * Vrací seznam všech záznamů o neaktivitě hráčů.
     *
     * @return seznam období neaktivity jako {@link PlayerInactivityPeriodDTO}
     */
    @GetMapping("/all")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getAll() {
        return service.getAll();
    }

    /**
     * Vrací detail záznamu o neaktivitě podle jeho ID.
     *
     * @param id ID záznamu o neaktivitě
     * @return DTO {@link PlayerInactivityPeriodDTO} s detailem období neaktivity
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<PlayerInactivityPeriodDTO> getById(@PathVariable Long id) {
        PlayerInactivityPeriodDTO dto = service.getById(id);
        return ResponseEntity.ok(dto);
    }

    /**
     * Vrací všechna období neaktivity pro konkrétního hráče.
     *
     * @param playerId ID hráče
     * @return seznam období neaktivity pro daného hráče
     */
    @GetMapping("/player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getByPlayer(@PathVariable Long playerId) {
        return service.getByPlayer(playerId);
    }

    /**
     * Vytváří nový záznam o neaktivitě hráče.
     *
     * Operace je vyhrazena pouze pro roli ADMIN.
     *
     * @param dto DTO s daty období neaktivity
     * @return vytvořený záznam jako {@link PlayerInactivityPeriodDTO}
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<PlayerInactivityPeriodDTO> create(
            @Valid @RequestBody PlayerInactivityPeriodDTO dto) {

        PlayerInactivityPeriodDTO created = service.create(dto);
        return ResponseEntity.ok(created);
    }

    /**
     * Aktualizuje existující záznam o neaktivitě hráče.
     *
     * Operace je vyhrazena pouze pro roli ADMIN.
     *
     * @param id  ID záznamu o neaktivitě
     * @param dto DTO s aktualizovanými daty období neaktivity
     * @return aktualizovaný záznam jako {@link PlayerInactivityPeriodDTO}
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<PlayerInactivityPeriodDTO> update(
            @PathVariable Long id,
            @Valid @RequestBody PlayerInactivityPeriodDTO dto) {

        PlayerInactivityPeriodDTO updated = service.update(id, dto);
        return ResponseEntity.ok(updated);
    }

    /**
     * Odstraňuje záznam o neaktivitě hráče.
     *
     * Operace je vyhrazena pouze pro roli ADMIN.
     *
     * @param id ID záznamu o neaktivitě
     * @return HTTP odpověď 204 No Content v případě úspěchu
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        service.delete(id);
        return ResponseEntity.noContent().build();
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerSettingsController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerSettingsDTO;
import cz.phsoft.hokej.models.services.PlayerSettingsService;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

/**
 * REST controller, který se používá pro správu nastavení hráče.
 *
 * Pracuje s nastavením navázaným na konkrétního hráče a na aktuálního
 * hráče (currentPlayer). Umožňuje načítat a aktualizovat nastavení
 * pro libovolného hráče podle ID a pro hráče, který je aktuálně
 * vybrán v kontextu přihlášeného uživatele.
 *
 * Veškerá business logika se předává do {@link PlayerSettingsService}.
 */
@RestController
@RequestMapping("/api")
public class PlayerSettingsController {

    private final PlayerSettingsService playerSettingsService;
    private final CurrentPlayerService currentPlayerService;

    public PlayerSettingsController(PlayerSettingsService playerSettingsService,
                                    CurrentPlayerService currentPlayerService) {
        this.playerSettingsService = playerSettingsService;
        this.currentPlayerService = currentPlayerService;
    }

    // Nastavení libovolného hráče podle ID

    /**
     * Vrací nastavení konkrétního hráče podle jeho ID.
     *
     * Ověření, zda hráč patří přihlášenému uživateli nebo zda má
     * uživatel roli ADMIN či MANAGER, může být prováděno v této
     * vrstvě nebo v service vrstvě.
     *
     * @param playerId ID hráče
     * @param auth     autentizační kontext přihlášeného uživatele
     * @return DTO {@link PlayerSettingsDTO} s nastavením hráče
     */
    @GetMapping("/players/{playerId}/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<PlayerSettingsDTO> getPlayerSettings(
            @PathVariable Long playerId,
            Authentication auth
    ) {
        PlayerSettingsDTO dto = playerSettingsService.getSettingsForPlayer(playerId);
        return ResponseEntity.ok(dto);
    }

    /**
     * Aktualizuje nastavení konkrétního hráče podle jeho ID.
     *
     * Kontrola vlastnictví hráče a oprávnění může být doplněna
     * podle potřeb aplikace.
     *
     * @param playerId   ID hráče
     * @param requestDto DTO s novým nastavením hráče
     * @param auth       autentizační kontext přihlášeného uživatele
     * @return DTO {@link PlayerSettingsDTO} s aktualizovaným nastavením
     */
    @PatchMapping("/players/{playerId}/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<PlayerSettingsDTO> updatePlayerSettings(
            @PathVariable Long playerId,
            @RequestBody PlayerSettingsDTO requestDto,
            Authentication auth
    ) {
        // TODO: případná kontrola vlastnictví hráče

        PlayerSettingsDTO updated = playerSettingsService.updateSettingsForPlayer(playerId, requestDto);
        return ResponseEntity.ok(updated);
    }

    // Nastavení aktuálního hráče (currentPlayer)

    /**
     * Vrací nastavení aktuálně vybraného hráče.
     *
     * Před čtením nastavení se vyžaduje, aby byl v kontextu
     * nastaven aktuální hráč.
     *
     * @return DTO {@link PlayerSettingsDTO} s nastavením aktuálního hráče
     */
    @GetMapping("/me/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<PlayerSettingsDTO> getCurrentPlayerSettings() {

        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        PlayerSettingsDTO dto = playerSettingsService.getSettingsForPlayer(currentPlayerId);

        return ResponseEntity.ok(dto);
    }

    /**
     * Aktualizuje nastavení aktuálně vybraného hráče.
     *
     * Informace o tom, který hráč je aktuální, se získává z
     * {@link CurrentPlayerService}. Endpoint se používá například
     * pro nastavení preferencí přímo z kontextu aktuálního hráče.
     *
     * @param requestDto DTO s novým nastavením aktuálního hráče
     * @return DTO {@link PlayerSettingsDTO} s aktualizovaným nastavením
     */
    @PatchMapping("/me/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<PlayerSettingsDTO> updateCurrentPlayerSettings(
            @RequestBody PlayerSettingsDTO requestDto
    ) {

        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        PlayerSettingsDTO updated = playerSettingsService.updateSettingsForPlayer(currentPlayerId, requestDto);

        return ResponseEntity.ok(updated);
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\SeasonController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.SeasonDTO;
import cz.phsoft.hokej.models.mappers.SeasonMapper;
import cz.phsoft.hokej.models.services.CurrentSeasonService;
import cz.phsoft.hokej.models.services.SeasonService;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller, který se používá pro správu sezón.
 *
 * Zajišťuje administrativní správu sezón pro roli ADMIN včetně
 * vytváření, aktualizace a nastavení globálně aktivní sezóny.
 * Dále poskytuje endpointy pro práci s aktuální sezónou uživatele
 * pod prefixem /me.
 *
 * Veškerá business logika se předává do {@link SeasonService}
 * a {@link CurrentSeasonService}.
 */
@RestController
@RequestMapping("/api/seasons")
public class SeasonController {

    private final SeasonService seasonService;
    private final SeasonMapper seasonMapper;
    private final CurrentSeasonService currentSeasonService;

    public SeasonController(SeasonService seasonService,
                            SeasonMapper seasonMapper,
                            CurrentSeasonService currentSeasonService) {
        this.seasonService = seasonService;
        this.seasonMapper = seasonMapper;
        this.currentSeasonService = currentSeasonService;
    }

    // ADMIN – globální správa sezón

    /**
     * Vytváří novou sezónu.
     *
     * @param seasonDTO DTO s daty nové sezóny
     * @return vytvořená sezóna jako {@link SeasonDTO}
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SeasonDTO> createSeason(
            @Valid @RequestBody SeasonDTO seasonDTO) {

        SeasonDTO created = seasonService.createSeason(seasonDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    }

    /**
     * Aktualizuje existující sezónu.
     *
     * @param id        ID sezóny
     * @param seasonDTO DTO s aktualizovanými daty sezóny
     * @return aktualizovaná sezóna jako {@link SeasonDTO}
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SeasonDTO> updateSeason(
            @PathVariable Long id,
            @Valid @RequestBody SeasonDTO seasonDTO
    ) {
        SeasonDTO updated = seasonService.updateSeason(id, seasonDTO);
        return ResponseEntity.ok(updated);
    }

    /**
     * Vrací seznam všech sezón v systému.
     *
     * Endpoint je v tuto chvíli omezen na roli ADMIN. Podle potřeby
     * může být v budoucnu zpřístupněn širšímu okruhu uživatelů.
     *
     * @return seznam sezón jako {@link SeasonDTO}
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<SeasonDTO>> getAllSeasonsAdmin() {
        List<SeasonDTO> seasons = seasonService.getAllSeasons();
        return ResponseEntity.ok(seasons);
    }

    /**
     * Vrací aktuálně globálně aktivní sezónu.
     *
     * Aktivní sezóna představuje výchozí období pro systémové operace,
     * které nejsou vázány na konkrétní volbu uživatele.
     *
     * @return aktivní sezóna jako {@link SeasonDTO}
     */
    @GetMapping("/active")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SeasonDTO> getActiveSeason() {
        SeasonDTO dto = seasonMapper.toDTO(seasonService.getActiveSeason());
        return ResponseEntity.ok(dto);
    }

    /**
     * Nastavuje zadanou sezónu jako globálně aktivní.
     *
     * Po nastavení se informace o aktivní sezóně používá v dalších
     * částech systému jako výchozí sezóna.
     *
     * @param id ID sezóny, která má být nastavena jako aktivní
     * @return nově aktivní sezóna jako {@link SeasonDTO}
     */
    @PutMapping("/{id}/active")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SeasonDTO> setActiveSeason(@PathVariable Long id) {
        seasonService.setActiveSeason(id);
        SeasonDTO active = seasonMapper.toDTO(seasonService.getActiveSeason());
        return ResponseEntity.ok(active);
    }

    // Uživatelská práce s „mojí“ sezónou

    /**
     * Vrací seznam všech sezón pro účely výběru na frontendu.
     *
     * Jedná se o uživatelskou variantu endpointu, která se používá
     * například pro zobrazení seznamu sezón v nabídce.
     *
     * @return seznam sezón jako {@link SeasonDTO}
     */
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public List<SeasonDTO> getAllSeasonsForUser() {
        return seasonService.getAllSeasons();
    }

    /**
     * Vrací sezónu, která je aktuálně vybraná pro přihlášeného uživatele.
     *
     * Pokud uživatel nemá explicitně vybranou sezónu, může být vrácena
     * výchozí hodnota podle implementace {@link CurrentSeasonService}.
     *
     * @return aktuální sezóna pro uživatele nebo null
     */
    @GetMapping("/me/current")
    @PreAuthorize("isAuthenticated()")
    public SeasonDTO getCurrentSeasonForUser() {
        Long id = currentSeasonService.getCurrentSeasonIdOrDefault();
        return (id != null) ? seasonService.getSeasonById(id) : null;
    }

    /**
     * Nastavuje aktuální sezónu pro přihlášeného uživatele.
     *
     * Před nastavením se ověřuje, že sezóna existuje. Id sezóny
     * se následně ukládá do kontextu aktuální sezóny uživatele.
     *
     * @param seasonId ID sezóny, která má být nastavena jako aktuální
     */
    @PostMapping("/me/current/{seasonId}")
    @PreAuthorize("isAuthenticated()")
    public void setCurrentSeasonForUser(@PathVariable Long seasonId) {
        seasonService.getSeasonById(seasonId);
        currentSeasonService.setCurrentSeasonId(seasonId);
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestController.java
-----

package cz.phsoft.hokej.controllers;

import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * Jednoduchý testovací REST controller.
 *
 * Slouží k ověření, že backend aplikace běží a že funguje
 * zabezpečení pro roli ADMIN.
 */
@RestController
@RequestMapping("/api/test")
@PreAuthorize("hasRole('ADMIN')")
public class TestController {

    /**
     * Vrací jednoduchou textovou zprávu pro ověření, že backend je online.
     *
     * @return textová zpráva potvrzující běh backendu
     */
    @GetMapping
    public String hello() {
        return "Backend je online!";
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestEmailController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.services.email.EmailService;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * Testovací REST controller pro odeslání e-mailu.
 *
 * Slouží k ověření konfigurace e-mailové služby v prostředí,
 * například při vývoji nebo testování.
 *
 * Veškerá logika odesílání e-mailů se předává do {@link EmailService}.
 */
@RestController
@RequestMapping("/api/email/test")
public class TestEmailController {

    private final EmailService emailService;

    public TestEmailController(EmailService emailService) {
        this.emailService = emailService;
    }

    /**
     * Odesílá testovací e-mail na pevně danou adresu.
     *
     * Endpoint se používá pro ověření, že e-mailová služba je správně
     * nakonfigurována a že lze e-maily z backendu odesílat.
     *
     * @return textová zpráva o odeslání e-mailu
     */
    @PostMapping("/send-mail")
    public String sendTestMail() {
        emailService.sendSimpleEmail(
                "petrhlista@seznam.cz",
                "APP - Testovací email",
                "Ahoj, toto je test z backendu."
        );
        return "Email odeslán";
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestSmsController.java
-----

/*
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.services.sms.SmsTextBeeService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * Testovací REST controller pro odeslání SMS.
 *
 * Slouží k ověření, že integrace se službou SmsTextBee funguje
 * správně v daném prostředí.
 */
/*
@RestController
public class TestSmsController {

    private final SmsTextBeeService smsTextBeeService;

    public TestSmsController(SmsTextBeeService smsTextBeeService) {
        this.smsTextBeeService = smsTextBeeService;
    }

    /**
     * Odesílá testovací SMS na testovací telefonní číslo.
     *
     * Endpoint se používá pro ověření funkčnosti SMS integrace.
     */
    /*
    @GetMapping("/api/test-sms")
    public String sendTestSms() {
        smsTextBeeService.sendSms("+420776609956", "testovací sms app-sg");
        return "SMS byla odeslána na testovací číslo +420776609956";
    }
}
*/


