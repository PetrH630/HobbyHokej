Balíček (složka): controllers
Cesta: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers

Seznam souborů:
AppUserController.java
AppUserSettingsController.java
AuthController.java
CurrentPlayerController.java
DebugController.java
MatchController.java
MatchRegistrationController.java
MatchRegistrationHistoryController.java
PlayerController.java
PlayerInactivityPeriodController.java
PlayerSettingsController.java
SeasonController.java
TestController.java
TestEmailController.java
TestSmsController.java



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AppUserController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.ChangePasswordDTO;
import cz.phsoft.hokej.models.services.AppUserService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller pro správu uživatelských účtů.
 * <p>
 * Zajišťuje:
 * <ul>
 *     <li>práci s přihlášeným uživatelem (profil, změna hesla),</li>
 *     <li>administrativní správu uživatelů (pouze ADMIN).</li>
 * </ul>
 * <p>
 * Veškerá business logika je delegována do {@link AppUserService}.
 */
@RestController
@RequestMapping("/api/users")
public class AppUserController {

    private final AppUserService appUserService;

    public AppUserController(AppUserService appUserService) {
        this.appUserService = appUserService;
    }

    /**
     * Vrátí detail aktuálně přihlášeného uživatele.
     * <p>
     * Identifikace uživatele probíhá pomocí e-mailu (username)
     * získaného z {@link Authentication}.
     *
     * @param authentication objekt s informacemi o přihlášeném uživateli
     * @return detail přihlášeného uživatele
     */
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public AppUserDTO getCurrentUser(Authentication authentication) {
        return appUserService.getCurrentUser(authentication.getName());
    }

    /**
     * Aktualizuje údaje aktuálně přihlášeného uživatele.
     *
     * @param authentication objekt s informacemi o přihlášeném uživateli
     * @param dto            aktualizovaná data uživatele
     * @return informace o úspěšné aktualizaci
     */
    @PutMapping("/me/update")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> updateUser(
            Authentication authentication,
            @Valid @RequestBody AppUserDTO dto) {

        String email = authentication.getName();
        appUserService.updateUser(email, dto);
        return ResponseEntity.ok("Uživatel byl změněn");
    }

    /**
     * Změní heslo aktuálně přihlášeného uživatele.
     *
     * @param authentication objekt s informacemi o přihlášeném uživateli
     * @param dto            DTO obsahující staré a nové heslo
     * @return informace o úspěšném provedení změny
     */
    @PostMapping("/me/change-password")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> changePassword(
            Authentication authentication,
            @Valid @RequestBody ChangePasswordDTO dto) {

        String email = authentication.getName();
        appUserService.changePassword(
                email,
                dto.getOldPassword(),
                dto.getNewPassword(),
                dto.getNewPasswordConfirm()
        );
        return ResponseEntity.ok("Heslo úspěšně změněno");
    }

    //ADMIN
    /**
     * Vrátí seznam všech uživatelů v systému.
     * <p>
     * Endpoint je dostupný pouze pro administrátora.
     *
     * @return seznam uživatelů
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    public List<AppUserDTO> getAllUsers() {
        return appUserService.getAllUsers();
    }

    // TODO - NOVÝ ENDPOINT
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public AppUserDTO getUserById(@PathVariable Long id ) {
        return appUserService.getUserById(id);
    }

    /**
     * Resetuje heslo uživatele na výchozí hodnotu.
     * <p>
     * Operace je vyhrazena pouze pro administrátora.
     *
     * @param id ID uživatele
     * @return informace o úspěšném resetu hesla
     */
    @PostMapping("/{id}/reset-password")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<String> resetPassword(@PathVariable Long id) {
        appUserService.resetPassword(id);
        return ResponseEntity.ok("Heslo resetováno na 'Player123'");
    }

    /**
     * Aktivuje účet uživatele.
     * <p>
     * Endpoint je dostupný pouze pro administrátora.
     */
    @PatchMapping("/{id}/activate")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<String> activateUserByAdmin(@PathVariable Long id) {
        appUserService.activateUserByAdmin(id);
        return ResponseEntity.ok("Uživatel byl úspěšně aktivován");
    }

    /**
     * Dektivuje účet uživatele.
     * <p>
     * Endpoint je dostupný pouze pro administrátora.
     */
    @PatchMapping("/{id}/deactivate")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<String> deactivateUserByAdmin(@PathVariable Long id) {
        appUserService.deactivateUserByAdmin(id);
        return ResponseEntity.ok("Uživatel byl úspěšně deaktivován");
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AppUserSettingsController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.AppUserSettingsDTO;
import cz.phsoft.hokej.models.services.AppUserSettingsService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

/**
 * REST controller pro nastavení uživatele (AppUser).
 *
 * Kontext: účet / uživatel, nikoliv currentPlayer.
 *
 * API:
 *  GET  /api/user/settings   – načtení nastavení přihlášeného uživatele
 *  PATCH /api/user/settings  – aktualizace nastavení přihlášeného uživatele
 */
@RestController
@RequestMapping("/api/user")
public class AppUserSettingsController {

    private final AppUserSettingsService appUserSettingsService;

    public AppUserSettingsController(AppUserSettingsService appUserSettingsService) {
        this.appUserSettingsService = appUserSettingsService;
    }

    /**
     * Vrátí nastavení aktuálně přihlášeného uživatele.
     *
     * Identifikace uživatele probíhá přes Authentication.getName()
     * (typicky email).
     */
    @GetMapping("/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<AppUserSettingsDTO> getCurrentUserSettings(Authentication auth) {
        String userEmail = auth.getName();

        AppUserSettingsDTO dto = appUserSettingsService.getSettingsForUser(userEmail);

        return ResponseEntity.ok(dto);
    }

    /**
     * Aktualizuje nastavení aktuálně přihlášeného uživatele.
     *
     * Předpoklad: FE posílá kompletní stav nastavení (full update).
     */
    @PatchMapping("/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<AppUserSettingsDTO> updateCurrentUserSettings(
            Authentication auth,
            @RequestBody AppUserSettingsDTO requestDto
    ) {
        String userEmail = auth.getName();

        AppUserSettingsDTO updated = appUserSettingsService.updateSettingsForUser(userEmail, requestDto);

        return ResponseEntity.ok(updated);
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AuthController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.EmailDTO;
import cz.phsoft.hokej.models.dto.ForgottenPasswordResetDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;
import cz.phsoft.hokej.models.services.AppUserService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

/**
 * REST controller pro autentizaci a registraci uživatelů.
 * <p>
 * Zajišťuje:
 * <ul>
 *     <li>registraci nových uživatelů,</li>
 *     <li>aktivaci uživatelského účtu pomocí ověřovacího tokenu,</li>
 *     <li>získání informací o aktuálně přihlášeném uživateli.</li>
 * </ul>
 *
 * Veškerá business logika je delegována do {@link AppUserService}.
 */
@RestController
@RequestMapping("/api/auth")
public class AuthController {

    private final AppUserService appUserService;

    /**
     * Base URL frontendové SPA aplikace (React / Vite).
     * Používá se pro přesměrování při resetu hesla.
     *
     * Např.:
     *   app.frontend-base-url=http://localhost:5173
     */
    @Value("${app.frontend-base-url:http://localhost:5173}")
    private String frontendBaseUrl;

    public AuthController(AppUserService appUserService) {
        this.appUserService = appUserService;
    }

    /**
     * Zaregistruje nového uživatele.
     * <p>
     * Po úspěšné registraci je uživateli odeslán aktivační e-mail
     * s ověřovacím odkazem.
     *
     * @param dto registrační údaje uživatele
     * @return informace o úspěšném přijetí registrace
     */
    @PostMapping("/register")
    public ResponseEntity<?> register(@Valid @RequestBody RegisterUserDTO dto) {
        appUserService.register(dto);
        return ResponseEntity.ok(
                Map.of(
                        "status", "ok",
                        "message", "Registrace úspěšná. Zkontrolujte email pro aktivaci účtu."
                )
        );
    }

    /**
     * Vrátí informace o aktuálně přihlášeném uživateli.
     *
     * @param authentication objekt s informacemi o přihlášeném uživateli
     * @return detail přihlášeného uživatele
     */
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<AppUserDTO> getCurrentUser(Authentication authentication) {
        AppUserDTO dto = appUserService.getCurrentUser(authentication.getName());
        return ResponseEntity.ok(dto);
    }

    /**
     * Aktivuje uživatelský účet na základě ověřovacího tokenu.
     * <p>
     * Token je zaslán uživateli e-mailem po registraci a má omezenou platnost.
     *
     * @param token aktivační token
     * @return výsledek aktivace účtu
     */
    @GetMapping("/verify")
    public ResponseEntity<String> verifyEmail(@RequestParam String token) {
        boolean activated = appUserService.activateUser(token);

        if (!activated) {
            // sjednocená odpověď pro neplatný nebo expirovaný token
            return ResponseEntity
                    .badRequest()
                    .body("Neplatný nebo expirovaný aktivační odkaz.");
        }

        return ResponseEntity.ok("Účet byl úspěšně aktivován.");
    }

    /**
     * Přesměruje uživatele z odkazu v e-mailu na frontendovou stránku
     * pro nastavení nového hesla.
     * <p>
     * Uživatel dostane e-mail s odkazem ve tvaru:
     *   http://localhost:8080/api/auth/reset-password?token=XYZ
     * Backend provede redirect (302) na:
     *   {frontendBaseUrl}/reset-password?token=XYZ
     * např.
     *   http://localhost:5173/reset-password?token=XYZ
     *
     * Samotné ověření tokenu a změnu hesla pak řeší frontend
     * přes REST endpointy:
     *  - GET  /api/auth/forgotten-password/info
     *  - POST /api/auth/forgotten-password/reset
     */
    @GetMapping("/reset-password")
    public ResponseEntity<Void> redirectResetPassword(@RequestParam String token) {
        String targetUrl = frontendBaseUrl + "/reset-password?token=" + token;

        return ResponseEntity
                .status(HttpStatus.FOUND) // 302
                .header("Location", targetUrl)
                .build();
    }

    // TODO MOŽNÁ DO APPUSERSETTINGS CONTROLLER
    @PostMapping("/forgotten-password")
    public ResponseEntity<Void> requestForgottenPassword(@RequestBody @Valid EmailDTO dto) {
        appUserService.requestForgottenPasswordReset(dto.getEmail());
        return ResponseEntity.ok().build();
    }

    @GetMapping("/forgotten-password/info")
    public ResponseEntity<Map<String, String>> getForgottenPasswordInfo(@RequestParam String token) {
        String email = appUserService.getForgottenPasswordResetEmail(token);
        return ResponseEntity.ok(Map.of("email", email));
    }

    @PostMapping("/forgotten-password/reset")
    public ResponseEntity<Void> forgottenPasswordReset(@RequestBody @Valid ForgottenPasswordResetDTO dto) {
        appUserService.forgottenPasswordReset(dto);
        return ResponseEntity.ok().build();
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\CurrentPlayerController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.services.PlayerService;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller pro práci s „aktuálním hráčem“ přihlášeného uživatele.
 * <p>
 * Aktuální hráč představuje kontext, ve kterém uživatel pracuje
 * (např. registrace na zápasy, zobrazení statistik apod.).
 * <p>
 * Controller umožňuje:
 * <ul>
 *     <li>ruční nastavení aktuálního hráče,</li>
 *     <li>automatický výběr aktuálního hráče po přihlášení,</li>
 *     <li>získání aktuálního hráče,</li>
 *     <li>získání seznamu hráčů přihlášeného uživatele.</li>
 * </ul>
 * <p>
 * Veškerá business logika je delegována do {@link PlayerService}
 * a {@link CurrentPlayerService}.
 */
@RestController
@RequestMapping("/api/current-player")
public class CurrentPlayerController {

    private final CurrentPlayerService currentPlayerService;
    private final PlayerService playerService;

    public CurrentPlayerController(CurrentPlayerService currentPlayerService,
                                   PlayerService playerService) {
        this.currentPlayerService = currentPlayerService;
        this.playerService = playerService;
    }

    /**
     * Nastaví aktuálního hráče pro přihlášeného uživatele.
     * <p>
     * Používá se zejména v případech, kdy má uživatel
     * přiřazeno více hráčů a chce mezi nimi ručně přepínat.
     *
     * @param playerId ID hráče, který má být nastaven jako aktuální
     * @param auth     autentizační kontext přihlášeného uživatele
     * @return informace o úspěšném nastavení aktuálního hráče
     */
    @PostMapping("/{playerId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<SuccessResponseDTO> setCurrentPlayer(
            @PathVariable Long playerId,
            Authentication auth) {

        SuccessResponseDTO response =
                playerService.setCurrentPlayerForUser(auth.getName(), playerId);

        return ResponseEntity.ok(response);
    }

    /**
     * Automaticky zvolí aktuálního hráče pro přihlášeného uživatele
     * podle jeho nastavení v AppUserSettings (playerSelectionMode).
     * <p>
     * - FIRST_PLAYER  → vybere prvního hráče podle ID
     * - ALWAYS_CHOOSE → hráče nevybere, FE má nabídnout manuální výběr
     */
    @PostMapping("/auto-select")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<SuccessResponseDTO> autoSelectCurrentPlayer(Authentication auth) {
        SuccessResponseDTO response =
                playerService.autoSelectCurrentPlayerForUser(auth.getName());

        return ResponseEntity.ok(response);
    }

    /**
     * Vrátí aktuálně zvoleného hráče přihlášeného uživatele.
     * <p>
     * Pokud uživatel nemá aktuálního hráče nastaveného,
     * je vrácena hodnota {@code null}.
     *
     * @return aktuální hráč nebo {@code null}, pokud není nastaven
     */
    @GetMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<PlayerDTO> getCurrentPlayer() {

        Long playerId = currentPlayerService.getCurrentPlayerId();
        if (playerId == null) {
            return ResponseEntity.ok(null);
        }

        PlayerDTO player = playerService.getPlayerById(playerId);
        return ResponseEntity.ok(player);
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\DebugController.java
-----

package cz.phsoft.hokej.controllers;

import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * Debug controller pro účely vývoje a ladění bezpečnostního kontextu.
 * <p>
 * Slouží k ověření:
 * <ul>
 *     <li>zda je uživatel autentizován,</li>
 *     <li>jaké údaje jsou dostupné v {@link Authentication},</li>
 *     <li>jaké role a authority má aktuální uživatel.</li>
 * </ul>
 *
 * Tento controller by měl být používán pouze ve vývojovém prostředí
 * a neměl by být dostupný v produkci.
 */
@RestController
public class DebugController {

    /**
     * Vrátí aktuální {@link Authentication} objekt.
     * <p>
     * Endpoint slouží výhradně pro ladění a diagnostiku.
     *
     * @param auth autentizační kontext aktuálního uživatele
     * @return objekt {@link Authentication}
     */
    @GetMapping("/api/debug/me")
    public Object me(Authentication auth) {
        return auth;
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\MatchController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.enums.MatchCancelReason;
import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;
import cz.phsoft.hokej.models.dto.MatchOverviewDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import cz.phsoft.hokej.models.services.MatchService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller pro práci se zápasy.
 *
 * Zajišťuje:
 * <ul>
 *     <li>administraci zápasů (CRUD, zrušení / obnovení) pro role ADMIN/MANAGER,</li>
 *     <li>pohled na zápasy z perspektivy aktuálního hráče,</li>
 *     <li>detail zápasu včetně stavů registrací pro aktuálního hráče.</li>
 * </ul>
 *
 * Business logika je delegována do {@link MatchService}.
 */
@RestController
@RequestMapping("/api/matches")
public class MatchController {

    private final MatchService matchService;
    private final CurrentPlayerService currentPlayerService;

    public MatchController(MatchService matchService,
                           CurrentPlayerService currentPlayerService) {
        this.matchService = matchService;
        this.currentPlayerService = currentPlayerService;
    }

    // =========================================================
    //  ADMIN / MANAGER – GLOBÁLNÍ SPRÁVA ZÁPASŮ
    // =========================================================

    /**
     * Vrátí seznam všech zápasů v systému.
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getAllMatches() {
        return matchService.getAllMatches();
    }

    /**
     * Vrátí seznam všech nadcházejících zápasů.
     */
    @GetMapping("/upcoming")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getUpcomingMatches() {
        return matchService.getUpcomingMatches();
    }

    /**
     * Vrátí seznam všech již odehraných (minulých) zápasů.
     */
    @GetMapping("/past")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getPastMatches() {
        return matchService.getPastMatches();
    }

    /**
     * Vytvoří nový zápas.
     *
     * @param matchDTO data nového zápasu
     * @return vytvořený zápas
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public MatchDTO createMatch(@Valid @RequestBody MatchDTO matchDTO) {
        return matchService.createMatch(matchDTO);
    }

    /**
     * Vrátí základní detail zápasu podle jeho ID
     * (admin / manager pohled – DTO bez hráčského kontextu).
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO getMatch(@PathVariable Long id) {
        return matchService.getMatchById(id);
    }

    /**
     * Aktualizuje existující zápas.
     *
     * @param id  ID zápasu
     * @param dto aktualizovaná data zápasu
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO updateMatch(@PathVariable Long id,
                                @Valid @RequestBody MatchDTO dto) {
        return matchService.updateMatch(id, dto);
    }

    /**
     * Odstraní zápas ze systému.
     *
     * Operace je vyhrazena pouze pro administrátora.
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SuccessResponseDTO> deleteMatch(@PathVariable Long id) {
        SuccessResponseDTO response = matchService.deleteMatch(id);
        return ResponseEntity.ok(response);
    }

    /**
     * Vrátí seznam zápasů, které jsou dostupné pro konkrétního hráče.
     *
     * @param playerId ID hráče
     */
    @GetMapping("/available-for-player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getAvailableMatchesForPlayer(@PathVariable Long playerId) {
        return matchService.getAvailableMatchesForPlayer(playerId);
    }

    /**
     * Zruší zápas a uloží důvod zrušení.
     *
     * @param matchId ID zápasu
     * @param reason  důvod zrušení zápasu
     */
    @PatchMapping("/{matchId}/cancel")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SuccessResponseDTO> cancelMatch(
            @PathVariable Long matchId,
            @RequestParam MatchCancelReason reason
    ) {
        SuccessResponseDTO response = matchService.cancelMatch(matchId, reason);
        return ResponseEntity.ok(response);
    }

    /**
     * Obnoví dříve zrušený zápas.
     *
     * @param matchId ID zápasu
     */
    @PatchMapping("/{matchId}/uncancel")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SuccessResponseDTO> unCancelMatch(@PathVariable Long matchId) {
        SuccessResponseDTO response = matchService.unCancelMatch(matchId);
        return ResponseEntity.ok(response);
    }

    // =========================================================
    //  HRÁČ – ENDPOINTY V KONTEXTU AKTUÁLNÍHO PLAYERA
    // =========================================================

    /**
     * Vrátí detail konkrétního zápasu z pohledu hráče
     * (včetně stavu registrací, práv, atd.).
     *
     * Změnil jsem URL na /{id}/detail kvůli konzistenci s ostatními
     * endpointy; pokud potřebuješ zachovat /matchDetail/{id},
     * můžeš přidat alias.
     */
    @GetMapping("/{id}/detail")
    @PreAuthorize("isAuthenticated()")
    public MatchDetailDTO getMatchDetail(@PathVariable Long id) {
        return matchService.getMatchDetail(id);
    }

    // Volitelný alias pro zpětnou kompatibilitu:
    // @GetMapping("/matchDetail/{id}")
    // public MatchDetailDTO getMatchDetailAlias(@PathVariable Long id) {
    //     return getMatchDetail(id);
    // }

    /**
     * Vrátí nejbližší nadcházející zápas (globálně).
     */
    @GetMapping("/next")
    @PreAuthorize("isAuthenticated()")
    public MatchDTO getNextMatch() {
        return matchService.getNextMatch();
    }

    /**
     * Vrátí seznam nadcházejících zápasů pro aktuálně zvoleného hráče.
     */
    @GetMapping("/me/upcoming")
    @PreAuthorize("isAuthenticated()")
    public List<MatchDTO> getUpcomingMatchesForMe(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getUpcomingMatchesForPlayer(currentPlayerId);
    }

    /**
     * Vrátí přehled nadcházejících zápasů pro aktuálního hráče.
     */
    @GetMapping("/me/upcoming-overview")
    @PreAuthorize("isAuthenticated()")
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForMe(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getUpcomingMatchesOverviewForPlayer(currentPlayerId);
    }

    /**
     * Vrátí seznam všech již odehraných zápasů pro aktuálního hráče.
     */
    @GetMapping("/me/all-passed")
    @PreAuthorize("isAuthenticated()")
    public List<MatchOverviewDTO> getAllMatchesForPlayer(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getAllPassedMatchesForPlayer(currentPlayerId);
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\MatchRegistrationController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.exceptions.CurrentPlayerNotSelectedException;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import cz.phsoft.hokej.models.services.MatchService;
import jakarta.validation.Valid;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller pro správu registrací hráčů na zápasy.
 *
 * Zajišťuje:
 * <ul>
 *     <li>administraci registrací (ADMIN / MANAGER),</li>
 *     <li>správu registrací aktuálního hráče (/me).</li>
 * </ul>
 *
 * Business logika je delegována do {@link MatchRegistrationService}
 * a částečně do {@link MatchService}.
 */
@RestController
@RequestMapping("/api/registrations")
public class MatchRegistrationController {

    private final MatchRegistrationService matchRegistrationService;
    private final CurrentPlayerService currentPlayerService;
    private final MatchService matchService;

    public MatchRegistrationController(MatchRegistrationService matchRegistrationService,
                                       CurrentPlayerService currentPlayerService,
                                       MatchService matchService) {
        this.matchRegistrationService = matchRegistrationService;
        this.currentPlayerService = currentPlayerService;
        this.matchService = matchService;
    }

    // =========================================================
    //  ADMIN / MANAGER – GLOBÁLNÍ SPRÁVA REGISTRACÍ
    // =========================================================

    /**
     * Vrátí všechny registrace všech hráčů na všechny zápasy.
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> getAllRegistrations() {
        return matchRegistrationService.getAllRegistrations();
    }

    /**
     * Vrátí všechny registrace hráčů pro konkrétní zápas.
     *
     * @param matchId ID zápasu
     */
    @GetMapping("/match/{matchId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> getRegistrationsForMatch(@PathVariable Long matchId) {
        return matchRegistrationService.getRegistrationsForMatch(matchId);
    }

    /**
     * Vrátí všechny registrace konkrétního hráče napříč zápasy.
     *
     * @param playerId ID hráče
     */
    @GetMapping("/player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> getRegistrationsForPlayer(@PathVariable Long playerId) {
        return matchRegistrationService.getRegistrationsForPlayer(playerId);
    }

    /**
     * Vrátí seznam hráčů, kteří na pozvánku k danému zápasu
     * zatím vůbec nereagovali (žádná registrace ani omluva).
     *
     * @param matchId ID zápasu
     */
    @GetMapping("/match/{matchId}/no-response")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getNoResponsePlayers(@PathVariable Long matchId) {
        return matchRegistrationService.getNoResponsePlayers(matchId);
    }

    /**
     * Univerzální endpoint pro vytvoření nebo aktualizaci registrace
     * za konkrétního hráče (ADMIN / MANAGER).
     *
     * @param playerId ID hráče, za kterého se změna provádí
     * @param request  požadavek na změnu registrace
     */
    @PostMapping("/upsert/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchRegistrationDTO upsertForPlayer(
            @PathVariable Long playerId,
            @Valid @RequestBody MatchRegistrationRequest request
    ) {
        return matchRegistrationService.upsertRegistration(playerId, request);
    }

    /**
     * Označí hráče v konkrétním zápase jako neomluveně nepřítomného.
     *
     * @param matchId   ID zápasu
     * @param playerId  ID hráče
     * @param adminNote volitelná poznámka administrátora
     */
    @PatchMapping("/match/{matchId}/players/{playerId}/no-excused")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchRegistrationDTO markNoExcused(
            @PathVariable Long matchId,
            @PathVariable Long playerId,
            @RequestParam(required = false) String adminNote
    ) {
        return matchRegistrationService.markNoExcused(matchId, playerId, adminNote);
    }

    // =========================================================
    //  USER – REGISTRACE AKTUÁLNÍHO HRÁČE (/me)
    // =========================================================

    /**
     * Univerzální endpoint pro správu registrace aktuálního hráče na zápas.
     * register/unregister/excuse/substitute
     * Pracuje automaticky s aktuálně zvoleným hráčem.
     */
    @PostMapping("/me/upsert")
    @PreAuthorize("isAuthenticated()")
    public MatchRegistrationDTO upsertForCurrentPlayer(
            @Valid @RequestBody MatchRegistrationRequest request
    ) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        if (currentPlayerId == null) {
            throw new CurrentPlayerNotSelectedException();
        }

        return matchRegistrationService.upsertRegistration(currentPlayerId, request);
    }

    /**
     * Vrátí všechny registrace aktuálně zvoleného hráče.
     */
    @GetMapping("/me/for-current-player")
    @PreAuthorize("isAuthenticated()")
    public List<MatchRegistrationDTO> getRegistrationsForCurrentPlayer() {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchRegistrationService.getRegistrationsForPlayer(currentPlayerId);
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\MatchRegistrationHistoryController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchRegistrationHistoryDTO;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import cz.phsoft.hokej.models.services.MatchRegistrationHistoryService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;


/**
 * REST controller pro práci s historií registrací hráčů k zápasům.
 *
 * <p>
 * Zajišťuje:
 * <ul>
 *     <li>zobrazení historie registrací přihlášeného hráče (/user),</li>
 *     <li>administrativní přístup k historii konkrétního hráče (/admin).</li>
 * </ul>
 * </p>
 *
 * <p>
 * Controller je read-only – neprovádí žádné zápisy do tabulky
 * {@code match_registration_history}, pouze ji čte.
 * </p>
 */
@RestController
@RequestMapping("/api/registrations/history")
public class MatchRegistrationHistoryController {

    private final MatchRegistrationHistoryService historyService;


    public MatchRegistrationHistoryController(MatchRegistrationHistoryService historyService) {
        this.historyService = historyService;

    }

    // ==========================
    // USER – aktuálně přihlášený hráč
    // ==========================

    /**
     * Vrátí historii všech změn registrace
     * aktuálně přihlášeného hráče pro daný zápas.
     *
     * <p>
     * Typické použití:
     * <ul>
     *     <li>detail zápasu – záložka „Historie mojí registrace“.</li>
     * </ul>
     * </p>
     *
     * <p><b>URL:</b> GET /api/user/matches/{matchId}/registrations/history</p>
     *
     * @param matchId ID zápasu
     * @return seznam historických záznamů seřazených od nejnovějšího
     */
    @GetMapping("/me/matches/{matchId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<MatchRegistrationHistoryDTO>> getMyHistoryForMatch(
            @PathVariable Long matchId
    ) {
        List<MatchRegistrationHistoryDTO> history =
                historyService.getHistoryForCurrentPlayerAndMatch(matchId);

        return ResponseEntity.ok(history);
    }

    // ==========================
    // ADMIN – audit konkrétního hráče
    // ==========================

    /**
     * Vrátí historii všech změn registrace konkrétního hráče
     * pro daný zápas.
     *
     * <p>
     * Typické použití:
     * <ul>
     *     <li>administrativní audit registrací hráče,</li>
     *     <li>řešení sporů (kdo a kdy změnil status).</li>
     * </ul>
     * </p>
     *
     * <p><b>URL:</b>
     * GET /api/admin/matches/{matchId}/players/{playerId}/registrations/history
     * </p>
     *
     * @param matchId  ID zápasu
     * @param playerId ID hráče
     * @return seznam historických záznamů seřazených od nejnovějšího
     */
    @GetMapping("/admin/matches/{matchId}/players/{playerId}")
    @PreAuthorize("hasRole('ADMIN')") // případně hasAnyRole('ADMIN','MANAGER')
    public ResponseEntity<List<MatchRegistrationHistoryDTO>> getPlayerHistoryForMatch(
            @PathVariable Long matchId,
            @PathVariable Long playerId
    ) {
        List<MatchRegistrationHistoryDTO> history =
                historyService.getHistoryForPlayerAndMatch(matchId, playerId);

        return ResponseEntity.ok(history);
    }
}






-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.dto.requests.ChangePlayerUserRequest;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import cz.phsoft.hokej.models.services.PlayerService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller pro správu hráčů.
 *
 * Zajišťuje:
 * <ul>
 *     <li>administraci hráčů (CRUD, schválení / zamítnutí, změna uživatele) pro role ADMIN/MANAGER,</li>
 *     <li>správu hráčů z pohledu přihlášeného uživatele (moji hráči /me).</li>
 * </ul>
 *
 * Veškerá business logika je delegována do {@link PlayerService}.
 */
@RestController
@RequestMapping("/api/players")
public class PlayerController {

    private final PlayerService playerService;
    private final CurrentPlayerService currentPlayerService;

    public PlayerController(PlayerService playerService,
                            CurrentPlayerService currentPlayerService) {
        this.playerService = playerService;
        this.currentPlayerService = currentPlayerService;
    }

    // =========================================================
    //  ADMIN / MANAGER – GLOBÁLNÍ SPRÁVA HRÁČŮ
    // =========================================================

    /**
     * Vrátí seznam všech hráčů v systému.
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getAllPlayers() {
        return playerService.getAllPlayers();
    }

    /**
     * Vrátí detail hráče podle jeho ID.
     *
     * @param id ID hráče
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public PlayerDTO getPlayerById(@PathVariable Long id) {
        return playerService.getPlayerById(id);
    }

    /**
     * Vytvoří nového hráče (administrátor/manažer).
     *
     * Používá se při ručním zakládání hráče do systému.
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public PlayerDTO createPlayer(@Valid @RequestBody PlayerDTO playerDTO) {
        return playerService.createPlayer(playerDTO);
    }

    /**
     * Aktualizuje údaje hráče administrátorem.
     *
     * @param id  ID hráče
     * @param dto aktualizovaná data hráče
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public PlayerDTO updatePlayerAdmin(@PathVariable Long id,
                                       @Valid @RequestBody PlayerDTO dto) {
        return playerService.updatePlayer(id, dto);
    }

    /**
     * Odstraní hráče ze systému.
     *
     * Operace je vyhrazena pouze pro administrátora.
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SuccessResponseDTO> deletePlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.deletePlayer(id);
        return ResponseEntity.ok(response);
    }

    /**
     * Schválí hráče (změní jeho stav na APPROVED).
     */
    @PutMapping("/{id}/approve")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SuccessResponseDTO> approvePlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.approvePlayer(id);
        return ResponseEntity.ok(response);
    }

    /**
     * Zamítne hráče (změní jeho stav na REJECTED).
     */
    @PutMapping("/{id}/reject")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<SuccessResponseDTO> rejectPlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.rejectPlayer(id);
        return ResponseEntity.ok(response);
    }

    /**
     * Změní přiřazení hráče k aplikačnímu uživateli.
     *
     * Operace je vyhrazena pouze pro roli ADMIN.
     *
     * @param playerId ID hráče, kterému má být změněn přiřazený uživatel
     * @param request  request obsahující ID nového uživatele
     */
    @PostMapping("/{playerId}/change-user")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<String> changePlayerUser(
            @PathVariable Long playerId,
            @RequestBody ChangePlayerUserRequest request
    ) {
        playerService.changePlayerUser(playerId, request.getNewUserId());
        return ResponseEntity.ok(
                "Hráč s id: " + playerId + " byl úspěšně přiřazen uživateli s ID: " + request.getNewUserId()
        );
    }

    // =========================================================
    //  USER – HRÁČI PŘIHLÁŠENÉHO UŽIVATELE (/me)
    // =========================================================

    /**
     * Vytvoří nového hráče pro přihlášeného uživatele.
     */
    @PostMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public PlayerDTO createMyPlayer(
            @Valid @RequestBody PlayerDTO playerDTO,
            Authentication authentication
    ) {
        String email = authentication.getName();
        return playerService.createPlayerForUser(playerDTO, email);
    }

    /**
     * Vrátí seznam všech hráčů patřících přihlášenému uživateli.
     */
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public List<PlayerDTO> getMyPlayers(Authentication authentication) {
        String email = authentication.getName();
        return playerService.getPlayersByUser(email);
    }

    /**
     * Aktualizuje údaje aktuálně zvoleného hráče.
     *
     * Vyžaduje, aby měl uživatel nastaveného „aktuálního hráče“.
     */
    @PutMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public PlayerDTO updateMyCurrentPlayer(@Valid @RequestBody PlayerDTO dto) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return playerService.updatePlayer(currentPlayerId, dto);
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerInactivityPeriodController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import cz.phsoft.hokej.models.services.PlayerInactivityPeriodService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller pro administraci období neaktivity hráčů.
 * <p>
 * Období neaktivity slouží k evidenci časových úseků, ve kterých
 * hráč dočasně nevystupuje v zápasech (např. zranění, dovolená).
 * <p>
 * Endpoints jsou určeny pro role ADMIN a MANAGER (dle typu operace)
 * a umožňují kompletní správu záznamů o neaktivitě.
 *
 * Veškerá business logika je delegována do {@link PlayerInactivityPeriodService}.
 */
@RestController
@RequestMapping("/api/inactivity/admin")
public class PlayerInactivityPeriodController {

    private final PlayerInactivityPeriodService service;

    public PlayerInactivityPeriodController(PlayerInactivityPeriodService service) {
        this.service = service;
    }

    /**
     * Vrátí seznam všech záznamů o neaktivitě hráčů.
     *
     * @return seznam období neaktivity
     */
    @GetMapping("/all")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getAll() {
        return service.getAll();
    }

    /**
     * Vrátí detail záznamu o neaktivitě podle jeho ID.
     *
     * @param id ID záznamu o neaktivitě
     * @return detail období neaktivity
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<PlayerInactivityPeriodDTO> getById(@PathVariable Long id) {
        PlayerInactivityPeriodDTO dto = service.getById(id);
        return ResponseEntity.ok(dto);
    }

    /**
     * Vrátí všechna období neaktivity pro konkrétního hráče.
     *
     * @param playerId ID hráče
     * @return seznam období neaktivity hráče
     */
    @GetMapping("/player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getByPlayer(@PathVariable Long playerId) {
        return service.getByPlayer(playerId);
    }

    /**
     * Vytvoří nový záznam o neaktivitě hráče.
     * <p>
     * Operace je vyhrazena pouze pro administrátora.
     *
     * @param dto data období neaktivity
     * @return vytvořený záznam o neaktivitě
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<PlayerInactivityPeriodDTO> create(
            @Valid @RequestBody PlayerInactivityPeriodDTO dto) {

        PlayerInactivityPeriodDTO created = service.create(dto);
        return ResponseEntity.ok(created);
    }

    /**
     * Aktualizuje existující záznam o neaktivitě hráče.
     * <p>
     * Operace je vyhrazena pouze pro administrátora.
     *
     * @param id  ID záznamu o neaktivitě
     * @param dto aktualizovaná data období neaktivity
     * @return aktualizovaný záznam o neaktivitě
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<PlayerInactivityPeriodDTO> update(
            @PathVariable Long id,
            @Valid @RequestBody PlayerInactivityPeriodDTO dto) {

        PlayerInactivityPeriodDTO updated = service.update(id, dto);
        return ResponseEntity.ok(updated);
    }

    /**
     * Odstraní záznam o neaktivitě hráče.
     * <p>
     * Operace je vyhrazena pouze pro administrátora.
     *
     * @param id ID záznamu o neaktivitě
     * @return HTTP 204 No Content
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        service.delete(id);
        return ResponseEntity.noContent().build();
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerSettingsController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerSettingsDTO;
import cz.phsoft.hokej.models.services.PlayerSettingsService;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

/**
 * REST controller pro nastavení hráče (PlayerSettingsEntity).
 *
 * API:
 *  GET   /api/players/{playerId}/settings         – nastavení konkrétního hráče
 *  PATCH /api/players/{playerId}/settings         – aktualizace nastavení konkrétního hráče
 *
 *  GET   /api/current-player/settings             – nastavení aktuálního hráče (currentPlayer)
 *  PATCH /api/current-player/settings             – aktualizace nastavení aktuálního hráče
 */
@RestController
@RequestMapping("/api")
public class PlayerSettingsController {

    private final PlayerSettingsService playerSettingsService;
    private final CurrentPlayerService currentPlayerService;

    public PlayerSettingsController(PlayerSettingsService playerSettingsService,
                                    CurrentPlayerService currentPlayerService) {
        this.playerSettingsService = playerSettingsService;
        this.currentPlayerService = currentPlayerService;
    }

    // =========================
    // /api/players/{id}/settings
    // =========================

    @GetMapping("/players/{playerId}/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<PlayerSettingsDTO> getPlayerSettings(
            @PathVariable Long playerId,
            Authentication auth
    ) {
        // POZNÁMKA:
        // Ověření, že hráč patří přihlášenému uživateli nebo že má roli ADMIN/MANAGER
        // může být buď tady, nebo v PlayerService/PlayerSettingsService.
        // Tady nechávám jen místo pro případnou kontrolu.

        PlayerSettingsDTO dto = playerSettingsService.getSettingsForPlayer(playerId);
        return ResponseEntity.ok(dto);
    }

    @PatchMapping("/players/{playerId}/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<PlayerSettingsDTO> updatePlayerSettings(
            @PathVariable Long playerId,
            @RequestBody PlayerSettingsDTO requestDto,
            Authentication auth
    ) {
        // TODO: případná kontrola vlastnictví hráče

        PlayerSettingsDTO updated = playerSettingsService.updateSettingsForPlayer(playerId, requestDto);
        return ResponseEntity.ok(updated);
    }

    // =========================
    // /api/current-player/settings
    // =========================

    @GetMapping("/me/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<PlayerSettingsDTO> getCurrentPlayerSettings() {

        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        PlayerSettingsDTO dto = playerSettingsService.getSettingsForPlayer(currentPlayerId);

        return ResponseEntity.ok(dto);
    }

    @PatchMapping("/me/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<PlayerSettingsDTO> updateCurrentPlayerSettings(
            @RequestBody PlayerSettingsDTO requestDto
    ) {

        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        PlayerSettingsDTO updated = playerSettingsService.updateSettingsForPlayer(currentPlayerId, requestDto);

        return ResponseEntity.ok(updated);
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\SeasonController.java
-----

package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.SeasonDTO;
import cz.phsoft.hokej.models.mappers.SeasonMapper;
import cz.phsoft.hokej.models.services.CurrentSeasonService;
import cz.phsoft.hokej.models.services.SeasonService;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller pro správu sezón.
 *
 * Zajišťuje:
 * <ul>
 *     <li>administraci sezón (CRUD, nastavení aktivní sezóny) pro roli ADMIN,</li>
 *     <li>práci s „aktuální sezónou“ pro přihlášeného uživatele (/me).</li>
 * </ul>
 *
 * Veškerá business logika je delegována do {@link SeasonService}
 * a {@link CurrentSeasonService}.
 */
@RestController
@RequestMapping("/api/seasons")
public class SeasonController {

    private final SeasonService seasonService;
    private final SeasonMapper seasonMapper;
    private final CurrentSeasonService currentSeasonService;

    public SeasonController(SeasonService seasonService,
                            SeasonMapper seasonMapper,
                            CurrentSeasonService currentSeasonService) {
        this.seasonService = seasonService;
        this.seasonMapper = seasonMapper;
        this.currentSeasonService = currentSeasonService;
    }

    // =========================================================
    //  ADMIN – GLOBÁLNÍ SPRÁVA SEZÓN
    // =========================================================

    /**
     * Vytvoří novou sezónu.
     *
     * @param seasonDTO data nové sezóny
     * @return vytvořená sezóna
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SeasonDTO> createSeason(
            @Valid @RequestBody SeasonDTO seasonDTO) {

        SeasonDTO created = seasonService.createSeason(seasonDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    }

    /**
     * Aktualizuje existující sezónu.
     *
     * @param id        ID sezóny
     * @param seasonDTO aktualizovaná data sezóny
     * @return aktualizovaná sezóna
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SeasonDTO> updateSeason(
            @PathVariable Long id,
            @Valid @RequestBody SeasonDTO seasonDTO
    ) {
        SeasonDTO updated = seasonService.updateSeason(id, seasonDTO);
        return ResponseEntity.ok(updated);
    }

    /**
     * Vrátí seznam všech sezón v systému.
     *
     * Tady můžeš nechat jen ADMIN, nebo klidně všem přihlášeným.
     * Aktuálně omezeno na ADMIN kvůli původnímu chování.
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<SeasonDTO>> getAllSeasonsAdmin() {
        List<SeasonDTO> seasons = seasonService.getAllSeasons();
        return ResponseEntity.ok(seasons);
    }

    /**
     * Vrátí aktuálně aktivní globální sezónu.
     */
    @GetMapping("/active")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SeasonDTO> getActiveSeason() {
        SeasonDTO dto = seasonMapper.toDTO(seasonService.getActiveSeason());
        return ResponseEntity.ok(dto);
    }

    /**
     * Nastaví zadanou sezónu jako globálně aktivní.
     *
     * @param id ID sezóny, která má být nastavena jako aktivní
     * @return nově aktivní sezóna
     */
    @PutMapping("/{id}/active")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SeasonDTO> setActiveSeason(@PathVariable Long id) {
        seasonService.setActiveSeason(id);
        SeasonDTO active = seasonMapper.toDTO(seasonService.getActiveSeason());
        return ResponseEntity.ok(active);
    }

    // =========================================================
    //  USER – PRÁCE S „MOJÍ“ SEZÓNOU (/me)
    // =========================================================

    /**
     * Vrátí všechny sezóny pro účely výběru na frontendu.
     *
     * Toto je user-friendly varianta (původní /api/seasons/me GET).
     */
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public List<SeasonDTO> getAllSeasonsForUser() {
        return seasonService.getAllSeasons();
    }

    /**
     * Vrátí sezónu, která je aktuálně vybraná pro přihlášeného uživatele.
     * Pokud není vybraná, vrátí null (nebo default dle CurrentSeasonService).
     */
    @GetMapping("/me/current")
    @PreAuthorize("isAuthenticated()")
    public SeasonDTO getCurrentSeasonForUser() {
        Long id = currentSeasonService.getCurrentSeasonIdOrDefault();
        return (id != null) ? seasonService.getSeasonById(id) : null;
    }

    /**
     * Nastaví aktuální sezónu pro přihlášeného uživatele.
     *
     * @param seasonId ID sezóny, která má být nastavena jako current pro uživatele
     */
    @PostMapping("/me/current/{seasonId}")
    @PreAuthorize("isAuthenticated()")
    public void setCurrentSeasonForUser(@PathVariable Long seasonId) {
        // jednoduchá validace – ověříme, že sezóna existuje
        seasonService.getSeasonById(seasonId);
        currentSeasonService.setCurrentSeasonId(seasonId);
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestController.java
-----

package cz.phsoft.hokej.controllers;

import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/test")
@PreAuthorize("hasRole('ADMIN')")
public class TestController {

    @GetMapping
    public String hello() {
        return "Backend je online!";
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestEmailController.java
-----

package cz.phsoft.hokej.controllers;


import cz.phsoft.hokej.models.services.email.EmailService;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/email/test")
public class TestEmailController {
    private final EmailService emailService;

    public TestEmailController(EmailService emailService) {
        this.emailService = emailService;
    }

    @PostMapping("/send-mail")
    public String sendTestMail() {
        emailService.sendSimpleEmail(
                "petrhlista@seznam.cz",
                "APP - Testovací email",
                "Ahoj, toto je test z backendu."
        );
        return "Email odeslán";
    }

}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestSmsController.java
-----

/*
package cz.phsoft.hokej.controllers;


import cz.phsoft.hokej.models.services.sms.SmsTextBeeService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TestSmsController {

    private final SmsTextBeeService smsTextBeeService;

    public TestSmsController(SmsTextBeeService smsTextBeeService) {
        this.smsTextBeeService = smsTextBeeService;
    }

    /**
     * Testovací endpoint pro odeslání SMS na testovací číslo.
     * Zavolej: GET /api/test-sms
     */
/*
    @GetMapping("/api/test-sms")
    public String sendTestSms() {
        smsTextBeeService.sendSms("+420776609956", "testovací sms app-sg");
        return "SMS byla odeslána na testovací číslo +420776609956";
    }
}

        */

