Balíček (složka): security
Cesta: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security

Seznam souborů:
CurrentPlayerContext.java
CurrentPlayerFilter.java
PlayerSecurity.java
SessionKeys.java



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\CurrentPlayerContext.java
-----

package cz.phsoft.hokej.security;

import cz.phsoft.hokej.data.entities.PlayerEntity;

/**
 * Thread-local kontext pro „aktuálního hráče“.
 *
 * Slouží k uchování instance {@link PlayerEntity},
 * která je zvolená jako „current player“
 * v rámci jednoho konkrétního HTTP requestu.
 *
 * -------------------------------------------------
 * ŽIVOTNÍ CYKLUS
 * -------------------------------------------------
 * <ul>
 *     <li>naplněn v {@code CurrentPlayerFilter} na začátku requestu,</li>
 *     <li>dostupný v celém call stacku
 *         (controller → service → helper),</li>
 *     <li>vyčištěn po dokončení requestu.</li>
 * </ul>
 *
 * -------------------------------------------------
 * PROČ THREADLOCAL
 * -------------------------------------------------
 * Spring obsluhuje HTTP requesty paralelně ve vláknech.
 * {@link ThreadLocal} zajišťuje, že:
 * <ul>
 *     <li>každý request má vlastní instanci {@code PlayerEntity},</li>
 *     <li>nedochází ke sdílení dat mezi uživateli,</li>
 *     <li>není nutné předávat hráče přes všechny metody.</li>
 * </ul>
 *
 * -------------------------------------------------
 * DŮLEŽITÉ
 * -------------------------------------------------
 * {@link ThreadLocal} MUSÍ být vždy vyčištěn pomocí {@link #clear()},
 * jinak hrozí:
 * <ul>
 *     <li>memory leak v aplikačním serveru,</li>
 *     <li>únik dat mezi jednotlivými requesty.</li>
 * </ul>
 */
public final class CurrentPlayerContext {

    /**
     * ThreadLocal uchovávající aktuálního hráče
     * pro právě zpracovávaný request.
     */
    private static final ThreadLocal<PlayerEntity> currentPlayer = new ThreadLocal<>();

    private CurrentPlayerContext() {
        // utility class – nelze instancovat
    }

    /**
     * Nastaví aktuálního hráče do thread-local kontextu.
     *
     * Volá se typicky:
     * <ul>
     *     <li>na začátku requestu ve {@code CurrentPlayerFilter}.</li>
     * </ul>
     *
     * @param player hráč zvolený jako aktuální pro daný request
     */
    public static void set(PlayerEntity player) {
        currentPlayer.set(player);
    }

    /**
     * Vrátí aktuálního hráče pro právě zpracovávaný request.
     *
     * @return {@link PlayerEntity} nebo {@code null},
     *         pokud hráč nebyl zvolen nebo request
     *         nevyžaduje kontext hráče
     */
    public static PlayerEntity get() {
        return currentPlayer.get();
    }

    /**
     * Vyčistí thread-local kontext.
     *
     * MUSÍ se volat:
     * <ul>
     *     <li>vždy po dokončení requestu (typicky ve {@code finally} bloku filtru).</li>
     * </ul>
     *
     * Použití {@link ThreadLocal#remove()}:
     * <ul>
     *     <li>uvolní referenci na {@link PlayerEntity},</li>
     *     <li>zabrání memory leakům při reuse vláken.</li>
     * </ul>
     */
    public static void clear() {
        currentPlayer.remove();
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\CurrentPlayerFilter.java
-----

package cz.phsoft.hokej.security;

import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

/**
 * Security / request filtr pro práci s „aktuálním hráčem“.
 *
 * ÚČEL:
 * ------
 * Zajistit, aby byl v průběhu zpracování jednoho HTTP requestu
 * v thread-local kontextu ({@link CurrentPlayerContext})
 * dostupný hráč, kterého si uživatel vybral jako „current player“.
 *
 * DŮVOD EXISTENCE:
 * ----------------
 * <ul>
 *     <li>uživatelský účet ({@code AppUser}) může mít více hráčů ({@code Player}),</li>
 *     <li>FE si zvolí, který hráč je právě aktivní,</li>
 *     <li>backend potřebuje mít v průběhu requestu pohodlně dostupného hráče
 *         bez nutnosti pracovat přímo s {@code HttpSession} v každé vrstvě.</li>
 * </ul>
 *
 * CHOVÁNÍ:
 * --------
 * <ol>
 *     <li>získá ID aktuálního hráče ze session přes {@link CurrentPlayerService},</li>
 *     <li>ověří existenci hráče v DB přes {@link PlayerRepository},</li>
 *     <li>uloží {@code PlayerEntity} do {@link CurrentPlayerContext} (ThreadLocal),</li>
 *     <li>předá řízení dál ve filter chainu,</li>
 *     <li>po dokončení requestu vždy kontext vyčistí.</li>
 * </ol>
 *
 * THREAD-SAFETY:
 * --------------
 * <ul>
 *     <li>využívá {@link ThreadLocal} – každý request má vlastní kontext,</li>
 *     <li>v {@code finally} bloku se vždy volá {@link CurrentPlayerContext#clear()},</li>
 *     <li>tím se předchází memory leakům a přenosu dat mezi requesty.</li>
 * </ul>
 */
@Component
public class CurrentPlayerFilter extends OncePerRequestFilter {

    private final PlayerRepository playerRepository;
    private final CurrentPlayerService currentPlayerService;

    public CurrentPlayerFilter(PlayerRepository playerRepository,
                               CurrentPlayerService currentPlayerService) {
        this.playerRepository = playerRepository;
        this.currentPlayerService = currentPlayerService;
    }

    /**
     * Hlavní filtrační metoda – volá se jednou pro každý HTTP request.
     *
     * Postup:
     * <ol>
     *     <li>načte {@code currentPlayerId} ze session
     *         pomocí {@link CurrentPlayerService#getCurrentPlayerId()},</li>
     *     <li>pokud ID existuje, ověří přítomnost hráče v databázi,</li>
     *     <li>pokud je hráč nalezen, uloží ho do {@link CurrentPlayerContext},</li>
     *     <li>pokračuje ve filter chainu,</li>
     *     <li>vždy v {@code finally} bloku vyčistí thread-local kontext.</li>
     * </ol>
     */
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {

        // ID aktuálního hráče uložené v HTTP session
        Long playerId = currentPlayerService.getCurrentPlayerId();

        if (playerId != null) {
            // bezpečnostní kontrola – hráč musí existovat v DB
            playerRepository.findById(playerId)
                    .ifPresent(CurrentPlayerContext::set);
        }

        try {
            // pokračování ve zpracování requestu
            filterChain.doFilter(request, response);
        } finally {
            // důležité: vždy vyčistit ThreadLocal kontext
            CurrentPlayerContext.clear();
        }
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\PlayerSecurity.java
-----

package cz.phsoft.hokej.security;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

/**
 * Bezpečnostní helper pro kontrolu vlastnictví hráče.
 *
 * ÚČEL:
 * -----
 * Poskytuje metody pro jemnozrnnou autorizaci nad entitou {@link PlayerEntity},
 * typicky ve SpEL výrazech v anotacích jako {@code @PreAuthorize}.
 *
 * Typické použití:
 * <pre>
 * {@code
 * @PreAuthorize("@playerSecurity.isOwner(authentication, #playerId)")
 * public ResponseEntity<?> getPlayerDetail(Long playerId) { ... }
 * }
 * </pre>
 *
 * Poznámka:
 * ---------
 * V aktuální verzi využívám hlavně endpointy typu {@code /me}
 * a {@link CurrentPlayerContext}, ale tato třída je připravena
 * pro případné rozšíření autorizace na úrovni konkrétních hráčů.
 */
@Component("playerSecurity") // název beany pro použití ve SpEL výrazech
public class PlayerSecurity {

    private static final Logger logger =
            LoggerFactory.getLogger(PlayerSecurity.class);

    private final PlayerRepository playerRepository;

    public PlayerSecurity(PlayerRepository playerRepository) {
        this.playerRepository = playerRepository;
    }

    /**
     * Ověří, zda je aktuálně přihlášený uživatel vlastníkem daného hráče.
     *
     * LOGIKA:
     * -------
     * <ol>
     *     <li>ověří existenci autentizace a její platnost,</li>
     *     <li>ověří, že {@code principal} je typu {@link UserDetails},</li>
     *     <li>načte hráče z DB podle {@code playerId},</li>
     *     <li>porovná email přihlášeného uživatele (username)
     *         s emailem uživatele přiřazeného k hráči.</li>
     * </ol>
     *
     * BEZPEČNOSTNÍ PRAVIDLO:
     * ----------------------
     * Jakákoli chyba nebo nesrovnalost → přístup je zamítnut
     * (metoda vždy vrací {@code false}, nikdy nevyhazuje výjimku).
     *
     * @param authentication aktuální {@link Authentication} objekt
     * @param playerId       ID hráče, ke kterému se má ověřit vlastnictví
     * @return {@code true}, pokud je uživatel vlastníkem hráče; jinak {@code false}
     */
    public boolean isOwner(Authentication authentication, Long playerId) {

        try {
            // 1) základní kontrola autentizace
            if (authentication == null || !authentication.isAuthenticated()) {
                logger.warn(
                        "Neautorizovaný přístup: žádná autentizace pro playerId {}",
                        playerId
                );
                return false;
            }

            // 2) kontrola typu principal
            Object principal = authentication.getPrincipal();
            if (!(principal instanceof UserDetails userDetails)) {
                logger.warn(
                        "Neautorizovaný přístup: principal není UserDetails pro playerId {}",
                        playerId
                );
                return false;
            }

            // 3) kontrola vlastnictví hráče
            boolean isOwner = playerRepository.findById(playerId)
                    .map(player ->
                            player.getUser() != null
                                    && player.getUser().getEmail()
                                    .equals(userDetails.getUsername())
                    )
                    .orElse(false);

            // 4) logování pokusu o neoprávněný přístup
            if (!isOwner) {
                logger.warn(
                        "Neautorizovaný přístup: uživatel {} není vlastníkem hráče {}",
                        userDetails.getUsername(),
                        playerId
                );
            }

            return isOwner;

        } catch (Exception e) {
            // NIKDY nepropouštět výjimku do SpEL výrazu – vždy vracíme boolean
            logger.error(
                    "Chyba při kontrole vlastníka hráče {}: {}",
                    playerId,
                    e.getMessage(),
                    e
            );
            return false;
        }
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\SessionKeys.java
-----

package cz.phsoft.hokej.security;

/**
 * Centrální definice klíčů používaných v HTTP session.
 * <p>
 * Tato třída slouží jako jednotné místo pro uložení názvů
 * session atributů, aby se zabránilo:
 * </p>
 * <ul>
 *     <li>duplicitám řetězcových konstant,</li>
 *     <li>překlepům v názvech klíčů,</li>
 *     <li>nekonzistenci napříč aplikací.</li>
 * </ul>
 *
 * Použití:
 * <ul>
 *     <li>využívá se ve službách pracujících s HTTP session,</li>
 *     <li>typicky v {@code CurrentPlayerService} a souvisejících třídách.</li>
 * </ul>
 *
 * Technická poznámka:
 * <ul>
 *     <li>třída je {@code final} a má privátní konstruktor,</li>
 *     <li>slouží výhradně jako držák konstant (utility class).</li>
 * </ul>
 */
public final class SessionKeys {

    /**
     * Klíč session atributu pro ID aktuálně zvoleného hráče.
     * <p>
     * Hodnota představuje identifikátor hráče, se kterým
     * aktuálně pracuje přihlášený uživatel.
     * </p>
     */
    public static final String CURRENT_PLAYER_ID = "CURRENT_PLAYER_ID";

    /**
     * Privátní konstruktor zabraňující vytvoření instance třídy.
     */
    private SessionKeys() {
    }
}


