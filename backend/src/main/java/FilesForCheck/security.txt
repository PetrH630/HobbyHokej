Balíček (složka): security
Cesta: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\security

Seznam souborů:
CurrentPlayerContext.java
CurrentPlayerFilter.java
package-info.java
PlayerSecurity.java
SessionKeys.java



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\security\CurrentPlayerContext.java
-----

package cz.phsoft.hokej.security;

import cz.phsoft.hokej.data.entities.PlayerEntity;

/**
 * Thread-local kontext pro uchování aktuálně zvoleného hráče.
 *
 * Slouží k uložení instance PlayerEntity, která je považována
 * za aktuálního hráče v rámci jednoho HTTP requestu.
 *
 * Kontext je:
 * - nastaven na začátku requestu ve filtru CurrentPlayerFilter,
 * - dostupný v celém call stacku (controller, service, helper),
 * - vyčištěn po dokončení zpracování requestu.
 *
 * Použití ThreadLocal zajišťuje, že každý HTTP request
 * má vlastní instanci kontextu a nedochází ke sdílení dat
 * mezi paralelně zpracovávanými požadavky.
 *
 * ThreadLocal musí být vždy vyčištěn metodou clear,
 * jinak hrozí únik paměti a nechtěné přenášení dat
 * mezi jednotlivými requesty.
 */
public final class CurrentPlayerContext {

    /**
     * ThreadLocal uchovávající aktuálního hráče
     * pro právě zpracovávaný request.
     */
    private static final ThreadLocal<PlayerEntity> currentPlayer = new ThreadLocal<>();

    private CurrentPlayerContext() {
        // Utility třída, instanci nelze vytvořit
    }

    /**
     * Nastaví aktuálního hráče do thread-local kontextu.
     *
     * Metoda se volá typicky ve filtru CurrentPlayerFilter
     * na začátku zpracování HTTP requestu.
     *
     * @param player hráč zvolený jako aktuální pro daný request
     */
    public static void set(PlayerEntity player) {
        currentPlayer.set(player);
    }

    /**
     * Vrátí aktuálního hráče pro právě zpracovávaný request.
     *
     * @return instance PlayerEntity nebo null,
     * pokud nebyl hráč pro request zvolen
     */
    public static PlayerEntity get() {
        return currentPlayer.get();
    }

    /**
     * Vyčistí thread-local kontext.
     *
     * Metoda musí být vždy volána po dokončení requestu,
     * typicky ve finally bloku filtru.
     *
     * Použití ThreadLocal.remove uvolňuje referenci
     * a zabraňuje memory leakům při opakovaném použití vláken.
     */
    public static void clear() {
        currentPlayer.remove();
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\security\CurrentPlayerFilter.java
-----

package cz.phsoft.hokej.security;

import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

/**
 * HTTP filtr zajišťující dostupnost aktuálního hráče
 * v průběhu zpracování requestu.
 *
 * Filtr:
 * - načítá ID aktuálního hráče z HTTP session,
 * - ověřuje existenci hráče v databázi,
 * - ukládá hráče do CurrentPlayerContext,
 * - po dokončení requestu kontext vždy vyčistí.
 *
 * Filtr umožňuje, aby servisní a controller vrstvy
 * pracovaly s aktuálním hráčem bez nutnosti
 * přímého přístupu k HttpSession.
 */
@Component
public class CurrentPlayerFilter extends OncePerRequestFilter {

    private final PlayerRepository playerRepository;
    private final CurrentPlayerService currentPlayerService;

    public CurrentPlayerFilter(PlayerRepository playerRepository,
                               CurrentPlayerService currentPlayerService) {
        this.playerRepository = playerRepository;
        this.currentPlayerService = currentPlayerService;
    }

    /**
     * Filtrační metoda volaná jednou pro každý HTTP request.
     *
     * Postup zpracování:
     * - načte ID aktuálního hráče ze session,
     * - ověří existenci hráče v databázi,
     * - uloží hráče do thread-local kontextu,
     * - předá řízení dalším filtrům,
     * - v závěru vždy vyčistí kontext.
     */
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {

        Long playerId = currentPlayerService.getCurrentPlayerId();

        if (playerId != null) {
            playerRepository.findById(playerId)
                    .ifPresent(CurrentPlayerContext::set);
        }

        try {
            filterChain.doFilter(request, response);
        } finally {
            CurrentPlayerContext.clear();
        }
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\security\package-info.java
-----

/**
 * Bezpečnostní vrstva aplikace.
 *
 * Obsahuje konfiguraci a komponenty pro:
 * - autentizaci a autorizaci uživatelů,
 * - integraci Spring Security,
 * - práci s uživatelskými rolemi a oprávněními.
 *
 * Tato vrstva:
 * - neobsahuje business logiku domény,
 * - určuje přístupová pravidla k API a zdrojům.
 */
package cz.phsoft.hokej.security;



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\security\PlayerSecurity.java
-----

package cz.phsoft.hokej.security;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

/**
 * Bezpečnostní helper pro kontrolu vlastnictví hráče.
 *
 * Poskytuje metody určené pro použití ve SpEL výrazech
 * v anotacích typu PreAuthorize.
 *
 * Slouží k jemnozrnné autorizaci nad entitou PlayerEntity,
 * zejména v případech, kdy se pracuje s konkrétním ID hráče.
 */
@Component("playerSecurity")
public class PlayerSecurity {

    private static final Logger logger =
            LoggerFactory.getLogger(PlayerSecurity.class);

    private final PlayerRepository playerRepository;

    public PlayerSecurity(PlayerRepository playerRepository) {
        this.playerRepository = playerRepository;
    }

    /**
     * Ověří, zda je aktuálně přihlášený uživatel
     * vlastníkem zadaného hráče.
     *
     * Při jakékoli chybě nebo nesrovnalosti
     * je přístup zamítnut a metoda vrací false.
     *
     * @param authentication aktuální autentizace
     * @param playerId ID hráče
     * @return true, pokud je uživatel vlastníkem hráče
     */
    public boolean isOwner(Authentication authentication, Long playerId) {

        try {
            if (authentication == null || !authentication.isAuthenticated()) {
                return false;
            }

            Object principal = authentication.getPrincipal();
            if (!(principal instanceof UserDetails userDetails)) {
                return false;
            }

            boolean isOwner = playerRepository.findById(playerId)
                    .map(player ->
                            player.getUser() != null
                                    && player.getUser().getEmail()
                                    .equals(userDetails.getUsername())
                    )
                    .orElse(false);

            if (!isOwner) {
                logger.warn(
                        "Neoprávněný přístup: uživatel {} není vlastníkem hráče {}",
                        userDetails.getUsername(),
                        playerId
                );
            }

            return isOwner;

        } catch (Exception e) {
            logger.error(
                    "Chyba při ověřování vlastníka hráče {}",
                    playerId,
                    e
            );
            return false;
        }
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\security\SessionKeys.java
-----

package cz.phsoft.hokej.security;

/**
 * Centrální definice klíčů používaných v HTTP session.
 *
 * Slouží jako jednotné místo pro názvy session atributů,
 * aby se zabránilo duplicitám, překlepům a nekonzistenci
 * napříč aplikací.
 *
 * Třída je určena výhradně jako držák konstant
 * a neobsahuje žádnou logiku.
 */
public final class SessionKeys {

    /**
     * Klíč session atributu pro ID aktuálně zvoleného hráče.
     *
     * Hodnota představuje identifikátor hráče,
     * se kterým přihlášený uživatel právě pracuje.
     */
    public static final String CURRENT_PLAYER_ID = "CURRENT_PLAYER_ID";

    private SessionKeys() {
        // Utility třída, instanci nelze vytvořit
    }
}


