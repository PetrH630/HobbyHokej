Balíček (složka): security
Cesta: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\security

Seznam souborů:
CurrentPlayerContext.java
CurrentPlayerFilter.java
package-info.java
PlayerSecurity.java
SessionKeys.java


-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\security\CurrentPlayerContext.java
-----
package cz.phsoft.hokej.security;

import cz.phsoft.hokej.player.entities.PlayerEntity;

/**
 * Thread-local kontext pro uchovĂˇnĂ­ aktuĂˇlnÄ› zvolenĂ©ho hrĂˇÄŤe.
 *
 * SlouĹľĂ­ k uloĹľenĂ­ instance PlayerEntity, kterĂˇ je povaĹľovĂˇna
 * za aktuĂˇlnĂ­ho hrĂˇÄŤe v rĂˇmci jednoho HTTP requestu.
 *
 * Kontext je:
 * - nastaven na zaÄŤĂˇtku requestu ve filtru CurrentPlayerFilter,
 * - dostupnĂ˝ v celĂ©m call stacku (controller, service, helper),
 * - vyÄŤiĹˇtÄ›n po dokonÄŤenĂ­ zpracovĂˇnĂ­ requestu.
 *
 * PouĹľitĂ­ ThreadLocal zajiĹˇĹĄuje, Ĺľe kaĹľdĂ˝ HTTP request
 * mĂˇ vlastnĂ­ instanci kontextu a nedochĂˇzĂ­ ke sdĂ­lenĂ­ dat
 * mezi paralelnÄ› zpracovĂˇvanĂ˝mi poĹľadavky.
 *
 * ThreadLocal musĂ­ bĂ˝t vĹľdy vyÄŤiĹˇtÄ›n metodou clear,
 * jinak hrozĂ­ Ăşnik pamÄ›ti a nechtÄ›nĂ© pĹ™enĂˇĹˇenĂ­ dat
 * mezi jednotlivĂ˝mi requesty.
 */
public final class CurrentPlayerContext {

    /**
     * ThreadLocal uchovĂˇvajĂ­cĂ­ aktuĂˇlnĂ­ho hrĂˇÄŤe
     * pro prĂˇvÄ› zpracovĂˇvanĂ˝ request.
     */
    private static final ThreadLocal<PlayerEntity> currentPlayer = new ThreadLocal<>();

    private CurrentPlayerContext() {
        // Utility tĹ™Ă­da, instanci nelze vytvoĹ™it
    }

    /**
     * NastavĂ­ aktuĂˇlnĂ­ho hrĂˇÄŤe do thread-local kontextu.
     *
     * Metoda se volĂˇ typicky ve filtru CurrentPlayerFilter
     * na zaÄŤĂˇtku zpracovĂˇnĂ­ HTTP requestu.
     *
     * @param player hrĂˇÄŤ zvolenĂ˝ jako aktuĂˇlnĂ­ pro danĂ˝ request
     */
    public static void set(PlayerEntity player) {
        currentPlayer.set(player);
    }

    /**
     * VrĂˇtĂ­ aktuĂˇlnĂ­ho hrĂˇÄŤe pro prĂˇvÄ› zpracovĂˇvanĂ˝ request.
     *
     * @return instance PlayerEntity nebo null,
     * pokud nebyl hrĂˇÄŤ pro request zvolen
     */
    public static PlayerEntity get() {
        return currentPlayer.get();
    }

    /**
     * VyÄŤistĂ­ thread-local kontext.
     *
     * Metoda musĂ­ bĂ˝t vĹľdy volĂˇna po dokonÄŤenĂ­ requestu,
     * typicky ve finally bloku filtru.
     *
     * PouĹľitĂ­ ThreadLocal.remove uvolĹuje referenci
     * a zabraĹuje memory leakĹŻm pĹ™i opakovanĂ©m pouĹľitĂ­ vlĂˇken.
     */
    public static void clear() {
        currentPlayer.remove();
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\security\CurrentPlayerFilter.java
-----
package cz.phsoft.hokej.security;

import cz.phsoft.hokej.player.repositories.PlayerRepository;
import cz.phsoft.hokej.player.services.CurrentPlayerService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

/**
 * HTTP filtr zajiĹˇĹĄujĂ­cĂ­ dostupnost aktuĂˇlnĂ­ho hrĂˇÄŤe
 * v prĹŻbÄ›hu zpracovĂˇnĂ­ requestu.
 *
 * Filtr:
 * - naÄŤĂ­tĂˇ ID aktuĂˇlnĂ­ho hrĂˇÄŤe z HTTP session,
 * - ovÄ›Ĺ™uje existenci hrĂˇÄŤe v databĂˇzi,
 * - uklĂˇdĂˇ hrĂˇÄŤe do CurrentPlayerContext,
 * - po dokonÄŤenĂ­ requestu kontext vĹľdy vyÄŤistĂ­.
 *
 * Filtr umoĹľĹuje, aby servisnĂ­ a controller vrstvy
 * pracovaly s aktuĂˇlnĂ­m hrĂˇÄŤem bez nutnosti
 * pĹ™Ă­mĂ©ho pĹ™Ă­stupu k HttpSession.
 */
@Component
public class CurrentPlayerFilter extends OncePerRequestFilter {

    private final PlayerRepository playerRepository;
    private final CurrentPlayerService currentPlayerService;

    public CurrentPlayerFilter(PlayerRepository playerRepository,
                               CurrentPlayerService currentPlayerService) {
        this.playerRepository = playerRepository;
        this.currentPlayerService = currentPlayerService;
    }

    /**
     * FiltraÄŤnĂ­ metoda volanĂˇ jednou pro kaĹľdĂ˝ HTTP request.
     *
     * Postup zpracovĂˇnĂ­:
     * - naÄŤte ID aktuĂˇlnĂ­ho hrĂˇÄŤe ze session,
     * - ovÄ›Ĺ™Ă­ existenci hrĂˇÄŤe v databĂˇzi,
     * - uloĹľĂ­ hrĂˇÄŤe do thread-local kontextu,
     * - pĹ™edĂˇ Ĺ™Ă­zenĂ­ dalĹˇĂ­m filtrĹŻm,
     * - v zĂˇvÄ›ru vĹľdy vyÄŤistĂ­ kontext.
     */
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {

        Long playerId = currentPlayerService.getCurrentPlayerId();

        if (playerId != null) {
            playerRepository.findById(playerId)
                    .ifPresent(CurrentPlayerContext::set);
        }

        try {
            filterChain.doFilter(request, response);
        } finally {
            CurrentPlayerContext.clear();
        }
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\security\package-info.java
-----
/**
 * BezpeÄŤnostnĂ­ vrstva aplikace.
 *
 * Obsahuje konfiguraci a komponenty pro:
 * - autentizaci a autorizaci uĹľivatelĹŻ,
 * - integraci Spring Security,
 * - prĂˇci s uĹľivatelskĂ˝mi rolemi a oprĂˇvnÄ›nĂ­mi.
 *
 * Tato vrstva:
 * - neobsahuje business logiku domĂ©ny,
 * - urÄŤuje pĹ™Ă­stupovĂˇ pravidla k API a zdrojĹŻm.
 */
package cz.phsoft.hokej.security;

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\security\PlayerSecurity.java
-----
package cz.phsoft.hokej.security;

import cz.phsoft.hokej.player.entities.PlayerEntity;
import cz.phsoft.hokej.player.repositories.PlayerRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

/**
 * BezpeÄŤnostnĂ­ helper pro kontrolu vlastnictvĂ­ hrĂˇÄŤe.
 *
 * Poskytuje metody urÄŤenĂ© pro pouĹľitĂ­ ve SpEL vĂ˝razech
 * v anotacĂ­ch typu PreAuthorize.
 *
 * SlouĹľĂ­ k jemnozrnnĂ© autorizaci nad entitou PlayerEntity,
 * zejmĂ©na v pĹ™Ă­padech, kdy se pracuje s konkrĂ©tnĂ­m ID hrĂˇÄŤe.
 */
@Component("playerSecurity")
public class PlayerSecurity {

    private static final Logger logger =
            LoggerFactory.getLogger(PlayerSecurity.class);

    private final PlayerRepository playerRepository;

    public PlayerSecurity(PlayerRepository playerRepository) {
        this.playerRepository = playerRepository;
    }

    /**
     * OvÄ›Ĺ™Ă­, zda je aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ˝ uĹľivatel
     * vlastnĂ­kem zadanĂ©ho hrĂˇÄŤe.
     *
     * PĹ™i jakĂ©koli chybÄ› nebo nesrovnalosti
     * je pĹ™Ă­stup zamĂ­tnut a metoda vracĂ­ false.
     *
     * @param authentication aktuĂˇlnĂ­ autentizace
     * @param playerId ID hrĂˇÄŤe
     * @return true, pokud je uĹľivatel vlastnĂ­kem hrĂˇÄŤe
     */
    public boolean isOwner(Authentication authentication, Long playerId) {

        try {
            if (authentication == null || !authentication.isAuthenticated()) {
                return false;
            }

            Object principal = authentication.getPrincipal();
            if (!(principal instanceof UserDetails userDetails)) {
                return false;
            }

            boolean isOwner = playerRepository.findById(playerId)
                    .map(player ->
                            player.getUser() != null
                                    && player.getUser().getEmail()
                                    .equals(userDetails.getUsername())
                    )
                    .orElse(false);

            if (!isOwner) {
                logger.warn(
                        "NeoprĂˇvnÄ›nĂ˝ pĹ™Ă­stup: uĹľivatel {} nenĂ­ vlastnĂ­kem hrĂˇÄŤe {}",
                        userDetails.getUsername(),
                        playerId
                );
            }

            return isOwner;

        } catch (Exception e) {
            logger.error(
                    "Chyba pĹ™i ovÄ›Ĺ™ovĂˇnĂ­ vlastnĂ­ka hrĂˇÄŤe {}",
                    playerId,
                    e
            );
            return false;
        }
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\security\SessionKeys.java
-----
package cz.phsoft.hokej.security;

/**
 * CentrĂˇlnĂ­ definice klĂ­ÄŤĹŻ pouĹľĂ­vanĂ˝ch v HTTP session.
 *
 * SlouĹľĂ­ jako jednotnĂ© mĂ­sto pro nĂˇzvy session atributĹŻ,
 * aby se zabrĂˇnilo duplicitĂˇm, pĹ™eklepĹŻm a nekonzistenci
 * napĹ™Ă­ÄŤ aplikacĂ­.
 *
 * TĹ™Ă­da je urÄŤena vĂ˝hradnÄ› jako drĹľĂˇk konstant
 * a neobsahuje ĹľĂˇdnou logiku.
 */
public final class SessionKeys {

    /**
     * KlĂ­ÄŤ session atributu pro ID aktuĂˇlnÄ› zvolenĂ©ho hrĂˇÄŤe.
     *
     * Hodnota pĹ™edstavuje identifikĂˇtor hrĂˇÄŤe,
     * se kterĂ˝m pĹ™ihlĂˇĹˇenĂ˝ uĹľivatel prĂˇvÄ› pracuje.
     */
    public static final String CURRENT_PLAYER_ID = "CURRENT_PLAYER_ID";

    private SessionKeys() {
        // Utility tĹ™Ă­da, instanci nelze vytvoĹ™it
    }
}
