Balíček (složka): entities
Cesta: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities

Seznam souborů:
AppUserEntity.java
AppUserHistoryEntity.java
AppUserSettingsEntity.java
EmailVerificationTokenEntity.java
ForgottenPasswordResetTokenEntity.java
MatchEntity.java
MatchHistoryEntity.java
MatchRegistrationEntity.java
MatchRegistrationHistoryEntity.java
NotificationEntity.java
package-info.java
PlayerEntity.java
PlayerHistoryEntity.java
PlayerInactivityPeriodEntity.java
PlayerSettingsEntity.java
SeasonEntity.java
SeasonHistoryEntity.java


-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\AppUserEntity.java
-----
package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.Role;
import jakarta.persistence.*;

import java.time.Instant;
import java.time.LocalDateTime;
import java.util.Set;

/**
 * Entita reprezentujĂ­cĂ­ uĹľivatelskĂ˝ ĂşÄŤet aplikace.
 *
 * SlouĹľĂ­ pro autentizaci a autorizaci uĹľivatelĹŻ v systĂ©mu.
 * UchovĂˇvĂˇ zĂˇkladnĂ­ identifikaÄŤnĂ­ Ăşdaje, pĹ™ihlaĹˇovacĂ­ informace,
 * roli uĹľivatele a stav aktivace ĂşÄŤtu.
 *
 * Jeden uĹľivatel mĹŻĹľe mĂ­t pĹ™iĹ™azeno vĂ­ce hrĂˇÄŤĹŻ. DetailnĂ­ uĹľivatelskĂ©
 * preference a nastavenĂ­ jsou oddÄ›leny do entity AppUserSettingsEntity.
 */
@Entity
@Table(name = "app_users")
public class AppUserEntity {

    /**
     * PrimĂˇrnĂ­ klĂ­ÄŤ uĹľivatele.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * KĹ™estnĂ­ jmĂ©no uĹľivatele.
     */
    @Column(nullable = false)
    private String name;

    /**
     * PĹ™Ă­jmenĂ­ uĹľivatele.
     * PĹ™i uloĹľenĂ­ je pĹ™evĂˇdÄ›no na velkĂˇ pĂ­smena.
     */
    @Column(nullable = false)
    private String surname;

    /**
     * UnikĂˇtnĂ­ e-mail uĹľivatele slouĹľĂ­cĂ­ pro pĹ™ihlĂˇĹˇenĂ­ do systĂ©mu.
     */
    @Column(nullable = false, unique = true)
    private String email;

    /**
     * Hash hesla uĹľivatele.
     * Heslo se nikdy neuklĂˇdĂˇ v otevĹ™enĂ© podobÄ›.
     */
    @Column(nullable = false)
    private String password;

    /**
     * Role uĹľivatele v systĂ©mu.
     * UrÄŤuje oprĂˇvnÄ›nĂ­ uĹľivatele pĹ™i pĹ™Ă­stupu k jednotlivĂ˝m endpointĹŻm.
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role;

    /**
     * PĹ™Ă­znak aktivace ĂşÄŤtu.
     * Nastavuje se napĹ™Ă­klad po ĂşspÄ›ĹˇnĂ© e-mailovĂ© aktivaci ĂşÄŤtu.
     */
    @Column(nullable = false)
    private boolean enabled = false;

    /**
     * HrĂˇÄŤi pĹ™iĹ™azenĂ­ k tomuto uĹľivateli.
     *
     * Vztah je typu one-to-many, kdy jeden uĹľivatel mĹŻĹľe mĂ­t vĂ­ce hrĂˇÄŤĹŻ.
     * Ĺ˝ivotnĂ­ cyklus hrĂˇÄŤĹŻ je navĂˇzĂˇn na uĹľivatele.
     */
    @OneToMany(
            mappedBy = "user",
            cascade = CascadeType.ALL,
            orphanRemoval = true
    )
    private Set<PlayerEntity> players;

    /**
     * NastavenĂ­ uĹľivatele.
     *
     * Obsahuje napĹ™Ă­klad zpĹŻsob vĂ˝bÄ›ru aktuĂˇlnĂ­ho hrĂˇÄŤe,
     * nastavenĂ­ notifikacĂ­ a dalĹˇĂ­ preference.
     * Jeden uĹľivatel mĂˇ prĂˇvÄ› jedno nastavenĂ­.
     */
    @OneToOne(mappedBy = "user",
            cascade = CascadeType.ALL,
            fetch = FetchType.LAZY,
            orphanRemoval = true)
    private AppUserSettingsEntity settings;

    /**
     * ÄŚasovĂ© razĂ­tko uĹľivatele.
     *
     * UchovĂˇvĂˇ datum a ÄŤas poslednĂ­ zmÄ›ny entity.
     * Hodnota se aktualizuje pĹ™i vytvoĹ™enĂ­ i pĹ™i kaĹľdĂ© ĂşpravÄ› zĂˇznamu.
     */
    @Column(nullable = false, updatable = true)
    private LocalDateTime timestamp = LocalDateTime.now();

    /**
     * Metoda volanĂˇ pĹ™ed prvnĂ­m uloĹľenĂ­m entity.
     *
     * Nastavuje aktuĂˇlnĂ­ ÄŤasovĂ© razĂ­tko a pĹ™evĂˇdĂ­ pĹ™Ă­jmenĂ­
     * na velkĂˇ pĂ­smena.
     */
    @PrePersist
    public void prePersist() {
        this.timestamp = LocalDateTime.now();
        if (surname != null) {
            this.surname = this.surname.toUpperCase();
        }
    }

    /**
     * Metoda volanĂˇ pĹ™ed aktualizacĂ­ entity.
     *
     * Aktualizuje ÄŤasovĂ© razĂ­tko a pĹ™evĂˇdĂ­ pĹ™Ă­jmenĂ­
     * na velkĂˇ pĂ­smena.
     */
    @PreUpdate
    public void preUpdate() {
        this.timestamp = LocalDateTime.now();
        if (surname != null) {
            this.surname = this.surname.toUpperCase();
        }
    }

    /**
     * UchovĂˇvĂˇ ÄŤas pĹ™edposlednĂ­ho pĹ™ihlĂˇĹˇenĂ­ uĹľivatele.
     * PouĹľĂ­vĂˇ se pro vĂ˝poÄŤet notifikacĂ­ od poslednĂ­ho pĹ™ihlĂˇĹˇenĂ­.
     */
    @Column(name = "last_login_at")
    private Instant lastLoginAt;

    /**
     * UchovĂˇvĂˇ ÄŤas poslednĂ­ho pĹ™ihlĂˇĹˇenĂ­ uĹľivatele.
     * Aktualizuje se pĹ™i kaĹľdĂ©m ĂşspÄ›ĹˇnĂ©m pĹ™ihlĂˇĹˇenĂ­.
     */
    @Column(name = "current_login_at")
    private Instant currentLoginAt;


    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }

    public void setName(String name) { this.name = name; }

    public String getSurname() { return surname; }

    public void setSurname(String surname) { this.surname = surname.toUpperCase(); }

    public String getEmail() { return email; }

    public void setEmail(String email) { this.email = email; }

    public String getPassword() { return password; }

    public void setPassword(String password) { this.password = password; }

    public Role getRole() { return role; }

    public void setRole(Role role) { this.role = role; }

    public boolean isEnabled() { return enabled; }

    public void setEnabled(boolean enabled) { this.enabled = enabled; }

    public Set<PlayerEntity> getPlayers() { return players; }

    public void setPlayers(Set<PlayerEntity> players) { this.players = players; }

    public AppUserSettingsEntity getSettings() { return settings; }

    /**
     * Nastavuje uĹľivatelskĂ© nastavenĂ­ a zĂˇroveĹ zajiĹˇĹĄuje obousmÄ›rnou vazbu.
     *
     * @param settings instance nastavenĂ­ uĹľivatele
     */
    public void setSettings(AppUserSettingsEntity settings) {
        this.settings = settings;
        if (settings != null) {
            settings.setUser(this);
        }
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }

    public Instant getLastLoginAt() {
        return lastLoginAt;
    }

    public void setLastLoginAt(Instant lastLoginAt) {
        this.lastLoginAt = lastLoginAt;
    }

    public Instant getCurrentLoginAt() {
        return currentLoginAt;
    }

    public void setCurrentLoginAt(Instant currentLoginAt) {
        this.currentLoginAt = currentLoginAt;
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\AppUserHistoryEntity.java
-----
package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.Role;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentujĂ­cĂ­ historickĂ˝ zĂˇznam o uĹľivateli.
 *
 * SlouĹľĂ­ pro auditnĂ­ ĂşÄŤely a uchovĂˇvĂˇnĂ­ zmÄ›n uĹľivatelskĂ©ho ĂşÄŤtu v ÄŤase.
 * KaĹľdĂ˝ zĂˇznam pĹ™edstavuje stav uĹľivatele v okamĹľiku provedenĂ­ operace
 * nad hlavnĂ­ entitou AppUserEntity.
 *
 * ZĂˇznamy jsou typicky vytvĂˇĹ™eny databĂˇzovĂ˝m triggerem pĹ™i operacĂ­ch
 * INSERT, UPDATE nebo DELETE.
 */
@Entity
@Table(name = "app_users_history")
public class AppUserHistoryEntity {

    /**
     * PrimĂˇrnĂ­ klĂ­ÄŤ historickĂ©ho zĂˇznamu.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Typ provedenĂ© operace.
     *
     * Typicky se jednĂˇ o hodnoty INSERT, UPDATE nebo DELETE.
     */
    @Column(name = "action", nullable = false)
    private String action;

    /**
     * Datum a ÄŤas provedenĂ­ zmÄ›ny.
     *
     * UdĂˇvĂˇ okamĹľik vytvoĹ™enĂ­ historickĂ©ho zĂˇznamu.
     */
    @Column(name = "changed_at", nullable = false)
    private LocalDateTime changedAt;

    /**
     * ID uĹľivatele z hlavnĂ­ tabulky app_users.
     *
     * SlouĹľĂ­ pro propojenĂ­ historickĂ©ho zĂˇznamu s pĹŻvodnĂ­ entitou uĹľivatele.
     */
    @Column(name = "user_id", nullable = false)
    private Long userId;

    /**
     * PĹŻvodnĂ­ ÄŤasovĂ© razĂ­tko uĹľivatele.
     *
     * JednĂˇ se o hodnotu timestamp z AppUserEntity v okamĹľiku zmÄ›ny.
     * UmoĹľĹuje dohledat pĹ™esnĂ˝ stav uĹľivatele pĹ™i konkrĂ©tnĂ­ operaci.
     */
    @Column(name = "original_timestamp", nullable = false)
    private LocalDateTime originalTimestamp;

    /**
     * JmĂ©no uĹľivatele v okamĹľiku zmÄ›ny.
     */
    @Column(name = "name", nullable = false)
    private String name;

    /**
     * PĹ™Ă­jmenĂ­ uĹľivatele v okamĹľiku zmÄ›ny.
     */
    @Column(name = "surname", nullable = false)
    private String surname;

    /**
     * E-mail uĹľivatele v okamĹľiku zmÄ›ny.
     */
    @Column(name = "email", nullable = false)
    private String email;

    /**
     * Role uĹľivatele v okamĹľiku zmÄ›ny.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "role", nullable = false)
    private Role role;

    /**
     * Stav aktivace ĂşÄŤtu v okamĹľiku zmÄ›ny.
     */
    @Column(name = "enabled", nullable = false)
    private boolean enabled;

    /**
     * BezparametrickĂ˝ konstruktor poĹľadovanĂ˝ JPA.
     */
    public AppUserHistoryEntity() {
    }

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getAction() { return action; }
    public void setAction(String action) { this.action = action; }

    public LocalDateTime getChangedAt() { return changedAt; }
    public void setChangedAt(LocalDateTime changedAt) { this.changedAt = changedAt; }

    public Long getUserId() { return userId; }
    public void setUserId(Long userId) { this.userId = userId; }

    public LocalDateTime getOriginalTimestamp() { return originalTimestamp; }
    public void setOriginalTimestamp(LocalDateTime originalTimestamp) { this.originalTimestamp = originalTimestamp; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getSurname() { return surname; }
    public void setSurname(String surname) { this.surname = surname; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public Role getRole() { return role; }
    public void setRole(Role role) { this.role = role; }

    public boolean isEnabled() { return enabled; }
    public void setEnabled(boolean enabled) { this.enabled = enabled; }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\AppUserSettingsEntity.java
-----
package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.PlayerSelectionMode;
import cz.phsoft.hokej.data.enums.GlobalNotificationLevel;
import jakarta.persistence.*;

import java.time.LocalTime;

/**
 * Entita uchovĂˇvajĂ­cĂ­ nastavenĂ­ uĹľivatelskĂ©ho ĂşÄŤtu.
 *
 * OddÄ›luje identitu uĹľivatele (AppUserEntity) od jeho preferencĂ­
 * a chovĂˇnĂ­ v systĂ©mu (AppUserSettingsEntity). SlouĹľĂ­ zejmĂ©na
 * pro nastavenĂ­ vĂ˝bÄ›ru hrĂˇÄŤe, globĂˇlnĂ­ ĂşrovnÄ› notifikacĂ­ a
 * preferencĂ­ souvisejĂ­cĂ­ch s uĹľivatelskĂ˝m rozhranĂ­m.
 */
@Entity
@Table(name = "app_user_settings")
public class AppUserSettingsEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * UĹľivatel, ke kterĂ©mu tato nastavenĂ­ patĹ™Ă­.
     * Pro jednoho uĹľivatele existuje prĂˇvÄ› jeden zĂˇznam nastavenĂ­.
     */
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false, unique = true)
    private AppUserEntity user;

    /**
     * ZpĹŻsob automatickĂ©ho vĂ˝bÄ›ru hrĂˇÄŤe po pĹ™ihlĂˇĹˇenĂ­
     * nebo pĹ™i auto-select logice.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "player_selection_mode", nullable = false, length = 50)
    private PlayerSelectionMode playerSelectionMode = PlayerSelectionMode.FIRST_PLAYER;

    /**
     * GlobĂˇlnĂ­ ĂşroveĹ notifikacĂ­ pro uĹľivatele.
     * UrÄŤuje, kolik notifikacĂ­ bude uĹľivatel dostĂˇvat
     * bez ohledu na nastavenĂ­ konkrĂ©tnĂ­ch hrĂˇÄŤĹŻ.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "global_notification_level", nullable = false, length = 50)
    private GlobalNotificationLevel globalNotificationLevel = GlobalNotificationLevel.ALL;

    /**
     * ĂšroveĹ notifikacĂ­, kterĂ© mĂˇ uĹľivatel dostĂˇvat v roli manaĹľera.
     *
     * Hodnota se pouĹľĂ­vĂˇ pĹ™i rozhodovĂˇnĂ­, zda majĂ­ bĂ˝t zasĂ­lĂˇny
     * kopie notifikacĂ­ na e-mail uĹľivatele, pokud mĂˇ zĂˇroveĹ
     * roli manaĹľera. NastavenĂ­ ovlivĹuje pouze manaĹľerskĂ© kopie,
     * nikoliv notifikace urÄŤenĂ© pĹ™Ă­mo tomuto uĹľivateli nebo hrĂˇÄŤĹŻm.
     *
     * Pokud je hodnota null, pouĹľĂ­vĂˇ se hodnota globalNotificationLevel
     * jako vĂ˝chozĂ­ chovĂˇnĂ­.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "manager_notification_level", length = 50)
    private GlobalNotificationLevel managerNotificationLevel;

    /**
     * UrÄŤuje, zda mĂˇ uĹľivatel dostĂˇvat kopie vĹˇech notifikacĂ­,
     * kterĂ© chodĂ­ jeho hrĂˇÄŤĹŻm.
     *
     * PĹ™Ă­klad:
     * true: rodiÄŤ chce mĂ­t pĹ™ehled o vĹˇem, co se dÄ›je u dÄ›tĂ­.
     * false: spolĂ©hĂˇ se pouze na notifikace hrĂˇÄŤĹŻ.
     */
    @Column(name = "copy_all_player_notifications_to_user_email", nullable = false)
    private boolean copyAllPlayerNotificationsToUserEmail = true;

    /**
     * UrÄŤuje, zda mĂˇ uĹľivatel dostĂˇvat notifikace i za hrĂˇÄŤe,
     * kteĹ™Ă­ majĂ­ vlastnĂ­ email (contactEmail v PlayerSettings).
     *
     * PĹ™Ă­klad:
     * false: pokud mĂˇ hrĂˇÄŤ vlastnĂ­ email, chodĂ­ notifikace pouze jemu.
     * true: uĹľivatel dostĂˇvĂˇ kopie notifikacĂ­ i v tomto pĹ™Ă­padÄ›.
     */
    @Column(name = "receive_notifications_for_players_with_own_email", nullable = false)
    private boolean receiveNotificationsForPlayersWithOwnEmail = false;

    /**
     * UrÄŤuje, zda mĂˇ bĂ˝t pouĹľĂ­vĂˇn dennĂ­ souhrn (digest) mĂ­sto
     * jednotlivĂ˝ch notifikacĂ­ bÄ›hem dne.
     */
    @Column(name = "email_digest_enabled", nullable = false)
    private boolean emailDigestEnabled = false;

    /**
     * ÄŚas, kdy mĂˇ chodit souhrnnĂ˝ email, pokud je digest zapnutĂ˝.
     */
    @Column(name = "email_digest_time")
    private LocalTime emailDigestTime;

    /**
     * PreferovanĂ˝ jazyk uĹľivatelskĂ©ho rozhranĂ­.
     * NapĹ™Ă­klad "cs" nebo "en".
     */
    @Column(name = "ui_language", length = 10)
    private String uiLanguage = "cs";

    /**
     * ÄŚasovĂˇ zĂłna uĹľivatele.
     * NapĹ™Ă­klad "Europe/Prague".
     */
    @Column(name = "timezone", length = 50)
    private String timezone = "Europe/Prague";

    /**
     * VĂ˝chozĂ­ obrazovka po pĹ™ihlĂˇĹˇenĂ­.
     * Z praktickĂ˝ch dĹŻvodĹŻ je uloĹľena jako Ĺ™etÄ›zec.
     */
    @Column(name = "default_landing_page", length = 50)
    private String defaultLandingPage = "DASHBOARD";

    public Long getId() {
        return id;
    }

    public AppUserEntity getUser() {
        return user;
    }

    public void setUser(AppUserEntity user) {
        this.user = user;
    }

    public PlayerSelectionMode getPlayerSelectionMode() {
        return playerSelectionMode;
    }

    public void setPlayerSelectionMode(PlayerSelectionMode playerSelectionMode) {
        this.playerSelectionMode = playerSelectionMode;
    }

    public GlobalNotificationLevel getGlobalNotificationLevel() {
        return globalNotificationLevel;
    }

    public void setGlobalNotificationLevel(GlobalNotificationLevel globalNotificationLevel) {
        this.globalNotificationLevel = globalNotificationLevel;
    }

    public GlobalNotificationLevel getManagerNotificationLevel() {
        return managerNotificationLevel;
    }

    public void setManagerNotificationLevel(GlobalNotificationLevel managerNotificationLevel) {
        this.managerNotificationLevel = managerNotificationLevel;
    }

    public boolean isCopyAllPlayerNotificationsToUserEmail() {
        return copyAllPlayerNotificationsToUserEmail;
    }

    public void setCopyAllPlayerNotificationsToUserEmail(boolean copyAllPlayerNotificationsToUserEmail) {
        this.copyAllPlayerNotificationsToUserEmail = copyAllPlayerNotificationsToUserEmail;
    }

    public boolean isReceiveNotificationsForPlayersWithOwnEmail() {
        return receiveNotificationsForPlayersWithOwnEmail;
    }

    public void setReceiveNotificationsForPlayersWithOwnEmail(boolean receiveNotificationsForPlayersWithOwnEmail) {
        this.receiveNotificationsForPlayersWithOwnEmail = receiveNotificationsForPlayersWithOwnEmail;
    }

    public boolean isEmailDigestEnabled() {
        return emailDigestEnabled;
    }

    public void setEmailDigestEnabled(boolean emailDigestEnabled) {
        this.emailDigestEnabled = emailDigestEnabled;
    }

    public LocalTime getEmailDigestTime() {
        return emailDigestTime;
    }

    public void setEmailDigestTime(LocalTime emailDigestTime) {
        this.emailDigestTime = emailDigestTime;
    }

    public String getUiLanguage() {
        return uiLanguage;
    }

    public void setUiLanguage(String uiLanguage) {
        this.uiLanguage = uiLanguage;
    }

    public String getTimezone() {
        return timezone;
    }

    public void setTimezone(String timezone) {
        this.timezone = timezone;
    }

    public String getDefaultLandingPage() {
        return defaultLandingPage;
    }

    public void setDefaultLandingPage(String defaultLandingPage) {
        this.defaultLandingPage = defaultLandingPage;
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\EmailVerificationTokenEntity.java
-----
package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentujĂ­cĂ­ ovÄ›Ĺ™ovacĂ­ token pro emailovou aktivaci uĹľivatele.
 *
 * SlouĹľĂ­ k ovÄ›Ĺ™enĂ­ emailovĂ© adresy a aktivaci uĹľivatelskĂ©ho ĂşÄŤtu.
 * Token je ÄŤasovÄ› omezenĂ˝ a navĂˇzanĂ˝ na konkrĂ©tnĂ­ho uĹľivatele.
 */
@Entity
@Table(name = "email_verification_tokens")
public class EmailVerificationTokenEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * UnikĂˇtnĂ­ ovÄ›Ĺ™ovacĂ­ token.
     */
    @Column(nullable = false, unique = true, length = 64)
    private String token;

    /**
     * Datum a ÄŤas expirace tokenu.
     */
    @Column(nullable = false)
    private LocalDateTime expiresAt;

    /**
     * UĹľivatel, ke kterĂ©mu je token pĹ™iĹ™azen.
     */
    @OneToOne
    @JoinColumn(name = "user_id", nullable = false)
    private AppUserEntity user;

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public String getToken() { return token; }

    public void setToken(String token) { this.token = token; }

    public LocalDateTime getExpiresAt() { return expiresAt; }

    public void setExpiresAt(LocalDateTime expiresAt) { this.expiresAt = expiresAt; }

    public AppUserEntity getUser() { return user; }

    public void setUser(AppUserEntity user) { this.user = user; }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\ForgottenPasswordResetTokenEntity.java
-----
package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;
import java.time.LocalDateTime;

/**
 * Entita reprezentujĂ­cĂ­ token pro reset zapomenutĂ©ho hesla.
 *
 * SlouĹľĂ­ k bezpeÄŤnĂ©mu nastavenĂ­ novĂ©ho hesla uĹľivatele.
 * Token je ÄŤasovÄ› omezenĂ˝ a navĂˇzanĂ˝ na konkrĂ©tnĂ­ho uĹľivatele.
 * VolitelnĂ© pole usedAt umoĹľĹuje evidovat okamĹľik pouĹľitĂ­ tokenu.
 */
@Entity
@Table(name = "forgotten_password_reset_token_entity")
public class ForgottenPasswordResetTokenEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * UnikĂˇtnĂ­ resetovacĂ­ token.
     */
    @Column(nullable = false, unique = true, length = 128)
    private String token;

    /**
     * UĹľivatel, ke kterĂ©mu token patĹ™Ă­.
     */
    @ManyToOne(optional = false, fetch = FetchType.LAZY)
    private AppUserEntity user;

    /**
     * Datum a ÄŤas expirace tokenu.
     */
    @Column(nullable = false)
    private LocalDateTime expiresAt;

    /**
     * Datum a ÄŤas, kdy byl token pouĹľit.
     * Hodnota je volitelnĂˇ a slouĹľĂ­ pro auditnĂ­ ĂşÄŤely.
     */
    private LocalDateTime usedAt;

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public String getToken() { return token; }

    public void setToken(String token) { this.token = token; }

    public AppUserEntity getUser() { return user; }

    public void setUser(AppUserEntity user) { this.user = user; }

    public LocalDateTime getExpiresAt() { return expiresAt; }

    public void setExpiresAt(LocalDateTime expiresAt) { this.expiresAt = expiresAt; }

    public LocalDateTime getUsedAt() { return usedAt; }

    public void setUsedAt(LocalDateTime usedAt) { this.usedAt = usedAt; }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchEntity.java
-----
package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.MatchCancelReason;
import cz.phsoft.hokej.data.enums.MatchStatus;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentujĂ­cĂ­ hokejovĂ˝ zĂˇpas.
 *
 * UchovĂˇvĂˇ zĂˇkladnĂ­ informace o zĂˇpasu, jeho kapacitÄ›,
 * cenÄ›, aktuĂˇlnĂ­m stavu a vazbÄ› na sezĂłnu.
 * Informace o ĂşÄŤasti hrĂˇÄŤĹŻ jsou uloĹľeny v samostatnĂ© entitÄ›
 * MatchRegistrationEntity.
 *
 * Entita dĂˇle obsahuje auditnĂ­ Ăşdaje o vytvoĹ™enĂ­ a poslednĂ­
 * ĂşpravÄ› zĂˇpasu.
 */
@Entity
@Table(name = "matches")
public class MatchEntity {

    /**
     * PrimĂˇrnĂ­ klĂ­ÄŤ zĂˇpasu.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Datum a ÄŤas konĂˇnĂ­ zĂˇpasu.
     */
    @Column(nullable = false)
    private LocalDateTime dateTime;

    /**
     * MĂ­sto konĂˇnĂ­ zĂˇpasu.
     */
    @Column(nullable = false)
    private String location;

    /**
     * VolitelnĂ˝ popis zĂˇpasu.
     *
     * SlouĹľĂ­ napĹ™Ă­klad pro doplĹujĂ­cĂ­ informace o organizaci zĂˇpasu.
     */
    private String description;

    /**
     * MaximĂˇlnĂ­ poÄŤet hrĂˇÄŤĹŻ povolenĂ˝ch pro zĂˇpas.
     *
     * Hodnota se pouĹľĂ­vĂˇ pro kontrolu kapacity pĹ™i registraci hrĂˇÄŤĹŻ.
     */
    @Column(nullable = false)
    private Integer maxPlayers;

    /**
     * CelkovĂˇ cena zĂˇpasu.
     *
     * Hodnota mĹŻĹľe slouĹľit pro vĂ˝poÄŤet podĂ­lu jednotlivĂ˝ch hrĂˇÄŤĹŻ.
     */
    @Column(nullable = false)
    private Integer price;

    /**
     * AktuĂˇlnĂ­ stav zĂˇpasu.
     *
     * Stav urÄŤuje, zda je zĂˇpas plĂˇnovanĂ˝, zruĹˇenĂ˝ nebo napĹ™Ă­klad odehranĂ˝.
     */
    @Enumerated(EnumType.STRING)
    private MatchStatus matchStatus;

    /**
     * DĹŻvod zruĹˇenĂ­ zĂˇpasu.
     *
     * VyplĹuje se pouze v pĹ™Ă­padÄ›, Ĺľe je zĂˇpas zruĹˇen.
     */
    @Enumerated(EnumType.STRING)
    private MatchCancelReason cancelReason;

    /**
     * SezĂłna, do kterĂ© zĂˇpas patĹ™Ă­.
     *
     * KaĹľdĂ˝ zĂˇpas musĂ­ bĂ˝t pĹ™iĹ™azen k existujĂ­cĂ­ sezĂłnÄ›.
     */
    @ManyToOne(optional = false)
    @JoinColumn(name = "season_id", nullable = false)
    private SeasonEntity season;

    /**
     * ÄŚasovĂ© razĂ­tko zĂˇpasu.
     *
     * UchovĂˇvĂˇ datum a ÄŤas vytvoĹ™enĂ­ nebo poslednĂ­ zmÄ›ny zĂˇpasu.
     * Hodnota se aktualizuje pĹ™i kaĹľdĂ© zmÄ›nÄ› zĂˇznamu.
     */
    @Column(nullable = false, updatable = true)
    private LocalDateTime timestamp = LocalDateTime.now();

    /**
     * ID uĹľivatele, kterĂ˝ zĂˇpas vytvoĹ™il.
     *
     * SlouĹľĂ­ pro auditnĂ­ ĂşÄŤely.
     */
    @Column(name = "created_by_user_id")
    private Long createdByUserId;

    /**
     * ID uĹľivatele, kterĂ˝ zĂˇpas naposledy zmÄ›nil.
     *
     * SlouĹľĂ­ pro auditnĂ­ ĂşÄŤely a sledovĂˇnĂ­ odpovÄ›dnosti za zmÄ›ny.
     */
    @Column(name = "last_modified_by_user_id")
    private Long lastModifiedByUserId;

    /**
     * BezparametrickĂ˝ konstruktor poĹľadovanĂ˝ JPA.
     */
    public MatchEntity() {
    }

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }

    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }

    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }

    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }

    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() { return price; }

    public void setPrice(Integer price) { this.price = price; }

    public MatchStatus getMatchStatus() { return matchStatus; }

    public void setMatchStatus(MatchStatus matchStatus) { this.matchStatus = matchStatus; }

    public MatchCancelReason getCancelReason() { return cancelReason; }

    public void setCancelReason(MatchCancelReason cancelReason) { this.cancelReason = cancelReason; }

    public SeasonEntity getSeason() { return season; }

    public void setSeason(SeasonEntity season) { this.season = season; }

    public LocalDateTime getTimestamp() { return timestamp; }

    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }

    public Long getCreatedByUserId() { return createdByUserId; }

    public void setCreatedByUserId(Long createdByUserId) { this.createdByUserId = createdByUserId; }

    public Long getLastModifiedByUserId() { return lastModifiedByUserId; }

    public void setLastModifiedByUserId(Long lastModifiedByUserId) { this.lastModifiedByUserId = lastModifiedByUserId; }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchHistoryEntity.java
-----
package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.MatchCancelReason;
import cz.phsoft.hokej.data.enums.MatchStatus;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentujĂ­cĂ­ historickĂ˝ zĂˇznam o zĂˇpasu.
 *
 * SlouĹľĂ­ pro auditnĂ­ ĂşÄŤely a uchovĂˇvĂˇnĂ­ zmÄ›n zĂˇpasĹŻ v ÄŤase.
 * KaĹľdĂ˝ zĂˇznam pĹ™edstavuje stav zĂˇpasu v okamĹľiku provedenĂ­ operace
 * nad hlavnĂ­ entitou MatchEntity.
 *
 * ZĂˇznamy jsou typicky vytvĂˇĹ™eny databĂˇzovĂ˝m triggerem pĹ™i operacĂ­ch
 * INSERT, UPDATE nebo DELETE.
 */
@Entity
@Table(name = "matches_history")
public class MatchHistoryEntity {

    /**
     * PrimĂˇrnĂ­ klĂ­ÄŤ historickĂ©ho zĂˇznamu.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Typ provedenĂ© operace nad zĂˇpasem.
     *
     * Typicky se jednĂˇ o hodnoty INSERT, UPDATE nebo DELETE.
     */
    @Column(name = "action", nullable = false)
    private String action;

    /**
     * Datum a ÄŤas provedenĂ­ zmÄ›ny.
     *
     * UdĂˇvĂˇ okamĹľik vytvoĹ™enĂ­ historickĂ©ho zĂˇznamu.
     */
    @Column(name = "changed_at", nullable = false)
    private LocalDateTime changedAt;

    /**
     * ID zĂˇpasu z hlavnĂ­ tabulky matches.
     *
     * SlouĹľĂ­ pro propojenĂ­ historickĂ©ho zĂˇznamu s pĹŻvodnĂ­ entitou zĂˇpasu.
     */
    @Column(name = "match_id", nullable = false)
    private Long matchId;

    /**
     * PĹŻvodnĂ­ ÄŤasovĂ© razĂ­tko zĂˇpasu.
     *
     * JednĂˇ se o hodnotu sloupce timestamp z MatchEntity
     * v okamĹľiku provedenĂ­ zmÄ›ny.
     */
    @Column(name = "original_timestamp", nullable = false)
    private LocalDateTime originalTimestamp;

    /**
     * Datum a ÄŤas konĂˇnĂ­ zĂˇpasu v okamĹľiku zmÄ›ny.
     */
    @Column(name = "date_time", nullable = false)
    private LocalDateTime dateTime;

    /**
     * MĂ­sto konĂˇnĂ­ zĂˇpasu v okamĹľiku zmÄ›ny.
     */
    @Column(name = "location", nullable = false)
    private String location;

    /**
     * Popis zĂˇpasu v okamĹľiku zmÄ›ny.
     */
    @Column(name = "description")
    private String description;

    /**
     * MaximĂˇlnĂ­ poÄŤet hrĂˇÄŤĹŻ povolenĂ˝ch pro zĂˇpas v okamĹľiku zmÄ›ny.
     */
    @Column(name = "max_players", nullable = false)
    private Integer maxPlayers;

    /**
     * Cena zĂˇpasu v okamĹľiku zmÄ›ny.
     */
    @Column(name = "price", nullable = false)
    private Integer price;

    /**
     * Stav zĂˇpasu v okamĹľiku zmÄ›ny.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "match_status")
    private MatchStatus matchStatus;

    /**
     * DĹŻvod zruĹˇenĂ­ zĂˇpasu v okamĹľiku zmÄ›ny.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "cancel_reason")
    private MatchCancelReason cancelReason;

    /**
     * ID sezĂłny, do kterĂ© zĂˇpas patĹ™il v okamĹľiku zmÄ›ny.
     */
    @Column(name = "season_id", nullable = false)
    private Long seasonId;

    /**
     * ID uĹľivatele, kterĂ˝ zĂˇpas pĹŻvodnÄ› vytvoĹ™il.
     */
    @Column(name = "created_by_user_id")
    private Long createdByUserId;

    /**
     * ID uĹľivatele, kterĂ˝ zĂˇpas naposledy zmÄ›nil pĹ™ed vytvoĹ™enĂ­m
     * historickĂ©ho zĂˇznamu.
     */
    @Column(name = "last_modified_by_user_id")
    private Long lastModifiedByUserId;

    /**
     * BezparametrickĂ˝ konstruktor poĹľadovanĂ˝ JPA.
     */
    public MatchHistoryEntity() {
    }

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getAction() { return action; }
    public void setAction(String action) { this.action = action; }

    public LocalDateTime getChangedAt() { return changedAt; }
    public void setChangedAt(LocalDateTime changedAt) { this.changedAt = changedAt; }

    public Long getMatchId() { return matchId; }
    public void setMatchId(Long matchId) { this.matchId = matchId; }

    public LocalDateTime getOriginalTimestamp() { return originalTimestamp; }
    public void setOriginalTimestamp(LocalDateTime originalTimestamp) { this.originalTimestamp = originalTimestamp; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }
    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() { return price; }
    public void setPrice(Integer price) { this.price = price; }

    public MatchStatus getMatchStatus() { return matchStatus; }
    public void setMatchStatus(MatchStatus matchStatus) { this.matchStatus = matchStatus; }

    public MatchCancelReason getCancelReason() { return cancelReason; }
    public void setCancelReason(MatchCancelReason cancelReason) { this.cancelReason = cancelReason; }

    public Long getSeasonId() { return seasonId; }
    public void setSeasonId(Long seasonId) { this.seasonId = seasonId; }

    public Long getCreatedByUserId() { return createdByUserId; }
    public void setCreatedByUserId(Long createdByUserId) { this.createdByUserId = createdByUserId; }

    public Long getLastModifiedByUserId() { return lastModifiedByUserId; }
    public void setLastModifiedByUserId(Long lastModifiedByUserId) { this.lastModifiedByUserId = lastModifiedByUserId; }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationEntity.java
-----
package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentujĂ­cĂ­ registraci hrĂˇÄŤe k zĂˇpasu.
 *
 * UchovĂˇvĂˇ informace o ĂşÄŤasti hrĂˇÄŤe, jeho aktuĂˇlnĂ­m stavu,
 * pĹ™Ă­padnĂ© omluvÄ› a administrativnĂ­ch poznĂˇmkĂˇch. SamostatnĂˇ
 * entita umoĹľĹuje sledovat zmÄ›ny registrace a pracovat
 * s historiĂ­ ĂşÄŤasti.
 */
@Entity
@Table(name = "match_registrations")
public class MatchRegistrationEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * ZĂˇpas, ke kterĂ©mu se registrace vztahuje.
     */
    @ManyToOne
    @JoinColumn(name = "match_id", nullable = false)
    private MatchEntity match;

    /**
     * HrĂˇÄŤ, kterĂ©ho se registrace tĂ˝kĂˇ.
     */
    @ManyToOne
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    /**
     * AktuĂˇlnĂ­ stav registrace hrĂˇÄŤe k zĂˇpasu.
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerMatchStatus status;

    /**
     * DĹŻvod omluvy hrĂˇÄŤe, pokud je hrĂˇÄŤ omluven.
     */
    @Enumerated(EnumType.STRING)
    private ExcuseReason excuseReason;

    /**
     * VolitelnĂˇ poznĂˇmka k omluvÄ› hrĂˇÄŤe.
     */
    private String excuseNote;

    /**
     * AdministrativnĂ­ poznĂˇmka k registraci.
     */
    private String adminNote;

    /**
     * TĂ˝m, do kterĂ©ho je hrĂˇÄŤ pro zĂˇpas zaĹ™azen.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "team")
    private Team team;

    /**
     * ÄŚasovĂ© razĂ­tko registrace.
     * PouĹľĂ­vĂˇ se napĹ™Ă­klad pro urÄŤenĂ­ poĹ™adĂ­ pĹ™ihlĂˇĹˇenĂ­.
     */
    @Column(nullable = false, updatable = true)
    private LocalDateTime timestamp = LocalDateTime.now();

    /**
     * PĹŻvod vytvoĹ™enĂ­ registrace.
     * TypickĂ© hodnoty jsou napĹ™Ă­klad "user" nebo "system".
     */
    @Column(nullable = false, updatable = true)
    private String createdBy;

    public MatchRegistrationEntity() {
    }

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public MatchEntity getMatch() { return match; }

    public void setMatch(MatchEntity match) { this.match = match; }

    public PlayerEntity getPlayer() { return player; }

    public void setPlayer(PlayerEntity player) { this.player = player; }

    public PlayerMatchStatus getStatus() { return status; }

    public void setStatus(PlayerMatchStatus status) { this.status = status; }

    public ExcuseReason getExcuseReason() { return excuseReason; }

    public void setExcuseReason(ExcuseReason excuseReason) { this.excuseReason = excuseReason; }

    public String getExcuseNote() { return excuseNote; }

    public void setExcuseNote(String excuseNote) { this.excuseNote = excuseNote; }

    public String getAdminNote() { return adminNote; }

    public void setAdminNote(String adminNote) { this.adminNote = adminNote; }

    public Team getTeam() { return team; }

    public void setTeam(Team team) { this.team = team; }

    public LocalDateTime getTimestamp() { return timestamp; }

    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }

    public String getCreatedBy() { return createdBy; }

    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationHistoryEntity.java
-----
package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentujĂ­cĂ­ historickĂ˝ zĂˇznam zmÄ›n registrace hrĂˇÄŤe k zĂˇpasu.
 *
 * SlouĹľĂ­ k auditovĂˇnĂ­ zmÄ›n registracĂ­, vÄŤetnÄ› vytvoĹ™enĂ­, Ăşprav a zruĹˇenĂ­.
 * UchovĂˇvĂˇ stav registrace v okamĹľiku zmÄ›ny a zĂˇkladnĂ­ Ăşdaje o pĹŻvodu
 * provedenĂ© operace.
 */
@Entity
@Table(name = "match_registration_history")
public class MatchRegistrationHistoryEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Typ provedenĂ© operace nad registracĂ­.
     * Typicky hodnoty INSERT, UPDATE nebo DELETE.
     */
    @Column(name = "action", nullable = false)
    private String action;

    /**
     * AdministrativnĂ­ poznĂˇmka vztahujĂ­cĂ­ se k registraci.
     */
    @Column(name = "admin_note")
    private String adminNote;

    /**
     * Datum a ÄŤas provedenĂ­ zmÄ›ny.
     */
    @Column(name = "changed_at", nullable = false)
    private LocalDateTime changedAt;

    /**
     * PĹŻvod vytvoĹ™enĂ­ nebo zmÄ›ny registrace.
     * Typicky hodnoty jako "user" nebo "system".
     */
    @Column(name = "created_by", nullable = false)
    private String createdBy;

    /**
     * TextovĂˇ poznĂˇmka k omluvÄ› hrĂˇÄŤe.
     */
    @Column(name = "excuse_note")
    private String excuseNote;

    /**
     * DĹŻvod omluvy hrĂˇÄŤe, pokud byl stav omluvenĂ˝.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "excuse_reason")
    private ExcuseReason excuseReason;

    /**
     * ID zĂˇpasu, ke kterĂ©mu se historickĂ˝ zĂˇznam vztahuje.
     */
    @Column(name = "match_id", nullable = false)
    private Long matchId;

    /**
     * ID pĹŻvodnĂ­ registrace z hlavnĂ­ tabulky registracĂ­.
     */
    @Column(name = "match_registration_id", nullable = false)
    private Long matchRegistrationId;

    /**
     * PĹŻvodnĂ­ ÄŤasovĂ© razĂ­tko registrace.
     */
    @Column(name = "original_timestamp", nullable = false)
    private LocalDateTime originalTimestamp;

    /**
     * ID hrĂˇÄŤe, kterĂ©ho se historickĂ˝ zĂˇznam tĂ˝kĂˇ.
     */
    @Column(name = "player_id", nullable = false)
    private Long playerId;

    /**
     * Stav registrace v okamĹľiku zmÄ›ny.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private PlayerMatchStatus status;

    /**
     * TĂ˝m, do kterĂ©ho byl hrĂˇÄŤ v danĂ©m okamĹľiku zaĹ™azen.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "team")
    private Team team;

    public MatchRegistrationHistoryEntity() {
    }

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public String getAction() { return action; }

    public void setAction(String action) { this.action = action; }

    public String getAdminNote() { return adminNote; }

    public void setAdminNote(String adminNote) { this.adminNote = adminNote; }

    public LocalDateTime getChangedAt() { return changedAt; }

    public void setChangedAt(LocalDateTime changedAt) { this.changedAt = changedAt; }

    public String getCreatedBy() { return createdBy; }

    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }

    public String getExcuseNote() { return excuseNote; }

    public void setExcuseNote(String excuseNote) { this.excuseNote = excuseNote; }

    public ExcuseReason getExcuseReason() { return excuseReason; }

    public void setExcuseReason(ExcuseReason excuseReason) { this.excuseReason = excuseReason; }

    public Long getMatchId() { return matchId; }

    public void setMatchId(Long matchId) { this.matchId = matchId; }

    public Long getMatchRegistrationId() { return matchRegistrationId; }

    public void setMatchRegistrationId(Long matchRegistrationId) { this.matchRegistrationId = matchRegistrationId; }

    public LocalDateTime getOriginalTimestamp() { return originalTimestamp; }

    public void setOriginalTimestamp(LocalDateTime originalTimestamp) { this.originalTimestamp = originalTimestamp; }

    public Long getPlayerId() { return playerId; }

    public void setPlayerId(Long playerId) { this.playerId = playerId; }

    public PlayerMatchStatus getStatus() { return status; }

    public void setStatus(PlayerMatchStatus status) { this.status = status; }

    public Team getTeam() { return team; }

    public void setTeam(Team team) { this.team = team; }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\NotificationEntity.java
-----
package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.NotificationType;
import jakarta.persistence.*;

import java.time.Instant;

/**
 * Entita reprezentujĂ­cĂ­ aplikaÄŤnĂ­ notifikaci.
 *
 * Notifikace vznikĂˇ pĹ™i udĂˇlostech definovanĂ˝ch v NotificationType.
 * SlouĹľĂ­ pro:
 * - zobrazenĂ­ badge (nepĹ™eÄŤtenĂ©),
 * - pĹ™ehled udĂˇlostĂ­,
 * - vĂ˝pis notifikacĂ­ od poslednĂ­ho pĹ™ihlĂˇĹˇenĂ­.
 *
 * VĹˇechny ÄŤasy jsou uklĂˇdĂˇny jako Instant (UTC).
 */
@Entity
@Table(
        name = "notifications",
        indexes = {
                @Index(name = "idx_notification_user", columnList = "user_id"),
                @Index(name = "idx_notification_created_at", columnList = "created_at"),
                @Index(name = "idx_notification_read_at", columnList = "read_at")
        }
)
public class NotificationEntity {

    /**
     * PrimĂˇrnĂ­ klĂ­ÄŤ notifikace.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * UĹľivatel, kterĂ©mu je notifikace urÄŤena.
     */
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "user_id", nullable = false)
    private AppUserEntity user;

    /**
     * VolitelnĂˇ vazba na hrĂˇÄŤe.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "player_id")
    private PlayerEntity player;

    /**
     * Typ notifikace.
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 100)
    private NotificationType type;

    /**
     * StruÄŤnĂ˝ text notifikace pro zobrazenĂ­ v dropdownu.
     */
    @Column(name = "message_short", nullable = false, length = 255)
    private String messageShort;

    /**
     * DetailnĂ­ text (volitelnĂ©).
     */
    @Column(name = "message_full", length = 2000)
    private String messageFull;

    /**
     * ÄŚas vytvoĹ™enĂ­ notifikace.
     */
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    /**
     * ÄŚas pĹ™eÄŤtenĂ­ notifikace.
     * Pokud je null â†’ notifikace je nepĹ™eÄŤtenĂˇ.
     */
    @Column(name = "read_at")
    private Instant readAt;

    /**
     * UĹľivatel, kterĂ˝ akci zpĹŻsobil (napĹ™. admin).
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "created_by_user_id")
    private AppUserEntity createdBy;

    /**
     * AutomatickĂ© nastavenĂ­ createdAt pĹ™i persist.
     */
    @PrePersist
    public void prePersist() {
        if (this.createdAt == null) {
            this.createdAt = Instant.now();
        }
    }

    // ==================================================
    // Business helper metody
    // ==================================================

    @Transient
    public boolean isRead() {
        return readAt != null;
    }

    // ==================================================
    // Gettery / Settery
    // ==================================================

    public Long getId() { return id; }

    public AppUserEntity getUser() { return user; }
    public void setUser(AppUserEntity user) { this.user = user; }

    public PlayerEntity getPlayer() { return player; }
    public void setPlayer(PlayerEntity player) { this.player = player; }

    public NotificationType getType() { return type; }
    public void setType(NotificationType type) { this.type = type; }

    public String getMessageShort() { return messageShort; }
    public void setMessageShort(String messageShort) { this.messageShort = messageShort; }

    public String getMessageFull() { return messageFull; }
    public void setMessageFull(String messageFull) { this.messageFull = messageFull; }

    public Instant getCreatedAt() { return createdAt; }
    public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; }

    public Instant getReadAt() { return readAt; }
    public void setReadAt(Instant readAt) { this.readAt = readAt; }

    public AppUserEntity getCreatedBy() { return createdBy; }
    public void setCreatedBy(AppUserEntity createdBy) { this.createdBy = createdBy; }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\package-info.java
-----
/**
 * DatabĂˇzovĂ© entity aplikace.
 *
 * ReprezentujĂ­ perzistentnĂ­ domĂ©novĂ˝ model systĂ©mu
 * mapovanĂ˝ pomocĂ­ JPA/Hibernate na databĂˇzovĂ© tabulky.
 *
 * Entity:
 * - definujĂ­ vztahy mezi daty (OneToMany, ManyToOne, apod.),
 * - nejsou urÄŤeny pro pĹ™Ă­mou komunikaci s frontendem,
 * - jsou pouĹľĂ­vĂˇny vĂ˝hradnÄ› v repository a service vrstvÄ›.
 */
package cz.phsoft.hokej.data.entities;

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerEntity.java
-----
package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerType;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentujĂ­cĂ­ hrĂˇÄŤe v systĂ©mu.
 *
 * HrĂˇÄŤ pĹ™edstavuje sportovnĂ­ identitu pouĹľĂ­vanou pĹ™i registracĂ­ch
 * na zĂˇpasy, notifikacĂ­ch a vyhodnocovĂˇnĂ­ ĂşÄŤasti. HrĂˇÄŤ mĹŻĹľe,
 * ale nemusĂ­ mĂ­t pĹ™iĹ™azen aplikaÄŤnĂ­ uĹľivatelskĂ˝ ĂşÄŤet.
 *
 * Entita obsahuje zĂˇkladnĂ­ identifikaÄŤnĂ­ Ăşdaje, stav hrĂˇÄŤe
 * v systĂ©mu a vazbu na uĹľivatele a nastavenĂ­ hrĂˇÄŤe.
 */
@Entity
@Table(name = "player_entity")
public class PlayerEntity {

    /**
     * PrimĂˇrnĂ­ klĂ­ÄŤ hrĂˇÄŤe.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * KĹ™estnĂ­ jmĂ©no hrĂˇÄŤe.
     */
    @Column(nullable = false)
    private String name;

    /**
     * PĹ™Ă­jmenĂ­ hrĂˇÄŤe.
     * PĹ™i nastavenĂ­ je pĹ™evĂˇdÄ›no na velkĂˇ pĂ­smena.
     */
    @Column(nullable = false)
    private String surname;

    /**
     * VolitelnĂˇ pĹ™ezdĂ­vka hrĂˇÄŤe.
     */
    private String nickname;

    /**
     * Typ hrĂˇÄŤe v systĂ©mu.
     *
     * UrÄŤuje napĹ™Ă­klad cenovĂ˝ nebo organizaÄŤnĂ­ reĹľim hrĂˇÄŤe.
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerType type;

    /**
     * CelĂ© jmĂ©no hrĂˇÄŤe odvozenĂ© z kĹ™estnĂ­ho jmĂ©na a pĹ™Ă­jmenĂ­.
     *
     * Hodnota se aktualizuje automaticky pĹ™i zmÄ›nÄ› jmĂ©na nebo pĹ™Ă­jmenĂ­.
     */
    private String fullName;

    /**
     * TelefonnĂ­ ÄŤĂ­slo hrĂˇÄŤe.
     *
     * PouĹľĂ­vĂˇ se zejmĂ©na pro zasĂ­lĂˇnĂ­ SMS notifikacĂ­.
     */
    private String phoneNumber;

    /**
     * TĂ˝m, ke kterĂ©mu je hrĂˇÄŤ pĹ™iĹ™azen.
     */
    @Enumerated(EnumType.STRING)
    private Team team;

    /**
     * AktuĂˇlnĂ­ stav hrĂˇÄŤe v systĂ©mu.
     *
     * Stav urÄŤuje napĹ™Ă­klad, zda je hrĂˇÄŤ ÄŤekajĂ­cĂ­ na schvĂˇlenĂ­,
     * schvĂˇlenĂ˝ nebo zamĂ­tnutĂ˝.
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerStatus playerStatus = PlayerStatus.PENDING;

    /**
     * UĹľivatelskĂ˝ ĂşÄŤet, ke kterĂ©mu hrĂˇÄŤ patĹ™Ă­.
     *
     * Vazba je volitelnĂˇ, protoĹľe hrĂˇÄŤ mĹŻĹľe existovat
     * i bez pĹ™Ă­mĂ© vazby na uĹľivatelskĂ˝ ĂşÄŤet.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private AppUserEntity user;

    /**
     * NastavenĂ­ hrĂˇÄŤe.
     *
     * Obsahuje napĹ™Ă­klad kontaktnĂ­ Ăşdaje a notifikaÄŤnĂ­ preference.
     * Jeden hrĂˇÄŤ mĂˇ prĂˇvÄ› jedno PlayerSettingsEntity.
     */
    @OneToOne(mappedBy = "player",
            cascade = CascadeType.ALL,
            fetch = FetchType.LAZY,
            orphanRemoval = true)
    private PlayerSettingsEntity settings;

    /**
     * ÄŚasovĂ© razĂ­tko hrĂˇÄŤe.
     *
     * UchovĂˇvĂˇ datum a ÄŤas vytvoĹ™enĂ­ hrĂˇÄŤe.
     * Hodnota se nastavuje pĹ™i prvnĂ­m uloĹľenĂ­ a dĂˇle se nemÄ›nĂ­.
     */
    @Column(nullable = false, updatable = false)
    private LocalDateTime timestamp = LocalDateTime.now();

    /**
     * Metoda volanĂˇ pĹ™ed prvnĂ­m uloĹľenĂ­m entity.
     *
     * ZajiĹˇĹĄuje inicializaci ÄŤasovĂ©ho razĂ­tka v pĹ™Ă­padÄ›,
     * Ĺľe nebylo nastaveno.
     */
    @PrePersist
    protected void onCreate() {
        if (this.timestamp == null) {
            this.timestamp = LocalDateTime.now();
        }
    }

    /**
     * BezparametrickĂ˝ konstruktor poĹľadovanĂ˝ JPA.
     *
     * VĂ˝chozĂ­ typ hrĂˇÄŤe je nastaven na BASIC.
     */
    public PlayerEntity() {
        this.type = PlayerType.BASIC;
    }

    /**
     * Konstruktor pro vytvoĹ™enĂ­ hrĂˇÄŤe s inicializaÄŤnĂ­mi hodnotami.
     *
     * @param name         kĹ™estnĂ­ jmĂ©no hrĂˇÄŤe
     * @param surname      pĹ™Ă­jmenĂ­ hrĂˇÄŤe
     * @param nickname     pĹ™ezdĂ­vka hrĂˇÄŤe
     * @param type         typ hrĂˇÄŤe
     * @param phoneNumber  telefonnĂ­ ÄŤĂ­slo hrĂˇÄŤe
     * @param team         tĂ˝m hrĂˇÄŤe
     * @param playerStatus aktuĂˇlnĂ­ stav hrĂˇÄŤe
     */
    public PlayerEntity(String name,
                        String surname,
                        String nickname,
                        PlayerType type,
                        String phoneNumber,
                        Team team,
                        PlayerStatus playerStatus) {

        this.name = name;
        this.surname = surname;
        this.nickname = nickname;
        this.type = type;
        this.phoneNumber = phoneNumber;
        this.team = team;
        this.playerStatus = playerStatus;
        updateFullName();
    }

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }

    public void setName(String name) {
        this.name = name;
        updateFullName();
    }

    public String getSurname() { return surname; }

    public void setSurname(String surname) {
        this.surname = surname.toUpperCase();
        updateFullName();
    }

    public String getNickname() { return nickname; }

    public void setNickname(String nickname) { this.nickname = nickname; }

    public String getFullName() { return fullName; }

    public PlayerType getType() { return type; }

    public void setType(PlayerType type) { this.type = type; }

    public String getPhoneNumber() { return phoneNumber; }

    public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }

    public Team getTeam() { return team; }

    public void setTeam(Team team) { this.team = team; }

    public PlayerStatus getPlayerStatus() { return playerStatus; }

    public void setPlayerStatus(PlayerStatus playerStatus) { this.playerStatus = playerStatus; }

    public AppUserEntity getUser() { return user; }

    public void setUser(AppUserEntity user) { this.user = user; }

    public PlayerSettingsEntity getSettings() { return settings; }

    /**
     * Nastavuje nastavenĂ­ hrĂˇÄŤe a zĂˇroveĹ zajiĹˇĹĄuje obousmÄ›rnou vazbu.
     *
     * @param settings instance nastavenĂ­ hrĂˇÄŤe
     */
    public void setSettings(PlayerSettingsEntity settings) {
        this.settings = settings;
        if (settings != null) {
            settings.setPlayer(this);
        }
    }

    /**
     * Aktualizuje celĂ© jmĂ©no hrĂˇÄŤe podle aktuĂˇlnĂ­ho jmĂ©na a pĹ™Ă­jmenĂ­.
     *
     * Metoda je volĂˇna pĹ™i zmÄ›nÄ› jmĂ©na nebo pĹ™Ă­jmenĂ­.
     */
    private void updateFullName() {
        this.fullName = name + " " + surname;
    }

    public LocalDateTime getTimestamp() { return timestamp; }

    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerHistoryEntity.java
-----
package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentujĂ­cĂ­ historickĂ˝ zĂˇznam o hrĂˇÄŤi.
 *
 * SlouĹľĂ­ pro auditnĂ­ ĂşÄŤely a uchovĂˇvĂˇnĂ­ zmÄ›n hrĂˇÄŤĹŻ v ÄŤase.
 * KaĹľdĂ˝ zĂˇznam pĹ™edstavuje stav hrĂˇÄŤe v okamĹľiku provedenĂ­ operace
 * nad hlavnĂ­ entitou PlayerEntity.
 *
 * ZĂˇznamy jsou typicky vytvĂˇĹ™eny databĂˇzovĂ˝m triggerem pĹ™i zmÄ›nÄ›
 * ĂşdajĹŻ hrĂˇÄŤe.
 */
@Entity
@Table(name = "player_entity_history")
public class PlayerHistoryEntity {

    /**
     * PrimĂˇrnĂ­ klĂ­ÄŤ historickĂ©ho zĂˇznamu.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Typ provedenĂ© operace.
     *
     * Typicky se jednĂˇ o hodnoty CREATE, STATUS_CHANGE,
     * USER_CHANGE nebo DELETE.
     */
    @Column(name = "action", nullable = false)
    private String action;

    /**
     * Datum a ÄŤas provedenĂ­ zmÄ›ny.
     *
     * UdĂˇvĂˇ okamĹľik vytvoĹ™enĂ­ historickĂ©ho zĂˇznamu.
     */
    @Column(name = "changed_at", nullable = false)
    private LocalDateTime changedAt;

    /**
     * ID hrĂˇÄŤe z hlavnĂ­ tabulky player_entity.
     *
     * SlouĹľĂ­ pro propojenĂ­ historickĂ©ho zĂˇznamu s pĹŻvodnĂ­ entitou hrĂˇÄŤe.
     */
    @Column(name = "player_id", nullable = false)
    private Long playerId;

    /**
     * PĹŻvodnĂ­ ÄŤasovĂ© razĂ­tko hrĂˇÄŤe.
     *
     * JednĂˇ se o hodnotu sloupce timestamp z tabulky player_entity
     * v okamĹľiku vytvoĹ™enĂ­ historickĂ©ho zĂˇznamu.
     */
    @Column(name = "original_timestamp", nullable = false)
    private LocalDateTime originalTimestamp;

    /**
     * KĹ™estnĂ­ jmĂ©no hrĂˇÄŤe v okamĹľiku zmÄ›ny.
     */
    @Column(name = "name", nullable = false)
    private String name;

    /**
     * PĹ™Ă­jmenĂ­ hrĂˇÄŤe v okamĹľiku zmÄ›ny.
     */
    @Column(name = "surname", nullable = false)
    private String surname;

    /**
     * PĹ™ezdĂ­vka hrĂˇÄŤe v okamĹľiku zmÄ›ny.
     */
    @Column(name = "nickname")
    private String nickname;

    /**
     * Typ hrĂˇÄŤe v okamĹľiku zmÄ›ny.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "type", nullable = false)
    private PlayerType type;

    /**
     * CelĂ© jmĂ©no hrĂˇÄŤe v okamĹľiku zmÄ›ny.
     */
    @Column(name = "full_name")
    private String fullName;

    /**
     * TelefonnĂ­ ÄŤĂ­slo hrĂˇÄŤe v okamĹľiku zmÄ›ny.
     */
    @Column(name = "phone_number")
    private String phoneNumber;

    /**
     * TĂ˝m hrĂˇÄŤe v okamĹľiku zmÄ›ny.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "team")
    private Team team;

    /**
     * Stav hrĂˇÄŤe v okamĹľiku zmÄ›ny.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "player_status", nullable = false)
    private PlayerStatus playerStatus;

    /**
     * ID uĹľivatele, ke kterĂ©mu byl hrĂˇÄŤ pĹ™iĹ™azen
     * v okamĹľiku vytvoĹ™enĂ­ historickĂ©ho zĂˇznamu.
     */
    @Column(name = "user_id")
    private Long userId;

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getAction() { return action; }
    public void setAction(String action) { this.action = action; }

    public LocalDateTime getChangedAt() { return changedAt; }
    public void setChangedAt(LocalDateTime changedAt) { this.changedAt = changedAt; }

    public Long getPlayerId() { return playerId; }
    public void setPlayerId(Long playerId) { this.playerId = playerId; }

    public LocalDateTime getOriginalTimestamp() { return originalTimestamp; }
    public void setOriginalTimestamp(LocalDateTime originalTimestamp) { this.originalTimestamp = originalTimestamp; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getSurname() { return surname; }
    public void setSurname(String surname) { this.surname = surname; }

    public String getNickname() { return nickname; }
    public void setNickname(String nickname) { this.nickname = nickname; }

    public PlayerType getType() { return type; }
    public void setType(PlayerType type) { this.type = type; }

    public String getFullName() { return fullName; }
    public void setFullName(String fullName) { this.fullName = fullName; }

    public String getPhoneNumber() { return phoneNumber; }
    public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }

    public Team getTeam() { return team; }
    public void setTeam(Team team) { this.team = team; }

    public PlayerStatus getPlayerStatus() { return playerStatus; }
    public void setPlayerStatus(PlayerStatus playerStatus) { this.playerStatus = playerStatus; }

    public Long getUserId() { return userId; }
    public void setUserId(Long userId) { this.userId = userId; }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerInactivityPeriodEntity.java
-----
package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentujĂ­cĂ­ obdobĂ­ neaktivity hrĂˇÄŤe.
 *
 * SlouĹľĂ­ k evidenci ÄŤasovĂ˝ch ĂşsekĹŻ, ve kterĂ˝ch se hrĂˇÄŤ
 * neĂşÄŤastnĂ­ zĂˇpasĹŻ, napĹ™Ă­klad z dĹŻvodu zranÄ›nĂ­ nebo dovolenĂ©.
 * ObdobĂ­ neaktivity se pouĹľĂ­vĂˇ pĹ™i vyhodnocovĂˇnĂ­ dostupnosti
 * hrĂˇÄŤe pro jednotlivĂ© zĂˇpasy.
 */
@Entity
@Table(name = "player_inactivity_period")
public class PlayerInactivityPeriodEntity {

    /**
     * PrimĂˇrnĂ­ klĂ­ÄŤ zĂˇznamu o neaktivitÄ›.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * HrĂˇÄŤ, ke kterĂ©mu se obdobĂ­ neaktivity vztahuje.
     *
     * Vazba je povinnĂˇ, protoĹľe kaĹľdĂ© obdobĂ­ neaktivity
     * musĂ­ bĂ˝t pĹ™iĹ™azeno konkrĂ©tnĂ­mu hrĂˇÄŤi.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    /**
     * ZaÄŤĂˇtek obdobĂ­ neaktivity.
     *
     * UrÄŤuje datum a ÄŤas, od kterĂ©ho je hrĂˇÄŤ povaĹľovĂˇn za neaktivnĂ­ho.
     */
    @Column(name = "inactive_from", nullable = false)
    private LocalDateTime inactiveFrom;

    /**
     * Konec obdobĂ­ neaktivity.
     *
     * UrÄŤuje datum a ÄŤas, do kterĂ©ho je hrĂˇÄŤ povaĹľovĂˇn za neaktivnĂ­ho.
     */
    @Column(name = "inactive_to", nullable = false)
    private LocalDateTime inactiveTo;

    /**
     * DĹŻvod neaktivity hrĂˇÄŤe.
     *
     * SlouĹľĂ­ k evidenci pĹ™Ă­ÄŤiny absence, napĹ™Ă­klad zranÄ›nĂ­,
     * dovolenĂˇ nebo jinĂ˝ osobnĂ­ dĹŻvod.
     */
    @Column(name = "inactivity_reason", nullable = false)
    private String inactivityReason;

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public PlayerEntity getPlayer() { return player; }

    public void setPlayer(PlayerEntity player) { this.player = player; }

    public LocalDateTime getInactiveFrom() { return inactiveFrom; }

    public void setInactiveFrom(LocalDateTime inactiveFrom) { this.inactiveFrom = inactiveFrom; }

    public LocalDateTime getInactiveTo() { return inactiveTo; }

    public void setInactiveTo(LocalDateTime inactiveTo) { this.inactiveTo = inactiveTo; }

    public String getInactivityReason() {
        return inactivityReason;
    }

    public void setInactivityReason(String inactivityReason) {
        this.inactivityReason = inactivityReason;
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerSettingsEntity.java
-----
package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

/**
 * Entita uchovĂˇvajĂ­cĂ­ nastavenĂ­ konkrĂ©tnĂ­ho hrĂˇÄŤe.
 *
 * OddÄ›luje identitu hrĂˇÄŤe (PlayerEntity) od jeho kontaktnĂ­ch ĂşdajĹŻ
 * a detailnĂ­ch notifikaÄŤnĂ­ch preferencĂ­. NastavenĂ­ se vyuĹľĂ­vĂˇ
 * pĹ™i rozhodovĂˇnĂ­ o tom, zda a jak budou hrĂˇÄŤi doruÄŤovĂˇny notifikace.
 */
@Entity
@Table(name = "player_settings")
public class PlayerSettingsEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * HrĂˇÄŤ, ke kterĂ©mu toto nastavenĂ­ patĹ™Ă­.
     * Pro jednoho hrĂˇÄŤe existuje prĂˇvÄ› jeden zĂˇznam nastavenĂ­.
     */
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "player_id", nullable = false, unique = true)
    private PlayerEntity player;

    /**
     * VolitelnĂ˝ email hrĂˇÄŤe.
     * Pokud nenĂ­ vyplnÄ›n, mĹŻĹľe se pouĹľĂ­t email uĹľivatele (AppUserEntity).
     */
    @Column(name = "contact_email", length = 255)
    private String contactEmail;

    /**
     * VolitelnĂ© telefonnĂ­ ÄŤĂ­slo hrĂˇÄŤe pro SMS notifikace.
     */
    @Column(name = "contact_phone", length = 50)
    private String contactPhone;

    /**
     * PĹ™Ă­znak, zda mĂˇ hrĂˇÄŤ dostĂˇvat emailovĂ© notifikace.
     */
    @Column(name = "email_enabled", nullable = false)
    private boolean emailEnabled = true;

    /**
     * PĹ™Ă­znak, zda mĂˇ hrĂˇÄŤ dostĂˇvat SMS notifikace.
     */
    @Column(name = "sms_enabled", nullable = false)
    private boolean smsEnabled = false;

    /**
     * PĹ™Ă­znak, zda chce hrĂˇÄŤ notifikace o registraci a odhlĂˇĹˇenĂ­.
     */
    @Column(name = "notify_on_registration", nullable = false)
    private boolean notifyOnRegistration = true;

    /**
     * PĹ™Ă­znak, zda chce hrĂˇÄŤ notifikace o omluvĂˇch.
     */
    @Column(name = "notify_on_excuse", nullable = false)
    private boolean notifyOnExcuse = true;

    /**
     * PĹ™Ă­znak, zda chce hrĂˇÄŤ notifikace o zmÄ›nĂˇch zĂˇpasu.
     */
    @Column(name = "notify_on_match_change", nullable = false)
    private boolean notifyOnMatchChange = true;

    /**
     * PĹ™Ă­znak, zda chce hrĂˇÄŤ notifikace o zruĹˇenĂ­ zĂˇpasu.
     */
    @Column(name = "notify_on_match_cancel", nullable = false)
    private boolean notifyOnMatchCancel = true;

    /**
     * PĹ™Ă­znak, zda chce hrĂˇÄŤ notifikace o platbĂˇch nebo vyĂşÄŤtovĂˇnĂ­.
     */
    @Column(name = "notify_on_payment", nullable = false)
    private boolean notifyOnPayment = false;

    /**
     * PĹ™Ă­znak, zda mĂˇ hrĂˇÄŤ dostĂˇvat pĹ™ipomĂ­nky pĹ™ed zĂˇpasem.
     */
    @Column(name = "notify_reminders", nullable = false)
    private boolean notifyReminders = true;

    /**
     * PoÄŤet hodin pĹ™ed zaÄŤĂˇtkem zĂˇpasu, kdy mĂˇ bĂ˝t odeslĂˇna pĹ™ipomĂ­nka.
     * NapĹ™Ă­klad hodnota 24 znamenĂˇ pĹ™ipomĂ­nku den pĹ™edem.
     */
    @Column(name = "reminder_hours_before")
    private Integer reminderHoursBefore = 24;

    /**
     * UrÄŤuje, zda jsou povoleny notifikace tĂ˝kajĂ­cĂ­ se registracĂ­.
     */
    @Transient
    public boolean isRegistrationNotificationsEnabled() {
        return notifyOnRegistration;
    }

    /**
     * UrÄŤuje, zda jsou povoleny notifikace tĂ˝kajĂ­cĂ­ se omluv.
     */
    @Transient
    public boolean isExcuseNotificationsEnabled() {
        return notifyOnExcuse;
    }

    /**
     * UrÄŤuje, zda jsou povoleny notifikace tĂ˝kajĂ­cĂ­ se informacĂ­ o zĂˇpase,
     * napĹ™Ă­klad zmÄ›n a pĹ™ipomĂ­nek.
     */
    @Transient
    public boolean isMatchInfoNotificationsEnabled() {
        return notifyOnMatchChange
                || notifyOnMatchCancel
                || notifyReminders;
    }

    /**
     * UrÄŤuje, zda jsou povoleny systĂ©movĂ© notifikace,
     * napĹ™Ă­klad o platbĂˇch.
     */
    @Transient
    public boolean isSystemNotificationsEnabled() {
        return notifyOnPayment;
    }

    public Long getId() {
        return id;
    }

    public PlayerEntity getPlayer() {
        return player;
    }

    public void setPlayer(PlayerEntity player) {
        this.player = player;
    }

    public String getContactEmail() {
        return contactEmail;
    }

    public void setContactEmail(String contactEmail) {
        this.contactEmail = contactEmail;
    }

    public String getContactPhone() {
        return contactPhone;
    }

    public void setContactPhone(String contactPhone) {
        this.contactPhone = contactPhone;
    }

    public boolean isEmailEnabled() {
        return emailEnabled;
    }

    public void setEmailEnabled(boolean emailEnabled) {
        this.emailEnabled = emailEnabled;
    }

    public boolean isSmsEnabled() {
        return smsEnabled;
    }

    public void setSmsEnabled(boolean smsEnabled) {
        this.smsEnabled = smsEnabled;
    }

    public boolean isNotifyOnRegistration() {
        return notifyOnRegistration;
    }

    public void setNotifyOnRegistration(boolean notifyOnRegistration) {
        this.notifyOnRegistration = notifyOnRegistration;
    }

    public boolean isNotifyOnExcuse() {
        return notifyOnExcuse;
    }

    public void setNotifyOnExcuse(boolean notifyOnExcuse) {
        this.notifyOnExcuse = notifyOnExcuse;
    }

    public boolean isNotifyOnMatchChange() {
        return notifyOnMatchChange;
    }

    public void setNotifyOnMatchChange(boolean notifyOnMatchChange) {
        this.notifyOnMatchChange = notifyOnMatchChange;
    }

    public boolean isNotifyOnMatchCancel() {
        return notifyOnMatchCancel;
    }

    public void setNotifyOnMatchCancel(boolean notifyOnMatchCancel) {
        this.notifyOnMatchCancel = notifyOnMatchCancel;
    }

    public boolean isNotifyOnPayment() {
        return notifyOnPayment;
    }

    public void setNotifyOnPayment(boolean notifyOnPayment) {
        this.notifyOnPayment = notifyOnPayment;
    }

    public boolean isNotifyReminders() {
        return notifyReminders;
    }

    public void setNotifyReminders(boolean notifyReminders) {
        this.notifyReminders = notifyReminders;
    }

    public Integer getReminderHoursBefore() {
        return reminderHoursBefore;
    }

    public void setReminderHoursBefore(Integer reminderHoursBefore) {
        this.reminderHoursBefore = reminderHoursBefore;
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\SeasonEntity.java
-----
package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDate;
import java.time.LocalDateTime;

/**
 * Entita reprezentujĂ­cĂ­ sezĂłnu.
 *
 * SezĂłna vymezuje ÄŤasovĂ© obdobĂ­, do kterĂ©ho spadajĂ­ zĂˇpasy
 * a souvisejĂ­cĂ­ statistiky. V systĂ©mu mĹŻĹľe bĂ˝t v jednom okamĹľiku
 * oznaÄŤena prĂˇvÄ› jedna sezĂłna jako aktivnĂ­.
 *
 * Entita dĂˇle obsahuje auditnĂ­ Ăşdaje o vytvoĹ™enĂ­ a poslednĂ­
 * zmÄ›nÄ› zĂˇznamu.
 */
@Entity
@Table(name = "season")
public class SeasonEntity {

    /**
     * PrimĂˇrnĂ­ klĂ­ÄŤ sezĂłny.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * NĂˇzev sezĂłny.
     *
     * NapĹ™Ă­klad hodnota ve formĂˇtu "2024/2025".
     */
    @Column(nullable = false)
    private String name;

    /**
     * Datum zaÄŤĂˇtku sezĂłny.
     *
     * UrÄŤuje prvnĂ­ den, od kterĂ©ho jsou zĂˇpasy
     * do sezĂłny zahrnovĂˇny.
     */
    @Column(nullable = false)
    private LocalDate startDate;

    /**
     * Datum konce sezĂłny.
     *
     * UrÄŤuje poslednĂ­ den, do kterĂ©ho sezĂłna trvĂˇ.
     */
    @Column(nullable = false)
    private LocalDate endDate;

    /**
     * PĹ™Ă­znak, zda je sezĂłna aktuĂˇlnÄ› aktivnĂ­.
     *
     * AktivnĂ­ sezĂłna se pouĹľĂ­vĂˇ jako vĂ˝chozĂ­ pĹ™i vytvĂˇĹ™enĂ­
     * novĂ˝ch zĂˇpasĹŻ a pĹ™i filtrovĂˇnĂ­ dat.
     */
    private boolean active;

    /**
     * IdentifikĂˇtor uĹľivatele, kterĂ˝ sezĂłnu vytvoĹ™il.
     *
     * Hodnota se nastavuje pĹ™i vytvoĹ™enĂ­ sezĂłny
     * a slouĹľĂ­ pro auditnĂ­ ĂşÄŤely.
     */
    @Column(name = "created_by_user_id")
    private Long createdByUserId;

    /**
     * ÄŚasovĂ© razĂ­tko sezĂłny.
     *
     * UchovĂˇvĂˇ datum a ÄŤas vytvoĹ™enĂ­ nebo poslednĂ­ zmÄ›ny sezĂłny.
     * Hodnota se aktualizuje pĹ™i kaĹľdĂ©m uloĹľenĂ­ entity.
     */
    @Column(nullable = false, updatable = true)
    private LocalDateTime timestamp = LocalDateTime.now();

    /**
     * Metoda volanĂˇ pĹ™ed prvnĂ­m uloĹľenĂ­m entity.
     *
     * Nastavuje aktuĂˇlnĂ­ ÄŤasovĂ© razĂ­tko.
     */
    @PrePersist
    public void prePersist() {
        this.timestamp = LocalDateTime.now();
    }

    /**
     * Metoda volanĂˇ pĹ™ed aktualizacĂ­ entity.
     *
     * Aktualizuje ÄŤasovĂ© razĂ­tko.
     */
    @PreUpdate
    public void preUpdate() {
        this.timestamp = LocalDateTime.now();
    }

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }

    public void setName(String name) { this.name = name; }

    public LocalDate getStartDate() { return startDate; }

    public void setStartDate(LocalDate startDate) { this.startDate = startDate; }

    public LocalDate getEndDate() { return endDate; }

    public void setEndDate(LocalDate endDate) { this.endDate = endDate; }

    public boolean isActive() { return active; }

    public void setActive(boolean active) { this.active = active; }

    public Long getCreatedByUserId() { return createdByUserId; }

    public void setCreatedByUserId(Long createdByUserId) { this.createdByUserId = createdByUserId; }

    public LocalDateTime getTimestamp() { return timestamp; }

    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\SeasonHistoryEntity.java
-----
package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDate;
import java.time.LocalDateTime;

/**
 * Entita reprezentujĂ­cĂ­ historickĂ˝ zĂˇznam o sezĂłnÄ›.
 *
 * SlouĹľĂ­ pro auditnĂ­ ĂşÄŤely a sledovĂˇnĂ­ zmÄ›n sezĂłn v ÄŤase.
 */
@Entity
@Table(name = "season_history")
public class SeasonHistoryEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Typ provedenĂ© operace (INSERT, UPDATE, DELETE).
     */
    @Column(nullable = false)
    private String action;

    /**
     * Datum a ÄŤas provedenĂ­ zmÄ›ny.
     */
    @Column(name = "changed_at", nullable = false)
    private LocalDateTime changedAt;

    /**
     * ID sezĂłny z hlavnĂ­ tabulky season.
     */
    @Column(name = "season_id", nullable = false)
    private Long seasonId;

    /**
     * PĹŻvodnĂ­ ÄŤasovĂ© razĂ­tko sezĂłny.
     */
    @Column(name = "original_timestamp", nullable = false)
    private LocalDateTime originalTimestamp;

    @Column(nullable = false)
    private String name;

    @Column(name = "start_date", nullable = false)
    private LocalDate startDate;

    @Column(name = "end_date", nullable = false)
    private LocalDate endDate;

    @Column(nullable = false)
    private boolean active;

    /**
     * ID uĹľivatele, kterĂ˝ sezĂłnu vytvoĹ™il.
     * ZkopĂ­rovĂˇno z pole createdByUserId v SeasonEntity.
     */
    @Column(name = "created_by_user_id")
    private Long createdByUserId;

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getAction() { return action; }
    public void setAction(String action) { this.action = action; }

    public LocalDateTime getChangedAt() { return changedAt; }
    public void setChangedAt(LocalDateTime changedAt) { this.changedAt = changedAt; }

    public Long getSeasonId() { return seasonId; }
    public void setSeasonId(Long seasonId) { this.seasonId = seasonId; }

    public LocalDateTime getOriginalTimestamp() { return originalTimestamp; }
    public void setOriginalTimestamp(LocalDateTime originalTimestamp) { this.originalTimestamp = originalTimestamp; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public LocalDate getStartDate() { return startDate; }
    public void setStartDate(LocalDate startDate) { this.startDate = startDate; }

    public LocalDate getEndDate() { return endDate; }
    public void setEndDate(LocalDate endDate) { this.endDate = endDate; }

    public boolean isActive() { return active; }
    public void setActive(boolean active) { this.active = active; }

    public Long getCreatedByUserId() { return createdByUserId; }
    public void setCreatedByUserId(Long createdByUserId) { this.createdByUserId = createdByUserId; }
}
