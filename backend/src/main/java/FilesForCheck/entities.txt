Balíček (složka): entities
Cesta: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities

Seznam souborů:
AppUserEntity.java
AppUserSettingsEntity.java
EmailVerificationTokenEntity.java
ForgottenPasswordResetTokenEntity.java
MatchEntity.java
MatchRegistrationEntity.java
MatchRegistrationHistoryEntity.java
NotificationSettings.java
PlayerEntity.java
PlayerInactivityPeriodEntity.java
PlayerSettingsEntity.java
SeasonEntity.java



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\AppUserEntity.java
-----

package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.Role;
import jakarta.persistence.*;

import java.util.Set;

/**
 * Entita reprezentující uživatelský účet aplikace.
 *
 * Slouží pro autentizaci a autorizaci uživatelů.
 * Jeden uživatel může mít přiřazeno více hráčů.
 */
@Entity
@Table(name = "app_users")
public class AppUserEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String surname;

    /**
     * Unikátní email uživatele sloužící pro přihlášení.
     */
    @Column(nullable = false, unique = true)
    private String email;

    /**
     * Hash hesla uživatele.
     */
    @Column(nullable = false)
    private String password;

    /**
     * Role uživatele v systému.
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role;

    /**
     * Příznak aktivace účtu (např. po emailové aktivaci).
     */
    @Column(nullable = false)
    private boolean enabled = false;

    /**
     * Hráči přiřazení k tomuto uživateli.
     */
    @OneToMany(
            mappedBy = "user",
            cascade = CascadeType.ALL,
            orphanRemoval = true
    )
    private Set<PlayerEntity> players;

    // nastavení uživatele (AppUserSettingsEntity)
    /**
     * Nastavení uživatele (způsob výběru hráče, notifikace atd.).
     *
     * Jeden uživatel má právě jedno AppUserSettingsEntity.
     */
    @OneToOne(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY, orphanRemoval = true)
    private AppUserSettingsEntity settings;


    public Long getId() {return id;}

    public void setId(Long id) {this.id = id;}

    public String getName() {return name;}

    public void setName(String name) {this.name = name;}

    public String getSurname() { return surname; }

    public void setSurname(String surname) { this.surname = surname; }

    public String getEmail() {return email;}

    public void setEmail(String email) {this.email = email;}

    public String getPassword() {return password;}

    public void setPassword(String password) {this.password = password;}

    public Role getRole() {return role;}

    public void setRole(Role role) {this.role = role;}

    public boolean isEnabled() {    return enabled;    }

    public void setEnabled(boolean enabled) {  this.enabled = enabled;    }

    public Set<PlayerEntity> getPlayers() {return players;}

    public void setPlayers(Set<PlayerEntity> players) {this.players = players;}

    public AppUserSettingsEntity getSettings() { return settings; }

    public void setSettings(AppUserSettingsEntity settings) {
        this.settings = settings;
        if (settings != null) {
            settings.setUser(this);
        }
    }

}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\AppUserSettingsEntity.java
-----

package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.PlayerSelectionMode;
import cz.phsoft.hokej.data.enums.GlobalNotificationLevel;
import jakarta.persistence.*;

import java.time.LocalTime;

/**
 * Entita uchovávající nastavení uživatelského účtu (AppUserEntity).
 *
 * Odděluje:
 * - identitu uživatele (AppUserEntity: login, heslo, role...)
 * - jeho preference a chování v systému (AppUserSettingsEntity).
 */
@Entity
@Table(name = "app_user_settings")
public class AppUserSettingsEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Jeden záznam AppUserSettingsEntity pro jednoho uživatele.
     */
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false, unique = true)
    private AppUserEntity user;

    /**
     * Způsob automatického výběru hráče po přihlášení
     * nebo při auto-select logice.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "player_selection_mode", nullable = false, length = 50)
    private PlayerSelectionMode playerSelectionMode = PlayerSelectionMode.FIRST_PLAYER;

    /**
     * Globální úroveň notifikací pro uživatele.
     * Určuje, kolik notifikací bude dostávat on sám,
     * nezávisle na hráčích.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "global_notification_level", nullable = false, length = 50)
    private GlobalNotificationLevel globalNotificationLevel = GlobalNotificationLevel.ALL;

    /**
     * Má uživatel dostávat kopie všech notifikací,
     * které chodí jeho hráčům?
     *
     * Příklad:
     * - TRUE: rodič chce mít přehled o všem, co se děje u dětí
     * - FALSE: spoléhá se jen na notifikace hráčů.
     */
    @Column(name = "copy_all_player_notifications_to_user_email", nullable = false)
    private boolean copyAllPlayerNotificationsToUserEmail = true;

    /**
     * Má uživatel dostávat notifikace i za hráče,
     * kteří mají vlastní email (contactEmail v PlayerSettings)?
     *
     * Příklad:
     * - FALSE: když má dítě vlastní email, chodí notifikace jen jemu
     * - TRUE: rodič chce kopii, i když má hráč svůj email.
     */
    @Column(name = "receive_notifications_for_players_with_own_email", nullable = false)
    private boolean receiveNotificationsForPlayersWithOwnEmail = false;

    /**
     * Má uživatel preferovat denní souhrn (digest)
     * místo jednotlivých notifikací během dne?
     */
    @Column(name = "email_digest_enabled", nullable = false)
    private boolean emailDigestEnabled = false;

    /**
     * Čas, kdy má chodit souhrnný email, pokud je digest zapnutý.
     * Např. 20:00.
     */
    @Column(name = "email_digest_time")
    private LocalTime emailDigestTime;

    /**
     * Preferovaný jazyk uživatelského rozhraní.
     * Např. "cs", "en".
     */
    @Column(name = "ui_language", length = 10)
    private String uiLanguage = "cs";

    /**
     * Časová zóna uživatele, např. "Europe/Prague".
     */
    @Column(name = "timezone", length = 50)
    private String timezone = "Europe/Prague";

    /**
     * Výchozí obrazovka po přihlášení.
     * Může být např. "DASHBOARD", "MATCHES", "PLAYERS".
     *
     * Z praktických důvodů ji necháme jako String,
     * enum můžeme doplnit později, pokud bude potřeba.
     */
    @Column(name = "default_landing_page", length = 50)
    private String defaultLandingPage = "DASHBOARD";

    // =========================================
    // Gettery a settery
    // =========================================

    public Long getId() {
        return id;
    }

    public AppUserEntity getUser() {
        return user;
    }

    public void setUser(AppUserEntity user) {
        this.user = user;
    }

    public PlayerSelectionMode getPlayerSelectionMode() {
        return playerSelectionMode;
    }

    public void setPlayerSelectionMode(PlayerSelectionMode playerSelectionMode) {
        this.playerSelectionMode = playerSelectionMode;
    }

    public GlobalNotificationLevel getGlobalNotificationLevel() {
        return globalNotificationLevel;
    }

    public void setGlobalNotificationLevel(GlobalNotificationLevel globalNotificationLevel) {
        this.globalNotificationLevel = globalNotificationLevel;
    }

    public boolean isCopyAllPlayerNotificationsToUserEmail() {
        return copyAllPlayerNotificationsToUserEmail;
    }

    public void setCopyAllPlayerNotificationsToUserEmail(boolean copyAllPlayerNotificationsToUserEmail) {
        this.copyAllPlayerNotificationsToUserEmail = copyAllPlayerNotificationsToUserEmail;
    }

    public boolean isReceiveNotificationsForPlayersWithOwnEmail() {
        return receiveNotificationsForPlayersWithOwnEmail;
    }

    public void setReceiveNotificationsForPlayersWithOwnEmail(boolean receiveNotificationsForPlayersWithOwnEmail) {
        this.receiveNotificationsForPlayersWithOwnEmail = receiveNotificationsForPlayersWithOwnEmail;
    }

    public boolean isEmailDigestEnabled() {
        return emailDigestEnabled;
    }

    public void setEmailDigestEnabled(boolean emailDigestEnabled) {
        this.emailDigestEnabled = emailDigestEnabled;
    }

    public LocalTime getEmailDigestTime() {
        return emailDigestTime;
    }

    public void setEmailDigestTime(LocalTime emailDigestTime) {
        this.emailDigestTime = emailDigestTime;
    }

    public String getUiLanguage() {
        return uiLanguage;
    }

    public void setUiLanguage(String uiLanguage) {
        this.uiLanguage = uiLanguage;
    }

    public String getTimezone() {
        return timezone;
    }

    public void setTimezone(String timezone) {
        this.timezone = timezone;
    }

    public String getDefaultLandingPage() {
        return defaultLandingPage;
    }

    public void setDefaultLandingPage(String defaultLandingPage) {
        this.defaultLandingPage = defaultLandingPage;
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\EmailVerificationTokenEntity.java
-----

package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentující ověřovací token pro emailovou aktivaci uživatele.
 *
 * Slouží k ověření emailové adresy a aktivaci uživatelského účtu.
 * Token je časově omezený a navázaný na konkrétního uživatele.
 */
@Entity
@Table(name = "email_verification_tokens")
public class EmailVerificationTokenEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Unikátní ověřovací token.
     */
    @Column(nullable = false, unique = true, length = 64)
    private String token;

    /**
     * Datum a čas expirace tokenu.
     */
    @Column(nullable = false)
    private LocalDateTime expiresAt;

    /**
     * Uživatel, ke kterému je token přiřazen.
     */
    @OneToOne
    @JoinColumn(name = "user_id", nullable = false)
    private AppUserEntity user;

    // gettery / settery

    // gettery / settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getToken() { return token; }
    public void setToken(String token) { this.token = token; }

    public LocalDateTime getExpiresAt() { return expiresAt; }
    public void setExpiresAt(LocalDateTime expiresAt) { this.expiresAt = expiresAt; }

    public AppUserEntity getUser() { return user; }
    public void setUser(AppUserEntity user) { this.user = user; }

}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\ForgottenPasswordResetTokenEntity.java
-----

package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
public class ForgottenPasswordResetTokenEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 128)
    private String token;

    @ManyToOne(optional = false, fetch = FetchType.LAZY)
    private AppUserEntity user;

    @Column(nullable = false)
    private LocalDateTime expiresAt;

    // volitelné – pokud chceš logovat použití
    private LocalDateTime usedAt;

    // gettery/settery

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getToken() { return token; }
    public void setToken(String token) { this.token = token; }

    public AppUserEntity getUser() { return user; }
    public void setUser(AppUserEntity user) { this.user = user; }

    public LocalDateTime getExpiresAt() { return expiresAt; }
    public void setExpiresAt(LocalDateTime expiresAt) { this.expiresAt = expiresAt; }

    public LocalDateTime getUsedAt() { return usedAt; }
    public void setUsedAt(LocalDateTime usedAt) { this.usedAt = usedAt; }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchEntity.java
-----

package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.MatchCancelReason;
import cz.phsoft.hokej.data.enums.MatchStatus;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentující zápas.
 *
 * Obsahuje základní informace o zápasu, jeho kapacitě,
 * stavu a vazbě na sezónu.
 */
@Entity
@Table(name = "matches")
public class MatchEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Datum a čas konání zápasu.
     */
    @Column(nullable = false)
    private LocalDateTime dateTime;

    /**
     * Místo konání zápasu.
     */
    @Column(nullable = false)
    private String location;

    /**
     * Volitelný popis zápasu.
     */
    private String description;

    /**
     * Maximální počet hráčů povolených pro zápas.
     */
    @Column(nullable = false)
    private Integer maxPlayers;

    /**
     * Celková cena zápasu.
     */
    @Column(nullable = false)
    private Integer price;

    /**
     * Aktuální stav zápasu (např. aktivní, zrušený).
     */
    @Enumerated(EnumType.STRING)
    private MatchStatus matchStatus;

    /**
     * Důvod zrušení zápasu (pouze pokud je zápas zrušen).
     */
    @Enumerated(EnumType.STRING)
    private MatchCancelReason cancelReason;

    /**
     * Sezóna, do které zápas patří.
     */
    @ManyToOne(optional = false)
    @JoinColumn(name = "season_id", nullable = false)
    private SeasonEntity season;

    public MatchEntity() {
    }

    // gettery / settery

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }
    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() { return price; }
    public void setPrice(Integer price) { this.price = price; }

    public MatchStatus getMatchStatus() { return matchStatus; }
    public void setMatchStatus(MatchStatus matchStatus) { this.matchStatus = matchStatus; }

    public MatchCancelReason getCancelReason() { return cancelReason; }
    public void setCancelReason(MatchCancelReason cancelReason) { this.cancelReason = cancelReason; }

    public SeasonEntity getSeason() { return season; }
    public void setSeason(SeasonEntity season) { this.season = season; }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationEntity.java
-----

package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentující registraci hráče k zápasu.
 *
 * Uchovává informace o účasti hráče, jeho stavu,
 * případné omluvě a administrativních poznámkách.
 */
@Entity
@Table(name = "match_registrations")
public class MatchRegistrationEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Zápas, ke kterému se registrace vztahuje.
     */
    @ManyToOne
    @JoinColumn(name = "match_id", nullable = false)
    private MatchEntity match;

    /**
     * Hráč, kterého se registrace týká.
     */
    @ManyToOne
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    /**
     * Aktuální stav registrace hráče k zápasu.
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerMatchStatus status;

    /**
     * Důvod omluvy hráče (pouze pokud je hráč omluven).
     */
    @Enumerated(EnumType.STRING)
    private ExcuseReason excuseReason;

    /**
     * Volitelná poznámka k omluvě hráče.
     */
    private String excuseNote;

    /**
     * Administrativní poznámka k registraci
     * (např. neomluvená absence).
     */
    private String adminNote;

    /**
     * Tým, do kterého je hráč pro zápas zařazen.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "team")
    private Team team;

    /**
     * Časové razítko registrace.
     *
     * Používá se pro určení pořadí registrací
     * (např. při uvolnění místa po odhlášení).
     */
    @Column(nullable = false, updatable = true)
    private LocalDateTime timestamp = LocalDateTime.now();

    /**
     * Původ vytvoření registrace.
     *
     * Typicky:
     * - "user"   – registrace vytvořená hráčem,
     * - "system" – automatická registrace dle kapacity.
     */
    @Column(nullable = false, updatable = true)
    private String createdBy;

    public MatchRegistrationEntity() {
    }

    // gettery / settery

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public MatchEntity getMatch() { return match; }
    public void setMatch(MatchEntity match) { this.match = match; }

    public PlayerEntity getPlayer() { return player; }
    public void setPlayer(PlayerEntity player) { this.player = player; }

    public PlayerMatchStatus getStatus() { return status; }
    public void setStatus(PlayerMatchStatus status) { this.status = status; }

    public ExcuseReason getExcuseReason() { return excuseReason; }
    public void setExcuseReason(ExcuseReason excuseReason) { this.excuseReason = excuseReason; }

    public String getExcuseNote() { return excuseNote; }
    public void setExcuseNote(String excuseNote) { this.excuseNote = excuseNote; }

    public String getAdminNote() { return adminNote; }
    public void setAdminNote(String adminNote) { this.adminNote = adminNote; }

    public Team getTeam() { return team; }
    public void setTeam(Team team) { this.team = team; }

    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }

    public String getCreatedBy() { return createdBy; }
    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationHistoryEntity.java
-----

package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentující historický záznam změn registrace hráče k zápasu.
 *
 * Slouží k auditování změn registrací (vytvoření, úprava, zrušení)
 * a uchovává kompletní stav registrace v okamžiku změny.
 */
@Entity
@Table(name = "match_registration_history")
public class MatchRegistrationHistoryEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Typ provedené operace nad registrací.
     * (INSERT / UPDATE / DELETE)
     */
    @Column(name = "action", nullable = false)
    private String action;

    /**
     * Administrativní poznámka vztahující se k registraci.
     */
    @Column(name = "admin_note")
    private String adminNote;

    /**
     * Datum a čas provedení změny.
     */
    @Column(name = "changed_at", nullable = false)
    private LocalDateTime changedAt;

    /**
     * Původ vytvoření / změny registrace (např. "user", "system").
     */
    @Column(name = "created_by", nullable = false)
    private String createdBy;

    /**
     * Textová poznámka k omluvě hráče.
     */
    @Column(name = "excuse_note")
    private String excuseNote;

    /**
     * Důvod omluvy hráče (pokud byl stav EXCUSED).
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "excuse_reason")
    private ExcuseReason excuseReason;

    /**
     * ID zápasu, ke kterému se historický záznam vztahuje.
     */
    @Column(name = "match_id", nullable = false)
    private Long matchId;

    /**
     * ID původní registrace z hlavní tabulky.
     */
    @Column(name = "match_registration_id", nullable = false)
    private Long matchRegistrationId;

    /**
     * Původní časové razítko registrace.
     */
    @Column(name = "original_timestamp", nullable = false)
    private LocalDateTime originalTimestamp;

    /**
     * ID hráče, kterého se historický záznam týká.
     */
    @Column(name = "player_id", nullable = false)
    private Long playerId;

    /**
     * Stav registrace v okamžiku změny.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private PlayerMatchStatus status;

    /**
     * Tým, do kterého byl hráč v daném okamžiku zařazen.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "team")
    private Team team;

    public MatchRegistrationHistoryEntity() {
    }

    // ===== gettery / settery =====

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public String getAction() { return action; }

    public void setAction(String action) { this.action = action; }

    public String getAdminNote() { return adminNote; }

    public void setAdminNote(String adminNote) { this.adminNote = adminNote; }

    public LocalDateTime getChangedAt() { return changedAt; }

    public void setChangedAt(LocalDateTime changedAt) { this.changedAt = changedAt; }

    public String getCreatedBy() { return createdBy; }

    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }

    public String getExcuseNote() { return excuseNote; }

    public void setExcuseNote(String excuseNote) { this.excuseNote = excuseNote; }

    public ExcuseReason getExcuseReason() { return excuseReason; }

    public void setExcuseReason(ExcuseReason excuseReason) { this.excuseReason = excuseReason; }

    public Long getMatchId() { return matchId; }

    public void setMatchId(Long matchId) { this.matchId = matchId; }

    public Long getMatchRegistrationId() { return matchRegistrationId; }

    public void setMatchRegistrationId(Long matchRegistrationId) { this.matchRegistrationId = matchRegistrationId; }

    public LocalDateTime getOriginalTimestamp() { return originalTimestamp; }

    public void setOriginalTimestamp(LocalDateTime originalTimestamp) { this.originalTimestamp = originalTimestamp; }

    public Long getPlayerId() { return playerId; }

    public void setPlayerId(Long playerId) { this.playerId = playerId; }

    public PlayerMatchStatus getStatus() { return status; }

    public void setStatus(PlayerMatchStatus status) { this.status = status; }

    public Team getTeam() { return team; }

    public void setTeam(Team team) { this.team = team; }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\NotificationSettings.java
-----

package cz.phsoft.hokej.data.entities;

import jakarta.persistence.Embeddable;
// TODO - ASI SMAZAT PO OTESTOVÁNÍ Z SETTINGS
/**
 * Vnořitelný objekt reprezentující nastavení notifikací uživatele / hráče.
 *
 * Slouží k určení, jakými kanály si uživatel přeje
 * přijímat systémové notifikace.
 */
@Embeddable
public class NotificationSettings {

    /**
     * Příznak povolení emailových notifikací.
     */
    private boolean emailEnabled;

    /**
     * Příznak povolení SMS notifikací.
     */
    private boolean smsEnabled;

    // gettery / settery

    public boolean isEmailEnabled() { return emailEnabled; }
    public void setEmailEnabled(boolean emailEnabled) { this.emailEnabled = emailEnabled; }

    public boolean isSmsEnabled() { return smsEnabled; }
    public void setSmsEnabled(boolean smsEnabled) { this.smsEnabled = smsEnabled; }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerEntity.java
-----

package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerType;
import jakarta.persistence.*;

/**
 * Entita reprezentující hráče v systému.
 *
 * Hráč představuje sportovní identitu uživatele a je
 * používán při registracích na zápasy, notifikacích
 * a statistikách.
 */
@Entity
@Table(name = "player_entity")
public class PlayerEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String surname;

    /**
     * Volitelná přezdívka hráče.
     */
    private String nickname;

    /**
     * Typ hráče (např. BASIC, STANDARD, VIP).
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerType type;

    /**
     * Celé jméno hráče (odvozené z name + surname).
     */
    private String fullName;

    /**
     * Telefonní číslo hráče pro SMS notifikace.
     */
    private String phoneNumber;

    /**
     * Tým, ke kterému je hráč přiřazen.
     */
    @Enumerated(EnumType.STRING)
    private Team team;

    /**
     * Aktuální stav hráče v systému (např. PENDING, APPROVED).
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerStatus playerStatus = PlayerStatus.PENDING;

    /**
     * Uživatel, ke kterému hráč patří.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private AppUserEntity user;

    /**
     * Nastavení hráče – kontakty a notifikační preference.
     *
     * Jeden hráč má právě jedno PlayerSettingsEntity.
     */
    @OneToOne(mappedBy = "player", cascade = CascadeType.ALL, fetch = FetchType.LAZY, orphanRemoval = true)
    private PlayerSettingsEntity settings;

    // ==================================================
    // KONSTRUKTORY
    // ==================================================

    public PlayerEntity() {
        this.type = PlayerType.BASIC;
    }

    public PlayerEntity(String name,
                        String surname,
                        String nickname,
                        PlayerType type,
                        String phoneNumber,
                        Team team,
                        PlayerStatus playerStatus) {

        this.name = name;
        this.surname = surname;
        this.nickname = nickname;
        this.type = type;
        this.phoneNumber = phoneNumber;
        this.team = team;
        this.playerStatus = playerStatus;
        updateFullName();
    }

    // ==================================================
    // GETTERY / SETTERY
    // ==================================================

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) {
        this.name = name;
        updateFullName();
    }

    public String getSurname() { return surname; }
    public void setSurname(String surname) {
        this.surname = surname;
        updateFullName();
    }

    public String getNickname() { return nickname; }
    public void setNickname(String nickname) { this.nickname = nickname; }

    public String getFullName() { return fullName; }

    public PlayerType getType() { return type; }
    public void setType(PlayerType type) { this.type = type; }

    public String getPhoneNumber() { return phoneNumber; }
    public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }

    public Team getTeam() { return team; }
    public void setTeam(Team team) { this.team = team; }

    public PlayerStatus getPlayerStatus() { return playerStatus; }
    public void setPlayerStatus(PlayerStatus playerStatus) { this.playerStatus = playerStatus; }

    public AppUserEntity getUser() { return user; }
    public void setUser(AppUserEntity user) { this.user = user; }


    public PlayerSettingsEntity getSettings() { return settings; }

    public void setSettings(PlayerSettingsEntity settings) { this.settings = settings;
        if (settings != null) {
            settings.setPlayer(this);
        }
    }

    // ==================================================
    // HELPER
    // ==================================================

    /**
     * Aktualizuje celé jméno hráče podle jména a příjmení.
     */
    private void updateFullName() {
        this.fullName = name + " " + surname;
    }


}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerInactivityPeriodEntity.java
-----

package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentující období neaktivity hráče.
 *
 * Slouží k evidenci časových úseků, ve kterých hráč
 * není k dispozici (např. zranění, dovolená).
 */
@Entity
@Table(name = "player_inactivity_period")
public class PlayerInactivityPeriodEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Hráč, ke kterému se období neaktivity vztahuje.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    /**
     * Začátek období neaktivity.
     */
    @Column(name = "inactive_from", nullable = false)
    private LocalDateTime inactiveFrom;

    /**
     * Konec období neaktivity.
     */
    @Column(name = "inactive_to", nullable = false)
    private LocalDateTime inactiveTo;

    // gettery / settery

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public PlayerEntity getPlayer() { return player; }
    public void setPlayer(PlayerEntity player) { this.player = player; }

    public LocalDateTime getInactiveFrom() { return inactiveFrom; }
    public void setInactiveFrom(LocalDateTime inactiveFrom) { this.inactiveFrom = inactiveFrom; }

    public LocalDateTime getInactiveTo() { return inactiveTo; }
    public void setInactiveTo(LocalDateTime inactiveTo) { this.inactiveTo = inactiveTo; }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerSettingsEntity.java
-----

package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

/**
 * Entita uchovávající nastavení konkrétního hráče.
 *
 * Odděluje:
 * - identitu hráče (PlayerEntity: jméno, tým, status...)
 * - jeho notifikační preference a kontaktní údaje (PlayerSettingsEntity).
 */
@Entity
@Table(name = "player_settings")
public class PlayerSettingsEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Jeden záznam PlayerSettingsEntity pro jednoho hráče.
     */
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "player_id", nullable = false, unique = true)
    private PlayerEntity player;

    // =========================================
    // KONTAKT
    // =========================================

    /**
     * Volitelný email hráče.
     *
     * Pokud je null/prázdný, používá se email uživatele (AppUser.email).
     * Toto pole tedy představuje "override", nikoliv povinný údaj.
     */
    @Column(name = "contact_email", length = 255)
    private String contactEmail;

    /**
     * Volitelné telefonní číslo hráče pro SMS.
     *
     * Pokud je null/prázdné, můžeš se rozhodnout:
     * - buď SMS neposílat,
     * - nebo použít telefon z jiného zdroje (pokud ho máš).
     */
    @Column(name = "contact_phone", length = 50)
    private String contactPhone;

    // =========================================
    // KANÁLY (EMAIL / SMS)
    // =========================================

    /**
     * Má hráč dostávat emailové notifikace?
     *
     * Pozn.: i když je TRUE, je potřeba mít k dispozici
     * efektivní email (contactEmail nebo email účtu).
     */
    @Column(name = "email_enabled", nullable = false)
    private boolean emailEnabled = true;

    /**
     * Má hráč dostávat SMS notifikace?
     *
     * Opět je nutné mít vyplněný kontakt (contactPhone),
     * jinak se SMS nebude posílat.
     */
    @Column(name = "sms_enabled", nullable = false)
    private boolean smsEnabled = false;

    // =========================================
    // TYPY NOTIFIKACÍ (detailní flagy)
    // =========================================

    /**
     * Chce být hráč informován o své registraci / odhlášení na zápas?
     */
    @Column(name = "notify_on_registration", nullable = false)
    private boolean notifyOnRegistration = true;

    /**
     * Chce být hráč informován o změně svého statusu na omluveného (EXCUSED)?
     */
    @Column(name = "notify_on_excuse", nullable = false)
    private boolean notifyOnExcuse = true;

    /**
     * Chce být hráč informován o změnách zápasu
     * (čas, místo, popis...)?
     */
    @Column(name = "notify_on_match_change", nullable = false)
    private boolean notifyOnMatchChange = true;

    /**
     * Chce být hráč informován o zrušení zápasu?
     */
    @Column(name = "notify_on_match_cancel", nullable = false)
    private boolean notifyOnMatchCancel = true;

    /**
     * Chce hráč notifikace o platbách / dluzích / vyúčtování?
     * (zatím do budoucna, můžeš začít i s FALSE a používat později).
     */
    @Column(name = "notify_on_payment", nullable = false)
    private boolean notifyOnPayment = false;

    // =========================================
    // PŘIPOMÍNKY PŘED ZÁPASEM
    // =========================================

    /**
     * Má hráč dostávat připomínky před zápasem?
     */
    @Column(name = "notify_reminders", nullable = false)
    private boolean notifyReminders = true;

    /**
     * Kolik hodin před začátkem zápasu poslat připomínku.
     * Např. 24 = den předem.
     *
     * Pokud je null, můžeš v logice použít default (např. 24 h).
     */
    @Column(name = "reminder_hours_before")
    private Integer reminderHoursBefore = 24;

    // =========================================
    // "KATEGORIE" – odvozené pohledy pro NotificationType
    // =========================================

    /**
     * Kategorie REGISTRATION – registrování / odhlašování na zápas.
     */
    @Transient
    public boolean isRegistrationNotificationsEnabled() {
        return notifyOnRegistration;
    }

    /**
     * Kategorie EXCUSE – omluvy a neomluvení.
     */
    @Transient
    public boolean isExcuseNotificationsEnabled() {
        return notifyOnExcuse;
    }

    /**
     * Kategorie MATCH_INFO – info o zápase:
     * změna času/místa, zrušení, připomínky.
     */
    @Transient
    public boolean isMatchInfoNotificationsEnabled() {
        return notifyOnMatchChange
                || notifyOnMatchCancel
                || notifyReminders;
    }

    /**
     * Kategorie SYSTEM – systémové věci (např. platby, do budoucna další).
     * Zatím svážeme s notifyOnPayment.
     */
    @Transient
    public boolean isSystemNotificationsEnabled() {
        return notifyOnPayment;
    }

    // =========================================
    // GETTERY / SETTERY
    // =========================================

    public Long getId() {
        return id;
    }

    public PlayerEntity getPlayer() {
        return player;
    }

    public void setPlayer(PlayerEntity player) {
        this.player = player;
    }

    public String getContactEmail() {
        return contactEmail;
    }

    public void setContactEmail(String contactEmail) {
        this.contactEmail = contactEmail;
    }

    public String getContactPhone() {
        return contactPhone;
    }

    public void setContactPhone(String contactPhone) {
        this.contactPhone = contactPhone;
    }

    public boolean isEmailEnabled() {
        return emailEnabled;
    }

    public void setEmailEnabled(boolean emailEnabled) {
        this.emailEnabled = emailEnabled;
    }

    public boolean isSmsEnabled() {
        return smsEnabled;
    }

    public void setSmsEnabled(boolean smsEnabled) {
        this.smsEnabled = smsEnabled;
    }

    public boolean isNotifyOnRegistration() {
        return notifyOnRegistration;
    }

    public void setNotifyOnRegistration(boolean notifyOnRegistration) {
        this.notifyOnRegistration = notifyOnRegistration;
    }

    public boolean isNotifyOnExcuse() {
        return notifyOnExcuse;
    }

    public void setNotifyOnExcuse(boolean notifyOnExcuse) {
        this.notifyOnExcuse = notifyOnExcuse;
    }

    public boolean isNotifyOnMatchChange() {
        return notifyOnMatchChange;
    }

    public void setNotifyOnMatchChange(boolean notifyOnMatchChange) {
        this.notifyOnMatchChange = notifyOnMatchChange;
    }

    public boolean isNotifyOnMatchCancel() {
        return notifyOnMatchCancel;
    }

    public void setNotifyOnMatchCancel(boolean notifyOnMatchCancel) {
        this.notifyOnMatchCancel = notifyOnMatchCancel;
    }

    public boolean isNotifyOnPayment() {
        return notifyOnPayment;
    }

    public void setNotifyOnPayment(boolean notifyOnPayment) {
        this.notifyOnPayment = notifyOnPayment;
    }

    public boolean isNotifyReminders() {
        return notifyReminders;
    }

    public void setNotifyReminders(boolean notifyReminders) {
        this.notifyReminders = notifyReminders;
    }

    public Integer getReminderHoursBefore() {
        return reminderHoursBefore;
    }

    public void setReminderHoursBefore(Integer reminderHoursBefore) {
        this.reminderHoursBefore = reminderHoursBefore;
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\SeasonEntity.java
-----

package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDate;

/**
 * Entita reprezentující sezónu.
 *
 * Sezóna vymezuje časové období, do kterého
 * spadají zápasy a související data.
 */
@Entity
@Table(name = "season")
public class SeasonEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Název sezóny (např. "2024/2025").
     */
    @Column(nullable = false)
    private String name;

    /**
     * Datum začátku sezóny.
     */
    @Column(nullable = false)
    private LocalDate startDate;

    /**
     * Datum konce sezóny.
     */
    @Column(nullable = false)
    private LocalDate endDate;

    /**
     * Příznak aktivní sezóny.
     */
    private boolean active;

    // gettery / settery

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public LocalDate getStartDate() { return startDate; }
    public void setStartDate(LocalDate startDate) { this.startDate = startDate; }

    public LocalDate getEndDate() { return endDate; }
    public void setEndDate(LocalDate endDate) { this.endDate = endDate; }

    public boolean isActive() { return active; }
    public void setActive(boolean active) { this.active = active; }
}


