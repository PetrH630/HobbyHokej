Balíček (složka): entities
Cesta: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities

Seznam souborů:
AppUserEntity.java
AppUserHistoryEntity.java
AppUserSettingsEntity.java
EmailVerificationTokenEntity.java
ForgottenPasswordResetTokenEntity.java
MatchEntity.java
MatchHistoryEntity.java
MatchRegistrationEntity.java
MatchRegistrationHistoryEntity.java
package-info.java
PlayerEntity.java
PlayerHistoryEntity.java
PlayerInactivityPeriodEntity.java
PlayerSettingsEntity.java
SeasonEntity.java
SeasonHistoryEntity.java



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\AppUserEntity.java
-----

package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.Role;
import jakarta.persistence.*;

import java.time.LocalDateTime;
import java.util.Set;

/**
 * Entita reprezentující uživatelský účet aplikace.
 *
 * Slouží pro autentizaci a autorizaci uživatelů v systému.
 * Uchovává základní identifikační údaje, přihlašovací informace,
 * roli uživatele a stav aktivace účtu.
 *
 * Jeden uživatel může mít přiřazeno více hráčů. Detailní uživatelské
 * preference a nastavení jsou odděleny do entity AppUserSettingsEntity.
 */
@Entity
@Table(name = "app_users")
public class AppUserEntity {

    /**
     * Primární klíč uživatele.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Křestní jméno uživatele.
     */
    @Column(nullable = false)
    private String name;

    /**
     * Příjmení uživatele.
     * Při uložení je převáděno na velká písmena.
     */
    @Column(nullable = false)
    private String surname;

    /**
     * Unikátní e-mail uživatele sloužící pro přihlášení do systému.
     */
    @Column(nullable = false, unique = true)
    private String email;

    /**
     * Hash hesla uživatele.
     * Heslo se nikdy neukládá v otevřené podobě.
     */
    @Column(nullable = false)
    private String password;

    /**
     * Role uživatele v systému.
     * Určuje oprávnění uživatele při přístupu k jednotlivým endpointům.
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role;

    /**
     * Příznak aktivace účtu.
     * Nastavuje se například po úspěšné e-mailové aktivaci účtu.
     */
    @Column(nullable = false)
    private boolean enabled = false;

    /**
     * Hráči přiřazení k tomuto uživateli.
     *
     * Vztah je typu one-to-many, kdy jeden uživatel může mít více hráčů.
     * Životní cyklus hráčů je navázán na uživatele.
     */
    @OneToMany(
            mappedBy = "user",
            cascade = CascadeType.ALL,
            orphanRemoval = true
    )
    private Set<PlayerEntity> players;

    /**
     * Nastavení uživatele.
     *
     * Obsahuje například způsob výběru aktuálního hráče,
     * nastavení notifikací a další preference.
     * Jeden uživatel má právě jedno nastavení.
     */
    @OneToOne(mappedBy = "user",
            cascade = CascadeType.ALL,
            fetch = FetchType.LAZY,
            orphanRemoval = true)
    private AppUserSettingsEntity settings;

    /**
     * Časové razítko uživatele.
     *
     * Uchovává datum a čas poslední změny entity.
     * Hodnota se aktualizuje při vytvoření i při každé úpravě záznamu.
     */
    @Column(nullable = false, updatable = true)
    private LocalDateTime timestamp = LocalDateTime.now();

    /**
     * Metoda volaná před prvním uložením entity.
     *
     * Nastavuje aktuální časové razítko a převádí příjmení
     * na velká písmena.
     */
    @PrePersist
    public void prePersist() {
        this.timestamp = LocalDateTime.now();
        if (surname != null) {
            this.surname = this.surname.toUpperCase();
        }
    }

    /**
     * Metoda volaná před aktualizací entity.
     *
     * Aktualizuje časové razítko a převádí příjmení
     * na velká písmena.
     */
    @PreUpdate
    public void preUpdate() {
        this.timestamp = LocalDateTime.now();
        if (surname != null) {
            this.surname = this.surname.toUpperCase();
        }
    }

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }

    public void setName(String name) { this.name = name; }

    public String getSurname() { return surname; }

    public void setSurname(String surname) { this.surname = surname.toUpperCase(); }

    public String getEmail() { return email; }

    public void setEmail(String email) { this.email = email; }

    public String getPassword() { return password; }

    public void setPassword(String password) { this.password = password; }

    public Role getRole() { return role; }

    public void setRole(Role role) { this.role = role; }

    public boolean isEnabled() { return enabled; }

    public void setEnabled(boolean enabled) { this.enabled = enabled; }

    public Set<PlayerEntity> getPlayers() { return players; }

    public void setPlayers(Set<PlayerEntity> players) { this.players = players; }

    public AppUserSettingsEntity getSettings() { return settings; }

    /**
     * Nastavuje uživatelské nastavení a zároveň zajišťuje obousměrnou vazbu.
     *
     * @param settings instance nastavení uživatele
     */
    public void setSettings(AppUserSettingsEntity settings) {
        this.settings = settings;
        if (settings != null) {
            settings.setUser(this);
        }
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\AppUserHistoryEntity.java
-----

package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.Role;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentující historický záznam o uživateli.
 *
 * Slouží pro auditní účely a uchovávání změn uživatelského účtu v čase.
 * Každý záznam představuje stav uživatele v okamžiku provedení operace
 * nad hlavní entitou AppUserEntity.
 *
 * Záznamy jsou typicky vytvářeny databázovým triggerem při operacích
 * INSERT, UPDATE nebo DELETE.
 */
@Entity
@Table(name = "app_users_history")
public class AppUserHistoryEntity {

    /**
     * Primární klíč historického záznamu.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Typ provedené operace.
     *
     * Typicky se jedná o hodnoty INSERT, UPDATE nebo DELETE.
     */
    @Column(name = "action", nullable = false)
    private String action;

    /**
     * Datum a čas provedení změny.
     *
     * Udává okamžik vytvoření historického záznamu.
     */
    @Column(name = "changed_at", nullable = false)
    private LocalDateTime changedAt;

    /**
     * ID uživatele z hlavní tabulky app_users.
     *
     * Slouží pro propojení historického záznamu s původní entitou uživatele.
     */
    @Column(name = "user_id", nullable = false)
    private Long userId;

    /**
     * Původní časové razítko uživatele.
     *
     * Jedná se o hodnotu timestamp z AppUserEntity v okamžiku změny.
     * Umožňuje dohledat přesný stav uživatele při konkrétní operaci.
     */
    @Column(name = "original_timestamp", nullable = false)
    private LocalDateTime originalTimestamp;

    /**
     * Jméno uživatele v okamžiku změny.
     */
    @Column(name = "name", nullable = false)
    private String name;

    /**
     * Příjmení uživatele v okamžiku změny.
     */
    @Column(name = "surname", nullable = false)
    private String surname;

    /**
     * E-mail uživatele v okamžiku změny.
     */
    @Column(name = "email", nullable = false)
    private String email;

    /**
     * Role uživatele v okamžiku změny.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "role", nullable = false)
    private Role role;

    /**
     * Stav aktivace účtu v okamžiku změny.
     */
    @Column(name = "enabled", nullable = false)
    private boolean enabled;

    /**
     * Bezparametrický konstruktor požadovaný JPA.
     */
    public AppUserHistoryEntity() {
    }

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getAction() { return action; }
    public void setAction(String action) { this.action = action; }

    public LocalDateTime getChangedAt() { return changedAt; }
    public void setChangedAt(LocalDateTime changedAt) { this.changedAt = changedAt; }

    public Long getUserId() { return userId; }
    public void setUserId(Long userId) { this.userId = userId; }

    public LocalDateTime getOriginalTimestamp() { return originalTimestamp; }
    public void setOriginalTimestamp(LocalDateTime originalTimestamp) { this.originalTimestamp = originalTimestamp; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getSurname() { return surname; }
    public void setSurname(String surname) { this.surname = surname; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public Role getRole() { return role; }
    public void setRole(Role role) { this.role = role; }

    public boolean isEnabled() { return enabled; }
    public void setEnabled(boolean enabled) { this.enabled = enabled; }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\AppUserSettingsEntity.java
-----

package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.PlayerSelectionMode;
import cz.phsoft.hokej.data.enums.GlobalNotificationLevel;
import jakarta.persistence.*;

import java.time.LocalTime;

/**
 * Entita uchovávající nastavení uživatelského účtu.
 *
 * Odděluje identitu uživatele (AppUserEntity) od jeho preferencí
 * a chování v systému (AppUserSettingsEntity). Slouží zejména
 * pro nastavení výběru hráče, globální úrovně notifikací a
 * preferencí souvisejících s uživatelským rozhraním.
 */
@Entity
@Table(name = "app_user_settings")
public class AppUserSettingsEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Uživatel, ke kterému tato nastavení patří.
     * Pro jednoho uživatele existuje právě jeden záznam nastavení.
     */
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false, unique = true)
    private AppUserEntity user;

    /**
     * Způsob automatického výběru hráče po přihlášení
     * nebo při auto-select logice.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "player_selection_mode", nullable = false, length = 50)
    private PlayerSelectionMode playerSelectionMode = PlayerSelectionMode.FIRST_PLAYER;

    /**
     * Globální úroveň notifikací pro uživatele.
     * Určuje, kolik notifikací bude uživatel dostávat
     * bez ohledu na nastavení konkrétních hráčů.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "global_notification_level", nullable = false, length = 50)
    private GlobalNotificationLevel globalNotificationLevel = GlobalNotificationLevel.ALL;

    /**
     * Úroveň notifikací, které má uživatel dostávat v roli manažera.
     *
     * Hodnota se používá při rozhodování, zda mají být zasílány
     * kopie notifikací na e-mail uživatele, pokud má zároveň
     * roli manažera. Nastavení ovlivňuje pouze manažerské kopie,
     * nikoliv notifikace určené přímo tomuto uživateli nebo hráčům.
     *
     * Pokud je hodnota null, používá se hodnota globalNotificationLevel
     * jako výchozí chování.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "manager_notification_level", length = 50)
    private GlobalNotificationLevel managerNotificationLevel;

    /**
     * Určuje, zda má uživatel dostávat kopie všech notifikací,
     * které chodí jeho hráčům.
     *
     * Příklad:
     * true: rodič chce mít přehled o všem, co se děje u dětí.
     * false: spoléhá se pouze na notifikace hráčů.
     */
    @Column(name = "copy_all_player_notifications_to_user_email", nullable = false)
    private boolean copyAllPlayerNotificationsToUserEmail = true;

    /**
     * Určuje, zda má uživatel dostávat notifikace i za hráče,
     * kteří mají vlastní email (contactEmail v PlayerSettings).
     *
     * Příklad:
     * false: pokud má hráč vlastní email, chodí notifikace pouze jemu.
     * true: uživatel dostává kopie notifikací i v tomto případě.
     */
    @Column(name = "receive_notifications_for_players_with_own_email", nullable = false)
    private boolean receiveNotificationsForPlayersWithOwnEmail = false;

    /**
     * Určuje, zda má být používán denní souhrn (digest) místo
     * jednotlivých notifikací během dne.
     */
    @Column(name = "email_digest_enabled", nullable = false)
    private boolean emailDigestEnabled = false;

    /**
     * Čas, kdy má chodit souhrnný email, pokud je digest zapnutý.
     */
    @Column(name = "email_digest_time")
    private LocalTime emailDigestTime;

    /**
     * Preferovaný jazyk uživatelského rozhraní.
     * Například "cs" nebo "en".
     */
    @Column(name = "ui_language", length = 10)
    private String uiLanguage = "cs";

    /**
     * Časová zóna uživatele.
     * Například "Europe/Prague".
     */
    @Column(name = "timezone", length = 50)
    private String timezone = "Europe/Prague";

    /**
     * Výchozí obrazovka po přihlášení.
     * Z praktických důvodů je uložena jako řetězec.
     */
    @Column(name = "default_landing_page", length = 50)
    private String defaultLandingPage = "DASHBOARD";

    public Long getId() {
        return id;
    }

    public AppUserEntity getUser() {
        return user;
    }

    public void setUser(AppUserEntity user) {
        this.user = user;
    }

    public PlayerSelectionMode getPlayerSelectionMode() {
        return playerSelectionMode;
    }

    public void setPlayerSelectionMode(PlayerSelectionMode playerSelectionMode) {
        this.playerSelectionMode = playerSelectionMode;
    }

    public GlobalNotificationLevel getGlobalNotificationLevel() {
        return globalNotificationLevel;
    }

    public void setGlobalNotificationLevel(GlobalNotificationLevel globalNotificationLevel) {
        this.globalNotificationLevel = globalNotificationLevel;
    }

    public GlobalNotificationLevel getManagerNotificationLevel() {
        return managerNotificationLevel;
    }

    public void setManagerNotificationLevel(GlobalNotificationLevel managerNotificationLevel) {
        this.managerNotificationLevel = managerNotificationLevel;
    }

    public boolean isCopyAllPlayerNotificationsToUserEmail() {
        return copyAllPlayerNotificationsToUserEmail;
    }

    public void setCopyAllPlayerNotificationsToUserEmail(boolean copyAllPlayerNotificationsToUserEmail) {
        this.copyAllPlayerNotificationsToUserEmail = copyAllPlayerNotificationsToUserEmail;
    }

    public boolean isReceiveNotificationsForPlayersWithOwnEmail() {
        return receiveNotificationsForPlayersWithOwnEmail;
    }

    public void setReceiveNotificationsForPlayersWithOwnEmail(boolean receiveNotificationsForPlayersWithOwnEmail) {
        this.receiveNotificationsForPlayersWithOwnEmail = receiveNotificationsForPlayersWithOwnEmail;
    }

    public boolean isEmailDigestEnabled() {
        return emailDigestEnabled;
    }

    public void setEmailDigestEnabled(boolean emailDigestEnabled) {
        this.emailDigestEnabled = emailDigestEnabled;
    }

    public LocalTime getEmailDigestTime() {
        return emailDigestTime;
    }

    public void setEmailDigestTime(LocalTime emailDigestTime) {
        this.emailDigestTime = emailDigestTime;
    }

    public String getUiLanguage() {
        return uiLanguage;
    }

    public void setUiLanguage(String uiLanguage) {
        this.uiLanguage = uiLanguage;
    }

    public String getTimezone() {
        return timezone;
    }

    public void setTimezone(String timezone) {
        this.timezone = timezone;
    }

    public String getDefaultLandingPage() {
        return defaultLandingPage;
    }

    public void setDefaultLandingPage(String defaultLandingPage) {
        this.defaultLandingPage = defaultLandingPage;
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\EmailVerificationTokenEntity.java
-----

package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentující ověřovací token pro emailovou aktivaci uživatele.
 *
 * Slouží k ověření emailové adresy a aktivaci uživatelského účtu.
 * Token je časově omezený a navázaný na konkrétního uživatele.
 */
@Entity
@Table(name = "email_verification_tokens")
public class EmailVerificationTokenEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Unikátní ověřovací token.
     */
    @Column(nullable = false, unique = true, length = 64)
    private String token;

    /**
     * Datum a čas expirace tokenu.
     */
    @Column(nullable = false)
    private LocalDateTime expiresAt;

    /**
     * Uživatel, ke kterému je token přiřazen.
     */
    @OneToOne
    @JoinColumn(name = "user_id", nullable = false)
    private AppUserEntity user;

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public String getToken() { return token; }

    public void setToken(String token) { this.token = token; }

    public LocalDateTime getExpiresAt() { return expiresAt; }

    public void setExpiresAt(LocalDateTime expiresAt) { this.expiresAt = expiresAt; }

    public AppUserEntity getUser() { return user; }

    public void setUser(AppUserEntity user) { this.user = user; }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\ForgottenPasswordResetTokenEntity.java
-----

package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;
import java.time.LocalDateTime;

/**
 * Entita reprezentující token pro reset zapomenutého hesla.
 *
 * Slouží k bezpečnému nastavení nového hesla uživatele.
 * Token je časově omezený a navázaný na konkrétního uživatele.
 * Volitelné pole usedAt umožňuje evidovat okamžik použití tokenu.
 */
@Entity
@Table(name = "forgotten_password_reset_token_entity")
public class ForgottenPasswordResetTokenEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Unikátní resetovací token.
     */
    @Column(nullable = false, unique = true, length = 128)
    private String token;

    /**
     * Uživatel, ke kterému token patří.
     */
    @ManyToOne(optional = false, fetch = FetchType.LAZY)
    private AppUserEntity user;

    /**
     * Datum a čas expirace tokenu.
     */
    @Column(nullable = false)
    private LocalDateTime expiresAt;

    /**
     * Datum a čas, kdy byl token použit.
     * Hodnota je volitelná a slouží pro auditní účely.
     */
    private LocalDateTime usedAt;

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public String getToken() { return token; }

    public void setToken(String token) { this.token = token; }

    public AppUserEntity getUser() { return user; }

    public void setUser(AppUserEntity user) { this.user = user; }

    public LocalDateTime getExpiresAt() { return expiresAt; }

    public void setExpiresAt(LocalDateTime expiresAt) { this.expiresAt = expiresAt; }

    public LocalDateTime getUsedAt() { return usedAt; }

    public void setUsedAt(LocalDateTime usedAt) { this.usedAt = usedAt; }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchEntity.java
-----

package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.MatchCancelReason;
import cz.phsoft.hokej.data.enums.MatchStatus;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentující hokejový zápas.
 *
 * Uchovává základní informace o zápasu, jeho kapacitě,
 * ceně, aktuálním stavu a vazbě na sezónu.
 * Informace o účasti hráčů jsou uloženy v samostatné entitě
 * MatchRegistrationEntity.
 *
 * Entita dále obsahuje auditní údaje o vytvoření a poslední
 * úpravě zápasu.
 */
@Entity
@Table(name = "matches")
public class MatchEntity {

    /**
     * Primární klíč zápasu.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Datum a čas konání zápasu.
     */
    @Column(nullable = false)
    private LocalDateTime dateTime;

    /**
     * Místo konání zápasu.
     */
    @Column(nullable = false)
    private String location;

    /**
     * Volitelný popis zápasu.
     *
     * Slouží například pro doplňující informace o organizaci zápasu.
     */
    private String description;

    /**
     * Maximální počet hráčů povolených pro zápas.
     *
     * Hodnota se používá pro kontrolu kapacity při registraci hráčů.
     */
    @Column(nullable = false)
    private Integer maxPlayers;

    /**
     * Celková cena zápasu.
     *
     * Hodnota může sloužit pro výpočet podílu jednotlivých hráčů.
     */
    @Column(nullable = false)
    private Integer price;

    /**
     * Aktuální stav zápasu.
     *
     * Stav určuje, zda je zápas plánovaný, zrušený nebo například odehraný.
     */
    @Enumerated(EnumType.STRING)
    private MatchStatus matchStatus;

    /**
     * Důvod zrušení zápasu.
     *
     * Vyplňuje se pouze v případě, že je zápas zrušen.
     */
    @Enumerated(EnumType.STRING)
    private MatchCancelReason cancelReason;

    /**
     * Sezóna, do které zápas patří.
     *
     * Každý zápas musí být přiřazen k existující sezóně.
     */
    @ManyToOne(optional = false)
    @JoinColumn(name = "season_id", nullable = false)
    private SeasonEntity season;

    /**
     * Časové razítko zápasu.
     *
     * Uchovává datum a čas vytvoření nebo poslední změny zápasu.
     * Hodnota se aktualizuje při každé změně záznamu.
     */
    @Column(nullable = false, updatable = true)
    private LocalDateTime timestamp = LocalDateTime.now();

    /**
     * ID uživatele, který zápas vytvořil.
     *
     * Slouží pro auditní účely.
     */
    @Column(name = "created_by_user_id")
    private Long createdByUserId;

    /**
     * ID uživatele, který zápas naposledy změnil.
     *
     * Slouží pro auditní účely a sledování odpovědnosti za změny.
     */
    @Column(name = "last_modified_by_user_id")
    private Long lastModifiedByUserId;

    /**
     * Bezparametrický konstruktor požadovaný JPA.
     */
    public MatchEntity() {
    }

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }

    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }

    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }

    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }

    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() { return price; }

    public void setPrice(Integer price) { this.price = price; }

    public MatchStatus getMatchStatus() { return matchStatus; }

    public void setMatchStatus(MatchStatus matchStatus) { this.matchStatus = matchStatus; }

    public MatchCancelReason getCancelReason() { return cancelReason; }

    public void setCancelReason(MatchCancelReason cancelReason) { this.cancelReason = cancelReason; }

    public SeasonEntity getSeason() { return season; }

    public void setSeason(SeasonEntity season) { this.season = season; }

    public LocalDateTime getTimestamp() { return timestamp; }

    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }

    public Long getCreatedByUserId() { return createdByUserId; }

    public void setCreatedByUserId(Long createdByUserId) { this.createdByUserId = createdByUserId; }

    public Long getLastModifiedByUserId() { return lastModifiedByUserId; }

    public void setLastModifiedByUserId(Long lastModifiedByUserId) { this.lastModifiedByUserId = lastModifiedByUserId; }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchHistoryEntity.java
-----

package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.MatchCancelReason;
import cz.phsoft.hokej.data.enums.MatchStatus;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentující historický záznam o zápasu.
 *
 * Slouží pro auditní účely a uchovávání změn zápasů v čase.
 * Každý záznam představuje stav zápasu v okamžiku provedení operace
 * nad hlavní entitou MatchEntity.
 *
 * Záznamy jsou typicky vytvářeny databázovým triggerem při operacích
 * INSERT, UPDATE nebo DELETE.
 */
@Entity
@Table(name = "matches_history")
public class MatchHistoryEntity {

    /**
     * Primární klíč historického záznamu.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Typ provedené operace nad zápasem.
     *
     * Typicky se jedná o hodnoty INSERT, UPDATE nebo DELETE.
     */
    @Column(name = "action", nullable = false)
    private String action;

    /**
     * Datum a čas provedení změny.
     *
     * Udává okamžik vytvoření historického záznamu.
     */
    @Column(name = "changed_at", nullable = false)
    private LocalDateTime changedAt;

    /**
     * ID zápasu z hlavní tabulky matches.
     *
     * Slouží pro propojení historického záznamu s původní entitou zápasu.
     */
    @Column(name = "match_id", nullable = false)
    private Long matchId;

    /**
     * Původní časové razítko zápasu.
     *
     * Jedná se o hodnotu sloupce timestamp z MatchEntity
     * v okamžiku provedení změny.
     */
    @Column(name = "original_timestamp", nullable = false)
    private LocalDateTime originalTimestamp;

    /**
     * Datum a čas konání zápasu v okamžiku změny.
     */
    @Column(name = "date_time", nullable = false)
    private LocalDateTime dateTime;

    /**
     * Místo konání zápasu v okamžiku změny.
     */
    @Column(name = "location", nullable = false)
    private String location;

    /**
     * Popis zápasu v okamžiku změny.
     */
    @Column(name = "description")
    private String description;

    /**
     * Maximální počet hráčů povolených pro zápas v okamžiku změny.
     */
    @Column(name = "max_players", nullable = false)
    private Integer maxPlayers;

    /**
     * Cena zápasu v okamžiku změny.
     */
    @Column(name = "price", nullable = false)
    private Integer price;

    /**
     * Stav zápasu v okamžiku změny.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "match_status")
    private MatchStatus matchStatus;

    /**
     * Důvod zrušení zápasu v okamžiku změny.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "cancel_reason")
    private MatchCancelReason cancelReason;

    /**
     * ID sezóny, do které zápas patřil v okamžiku změny.
     */
    @Column(name = "season_id", nullable = false)
    private Long seasonId;

    /**
     * ID uživatele, který zápas původně vytvořil.
     */
    @Column(name = "created_by_user_id")
    private Long createdByUserId;

    /**
     * ID uživatele, který zápas naposledy změnil před vytvořením
     * historického záznamu.
     */
    @Column(name = "last_modified_by_user_id")
    private Long lastModifiedByUserId;

    /**
     * Bezparametrický konstruktor požadovaný JPA.
     */
    public MatchHistoryEntity() {
    }

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getAction() { return action; }
    public void setAction(String action) { this.action = action; }

    public LocalDateTime getChangedAt() { return changedAt; }
    public void setChangedAt(LocalDateTime changedAt) { this.changedAt = changedAt; }

    public Long getMatchId() { return matchId; }
    public void setMatchId(Long matchId) { this.matchId = matchId; }

    public LocalDateTime getOriginalTimestamp() { return originalTimestamp; }
    public void setOriginalTimestamp(LocalDateTime originalTimestamp) { this.originalTimestamp = originalTimestamp; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }
    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() { return price; }
    public void setPrice(Integer price) { this.price = price; }

    public MatchStatus getMatchStatus() { return matchStatus; }
    public void setMatchStatus(MatchStatus matchStatus) { this.matchStatus = matchStatus; }

    public MatchCancelReason getCancelReason() { return cancelReason; }
    public void setCancelReason(MatchCancelReason cancelReason) { this.cancelReason = cancelReason; }

    public Long getSeasonId() { return seasonId; }
    public void setSeasonId(Long seasonId) { this.seasonId = seasonId; }

    public Long getCreatedByUserId() { return createdByUserId; }
    public void setCreatedByUserId(Long createdByUserId) { this.createdByUserId = createdByUserId; }

    public Long getLastModifiedByUserId() { return lastModifiedByUserId; }
    public void setLastModifiedByUserId(Long lastModifiedByUserId) { this.lastModifiedByUserId = lastModifiedByUserId; }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationEntity.java
-----

package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentující registraci hráče k zápasu.
 *
 * Uchovává informace o účasti hráče, jeho aktuálním stavu,
 * případné omluvě a administrativních poznámkách. Samostatná
 * entita umožňuje sledovat změny registrace a pracovat
 * s historií účasti.
 */
@Entity
@Table(name = "match_registrations")
public class MatchRegistrationEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Zápas, ke kterému se registrace vztahuje.
     */
    @ManyToOne
    @JoinColumn(name = "match_id", nullable = false)
    private MatchEntity match;

    /**
     * Hráč, kterého se registrace týká.
     */
    @ManyToOne
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    /**
     * Aktuální stav registrace hráče k zápasu.
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerMatchStatus status;

    /**
     * Důvod omluvy hráče, pokud je hráč omluven.
     */
    @Enumerated(EnumType.STRING)
    private ExcuseReason excuseReason;

    /**
     * Volitelná poznámka k omluvě hráče.
     */
    private String excuseNote;

    /**
     * Administrativní poznámka k registraci.
     */
    private String adminNote;

    /**
     * Tým, do kterého je hráč pro zápas zařazen.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "team")
    private Team team;

    /**
     * Časové razítko registrace.
     * Používá se například pro určení pořadí přihlášení.
     */
    @Column(nullable = false, updatable = true)
    private LocalDateTime timestamp = LocalDateTime.now();

    /**
     * Původ vytvoření registrace.
     * Typické hodnoty jsou například "user" nebo "system".
     */
    @Column(nullable = false, updatable = true)
    private String createdBy;

    public MatchRegistrationEntity() {
    }

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public MatchEntity getMatch() { return match; }

    public void setMatch(MatchEntity match) { this.match = match; }

    public PlayerEntity getPlayer() { return player; }

    public void setPlayer(PlayerEntity player) { this.player = player; }

    public PlayerMatchStatus getStatus() { return status; }

    public void setStatus(PlayerMatchStatus status) { this.status = status; }

    public ExcuseReason getExcuseReason() { return excuseReason; }

    public void setExcuseReason(ExcuseReason excuseReason) { this.excuseReason = excuseReason; }

    public String getExcuseNote() { return excuseNote; }

    public void setExcuseNote(String excuseNote) { this.excuseNote = excuseNote; }

    public String getAdminNote() { return adminNote; }

    public void setAdminNote(String adminNote) { this.adminNote = adminNote; }

    public Team getTeam() { return team; }

    public void setTeam(Team team) { this.team = team; }

    public LocalDateTime getTimestamp() { return timestamp; }

    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }

    public String getCreatedBy() { return createdBy; }

    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationHistoryEntity.java
-----

package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentující historický záznam změn registrace hráče k zápasu.
 *
 * Slouží k auditování změn registrací, včetně vytvoření, úprav a zrušení.
 * Uchovává stav registrace v okamžiku změny a základní údaje o původu
 * provedené operace.
 */
@Entity
@Table(name = "match_registration_history")
public class MatchRegistrationHistoryEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Typ provedené operace nad registrací.
     * Typicky hodnoty INSERT, UPDATE nebo DELETE.
     */
    @Column(name = "action", nullable = false)
    private String action;

    /**
     * Administrativní poznámka vztahující se k registraci.
     */
    @Column(name = "admin_note")
    private String adminNote;

    /**
     * Datum a čas provedení změny.
     */
    @Column(name = "changed_at", nullable = false)
    private LocalDateTime changedAt;

    /**
     * Původ vytvoření nebo změny registrace.
     * Typicky hodnoty jako "user" nebo "system".
     */
    @Column(name = "created_by", nullable = false)
    private String createdBy;

    /**
     * Textová poznámka k omluvě hráče.
     */
    @Column(name = "excuse_note")
    private String excuseNote;

    /**
     * Důvod omluvy hráče, pokud byl stav omluvený.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "excuse_reason")
    private ExcuseReason excuseReason;

    /**
     * ID zápasu, ke kterému se historický záznam vztahuje.
     */
    @Column(name = "match_id", nullable = false)
    private Long matchId;

    /**
     * ID původní registrace z hlavní tabulky registrací.
     */
    @Column(name = "match_registration_id", nullable = false)
    private Long matchRegistrationId;

    /**
     * Původní časové razítko registrace.
     */
    @Column(name = "original_timestamp", nullable = false)
    private LocalDateTime originalTimestamp;

    /**
     * ID hráče, kterého se historický záznam týká.
     */
    @Column(name = "player_id", nullable = false)
    private Long playerId;

    /**
     * Stav registrace v okamžiku změny.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private PlayerMatchStatus status;

    /**
     * Tým, do kterého byl hráč v daném okamžiku zařazen.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "team")
    private Team team;

    public MatchRegistrationHistoryEntity() {
    }

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public String getAction() { return action; }

    public void setAction(String action) { this.action = action; }

    public String getAdminNote() { return adminNote; }

    public void setAdminNote(String adminNote) { this.adminNote = adminNote; }

    public LocalDateTime getChangedAt() { return changedAt; }

    public void setChangedAt(LocalDateTime changedAt) { this.changedAt = changedAt; }

    public String getCreatedBy() { return createdBy; }

    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }

    public String getExcuseNote() { return excuseNote; }

    public void setExcuseNote(String excuseNote) { this.excuseNote = excuseNote; }

    public ExcuseReason getExcuseReason() { return excuseReason; }

    public void setExcuseReason(ExcuseReason excuseReason) { this.excuseReason = excuseReason; }

    public Long getMatchId() { return matchId; }

    public void setMatchId(Long matchId) { this.matchId = matchId; }

    public Long getMatchRegistrationId() { return matchRegistrationId; }

    public void setMatchRegistrationId(Long matchRegistrationId) { this.matchRegistrationId = matchRegistrationId; }

    public LocalDateTime getOriginalTimestamp() { return originalTimestamp; }

    public void setOriginalTimestamp(LocalDateTime originalTimestamp) { this.originalTimestamp = originalTimestamp; }

    public Long getPlayerId() { return playerId; }

    public void setPlayerId(Long playerId) { this.playerId = playerId; }

    public PlayerMatchStatus getStatus() { return status; }

    public void setStatus(PlayerMatchStatus status) { this.status = status; }

    public Team getTeam() { return team; }

    public void setTeam(Team team) { this.team = team; }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\package-info.java
-----

/**
 * Databázové entity aplikace.
 *
 * Reprezentují perzistentní doménový model systému
 * mapovaný pomocí JPA/Hibernate na databázové tabulky.
 *
 * Entity:
 * - definují vztahy mezi daty (OneToMany, ManyToOne, apod.),
 * - nejsou určeny pro přímou komunikaci s frontendem,
 * - jsou používány výhradně v repository a service vrstvě.
 */
package cz.phsoft.hokej.data.entities;



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerEntity.java
-----

package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerType;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentující hráče v systému.
 *
 * Hráč představuje sportovní identitu používanou při registracích
 * na zápasy, notifikacích a vyhodnocování účasti. Hráč může,
 * ale nemusí mít přiřazen aplikační uživatelský účet.
 *
 * Entita obsahuje základní identifikační údaje, stav hráče
 * v systému a vazbu na uživatele a nastavení hráče.
 */
@Entity
@Table(name = "player_entity")
public class PlayerEntity {

    /**
     * Primární klíč hráče.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Křestní jméno hráče.
     */
    @Column(nullable = false)
    private String name;

    /**
     * Příjmení hráče.
     * Při nastavení je převáděno na velká písmena.
     */
    @Column(nullable = false)
    private String surname;

    /**
     * Volitelná přezdívka hráče.
     */
    private String nickname;

    /**
     * Typ hráče v systému.
     *
     * Určuje například cenový nebo organizační režim hráče.
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerType type;

    /**
     * Celé jméno hráče odvozené z křestního jména a příjmení.
     *
     * Hodnota se aktualizuje automaticky při změně jména nebo příjmení.
     */
    private String fullName;

    /**
     * Telefonní číslo hráče.
     *
     * Používá se zejména pro zasílání SMS notifikací.
     */
    private String phoneNumber;

    /**
     * Tým, ke kterému je hráč přiřazen.
     */
    @Enumerated(EnumType.STRING)
    private Team team;

    /**
     * Aktuální stav hráče v systému.
     *
     * Stav určuje například, zda je hráč čekající na schválení,
     * schválený nebo zamítnutý.
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerStatus playerStatus = PlayerStatus.PENDING;

    /**
     * Uživatelský účet, ke kterému hráč patří.
     *
     * Vazba je volitelná, protože hráč může existovat
     * i bez přímé vazby na uživatelský účet.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private AppUserEntity user;

    /**
     * Nastavení hráče.
     *
     * Obsahuje například kontaktní údaje a notifikační preference.
     * Jeden hráč má právě jedno PlayerSettingsEntity.
     */
    @OneToOne(mappedBy = "player",
            cascade = CascadeType.ALL,
            fetch = FetchType.LAZY,
            orphanRemoval = true)
    private PlayerSettingsEntity settings;

    /**
     * Časové razítko hráče.
     *
     * Uchovává datum a čas vytvoření hráče.
     * Hodnota se nastavuje při prvním uložení a dále se nemění.
     */
    @Column(nullable = false, updatable = false)
    private LocalDateTime timestamp = LocalDateTime.now();

    /**
     * Metoda volaná před prvním uložením entity.
     *
     * Zajišťuje inicializaci časového razítka v případě,
     * že nebylo nastaveno.
     */
    @PrePersist
    protected void onCreate() {
        if (this.timestamp == null) {
            this.timestamp = LocalDateTime.now();
        }
    }

    /**
     * Bezparametrický konstruktor požadovaný JPA.
     *
     * Výchozí typ hráče je nastaven na BASIC.
     */
    public PlayerEntity() {
        this.type = PlayerType.BASIC;
    }

    /**
     * Konstruktor pro vytvoření hráče s inicializačními hodnotami.
     *
     * @param name         křestní jméno hráče
     * @param surname      příjmení hráče
     * @param nickname     přezdívka hráče
     * @param type         typ hráče
     * @param phoneNumber  telefonní číslo hráče
     * @param team         tým hráče
     * @param playerStatus aktuální stav hráče
     */
    public PlayerEntity(String name,
                        String surname,
                        String nickname,
                        PlayerType type,
                        String phoneNumber,
                        Team team,
                        PlayerStatus playerStatus) {

        this.name = name;
        this.surname = surname;
        this.nickname = nickname;
        this.type = type;
        this.phoneNumber = phoneNumber;
        this.team = team;
        this.playerStatus = playerStatus;
        updateFullName();
    }

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }

    public void setName(String name) {
        this.name = name;
        updateFullName();
    }

    public String getSurname() { return surname; }

    public void setSurname(String surname) {
        this.surname = surname.toUpperCase();
        updateFullName();
    }

    public String getNickname() { return nickname; }

    public void setNickname(String nickname) { this.nickname = nickname; }

    public String getFullName() { return fullName; }

    public PlayerType getType() { return type; }

    public void setType(PlayerType type) { this.type = type; }

    public String getPhoneNumber() { return phoneNumber; }

    public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }

    public Team getTeam() { return team; }

    public void setTeam(Team team) { this.team = team; }

    public PlayerStatus getPlayerStatus() { return playerStatus; }

    public void setPlayerStatus(PlayerStatus playerStatus) { this.playerStatus = playerStatus; }

    public AppUserEntity getUser() { return user; }

    public void setUser(AppUserEntity user) { this.user = user; }

    public PlayerSettingsEntity getSettings() { return settings; }

    /**
     * Nastavuje nastavení hráče a zároveň zajišťuje obousměrnou vazbu.
     *
     * @param settings instance nastavení hráče
     */
    public void setSettings(PlayerSettingsEntity settings) {
        this.settings = settings;
        if (settings != null) {
            settings.setPlayer(this);
        }
    }

    /**
     * Aktualizuje celé jméno hráče podle aktuálního jména a příjmení.
     *
     * Metoda je volána při změně jména nebo příjmení.
     */
    private void updateFullName() {
        this.fullName = name + " " + surname;
    }

    public LocalDateTime getTimestamp() { return timestamp; }

    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerHistoryEntity.java
-----

package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentující historický záznam o hráči.
 *
 * Slouží pro auditní účely a uchovávání změn hráčů v čase.
 * Každý záznam představuje stav hráče v okamžiku provedení operace
 * nad hlavní entitou PlayerEntity.
 *
 * Záznamy jsou typicky vytvářeny databázovým triggerem při změně
 * údajů hráče.
 */
@Entity
@Table(name = "player_entity_history")
public class PlayerHistoryEntity {

    /**
     * Primární klíč historického záznamu.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Typ provedené operace.
     *
     * Typicky se jedná o hodnoty CREATE, STATUS_CHANGE,
     * USER_CHANGE nebo DELETE.
     */
    @Column(name = "action", nullable = false)
    private String action;

    /**
     * Datum a čas provedení změny.
     *
     * Udává okamžik vytvoření historického záznamu.
     */
    @Column(name = "changed_at", nullable = false)
    private LocalDateTime changedAt;

    /**
     * ID hráče z hlavní tabulky player_entity.
     *
     * Slouží pro propojení historického záznamu s původní entitou hráče.
     */
    @Column(name = "player_id", nullable = false)
    private Long playerId;

    /**
     * Původní časové razítko hráče.
     *
     * Jedná se o hodnotu sloupce timestamp z tabulky player_entity
     * v okamžiku vytvoření historického záznamu.
     */
    @Column(name = "original_timestamp", nullable = false)
    private LocalDateTime originalTimestamp;

    /**
     * Křestní jméno hráče v okamžiku změny.
     */
    @Column(name = "name", nullable = false)
    private String name;

    /**
     * Příjmení hráče v okamžiku změny.
     */
    @Column(name = "surname", nullable = false)
    private String surname;

    /**
     * Přezdívka hráče v okamžiku změny.
     */
    @Column(name = "nickname")
    private String nickname;

    /**
     * Typ hráče v okamžiku změny.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "type", nullable = false)
    private PlayerType type;

    /**
     * Celé jméno hráče v okamžiku změny.
     */
    @Column(name = "full_name")
    private String fullName;

    /**
     * Telefonní číslo hráče v okamžiku změny.
     */
    @Column(name = "phone_number")
    private String phoneNumber;

    /**
     * Tým hráče v okamžiku změny.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "team")
    private Team team;

    /**
     * Stav hráče v okamžiku změny.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "player_status", nullable = false)
    private PlayerStatus playerStatus;

    /**
     * ID uživatele, ke kterému byl hráč přiřazen
     * v okamžiku vytvoření historického záznamu.
     */
    @Column(name = "user_id")
    private Long userId;

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getAction() { return action; }
    public void setAction(String action) { this.action = action; }

    public LocalDateTime getChangedAt() { return changedAt; }
    public void setChangedAt(LocalDateTime changedAt) { this.changedAt = changedAt; }

    public Long getPlayerId() { return playerId; }
    public void setPlayerId(Long playerId) { this.playerId = playerId; }

    public LocalDateTime getOriginalTimestamp() { return originalTimestamp; }
    public void setOriginalTimestamp(LocalDateTime originalTimestamp) { this.originalTimestamp = originalTimestamp; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getSurname() { return surname; }
    public void setSurname(String surname) { this.surname = surname; }

    public String getNickname() { return nickname; }
    public void setNickname(String nickname) { this.nickname = nickname; }

    public PlayerType getType() { return type; }
    public void setType(PlayerType type) { this.type = type; }

    public String getFullName() { return fullName; }
    public void setFullName(String fullName) { this.fullName = fullName; }

    public String getPhoneNumber() { return phoneNumber; }
    public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }

    public Team getTeam() { return team; }
    public void setTeam(Team team) { this.team = team; }

    public PlayerStatus getPlayerStatus() { return playerStatus; }
    public void setPlayerStatus(PlayerStatus playerStatus) { this.playerStatus = playerStatus; }

    public Long getUserId() { return userId; }
    public void setUserId(Long userId) { this.userId = userId; }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerInactivityPeriodEntity.java
-----

package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * Entita reprezentující období neaktivity hráče.
 *
 * Slouží k evidenci časových úseků, ve kterých se hráč
 * neúčastní zápasů, například z důvodu zranění nebo dovolené.
 * Období neaktivity se používá při vyhodnocování dostupnosti
 * hráče pro jednotlivé zápasy.
 */
@Entity
@Table(name = "player_inactivity_period")
public class PlayerInactivityPeriodEntity {

    /**
     * Primární klíč záznamu o neaktivitě.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Hráč, ke kterému se období neaktivity vztahuje.
     *
     * Vazba je povinná, protože každé období neaktivity
     * musí být přiřazeno konkrétnímu hráči.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    /**
     * Začátek období neaktivity.
     *
     * Určuje datum a čas, od kterého je hráč považován za neaktivního.
     */
    @Column(name = "inactive_from", nullable = false)
    private LocalDateTime inactiveFrom;

    /**
     * Konec období neaktivity.
     *
     * Určuje datum a čas, do kterého je hráč považován za neaktivního.
     */
    @Column(name = "inactive_to", nullable = false)
    private LocalDateTime inactiveTo;

    /**
     * Důvod neaktivity hráče.
     *
     * Slouží k evidenci příčiny absence, například zranění,
     * dovolená nebo jiný osobní důvod.
     */
    @Column(name = "inactivity_reason", nullable = false)
    private String inactivityReason;

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public PlayerEntity getPlayer() { return player; }

    public void setPlayer(PlayerEntity player) { this.player = player; }

    public LocalDateTime getInactiveFrom() { return inactiveFrom; }

    public void setInactiveFrom(LocalDateTime inactiveFrom) { this.inactiveFrom = inactiveFrom; }

    public LocalDateTime getInactiveTo() { return inactiveTo; }

    public void setInactiveTo(LocalDateTime inactiveTo) { this.inactiveTo = inactiveTo; }

    public String getInactivityReason() {
        return inactivityReason;
    }

    public void setInactivityReason(String inactivityReason) {
        this.inactivityReason = inactivityReason;
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerSettingsEntity.java
-----

package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

/**
 * Entita uchovávající nastavení konkrétního hráče.
 *
 * Odděluje identitu hráče (PlayerEntity) od jeho kontaktních údajů
 * a detailních notifikačních preferencí. Nastavení se využívá
 * při rozhodování o tom, zda a jak budou hráči doručovány notifikace.
 */
@Entity
@Table(name = "player_settings")
public class PlayerSettingsEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Hráč, ke kterému toto nastavení patří.
     * Pro jednoho hráče existuje právě jeden záznam nastavení.
     */
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "player_id", nullable = false, unique = true)
    private PlayerEntity player;

    /**
     * Volitelný email hráče.
     * Pokud není vyplněn, může se použít email uživatele (AppUserEntity).
     */
    @Column(name = "contact_email", length = 255)
    private String contactEmail;

    /**
     * Volitelné telefonní číslo hráče pro SMS notifikace.
     */
    @Column(name = "contact_phone", length = 50)
    private String contactPhone;

    /**
     * Příznak, zda má hráč dostávat emailové notifikace.
     */
    @Column(name = "email_enabled", nullable = false)
    private boolean emailEnabled = true;

    /**
     * Příznak, zda má hráč dostávat SMS notifikace.
     */
    @Column(name = "sms_enabled", nullable = false)
    private boolean smsEnabled = false;

    /**
     * Příznak, zda chce hráč notifikace o registraci a odhlášení.
     */
    @Column(name = "notify_on_registration", nullable = false)
    private boolean notifyOnRegistration = true;

    /**
     * Příznak, zda chce hráč notifikace o omluvách.
     */
    @Column(name = "notify_on_excuse", nullable = false)
    private boolean notifyOnExcuse = true;

    /**
     * Příznak, zda chce hráč notifikace o změnách zápasu.
     */
    @Column(name = "notify_on_match_change", nullable = false)
    private boolean notifyOnMatchChange = true;

    /**
     * Příznak, zda chce hráč notifikace o zrušení zápasu.
     */
    @Column(name = "notify_on_match_cancel", nullable = false)
    private boolean notifyOnMatchCancel = true;

    /**
     * Příznak, zda chce hráč notifikace o platbách nebo vyúčtování.
     */
    @Column(name = "notify_on_payment", nullable = false)
    private boolean notifyOnPayment = false;

    /**
     * Příznak, zda má hráč dostávat připomínky před zápasem.
     */
    @Column(name = "notify_reminders", nullable = false)
    private boolean notifyReminders = true;

    /**
     * Počet hodin před začátkem zápasu, kdy má být odeslána připomínka.
     * Například hodnota 24 znamená připomínku den předem.
     */
    @Column(name = "reminder_hours_before")
    private Integer reminderHoursBefore = 24;

    /**
     * Určuje, zda jsou povoleny notifikace týkající se registrací.
     */
    @Transient
    public boolean isRegistrationNotificationsEnabled() {
        return notifyOnRegistration;
    }

    /**
     * Určuje, zda jsou povoleny notifikace týkající se omluv.
     */
    @Transient
    public boolean isExcuseNotificationsEnabled() {
        return notifyOnExcuse;
    }

    /**
     * Určuje, zda jsou povoleny notifikace týkající se informací o zápase,
     * například změn a připomínek.
     */
    @Transient
    public boolean isMatchInfoNotificationsEnabled() {
        return notifyOnMatchChange
                || notifyOnMatchCancel
                || notifyReminders;
    }

    /**
     * Určuje, zda jsou povoleny systémové notifikace,
     * například o platbách.
     */
    @Transient
    public boolean isSystemNotificationsEnabled() {
        return notifyOnPayment;
    }

    public Long getId() {
        return id;
    }

    public PlayerEntity getPlayer() {
        return player;
    }

    public void setPlayer(PlayerEntity player) {
        this.player = player;
    }

    public String getContactEmail() {
        return contactEmail;
    }

    public void setContactEmail(String contactEmail) {
        this.contactEmail = contactEmail;
    }

    public String getContactPhone() {
        return contactPhone;
    }

    public void setContactPhone(String contactPhone) {
        this.contactPhone = contactPhone;
    }

    public boolean isEmailEnabled() {
        return emailEnabled;
    }

    public void setEmailEnabled(boolean emailEnabled) {
        this.emailEnabled = emailEnabled;
    }

    public boolean isSmsEnabled() {
        return smsEnabled;
    }

    public void setSmsEnabled(boolean smsEnabled) {
        this.smsEnabled = smsEnabled;
    }

    public boolean isNotifyOnRegistration() {
        return notifyOnRegistration;
    }

    public void setNotifyOnRegistration(boolean notifyOnRegistration) {
        this.notifyOnRegistration = notifyOnRegistration;
    }

    public boolean isNotifyOnExcuse() {
        return notifyOnExcuse;
    }

    public void setNotifyOnExcuse(boolean notifyOnExcuse) {
        this.notifyOnExcuse = notifyOnExcuse;
    }

    public boolean isNotifyOnMatchChange() {
        return notifyOnMatchChange;
    }

    public void setNotifyOnMatchChange(boolean notifyOnMatchChange) {
        this.notifyOnMatchChange = notifyOnMatchChange;
    }

    public boolean isNotifyOnMatchCancel() {
        return notifyOnMatchCancel;
    }

    public void setNotifyOnMatchCancel(boolean notifyOnMatchCancel) {
        this.notifyOnMatchCancel = notifyOnMatchCancel;
    }

    public boolean isNotifyOnPayment() {
        return notifyOnPayment;
    }

    public void setNotifyOnPayment(boolean notifyOnPayment) {
        this.notifyOnPayment = notifyOnPayment;
    }

    public boolean isNotifyReminders() {
        return notifyReminders;
    }

    public void setNotifyReminders(boolean notifyReminders) {
        this.notifyReminders = notifyReminders;
    }

    public Integer getReminderHoursBefore() {
        return reminderHoursBefore;
    }

    public void setReminderHoursBefore(Integer reminderHoursBefore) {
        this.reminderHoursBefore = reminderHoursBefore;
    }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\SeasonEntity.java
-----

package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDate;
import java.time.LocalDateTime;

/**
 * Entita reprezentující sezónu.
 *
 * Sezóna vymezuje časové období, do kterého spadají zápasy
 * a související statistiky. V systému může být v jednom okamžiku
 * označena právě jedna sezóna jako aktivní.
 *
 * Entita dále obsahuje auditní údaje o vytvoření a poslední
 * změně záznamu.
 */
@Entity
@Table(name = "season")
public class SeasonEntity {

    /**
     * Primární klíč sezóny.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Název sezóny.
     *
     * Například hodnota ve formátu "2024/2025".
     */
    @Column(nullable = false)
    private String name;

    /**
     * Datum začátku sezóny.
     *
     * Určuje první den, od kterého jsou zápasy
     * do sezóny zahrnovány.
     */
    @Column(nullable = false)
    private LocalDate startDate;

    /**
     * Datum konce sezóny.
     *
     * Určuje poslední den, do kterého sezóna trvá.
     */
    @Column(nullable = false)
    private LocalDate endDate;

    /**
     * Příznak, zda je sezóna aktuálně aktivní.
     *
     * Aktivní sezóna se používá jako výchozí při vytváření
     * nových zápasů a při filtrování dat.
     */
    private boolean active;

    /**
     * Identifikátor uživatele, který sezónu vytvořil.
     *
     * Hodnota se nastavuje při vytvoření sezóny
     * a slouží pro auditní účely.
     */
    @Column(name = "created_by_user_id")
    private Long createdByUserId;

    /**
     * Časové razítko sezóny.
     *
     * Uchovává datum a čas vytvoření nebo poslední změny sezóny.
     * Hodnota se aktualizuje při každém uložení entity.
     */
    @Column(nullable = false, updatable = true)
    private LocalDateTime timestamp = LocalDateTime.now();

    /**
     * Metoda volaná před prvním uložením entity.
     *
     * Nastavuje aktuální časové razítko.
     */
    @PrePersist
    public void prePersist() {
        this.timestamp = LocalDateTime.now();
    }

    /**
     * Metoda volaná před aktualizací entity.
     *
     * Aktualizuje časové razítko.
     */
    @PreUpdate
    public void preUpdate() {
        this.timestamp = LocalDateTime.now();
    }

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }

    public void setName(String name) { this.name = name; }

    public LocalDate getStartDate() { return startDate; }

    public void setStartDate(LocalDate startDate) { this.startDate = startDate; }

    public LocalDate getEndDate() { return endDate; }

    public void setEndDate(LocalDate endDate) { this.endDate = endDate; }

    public boolean isActive() { return active; }

    public void setActive(boolean active) { this.active = active; }

    public Long getCreatedByUserId() { return createdByUserId; }

    public void setCreatedByUserId(Long createdByUserId) { this.createdByUserId = createdByUserId; }

    public LocalDateTime getTimestamp() { return timestamp; }

    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
}



-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\data\entities\SeasonHistoryEntity.java
-----

package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDate;
import java.time.LocalDateTime;

/**
 * Entita reprezentující historický záznam o sezóně.
 *
 * Slouží pro auditní účely a sledování změn sezón v čase.
 */
@Entity
@Table(name = "season_history")
public class SeasonHistoryEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Typ provedené operace (INSERT, UPDATE, DELETE).
     */
    @Column(nullable = false)
    private String action;

    /**
     * Datum a čas provedení změny.
     */
    @Column(name = "changed_at", nullable = false)
    private LocalDateTime changedAt;

    /**
     * ID sezóny z hlavní tabulky season.
     */
    @Column(name = "season_id", nullable = false)
    private Long seasonId;

    /**
     * Původní časové razítko sezóny.
     */
    @Column(name = "original_timestamp", nullable = false)
    private LocalDateTime originalTimestamp;

    @Column(nullable = false)
    private String name;

    @Column(name = "start_date", nullable = false)
    private LocalDate startDate;

    @Column(name = "end_date", nullable = false)
    private LocalDate endDate;

    @Column(nullable = false)
    private boolean active;

    /**
     * ID uživatele, který sezónu vytvořil.
     * Zkopírováno z pole createdByUserId v SeasonEntity.
     */
    @Column(name = "created_by_user_id")
    private Long createdByUserId;

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getAction() { return action; }
    public void setAction(String action) { this.action = action; }

    public LocalDateTime getChangedAt() { return changedAt; }
    public void setChangedAt(LocalDateTime changedAt) { this.changedAt = changedAt; }

    public Long getSeasonId() { return seasonId; }
    public void setSeasonId(Long seasonId) { this.seasonId = seasonId; }

    public LocalDateTime getOriginalTimestamp() { return originalTimestamp; }
    public void setOriginalTimestamp(LocalDateTime originalTimestamp) { this.originalTimestamp = originalTimestamp; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public LocalDate getStartDate() { return startDate; }
    public void setStartDate(LocalDate startDate) { this.startDate = startDate; }

    public LocalDate getEndDate() { return endDate; }
    public void setEndDate(LocalDate endDate) { this.endDate = endDate; }

    public boolean isActive() { return active; }
    public void setActive(boolean active) { this.active = active; }

    public Long getCreatedByUserId() { return createdByUserId; }
    public void setCreatedByUserId(Long createdByUserId) { this.createdByUserId = createdByUserId; }
}


