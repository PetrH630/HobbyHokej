Balíček (složka): config
Cesta: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\config

Seznam souborů:
AppConfig.java
AuditAspect.java
CustomJsonLoginFilter.java
CustomUserDetailsService.java
DataInitializer.java
GlobalExceptionHandler.java
package-info.java
SecurityConfig.java
TimeConfig.java


-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\config\AppConfig.java
-----
package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

/**
 * AplikaÄŤnĂ­ konfigurace pro sdĂ­lenĂ© Spring beany.
 *
 * V tĂ©to tĹ™Ă­dÄ› se definujĂ­ technickĂ© komponenty,
 * kterĂ© se pouĹľĂ­vajĂ­ napĹ™Ă­ÄŤ aplikacĂ­.
 *
 * V souÄŤasnĂ© dobÄ› se zde vytvĂˇĹ™Ă­ instance {@link RestTemplate},
 * kterĂˇ slouĹľĂ­ pro volĂˇnĂ­ externĂ­ch HTTP sluĹľeb.
 */
@Configuration
public class AppConfig {

    /**
     * VytvĂˇĹ™Ă­ instanci aplikaÄŤnĂ­ konfigurace.
     *
     * Konstruktor je prĂˇzdnĂ˝, protoĹľe konfigurace je spravovĂˇna
     * Spring kontejnerem a neobsahuje ĹľĂˇdnou vlastnĂ­ logiku inicializace.
     */
    public AppConfig() {
        // bez vlastnĂ­ logiky
    }

    /**
     * VytvĂˇĹ™Ă­ a registruje instanci {@link RestTemplate}.
     *
     * Tato instance se pouĹľĂ­vĂˇ pro synchronnĂ­ volĂˇnĂ­
     * externĂ­ch HTTP API z aplikaÄŤnĂ­ logiky,
     * typicky ze service vrstvy.
     *
     * @return novĂˇ instance {@link RestTemplate} spravovanĂˇ Spring kontejnerem
     */
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\config\AuditAspect.java
-----
package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

/**
 * Aspekt pro auditnĂ­ logovĂˇnĂ­ service vrstvy.
 *
 * PouĹľĂ­vĂˇ se k centrĂˇlnĂ­mu zaznamenĂˇvĂˇnĂ­ volĂˇnĂ­ metod ve sluĹľbĂˇch
 * vÄŤetnÄ› argumentĹŻ, nĂˇvratovĂ˝ch hodnot a ÄŤasovĂ˝ch razĂ­tek. ChovĂˇnĂ­
 * aplikace se tĂ­mto aspektem nemÄ›nĂ­, pouze se doplĹujĂ­ auditnĂ­ logy
 * do samostatnĂ©ho loggeru.
 */
@Component
@Aspect
public class AuditAspect {

    /**
     * SpeciĂˇlnĂ­ logger urÄŤenĂ˝ pouze pro auditnĂ­ zĂˇznamy.
     *
     * DoporuÄŤuje se mĂ­t pro tento logger samostatnĂ˝ appender
     * a oddÄ›lenĂ˝ soubor logu, aby byly auditnĂ­ zĂˇznamy oddÄ›leny
     * od bÄ›ĹľnĂ˝ch aplikaÄŤnĂ­ch logĹŻ.
     */
    private static final Logger logger = LoggerFactory.getLogger("AUDIT_LOGGER");

    // Pointcut pro metody service vrstvy

    /**
     * Pointcut definujĂ­cĂ­ vĹˇechny metody ve service vrstvÄ› aplikace.
     *
     * Zahrnuje vĹˇechny tĹ™Ă­dy a metody v balĂ­ÄŤku
     * {@code cz.phsoft.hokej.models.services..} vÄŤetnÄ› podbalĂ­ÄŤkĹŻ.
     */
    @Pointcut("within(cz.phsoft.hokej.models.services..*)")
    public void serviceMethods() {
        // Marker metoda pro pointcut
    }

    // LogovĂˇnĂ­ pĹ™ed volĂˇnĂ­m metody

    /**
     * ProvĂˇdĂ­ auditnĂ­ zĂˇznam pĹ™ed zavolĂˇnĂ­m jakĂ©koli service metody.
     *
     * Zapisuje nĂˇzev metody, argumenty a aktuĂˇlnĂ­ ÄŤas. SlouĹľĂ­ k evidenci
     * zaÄŤĂˇtku provĂˇdÄ›nĂ­ operace a k pozdÄ›jĹˇĂ­ analĂ˝ze prĹŻbÄ›hu volĂˇnĂ­.
     *
     * @param joinPoint kontext volanĂ© metody
     */
    @Before("serviceMethods()")
    public void logBefore(JoinPoint joinPoint) {

        String methodName = joinPoint.getSignature().toShortString();
        String args = java.util.Arrays.toString(joinPoint.getArgs());

        logger.info(
                "START {} at {} with args {}",
                methodName,
                LocalDateTime.now(),
                args
        );
    }

    // LogovĂˇnĂ­ po ĂşspÄ›ĹˇnĂ©m dokonÄŤenĂ­ metody

    /**
     * ProvĂˇdĂ­ auditnĂ­ zĂˇznam po ĂşspÄ›ĹˇnĂ©m dokonÄŤenĂ­ metody.
     *
     * Metoda se nespouĹˇtĂ­ pĹ™i vyhozenĂ­ vĂ˝jimky. Zapisuje nĂˇzev metody,
     * pĹ™Ă­padnĂ© identifikĂˇtory hrĂˇÄŤe a nĂˇvratovou hodnotu vÄŤetnÄ› ÄŤasu
     * ukonÄŤenĂ­ operace.
     *
     * @param joinPoint kontext volanĂ© metody
     * @param result    nĂˇvratovĂˇ hodnota metody
     */
    @AfterReturning(
            pointcut = "serviceMethods()",
            returning = "result"
    )
    public void logAfterReturning(JoinPoint joinPoint, Object result) {

        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();

        Long userId = null;
        Long playerId = null;

        // Pokus o extrakci business identifikĂˇtorĹŻ z parametrĹŻ metody
        for (Object arg : args) {
            if (arg instanceof PlayerEntity player) {
                playerId = player.getId();
            } else if (arg instanceof MatchRegistrationEntity registration) {
                playerId = registration.getPlayer().getId();
            } else if (arg instanceof Long id) {
                // PĹ™Ă­padnĂ© rozliĹˇenĂ­ konkrĂ©tnĂ­ho ID lze doplnit podle konvence signatur metod
            }
        }

        logger.info(
                "END {} - userId={} playerId={} returned [{}] at {}",
                methodName,
                userId,
                playerId,
                result,
                LocalDateTime.now()
        );
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\config\CustomJsonLoginFilter.java
-----
package cz.phsoft.hokej.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import cz.phsoft.hokej.models.services.AppUserService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.context.HttpSessionSecurityContextRepository;


import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

/**
 * VlastnĂ­ autentizaÄŤnĂ­ filtr pro REST pĹ™ihlĂˇĹˇenĂ­.
 *
 * Filtr rozĹˇiĹ™uje vĂ˝chozĂ­ {@link UsernamePasswordAuthenticationFilter} tak,
 * aby podporoval pĹ™ihlĂˇĹˇenĂ­ jak pomocĂ­ formulĂˇĹ™e, tak pomocĂ­ JSON payloadu.
 * StandardnĂ­ redirect chovĂˇnĂ­ Spring Security je nahrazeno JSON odpovÄ›ÄŹmi
 * a po ĂşspÄ›ĹˇnĂ©m pĹ™ihlĂˇĹˇenĂ­ se vytvĂˇĹ™Ă­ HTTP session se SecurityContextem.
 *
 * Filtr je urÄŤen pro stavovĂ˝ (session-based) zpĹŻsob autentizace. Pro
 * stateless pĹ™Ă­stup s JWT by se pouĹľil jinĂ˝ mechanismus.
 */
public class CustomJsonLoginFilter extends UsernamePasswordAuthenticationFilter {

    /**
     * Objekt pro ÄŤtenĂ­ JSON z request body.
     */
    private final ObjectMapper objectMapper = new ObjectMapper();
    /**
     * Servis pro prĂˇci s uĹľivatelskĂ˝mi ĂşÄŤty.
     *
     * PouĹľĂ­vĂˇ se pro aktualizaci ÄŤasovĂ˝ch razĂ­tek pĹ™ihlĂˇĹˇenĂ­
     * po ĂşspÄ›ĹˇnĂ© autentizaci.
     */
    private final AppUserService appUserService;

    /**
     * VytvoĹ™Ă­ filtr pro zadanou login URL.
     *
     * @param loginUrl    URL endpointu pro login, napĹ™Ă­klad /api/auth/login
     * @param authManager instance AuthenticationManager pouĹľĂ­vanĂˇ pro autentizaci
     * @param appUserService servis pro sprĂˇvu uĹľivatelskĂ˝ch ĂşÄŤtĹŻ
     */
    public CustomJsonLoginFilter(String loginUrl,
                                 AuthenticationManager authManager,
                                 AppUserService appUserService) {
        setFilterProcessesUrl(loginUrl);
        setAuthenticationManager(authManager);
        this.appUserService = appUserService;
    }

    // Pokus o autentizaci (login)

    /**
     * PokusĂ­ se autentizovat uĹľivatele na zĂˇkladÄ› HTTP requestu.
     *
     * PodporovanĂ© formĂˇty:
     * - {@code application/x-www-form-urlencoded} (klasickĂ˝ form login),
     * - {@code application/json} (SPA frontend).
     *
     * OÄŤekĂˇvanĂˇ pole:
     * - {@code email} (pĹ™Ă­padnÄ› {@code username} u form loginu),
     * - {@code password}.
     *
     * @throws AuthenticationException pĹ™i chybÄ› pĹ™ihlĂˇĹˇenĂ­
     */
    @Override
    public Authentication attemptAuthentication(HttpServletRequest request,
                                                HttpServletResponse response)
            throws AuthenticationException {

        try {
            String email = null;
            String password = null;

            // Form login (x-www-form-urlencoded)
            if (request.getContentType() != null &&
                    request.getContentType().contains("application/x-www-form-urlencoded")) {

                email = request.getParameter("username");
                password = request.getParameter("password");
            }

            // JSON login (application/json)
            if ((email == null || password == null) &&
                    request.getContentType() != null &&
                    request.getContentType().contains("application/json")) {

                Map<String, String> json =
                        objectMapper.readValue(request.getInputStream(), Map.class);

                email = json.get("email");
                password = json.get("password");
            }

            // ZĂˇkladnĂ­ validace vstupĹŻ
            if (email == null || password == null ||
                    email.isBlank() || password.isBlank()) {

                throw new BadCredentialsException("BE - ChybĂ­ pĹ™ihlaĹˇovacĂ­ Ăşdaje");
            }

            // VytvoĹ™enĂ­ Authentication tokenu
            UsernamePasswordAuthenticationToken authRequest =
                    new UsernamePasswordAuthenticationToken(email, password);

            setDetails(request, authRequest);

            // Delegace autentizace na AuthenticationManager
            return this.getAuthenticationManager().authenticate(authRequest);

        } catch (IOException e) {
            // Chyba pĹ™i ÄŤtenĂ­ JSON body
            throw new RuntimeException(e);
        }
    }

    // ĂšspÄ›ĹˇnĂ˝ login

    /**
     * Zpracuje ĂşspÄ›Ĺˇnou autentizaci.
     *
     * Do {@link SecurityContextHolder} se uloĹľĂ­ autentizace, vytvoĹ™Ă­ se
     * HTTP session a do nĂ­ se uloĹľĂ­ {@link org.springframework.security.core.context.SecurityContext}.
     * NĂˇslednÄ› se klientovi vracĂ­ JSON odpovÄ›ÄŹ mĂ­sto redirectu.
     */
    @Override
    protected void successfulAuthentication(HttpServletRequest request,
                                            HttpServletResponse response,
                                            FilterChain chain,
                                            Authentication authResult)
            throws IOException, ServletException {

        // Aktualizace login timestampĹŻ v AppUserEntity
        String email = authResult.getName();
        appUserService.onSuccessfulLogin(email);

        // NastavenĂ­ SecurityContext
        SecurityContextHolder.getContext().setAuthentication(authResult);

        // VytvoĹ™enĂ­ session a uloĹľenĂ­ kontextu
        request.getSession(true).setAttribute(
                HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY,
                SecurityContextHolder.getContext()
        );

        // JSON odpovÄ›ÄŹ
        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");

        Map<String, Object> result = new HashMap<>();
        result.put("status", "ok");
        result.put("user", authResult.getName());

        objectMapper.writeValue(response.getWriter(), result);
    }

    // NeĂşspÄ›ĹˇnĂ˝ login

    /**
     * Zpracuje neĂşspÄ›Ĺˇnou autentizaci.
     *
     * VracĂ­ se HTTP status 401 a JSON odpovÄ›ÄŹ s informacĂ­ o chybÄ›.
     * RozliĹˇuje se neaktivovanĂ˝ ĂşÄŤet, neplatnĂ© pĹ™ihlaĹˇovacĂ­ Ăşdaje
     * a ostatnĂ­ chyby pĹ™i pĹ™ihlĂˇĹˇenĂ­.
     */
    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request,
                                              HttpServletResponse response,
                                              AuthenticationException failed)
            throws IOException, ServletException {

        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");

        Map<String, Object> result = new HashMap<>();
        result.put("status", "error");

        if (failed.getCause() instanceof cz.phsoft.hokej.exceptions.AccountNotActivatedException) {
            result.put("message", failed.getCause().getMessage());
        } else if (failed instanceof BadCredentialsException) {
            result.put("message", "BE - NeplatnĂ© pĹ™ihlaĹˇovacĂ­ Ăşdaje");
        } else {
            result.put("message", "BE - Chyba pĹ™i pĹ™ihlĂˇĹˇenĂ­");
        }

        objectMapper.writeValue(response.getWriter(), result);
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\config\CustomUserDetailsService.java
-----
package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.exceptions.AccountNotActivatedException;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

/**
 * Implementace {@link UserDetailsService} pro napojenĂ­ Spring Security
 * na databĂˇzovĂ˝ model uĹľivatele.
 *
 * TĹ™Ă­da naÄŤĂ­tĂˇ uĹľivatele z databĂˇze podle e-mailu, ovÄ›Ĺ™uje, zda je ĂşÄŤet
 * aktivnĂ­, a pĹ™evĂˇdĂ­ entitu {@link AppUserEntity} na objekt
 * {@link UserDetails}, kterĂ˝ Spring Security pouĹľĂ­vĂˇ pĹ™i autentizaci.
 */
@Service
public class CustomUserDetailsService implements UserDetailsService {

    /**
     * RepozitĂˇĹ™ pro naÄŤĂ­tĂˇnĂ­ uĹľivatelĹŻ pĹ™i pĹ™ihlĂˇĹˇenĂ­.
     */
    private final AppUserRepository appUserRepository;

    public CustomUserDetailsService(AppUserRepository appUserRepository) {
        this.appUserRepository = appUserRepository;
    }

    // NaÄŤtenĂ­ uĹľivatele pro Spring Security

    /**
     * NaÄŤte uĹľivatele podle e-mailu pro potĹ™eby autentizace.
     *
     * Metoda se volĂˇ Spring Security pĹ™i pĹ™ihlĂˇĹˇenĂ­. V pĹ™Ă­padÄ›, Ĺľe uĹľivatel
     * neexistuje, je vyhozena {@link UsernameNotFoundException}. Pokud ĂşÄŤet
     * existuje, ale nenĂ­ aktivnĂ­, je vyhozena {@link AccountNotActivatedException}.
     *
     * @param email e-mail zadanĂ˝ uĹľivatelem pĹ™i pĹ™ihlĂˇĹˇenĂ­
     * @return objekt {@link UserDetails} pouĹľitĂ˝ pro autentizaci
     * @throws UsernameNotFoundException    pokud uĹľivatel s danĂ˝m e-mailem neexistuje
     * @throws AccountNotActivatedException pokud ĂşÄŤet existuje, ale nenĂ­ aktivnĂ­
     */
    @Override
    public UserDetails loadUserByUsername(String email)
            throws UsernameNotFoundException {

        // NaÄŤtenĂ­ uĹľivatele z databĂˇze
        AppUserEntity user = appUserRepository.findByEmail(email)
                .orElseThrow(() ->
                        new UsernameNotFoundException("BE - UĹľivatel nenalezen")
                );

        // Kontrola aktivace ĂşÄŤtu
        if (!user.isEnabled()) {
            // VĂ˝jimka se typicky zachytĂˇvĂˇ ve filtru pro login a pĹ™evĂˇdĂ­ na odpovÄ›ÄŹ pro frontend
            throw new AccountNotActivatedException();
        }

        // MapovĂˇnĂ­ na UserDetails
        return User.builder()
                .username(user.getEmail())
                .password(user.getPassword())
                // Role se uklĂˇdĂˇ bez prefixu ROLE_, Spring si prefix pĹ™idĂˇ automaticky
                .roles(user.getRole().name().replace("ROLE_", ""))
                // Disabled flag se drĹľĂ­ konzistentnĂ­ se stavem entity
                .disabled(!user.isEnabled())
                .build();
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\config\DataInitializer.java
-----
package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.*;
import cz.phsoft.hokej.data.enums.*;
import cz.phsoft.hokej.data.repositories.*;
import cz.phsoft.hokej.models.services.AppUserSettingsService;
import cz.phsoft.hokej.models.services.PlayerSettingsService;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Component;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.temporal.TemporalAdjusters;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;

/**
 * Komponenta pro inicializaci ukĂˇzkovĂ˝ch dat v databĂˇzi.
 *
 * Po startu aplikace se vytvĂˇĹ™Ă­ vĂ˝chozĂ­ administrĂˇtor, ukĂˇzkovĂ­ hrĂˇÄŤi s uĹľivateli,
 * vĂ˝chozĂ­ nastavenĂ­ uĹľivatelĹŻ a hrĂˇÄŤĹŻ, sezĂłny, zĂˇpasy a ukĂˇzkovĂ© registrace.
 *
 * Inicializace se spouĹˇtĂ­ pouze pĹ™i zapnutĂ­ vlastnosti {@code app.seed.enabled=true}.
 * DatabĂˇzovĂ© triggery se v tĂ©to tĹ™Ă­dÄ› nevytvĂˇĹ™ejĂ­, protoĹľe se spravujĂ­ pomocĂ­ Flyway migracĂ­.
 */
@Component
@ConditionalOnProperty(name = "app.seed.enabled", havingValue = "true", matchIfMissing = false)
public class DataInitializer {

    private static final Logger log = LoggerFactory.getLogger(DataInitializer.class);

    private final PlayerRepository playerRepository;
    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository matchRegistrationRepository;
    private final AppUserRepository appUserRepository;
    private final SeasonRepository seasonRepository;
    private final AppUserSettingsRepository appUserSettingsRepository;
    private final PlayerSettingsRepository playerSettingsRepository;
    private final AppUserSettingsService appUserSettingService;
    private final PlayerSettingsService playerSettingService;
    private final JdbcTemplate jdbcTemplate;

    private final BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();

    public DataInitializer(PlayerRepository playerRepository,
                           MatchRepository matchRepository,
                           MatchRegistrationRepository matchRegistrationRepository,
                           AppUserRepository appUserRepository,
                           SeasonRepository seasonRepository,
                           AppUserSettingsRepository appUserSettingsRepository,
                           PlayerSettingsRepository playerSettingsRepository,
                           AppUserSettingsService appUserSettingService,
                           PlayerSettingsService playerSettingService,
                           JdbcTemplate jdbcTemplate) {
        this.playerRepository = playerRepository;
        this.matchRepository = matchRepository;
        this.matchRegistrationRepository = matchRegistrationRepository;
        this.appUserRepository = appUserRepository;
        this.seasonRepository = seasonRepository;
        this.appUserSettingsRepository = appUserSettingsRepository;
        this.playerSettingsRepository = playerSettingsRepository;
        this.appUserSettingService = appUserSettingService;
        this.playerSettingService = playerSettingService;
        this.jdbcTemplate = jdbcTemplate;
    }

    /**
     * SpouĹˇtĂ­ inicializaci ukĂˇzkovĂ˝ch dat po startu aplikace.
     *
     * Metody se volajĂ­ v poĹ™adĂ­ tak, aby byly zachovĂˇny zĂˇvislosti mezi entitami.
     * Triggery se nevytvĂˇĹ™ejĂ­, protoĹľe se spravujĂ­ pomocĂ­ Flyway.
     */
    @PostConstruct
    public void init() {
        log.info("DataInitializer is enabled. Demo/test data initialization starts.");

        initAdmin();
        initPlayersAndUsers();
        initUserSettings();
        initPlayerSettings();
        initSeasons();
        initMatches();
        initRegistrations();

        log.info("Data initialization completed.");
    }

    /**
     * VytvĂˇĹ™Ă­ vĂ˝chozĂ­ho administrĂˇtora, pokud jeĹˇtÄ› neexistuje.
     *
     * Timestamp se po uloĹľenĂ­ upravĂ­ pĹ™es JdbcTemplate, protoĹľe AppUserEntity nastavuje
     * timestamp pĹ™i persistenci automaticky.
     */
    private void initAdmin() {
        appUserRepository.findByEmail("admin@example.com").ifPresentOrElse(
                existing -> log.info("Admin user already exists. Initialization is skipped."),
                () -> {
                    AppUserEntity admin = new AppUserEntity();
                    admin.setName("admin");
                    admin.setSurname("admin");
                    admin.setEmail("admin@example.com");
                    admin.setPassword(encoder.encode("Administrator123"));
                    admin.setRole(Role.ROLE_ADMIN);
                    admin.setEnabled(true);

                    appUserRepository.save(admin);

                    LocalDateTime fixedTimestamp = LocalDateTime.of(2024, 11, 1, 8, 0);
                    jdbcTemplate.update(
                            "UPDATE app_users SET timestamp = ? WHERE id = ?",
                            fixedTimestamp,
                            admin.getId()
                    );

                    log.info("Default admin user has been created (id={}).", admin.getId());
                }
        );
    }

    /**
     * VytvĂˇĹ™Ă­ testovacĂ­ hrĂˇÄŤe a k nim pĹ™iĹ™azenĂ© uĹľivatele.
     *
     * Pokud jiĹľ v databĂˇzi existujĂ­ hrĂˇÄŤi, inicializace se pĹ™eskoÄŤĂ­.
     */
    private void initPlayersAndUsers() {
        if (playerRepository.count() > 0) {
            log.info("Players already exist. Player initialization is skipped.");
            return;
        }

        String[] names = {
                "Jan", "Petr", "JiĹ™Ă­", "Josef", "Pavel",
                "Martin", "TomĂˇĹˇ", "Jaroslav", "Miroslav", "ZdenÄ›k"
        };
        String[] surnames = {
                "NovĂˇk", "Svoboda", "NovotnĂ˝", "DvoĹ™Ăˇk", "ÄŚernĂ˝",
                "ProchĂˇzka", "KuÄŤera", "VeselĂ˝", "HorĂˇk", "NÄ›mec"
        };

        for (int i = 0; i < 10; i++) {
            PlayerEntity player = new PlayerEntity();
            AppUserEntity user = new AppUserEntity();

            player.setName(names[i]);
            user.setName(names[i]);

            player.setSurname(surnames[i].toUpperCase());
            user.setSurname(surnames[i].toUpperCase());

            String email = "player" + (i + 1) + "@example.com";
            user.setEmail(email);
            user.setPassword(encoder.encode("Heslo123"));

            switch (i) {
                case 0, 1, 2 -> player.setType(PlayerType.VIP);
                case 3, 4, 5, 6 -> player.setType(PlayerType.STANDARD);
                default -> player.setType(PlayerType.BASIC);
            }

            player.setPhoneNumber("");
            player.setTeam(i < 5 ? Team.DARK : Team.LIGHT);
            player.setPlayerStatus(i < 8 ? PlayerStatus.APPROVED : PlayerStatus.PENDING);

            user.setRole(i == 0 ? Role.ROLE_MANAGER : Role.ROLE_PLAYER);
            user.setEnabled(true);

            player.setUser(user);

            LocalDateTime randomTs = randomTimestampForDemoData();
            player.setTimestamp(randomTs);

            appUserRepository.save(user);
            playerRepository.save(player);

            jdbcTemplate.update(
                    "UPDATE app_users SET timestamp = ? WHERE id = ?",
                    randomTs,
                    user.getId()
            );
        }

        log.info("Players and users have been initialized.");
    }

    /**
     * VytvĂˇĹ™Ă­ vĂ˝chozĂ­ nastavenĂ­ pro vĹˇechny uĹľivatele, kteĹ™Ă­ je jeĹˇtÄ› nemajĂ­.
     */
    private void initUserSettings() {
        log.info("User settings initialization starts.");

        List<AppUserEntity> users = appUserRepository.findAll();
        for (AppUserEntity user : users) {
            boolean hasSettings = appUserSettingsRepository.existsByUser(user);
            if (hasSettings) {
                continue;
            }

            AppUserSettingsEntity settings =
                    appUserSettingService.createDefaultSettingsForUser(user);

            appUserSettingsRepository.save(settings);
        }

        log.info("User settings have been initialized.");
    }

    /**
     * VytvĂˇĹ™Ă­ vĂ˝chozĂ­ nastavenĂ­ pro vĹˇechny hrĂˇÄŤe, kteĹ™Ă­ je jeĹˇtÄ› nemajĂ­.
     */
    private void initPlayerSettings() {
        log.info("Player settings initialization starts.");

        List<PlayerEntity> players = playerRepository.findAll();
        for (PlayerEntity player : players) {
            boolean hasSettings = playerSettingsRepository.existsByPlayer(player);
            if (hasSettings) {
                continue;
            }

            PlayerSettingsEntity settings =
                    playerSettingService.createDefaultSettingsForPlayer(player);

            playerSettingsRepository.save(settings);
        }

        log.info("Player settings have been initialized.");
    }

    /**
     * VytvĂˇĹ™Ă­ vĂ˝chozĂ­ sezĂłny, pokud ĹľĂˇdnĂ© neexistujĂ­.
     */
    private void initSeasons() {
        if (seasonRepository.count() > 0) {
            log.info("Seasons already exist. Season initialization is skipped.");
            return;
        }

        log.info("Season initialization starts.");

        SeasonEntity season2024_2025 = new SeasonEntity();
        season2024_2025.setName("2024/2025");
        season2024_2025.setStartDate(LocalDate.of(2024, 11, 1));
        season2024_2025.setEndDate(LocalDate.of(2025, 3, 31));
        season2024_2025.setActive(false);
        season2024_2025.setCreatedByUserId(2L);

        SeasonEntity season2025_2026 = new SeasonEntity();
        season2025_2026.setName("2025/2026");
        season2025_2026.setStartDate(LocalDate.of(2025, 11, 1));
        season2025_2026.setEndDate(LocalDate.of(2026, 3, 31));
        season2025_2026.setActive(true);
        season2025_2026.setCreatedByUserId(2L);

        SeasonEntity season2026_2027 = new SeasonEntity();
        season2026_2027.setName("2026/2027");
        season2026_2027.setStartDate(LocalDate.of(2026, 11, 1));
        season2026_2027.setEndDate(LocalDate.of(2027, 3, 31));
        season2026_2027.setActive(false);
        season2026_2027.setCreatedByUserId(2L);

        seasonRepository.saveAll(List.of(season2024_2025, season2025_2026, season2026_2027));

        log.info("Seasons have been initialized.");
    }

    /**
     * VytvĂˇĹ™Ă­ zĂˇpasy pro prvnĂ­ dvÄ› sezĂłny.
     *
     * ZĂˇpasy se generujĂ­ po pĂˇtcĂ­ch v rĂˇmci obdobĂ­ sezĂłny.
     * Pokud jiĹľ existujĂ­ zĂˇpasy, inicializace se pĹ™eskoÄŤĂ­.
     */
    private void initMatches() {
        if (matchRepository.count() > 0) {
            log.info("Matches already exist. Match initialization is skipped.");
            return;
        }

        List<SeasonEntity> seasons = seasonRepository.findAll();
        if (seasons.isEmpty()) {
            throw new IllegalStateException("Nelze inicializovat zĂˇpasy, protoĹľe neexistuje ĹľĂˇdnĂˇ sezĂłna.");
        }

        log.info("Match initialization starts.");

        for (int j = 0; j < 2 && j < seasons.size(); j++) {
            SeasonEntity actualSeason = seasons.get(j);

            LocalDate startSeasonDate = actualSeason.getStartDate();
            LocalDate endSeasonDate = actualSeason.getEndDate();

            LocalDateTime firstMatchDate = startSeasonDate
                    .with(TemporalAdjusters.nextOrSame(DayOfWeek.FRIDAY))
                    .atTime(18, 45);

            int fridaysCount = countFridays(startSeasonDate, endSeasonDate);

            for (int i = 0; i < fridaysCount; i++) {
                MatchEntity match = new MatchEntity();
                match.setDateTime(firstMatchDate.plusWeeks(i));
                match.setLocation("NÄšJAKĂ HALA");
                match.setDescription("");
                match.setMaxPlayers(12);
                match.setPrice(2200);
                match.setMatchStatus(null);
                match.setCancelReason(null);
                match.setSeason(actualSeason);
                match.setCreatedByUserId(2L);

                matchRepository.save(match);
            }
        }

        log.info("Matches have been initialized.");
    }

    /**
     * VytvĂˇĹ™Ă­ ukĂˇzkovĂ© registrace hrĂˇÄŤĹŻ na zĂˇpasy.
     *
     * Registrace se vytvĂˇĹ™ejĂ­ pouze pro zĂˇpasy v blĂ­zkĂ© budoucnosti.
     * Pokud jiĹľ registrace existujĂ­, inicializace se pĹ™eskoÄŤĂ­.
     */
    private void initRegistrations() {
        if (matchRegistrationRepository.count() > 0) {
            log.info("Match registrations already exist. Registration initialization is skipped.");
            return;
        }

        LocalDateTime finalDate = LocalDateTime.now().plusWeeks(1);

        List<MatchEntity> matches = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().isBefore(finalDate))
                .toList();

        List<PlayerEntity> players = playerRepository.findAll().stream()
                .filter(p -> p.getId() != null)
                .filter(p -> p.getPlayerStatus() == PlayerStatus.APPROVED)
                .toList();

        if (matches.isEmpty() || players.size() < 6) {
            log.info("Not enough data for registration initialization. Initialization is skipped.");
            return;
        }

        for (MatchEntity match : matches) {
            List<PlayerEntity> shuffledPlayers = new ArrayList<>(players);
            Collections.shuffle(shuffledPlayers);
            List<PlayerEntity> selectedPlayers = shuffledPlayers.subList(0, 8);

            List<Integer> indexes = new ArrayList<>();
            for (int i = 0; i < selectedPlayers.size(); i++) {
                indexes.add(i);
            }
            Collections.shuffle(indexes);

            int excusedIndex = indexes.get(0);
            int unregisteredIndex1 = indexes.get(1);
            int unregisteredIndex2 = indexes.get(2);

            for (int i = 0; i < selectedPlayers.size(); i++) {
                PlayerEntity player = selectedPlayers.get(i);

                MatchRegistrationEntity reg = new MatchRegistrationEntity();
                reg.setMatch(match);
                reg.setPlayer(player);

                if (i == excusedIndex) {
                    reg.setStatus(PlayerMatchStatus.EXCUSED);
                    reg.setExcuseReason(ExcuseReason.NEMOC);
                    reg.setExcuseNote("chĹ™ipka");
                } else if (i == unregisteredIndex1 || i == unregisteredIndex2) {
                    reg.setStatus(PlayerMatchStatus.UNREGISTERED);
                    reg.setExcuseReason(null);
                    reg.setExcuseNote(null);
                } else {
                    reg.setStatus(PlayerMatchStatus.REGISTERED);
                    reg.setExcuseReason(null);
                    reg.setExcuseNote(null);
                }

                reg.setTeam(player.getTeam());
                reg.setTimestamp(LocalDateTime.now());
                reg.setCreatedBy("initializer");

                matchRegistrationRepository.save(reg);
            }
        }

        log.info("Match registrations have been initialized.");
    }

    /**
     * SpoÄŤĂ­tĂˇ poÄŤet pĂˇtkĹŻ v obdobĂ­ vÄŤetnÄ›.
     *
     * @param from poÄŤĂˇteÄŤnĂ­ datum
     * @param to koncovĂ© datum
     * @return poÄŤet pĂˇtkĹŻ v obdobĂ­
     */
    private int countFridays(LocalDate from, LocalDate to) {
        if (to.isBefore(from)) {
            return 0;
        }

        LocalDate firstFriday = from.with(TemporalAdjusters.nextOrSame(DayOfWeek.FRIDAY));
        if (firstFriday.isAfter(to)) {
            return 0;
        }

        int count = 0;
        for (LocalDate date = firstFriday; !date.isAfter(to); date = date.plusWeeks(1)) {
            count++;
        }
        return count;
    }

    /**
     * Vygeneruje nĂˇhodnĂ˝ timestamp v rozsahu urÄŤenĂ©m pro ukĂˇzkovĂˇ data.
     *
     * @return nĂˇhodnĂ˝ timestamp v UTC
     */
    private LocalDateTime randomTimestampForDemoData() {
        LocalDateTime from = LocalDateTime.of(2024, 11, 1, 0, 0);
        LocalDateTime to = LocalDateTime.of(2025, 2, 10, 23, 59);

        long fromEpoch = from.toEpochSecond(ZoneOffset.UTC);
        long toEpoch = to.toEpochSecond(ZoneOffset.UTC);

        long randomEpoch = ThreadLocalRandom.current().nextLong(fromEpoch, toEpoch + 1);
        return LocalDateTime.ofEpochSecond(randomEpoch, 0, ZoneOffset.UTC);
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\config\GlobalExceptionHandler.java
-----
package cz.phsoft.hokej.config;

import cz.phsoft.hokej.exceptions.ApiError;
import cz.phsoft.hokej.exceptions.BusinessException;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.Map;

/**
 * GlobĂˇlnĂ­ handler vĂ˝jimek pro REST API.
 *
 * SlouĹľĂ­ k centralizovanĂ©mu zachytĂˇvĂˇnĂ­ vĂ˝jimek z controllerĹŻ a service
 * vrstvy, jejich pĹ™evodu na jednotnĂ˝ JSON formĂˇt {@link ApiError} a
 * k nastavenĂ­ odpovĂ­dajĂ­cĂ­ch HTTP status kĂłdĹŻ.
 *
 * TĹ™Ă­da neĹ™eĹˇĂ­ business logiku ani detailnĂ­ logovĂˇnĂ­. Tyto aspekty lze
 * doplnit do jednotlivĂ˝ch handler metod podle potĹ™eby.
 */
@RestControllerAdvice
public class GlobalExceptionHandler {

    // 1) DomĂ©novĂ© vĂ˝jimky

    /**
     * ZachytĂˇvĂˇ vĂ˝jimky typu {@link BusinessException}.
     *
     * VĂ˝jimka pĹ™edĂˇvĂˇ HTTP status, uĹľivatelskou zprĂˇvu a dalĹˇĂ­ informace,
     * kterĂ© se pouĹľĂ­vajĂ­ pĹ™i sestavenĂ­ odpovÄ›di {@link ApiError}.
     */
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ApiError> handleBusinessException(
            BusinessException ex,
            HttpServletRequest request) {

        ApiError error = new ApiError(
                ex.getStatus().value(),
                ex.getStatus().getReasonPhrase(),
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()
        );

        return ResponseEntity
                .status(ex.getStatus())
                .body(error);
    }

    // 2) PĹ™Ă­stup odepĹ™en (Spring Security)

    /**
     * ZachytĂˇvĂˇ {@link AccessDeniedException} vyhozenou Spring Security.
     *
     * Typicky jde o situace, kdy uĹľivatel nemĂˇ potĹ™ebnou roli pro volĂˇnĂ­
     * danĂ©ho endpointu. VracĂ­ se HTTP status 403 Forbidden.
     */
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ApiError> handleAccessDenied(AccessDeniedException ex,
                                                       HttpServletRequest request) {

        ApiError error = new ApiError(
                HttpStatus.FORBIDDEN.value(),
                "Forbidden",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()
        );

        return ResponseEntity
                .status(HttpStatus.FORBIDDEN)
                .body(error);
    }

    // 3) ChybnĂ© vstupy (IllegalArgumentException)

    /**
     * ZachytĂˇvĂˇ {@link IllegalArgumentException}.
     *
     * PouĹľĂ­vĂˇ se pro obecnĂ© validaÄŤnĂ­ chyby vstupĹŻ nebo nesprĂˇvnĂ©
     * parametry pĹ™edanĂ© do service vrstvy. VracĂ­ se HTTP status 400.
     */
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ApiError> handleIllegalArgument(IllegalArgumentException ex,
                                                          HttpServletRequest request) {

        ApiError error = new ApiError(
                HttpStatus.BAD_REQUEST.value(),
                "Bad Request",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()
        );

        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(error);
    }

    // 4) NeplatnĂ˝ stav aplikace (IllegalStateException)

    /**
     * ZachytĂˇvĂˇ {@link IllegalStateException}.
     *
     * PouĹľĂ­vĂˇ se pro situace, kdy je aplikace v neplatnĂ©m stavu a
     * danĂˇ operace nemĹŻĹľe bĂ˝t provedena. Typicky se vracĂ­ HTTP status 409.
     */
    @ExceptionHandler(IllegalStateException.class)
    public ResponseEntity<ApiError> handleIllegalState(IllegalStateException ex,
                                                       HttpServletRequest request) {

        ApiError error = new ApiError(
                HttpStatus.CONFLICT.value(),
                "Conflict",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()
        );

        return ResponseEntity
                .status(HttpStatus.CONFLICT)
                .body(error);
    }

    // 5) PoruĹˇenĂ­ integrity dat

    /**
     * ZachytĂˇvĂˇ {@link DataIntegrityViolationException} z databĂˇzovĂ© vrstvy.
     *
     * Typicky jde o poruĹˇenĂ­ unikĂˇtnĂ­ch omezenĂ­ nebo jinĂ© konflikty pĹ™i
     * uklĂˇdĂˇnĂ­ dat. Z bezpeÄŤnostnĂ­ch dĹŻvodĹŻ se nevracĂ­ detailnĂ­ databĂˇzovĂˇ
     * zprĂˇva, ale obecnÄ›jĹˇĂ­ chybovĂ© hlĂˇĹˇenĂ­.
     */
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ApiError> handleDataIntegrity(
            DataIntegrityViolationException ex,
            HttpServletRequest request
    ) {
        ApiError error = new ApiError(
                HttpStatus.CONFLICT.value(),
                "Conflict",
                "BE - ZĂˇznam poruĹˇuje unikĂˇtnĂ­ omezenĂ­ (pravdÄ›podobnÄ› duplicitnĂ­ hrĂˇÄŤ).",
                request.getRequestURI(),
                request.getRemoteAddr()
        );

        return ResponseEntity
                .status(HttpStatus.CONFLICT)
                .body(error);
    }

    // 6) NeoÄŤekĂˇvanĂ© chyby (fallback)

    /**
     * Fallback handler pro vĹˇechny neoĹˇetĹ™enĂ© vĂ˝jimky.
     *
     * SlouĹľĂ­ jako poslednĂ­ ochrana proti pĂˇdu aplikace bez odpovÄ›di
     * a vracĂ­ jednotnĂ˝ formĂˇt chyby s HTTP statusem 500.
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiError> handleAll(Exception ex,
                                              HttpServletRequest request) {

        ApiError error = new ApiError(
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error",
                "BE - DoĹˇlo k neoÄŤekĂˇvanĂ© chybÄ› na serveru.",
                request.getRequestURI(),
                request.getRemoteAddr()
        );

        return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(error);
    }

    // 7) ValidaÄŤnĂ­ chyby (@Valid, Bean Validation)

    /**
     * ZachytĂˇvĂˇ validaÄŤnĂ­ chyby vyvolanĂ© anotacĂ­ {@code @Valid}.
     *
     * Do pole {@code details} se uklĂˇdĂˇ mapa ve tvaru nĂˇzev pole â†’ text
     * validaÄŤnĂ­ chyby. VracĂ­ se HTTP status 400 Bad Request.
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiError> handleValidationException(
            MethodArgumentNotValidException ex,
            HttpServletRequest request
    ) {
        HttpStatus status = HttpStatus.BAD_REQUEST;

        Map<String, String> fieldErrors = new java.util.LinkedHashMap<>();

        for (FieldError fieldError : ex.getBindingResult().getFieldErrors()) {
            String fieldName = fieldError.getField();
            String errorMessage = fieldError.getDefaultMessage();

            fieldErrors.merge(
                    fieldName,
                    errorMessage,
                    (existing, added) -> existing + "; " + added
            );
        }

        ApiError error = new ApiError(
                status.value(),
                status.getReasonPhrase(),
                "BE - NeplatnĂˇ vstupnĂ­ data.",
                request.getRequestURI(),
                request.getRemoteAddr(),
                fieldErrors
        );

        return ResponseEntity
                .status(status)
                .body(error);
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\config\package-info.java
-----
/**
 * KonfiguraÄŤnĂ­ tĹ™Ă­dy aplikace.
 *
 * Obsahuje:
 * - obecnou konfiguraci Spring Boot aplikace,
 * - nastavenĂ­ beanĹŻ a integraÄŤnĂ­ch komponent,
 * - konfiguraci technickĂ˝ch aspektĹŻ (napĹ™. CORS, mail, SMS, logging).
 *
 * Tato vrstva:
 * - neobsahuje business logiku,
 * - pĹ™ipravuje prostĹ™edĂ­ a infrastrukturu pro bÄ›h aplikace.
 */
package cz.phsoft.hokej.config;

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\config\SecurityConfig.java
-----
package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.security.impersonation.ImpersonationFilter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import cz.phsoft.hokej.models.services.AppUserService;


import java.util.List;

/**
 * HlavnĂ­ konfigurace Spring Security pro backend aplikace.
 *
 * TĹ™Ă­da zajiĹˇĹĄuje nastavenĂ­ autentizace, autorizace endpointĹŻ,
 * login mechanizmu, sprĂˇvy session a CORS.
 * PouĹľĂ­vĂˇ produkÄŤnĂ­ JSON login a rolovÄ› Ĺ™Ă­zenĂ˝ pĹ™Ă­stup.
 */
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;
    private final PlayerRepository playerRepository;
    private final AppUserService appUserService;

    /**
     * PĹ™Ă­znak demo reĹľimu.
     *
     * Pokud je {@code app.demo-mode=true}, nÄ›kterĂ© operace mohou bĂ˝t
     * omezeny na Ăşrovni service vrstvy.
     */
    @Value("${app.demo-mode:false}")
    private boolean isDemoMode;

    /**
     * Seznam povolenĂ˝ch originĹŻ pro CORS.
     *
     * PĹ™Ă­klad:
     * app.cors.allowed-origins=http://localhost:5173,https://hokej.phsoft.cz
     */
    @Value("${app.cors.allowed-origins:http://localhost:5173,https://hokej.phsoft.cz}")
    private String allowedOrigins;

    public SecurityConfig(CustomUserDetailsService userDetailsService,
                          PlayerRepository playerRepository,
                          AppUserService appUserService) {
        this.userDetailsService = userDetailsService;
        this.playerRepository = playerRepository;
        this.appUserService = appUserService;
    }

    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig)
            throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http,
                                                   AuthenticationManager authManager) throws Exception {

        http
                .csrf(csrf -> csrf.disable())
                .cors(cors -> {})
                .authenticationProvider(authenticationProvider())

                .authorizeHttpRequests(auth -> {

                    /*
                     * PovolenĂ­ CORS preflight requestĹŻ.
                     */
                    auth.requestMatchers(HttpMethod.OPTIONS, "/**").permitAll();

                    /*
                     * VeĹ™ejnĂ© endpointy.
                     */
                    auth.requestMatchers(
                            "/api/auth/register",
                            "/api/auth/verify",
                            "/api/auth/login",
                            "/api/auth/logout",
                            "/api/auth/forgotten-password",
                            "/api/auth/forgotten-password/info",
                            "/api/auth/forgotten-password/reset",
                            "/api/auth/reset-password",
                            "/error",
                            "/favicon.ico",
                            "/public/**",
                            "/api/inactivity/admin/me/**"
                    ).permitAll();

                    /*
                     * DEMO reĹľim: umoĹľnĂ­ ÄŤĂ­st demo notifikace bez pĹ™ihlĂˇĹˇenĂ­.
                     */
                    if (isDemoMode) {
                        auth.requestMatchers("/api/demo/notifications/**").permitAll();
                    }

                    /*
                     * Admin-only endpointy.
                     */
                    auth.requestMatchers("/api/admin/seasons/**").hasRole("ADMIN");
                    auth.requestMatchers("/api/email/test/**").hasRole("ADMIN");
                    auth.requestMatchers("/api/debug/me").hasRole("ADMIN");
                    auth.requestMatchers("/api/test/**").hasRole("ADMIN");

                    /*
                     * Admin + Manager endpointy.
                     */
                    auth.requestMatchers("/api/matches/admin/**").hasAnyRole("ADMIN", "MANAGER");
                    auth.requestMatchers("/api/players/admin/**").hasAnyRole("ADMIN", "MANAGER");
                    auth.requestMatchers("/api/registrations/admin/**").hasAnyRole("ADMIN", "MANAGER");
                    auth.requestMatchers("/api/inactivity/admin/**").hasAnyRole("ADMIN", "MANAGER");

                    /*
                     * Zbytek API pouze pro pĹ™ihlĂˇĹˇenĂ©.
                     */
                    auth.requestMatchers("/api/**").authenticated();
                    auth.anyRequest().authenticated();
                })

                .sessionManagement(sm ->
                        sm.sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
                )

                .addFilterAt(
                        new CustomJsonLoginFilter("/api/auth/login", authManager, appUserService),
                        UsernamePasswordAuthenticationFilter.class
                )

                .addFilterAfter(
                        new ImpersonationFilter(playerRepository),
                        UsernamePasswordAuthenticationFilter.class
                )

                .logout(logout -> logout
                        .logoutUrl("/api/auth/logout")
                        .deleteCookies("JSESSIONID")
                        .logoutSuccessHandler((request, response, auth) -> {
                            request.getSession().removeAttribute("CURRENT_PLAYER_ID");
                            request.getSession().removeAttribute("CURRENT_SEASON_ID");
                            request.getSession().removeAttribute("CURRENT_SEASON_CUSTOM");
                            response.setContentType("application/json");
                            response.setCharacterEncoding("UTF-8");
                            response.getWriter()
                                    .write("{\"status\":\"ok\",\"message\":\"OdhlĂˇĹˇeno\"}");
                        })
                );

        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {

        CorsConfiguration configuration = new CorsConfiguration();

        List<String> origins = List.of(allowedOrigins.split("\\s*,\\s*"));
        configuration.setAllowedOrigins(origins);

        configuration.setAllowedMethods(
                List.of("GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS")
        );

        configuration.setAllowedHeaders(
                List.of("Content-Type", "Authorization", "X-Requested-With")
        );

        configuration.setAllowCredentials(true);

        configuration.setExposedHeaders(List.of("Set-Cookie"));

        UrlBasedCorsConfigurationSource source =
                new UrlBasedCorsConfigurationSource();

        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}

-----
# Soubor: C:\ProjektyPrace\HobbyHokej\backend\src\main\java\cz\phsoft\hokej\config\TimeConfig.java
-----
package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.Clock;

/**
 * Konfigurace systĂ©movĂ©ho ÄŤasu.
 *
 * Poskytuje aplikaÄŤnĂ­ Clock, kterĂ˝ se pouĹľĂ­vĂˇ pro prĂˇci s ÄŤasem
 * napĹ™Ă­ÄŤ aplikacĂ­, aby bylo moĹľnĂ© ÄŤas snadno testovat a udrĹľet
 * konzistentnĂ­ nastavenĂ­ ÄŤasovĂ© zĂłny.
 */
@Configuration
public class TimeConfig {

    @Bean
    public Clock clock() {
        return Clock.systemUTC();
    }
}
