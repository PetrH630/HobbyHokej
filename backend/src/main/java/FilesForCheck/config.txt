Balíček (složka): config
Cesta: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config

Seznam souborů:
AppConfig.java
AuditAspect.java
CustomJsonLoginFilter.java
CustomUserDetailsService.java
DataInitializer.java
GlobalExceptionHandler.java
SecurityConfig.java



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\AppConfig.java
-----

package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class AppConfig {

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\AuditAspect.java
-----

package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

@Component
@Aspect
public class AuditAspect {

    private static final Logger logger = LoggerFactory.getLogger("AUDIT_LOGGER");

    // Pointcut pro vĹˇechny metody ve sluĹľbĂˇch
    @Pointcut("within(cz.phsoft.hokej.models.services..*)")
    public void serviceMethods() {}

    // SpustĂ­ se pĹ™ed metodou
    @Before("serviceMethods()")
    public void logBefore(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().toShortString();
        String args = java.util.Arrays.toString(joinPoint.getArgs());
        logger.info("START {} at {} with args {}", methodName, LocalDateTime.now(), args);
    }

    // SpustĂ­ se po ĂşspÄ›ĹˇnĂ©m dokonÄŤenĂ­ metody
    @AfterReturning(pointcut = "serviceMethods()", returning = "result")
    public void logAfterReturning(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();

        Long userId = null;
        Long playerId = null;

        for (Object arg : args) {
            if (arg instanceof PlayerEntity player) {
                playerId = player.getId();
            } else if (arg instanceof MatchRegistrationEntity registration) {
                playerId = registration.getPlayer().getId();
            } else if (arg instanceof Long id) {
                // pokud mĂˇ metoda Long parametry, mĹŻĹľeĹˇ urÄŤit podle poĹ™adĂ­
                // tĹ™eba prvnĂ­ Long = matchId, druhĂ˝ = playerId
            }
        }

        // logovĂˇnĂ­
        logger.info("END {} - userId={} playerId={} returned [{}] at {}",
                methodName, userId, playerId, result, LocalDateTime.now());
    }
}




-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\CustomJsonLoginFilter.java
-----

package cz.phsoft.hokej.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.context.HttpSessionSecurityContextRepository;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

// filtr pro REST login
public class CustomJsonLoginFilter extends UsernamePasswordAuthenticationFilter {

    private final ObjectMapper objectMapper = new ObjectMapper();

    public CustomJsonLoginFilter(String loginUrl, AuthenticationManager authManager) {
        setFilterProcessesUrl(loginUrl);
        setAuthenticationManager(authManager);
    }

    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        try {
            // x-www-form-urlencoded i JSON
            String email = null;
            String password = null;

// x-www-form-urlencoded
            if (request.getContentType() != null &&
                    request.getContentType().contains("application/x-www-form-urlencoded")) {
                email = request.getParameter("username");
                password = request.getParameter("password");
            }

// JSON
            if ((email == null || password == null) &&
                    request.getContentType() != null &&
                    request.getContentType().contains("application/json")) {
                Map<String, String> json = objectMapper.readValue(request.getInputStream(), Map.class);
                email = json.get("email");
                password = json.get("password");
            }

            if (email == null || password == null || email.isBlank() || password.isBlank()) {
                throw new BadCredentialsException("BE - ChybĂ­ pĹ™ihlaĹˇovacĂ­ Ăşdaje");
            }

            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(email, password);
            setDetails(request, authRequest);

            return this.getAuthenticationManager().authenticate(authRequest);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    // ĂšspÄ›ĹˇnĂ˝ login
    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
                                            FilterChain chain, Authentication authResult)
            throws IOException, ServletException {

        // UloĹľenĂ­ do SecurityContextHolder
        SecurityContextHolder.getContext().setAuthentication(authResult);

        // VytvoĹ™enĂ­ session a uloĹľenĂ­ SPRING_SECURITY_CONTEXT
        request.getSession(true).setAttribute(
                HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY,
                SecurityContextHolder.getContext()
        );

        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");

        Map<String, Object> result = new HashMap<>();
        result.put("status", "ok");
        result.put("user", authResult.getName());

        objectMapper.writeValue(response.getWriter(), result);
    }

    // NeĂşspÄ›ĹˇnĂ˝ login
    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException {
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");

        Map<String, Object> result = new HashMap<>();
        result.put("status", "error");

        // RozliĹˇenĂ­ neaktivovanĂ©ho ĂşÄŤtu
        if (failed.getCause() instanceof cz.phsoft.hokej.exceptions.AccountNotActivatedException) {
            result.put("message", failed.getCause().getMessage()); // napĹ™. "ĂšÄŤet nenĂ­ aktivovĂˇn. Zkontrolujte email."
        } else if (failed instanceof BadCredentialsException) {
            result.put("message", "BE - NeplatnĂ© pĹ™ihlaĹˇovacĂ­ Ăşdaje");
        } else {
            result.put("message", "BE - Chyba pĹ™i pĹ™ihlĂˇĹˇenĂ­");
        }

        objectMapper.writeValue(response.getWriter(), result);
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\CustomUserDetailsService.java
-----

package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import cz.phsoft.hokej.exceptions.AccountNotActivatedException;

import java.util.Set;
import java.util.stream.Collectors;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final AppUserRepository appUserRepository;

    public CustomUserDetailsService(AppUserRepository appUserRepository) {
        this.appUserRepository = appUserRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        AppUserEntity user = appUserRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("BE - UĹľivatel nenalezen"));

        if (!user.isEnabled()) { // nebo podle status == PENDING
            throw new AccountNotActivatedException();
        }

        return org.springframework.security.core.userdetails.User.builder()
                .username(user.getEmail())
                .password(user.getPassword())
                .roles(user.getRole().name().replace("ROLE_", "")) // "ADMIN", "PLAYER", ...
                .disabled(!user.isEnabled()) // neaktivnĂ­ - nelze se pĹ™Ă­hlĂˇsit
                .build();
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\DataInitializer.java
-----

package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.*;
import cz.phsoft.hokej.data.enums.*;
import cz.phsoft.hokej.data.repositories.*;
import jakarta.annotation.PostConstruct;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Component;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Component
public class DataInitializer {


    private final PlayerRepository playerRepository;
    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository matchRegistrationRepository;
    private final AppUserRepository appUserRepository;
    private final SeasonRepository seasonRepository;
    private final JdbcTemplate jdbcTemplate;
    private final BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();

    public DataInitializer(PlayerRepository playerRepository,
                           MatchRepository matchRepository,
                           MatchRegistrationRepository matchRegistrationRepository,
                           AppUserRepository appUserRepository,
                           SeasonRepository seasonRepository,
                           JdbcTemplate jdbcTemplate) {
        this.playerRepository = playerRepository;
        this.matchRepository = matchRepository;
        this.matchRegistrationRepository = matchRegistrationRepository;
        this.appUserRepository = appUserRepository;
        this.seasonRepository = seasonRepository;
        this.jdbcTemplate = jdbcTemplate;
    }

    @PostConstruct
    public void init() {
        initAdmin();
        initPlayersAndUsers();
        initSeasons();
        initMatches();
        initRegistrations();
        initTriggers();

        System.out.println("Data initialization completed.");
    }

    // =====================
    // ADMIN
    // =====================
    private void initAdmin() {
        appUserRepository.findByEmail("admin@example.com").ifPresentOrElse(
                existing -> System.out.println("Admin user already exists â€“ skipping."),
                () -> {
                    AppUserEntity admin = new AppUserEntity();
                    admin.setName("admin");
                    admin.setSurname("admin");
                    admin.setEmail("admin@example.com");
                    admin.setPassword(encoder.encode("Administrator123"));
                    admin.setRole(Role.ROLE_ADMIN);
                    admin.setEnabled(true);
                    appUserRepository.save(admin);
                    System.out.println("Default admin user created.");
                }
        );
    }

    // =====================
    // PLAYERS + USERS
    // =====================
    private void initPlayersAndUsers() {
        if (playerRepository.count() > 0) {
            System.out.println("Players already exist â€“ skipping player initialization.");
            return;
        }

        List<PlayerEntity> players = new ArrayList<>(List.of(
                new PlayerEntity("HrĂˇÄŤ_1", "Jedna", "", PlayerType.VIP, "+420776609956", Team.DARK, PlayerStatus.APPROVED),
                new PlayerEntity("HrĂˇÄŤ_2", "Dva", "", PlayerType.VIP, "+420776609956", Team.LIGHT, PlayerStatus.APPROVED),
                new PlayerEntity("HrĂˇÄŤ_3", "TĹ™i", "", PlayerType.VIP, "+420776609956", Team.LIGHT, PlayerStatus.APPROVED),
                new PlayerEntity("HrĂˇÄŤ_4", "ÄŚtyĹ™i", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT, PlayerStatus.APPROVED),
                new PlayerEntity("HrĂˇÄŤ_5", "PÄ›t", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT, PlayerStatus.PENDING),
                new PlayerEntity("HrĂˇÄŤ_6", "Ĺ est", "", PlayerType.STANDARD, "+420776609956", Team.DARK, PlayerStatus.PENDING),
                new PlayerEntity("HrĂˇÄŤ_7", "Sedm", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT, PlayerStatus.PENDING),
                new PlayerEntity("HrĂˇÄŤ_8", "Osum", "", PlayerType.BASIC, "+420776609956", Team.DARK, PlayerStatus.PENDING),
                new PlayerEntity("HrĂˇÄŤ_9", "DevÄ›t", "", PlayerType.BASIC, "+420776609956", Team.DARK, PlayerStatus.PENDING),
                new PlayerEntity("HrĂˇÄŤ_10", "Deset", "", PlayerType.BASIC, "+420776609956", Team.DARK, PlayerStatus.PENDING)
        ));

        for (PlayerEntity player : players) {
            player.setNotifyByEmail(true);
            player.setNotifyBySms(true);
        }

        int playerCounter = 1;
        for (PlayerEntity player : players) {
            String email = "player" + playerCounter + "@example.com";
            String password = "Player123";

            AppUserEntity user = new AppUserEntity();
            user.setName("HrĂˇÄŤ" + playerCounter);
            user.setSurname("ÄŚĂ­slo_" + playerCounter);
            user.setEmail(email);
            user.setPassword(encoder.encode(password));

            switch (playerCounter) {
                case 1 -> user.setRole(Role.ROLE_ADMIN);
                case 2 -> user.setRole(Role.ROLE_MANAGER);
                default -> user.setRole(Role.ROLE_PLAYER);
            }
            user.setEnabled(true);

            // vztah user <-> player podle tvĂ©ho modelu
            player.setUser(user);

            appUserRepository.save(user); // nebo playerRepository.save(player) â€“ podle cascade
            playerCounter++;
        }

        // pokud cascade nenĂ­, mĹŻĹľeĹˇ explicitnÄ› uloĹľit i hrĂˇÄŤe:
        playerRepository.saveAll(players);

        System.out.println("Players and users initialized.");
    }

    // =====================
    // SEASONS
    // =====================

    private void initSeasons() {
        if (seasonRepository.count() > 0) {
            System.out.println("Seasons already exist â€“ skipping match initialization.");
            return;
        }
        System.out.println("Initializing seasons...");

        // SezĂłna 2024/2025: 1.11.2024 â€“ 31.3.2025
        SeasonEntity season2024_2025 = new SeasonEntity();
        season2024_2025.setName("2024/2025");
        season2024_2025.setStartDate(LocalDate.of(2024, 11, 1));
        season2024_2025.setEndDate(LocalDate.of(2025, 3, 31));
        season2024_2025.setActive(false);

        // SezĂłna 2025/2026: 1.11.2025 â€“ 31.3.2026 (aktuĂˇlnĂ­ â€“ nastavĂ­me jako active)
        SeasonEntity season2025_2026 = new SeasonEntity();
        season2025_2026.setName("2025/2026");
        season2025_2026.setStartDate(LocalDate.of(2025, 11, 1));
        season2025_2026.setEndDate(LocalDate.of(2026, 3, 31));
        season2025_2026.setActive(true);

        // SezĂłna 2026/2027: 1.11.2026 â€“ 31.3.2027
        SeasonEntity season2026_2027 = new SeasonEntity();
        season2026_2027.setName("2026/2027");
        season2026_2027.setStartDate(LocalDate.of(2026, 11, 1));
        season2026_2027.setEndDate(LocalDate.of(2027, 3, 31));
        season2026_2027.setActive(false);

        seasonRepository.saveAll(List.of(
                season2024_2025,
                season2025_2026,
                season2026_2027
        ));

        System.out.println("Seasons initialized.");
    }

    // =====================
    // MATCHES
    // =====================
    private void initMatches() {
        // Pokud uĹľ nÄ›jakĂ© zĂˇpasy existujĂ­, nic nevytvĂˇĹ™Ă­me
        if (matchRepository.count() > 0) {
            System.out.println("Matches already exist â€“ skipping match initialization.");
            return;
        }

        // SezĂłny MUSĂŤ existovat, jinak nemĂˇme co pĹ™iĹ™adit
        java.util.List<SeasonEntity> seasons = seasonRepository.findAll();
        if (seasons.isEmpty()) {
            throw new IllegalStateException("BE - Nelze inicializovat zĂˇpasy, neexistuje ĹľĂˇdnĂˇ sezĂłna.");
        }

        System.out.println("Initializing matches...");

        // vĂ˝chozĂ­ datum prvnĂ­ho zĂˇpasu
        java.time.LocalDateTime startDate = java.time.LocalDateTime.of(2025, 11, 21, 18, 45);

        for (int i = 0; i < 15; i++) {
            MatchEntity match = new MatchEntity();

            java.time.LocalDateTime dateTime = startDate.plusWeeks(i);

            match.setDateTime(dateTime);
            match.setLocation("WOODARĂ‰NA");
            match.setDescription("");
            match.setMaxPlayers(12);
            match.setPrice(2200);
            match.setMatchStatus(null);
            match.setCancelReason(null);

            // đź”ą TADY je KLĂŤÄŚ: vĹľdy najdeme sezĂłnu a nastavĂ­me ji
            SeasonEntity season = findSeasonForDate(dateTime.toLocalDate(), seasons);
            if (season == null) {
                // Tohle by za normĂˇlnĂ­ch okolnostĂ­ nemÄ›lo nastat, ale kdyĹľ jo, chceme failnout srozumitelnÄ›
                throw new IllegalStateException(
                        "BE - NepodaĹ™ilo se najĂ­t sezĂłnu pro datum zĂˇpasu " + dateTime.toLocalDate()
                );
            }
            match.setSeason(season);

            // uloĹľĂ­me zĂˇpas
            matchRepository.save(match);
        }

        System.out.println("Matches initialized.");
    }

    // POMOCNĂ METODA PRO INIT MATCHES - NastavenĂ­ sezony
    private SeasonEntity findSeasonForDate(
            java.time.LocalDate date,
            java.util.List<SeasonEntity> seasons
    ) {
        // 1) ZkusĂ­me najĂ­t sezĂłnu, do kterĂ© datum spadĂˇ (startDate <= date <= endDate)
        for (SeasonEntity season : seasons) {
            boolean startsBeforeOrSame = !date.isBefore(season.getStartDate()); // date >= start
            boolean endsAfterOrSame = !date.isAfter(season.getEndDate());       // date <= end

            if (startsBeforeOrSame && endsAfterOrSame) {
                return season;
            }
        }

        // 2) Pokud ĹľĂˇdnĂˇ nesedĂ­ intervalem, vezmeme aktivnĂ­ sezĂłnu (pokud nÄ›jakĂˇ je)
        for (SeasonEntity season : seasons) {
            if (season.isActive()) {
                return season;
            }
        }

        // 3) Jako ĂşplnĂ˝ fallback vezmeme prvnĂ­ sezĂłnu v seznamu
        //    (k tomuhle by se to nemÄ›lo moc dostĂˇvat, ale je to bezpeÄŤnĂˇ pojistka)
        return seasons.get(0);
    }



    // =====================
    // REGISTRATIONS
    // =====================
    private void initRegistrations() {
        if (matchRegistrationRepository.count() > 0) {
            System.out.println("Match registrations already exist â€“ skipping registration initialization.");
            return;
        }

        List<MatchEntity> matches = matchRepository.findAll();
        List<PlayerEntity> players = playerRepository.findAll();

        if (matches.isEmpty() || players.size() < 6) {
            System.out.println("Not enough data to create registrations â€“ skipping.");
            return;
        }

        MatchEntity match = matches.get(2); // â€žtĹ™etĂ­â€ś vytvoĹ™enĂ˝ zĂˇpas
        for (int i = 0; i < 6; i++) {
            PlayerEntity player = players.get(i);

            MatchRegistrationEntity reg = new MatchRegistrationEntity();
            reg.setMatch(match);
            reg.setPlayer(player);
            reg.setStatus(PlayerMatchStatus.REGISTERED);
            reg.setTeam(i < 3 ? Team.DARK : Team.LIGHT);
            reg.setTimestamp(LocalDateTime.now());
            reg.setCreatedBy("initializer");

            matchRegistrationRepository.save(reg);
        }

        System.out.println("Sample registrations initialized.");
    }

    // =====================
    // TRIGGERS
    // =====================
    private void initTriggers() {
        createTrigger("trg_match_reg_insert", """
                CREATE TRIGGER trg_match_reg_insert
                AFTER INSERT ON match_registrations
                FOR EACH ROW
                BEGIN
                    INSERT INTO match_registration_history
                    (match_registration_id, match_id, player_id, status, excuse_reason,
                     excuse_note, admin_note, team, original_timestamp, created_by,
                     action, changed_at)
                    VALUES
                    (NEW.id, NEW.match_id, NEW.player_id, NEW.status, NEW.excuse_reason,
                     NEW.excuse_note, NEW.admin_note, NEW.team, NEW.timestamp, NEW.created_by,
                     'INSERT', NOW());
                END
                """);

        createTrigger("trg_match_reg_update", """
                CREATE TRIGGER trg_match_reg_update
                AFTER UPDATE ON match_registrations
                FOR EACH ROW
                BEGIN
                    INSERT INTO match_registration_history
                    (match_registration_id, match_id, player_id, status, excuse_reason,
                     excuse_note, admin_note, team, original_timestamp, created_by,
                     action, changed_at)
                    VALUES
                    (NEW.id, NEW.match_id, NEW.player_id, NEW.status, NEW.excuse_reason,
                     NEW.excuse_note, NEW.admin_note, NEW.team, NEW.timestamp, NEW.created_by,
                     'UPDATE', NOW());
                END
                """);

        createTrigger("trg_match_reg_delete", """
                CREATE TRIGGER trg_match_reg_delete
                AFTER DELETE ON match_registrations
                FOR EACH ROW
                BEGIN
                    INSERT INTO match_registration_history
                    (match_registration_id, match_id, player_id, status, excuse_reason,
                     excuse_note, admin_note, team, original_timestamp, created_by,
                     action, changed_at)
                    VALUES
                    (OLD.id, OLD.match_id, OLD.player_id, OLD.status, OLD.excuse_reason,
                     OLD.excuse_note, OLD.admin_note, OLD.team, OLD.timestamp, OLD.created_by,
                     'DELETE', NOW());
                END
                """);
    }

    private void createTrigger(String name, String sql) {
        try {
            jdbcTemplate.execute(sql);
            System.out.println("Trigger " + name + " created successfully.");
        } catch (Exception e) {
            System.out.println("Trigger " + name + " already exists or error: " + e.getMessage());
        }
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\GlobalExceptionHandler.java
-----

package cz.phsoft.hokej.config;

import cz.phsoft.hokej.exceptions.ApiError;
import cz.phsoft.hokej.exceptions.BusinessException;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import jakarta.servlet.http.HttpServletRequest;

@ControllerAdvice
public class GlobalExceptionHandler {

    // 1) VĹˇechny domĂ©novĂ© / business chyby (extends BusinessException)
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ApiError> handleBusinessException(
            BusinessException ex,
            HttpServletRequest request) {

        ApiError error = new ApiError(
                ex.getStatus().value(),
                ex.getStatus().getReasonPhrase(),
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()
        );
        return ResponseEntity.status(ex.getStatus()).body(error);
    }

    // 2) PĹ™Ă­stup odepĹ™en (Spring Security)
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ApiError> handleAccessDenied(AccessDeniedException ex,
                                                       HttpServletRequest request) {

        ApiError error = new ApiError(
                HttpStatus.FORBIDDEN.value(),
                "Forbidden",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()
        );
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(error);
    }

    // 3) ValidaÄŤnĂ­ chyby - ĹˇpatnĂ© vstupy (napĹ™. hesla se neshodujĂ­, ĹˇpatnĂ© datum)
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ApiError> handleIllegalArgument(IllegalArgumentException ex,
                                                          HttpServletRequest request) {

        ApiError error = new ApiError(
                HttpStatus.BAD_REQUEST.value(),
                "Bad Request",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()
        );
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    // 4) StavovĂ© chyby aplikace - typicky konflikty (napĹ™. nelze zvolit neschvĂˇlenĂ©ho hrĂˇÄŤe)
    @ExceptionHandler(IllegalStateException.class)
    public ResponseEntity<ApiError> handleIllegalState(IllegalStateException ex,
                                                       HttpServletRequest request) {

        ApiError error = new ApiError(
                HttpStatus.CONFLICT.value(),
                "Conflict",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()
        );
        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
    }

    // 5) race condition
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ApiError> handleDataIntegrity(
            DataIntegrityViolationException ex,
            HttpServletRequest request
    ) {
        ApiError error = new ApiError(
                HttpStatus.CONFLICT.value(),
                "Conflict",
                "BE - ZĂˇznam poruĹˇuje unikĂˇtnĂ­ omezenĂ­ (pravdÄ›podobnÄ› duplicitnĂ­ hrĂˇÄŤ).",
                request.getRequestURI(),
                request.getRemoteAddr()
        );

        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
    }


    // 6) OstatnĂ­ neÄŤekanĂ© chyby (fallback)
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiError> handleAll(Exception ex,
                                              HttpServletRequest request) {

        ApiError error = new ApiError(
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()
        );
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\SecurityConfig.java
-----

package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.security.config.http.SessionCreationPolicy;


import java.util.List;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;

    @Value("${app.test-mode:false}")
    private boolean isTestMode;

    public SecurityConfig(CustomUserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    // Password encoder
    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    // Authentication provider
    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    // AuthenticationManager
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    // Security filter chain
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http, AuthenticationManager authManager) throws Exception {

        http.csrf(csrf -> csrf.disable())
                .cors(cors -> {
                });

        if (isTestMode) {
            // Test mode - vĹˇechno povoleno a HTTP Basic pro Postman
            http.authorizeHttpRequests(auth -> auth.anyRequest().permitAll())
                    .httpBasic();
        } else {
            // Produkce - REST login pĹ™es CustomJsonLoginFilter
            http
                    .authenticationProvider(authenticationProvider())
                    .authorizeHttpRequests(auth -> auth
                            .requestMatchers("/api/auth/register", "/api/auth/verify").permitAll()
                            .requestMatchers("/api/login").permitAll()
                            .requestMatchers("/api/logout").permitAll()
                            .requestMatchers("/api/matches").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/matches/upcoming", "/api/matches/past").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/matches/**").authenticated()
                            .requestMatchers("/api/players").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/players/**").authenticated()
                            .requestMatchers("/api/registrations/all",
                                    "/api/registrations/for-match/**",
                                    "/api/registrations/no-response/**").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/registrations/**").authenticated()
                            .requestMatchers("/api/inactivity/All",
                                    "/api/inactivity/**").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/inactivity/player/**").authenticated()
                            .anyRequest().authenticated()
                    )
                    //  TADY PĹESNÄš
                    .sessionManagement(sm ->
                            sm.sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
                    )
                    //  a TEPRVE PAK login filter
                    .addFilterAt(
                            new CustomJsonLoginFilter("/api/login", authManager),
                            UsernamePasswordAuthenticationFilter.class
                    )
                    .logout(logout -> logout
                            .logoutUrl("/api/logout")
                            .deleteCookies("JSESSIONID")
                            .logoutSuccessHandler((request, response, auth) -> {
                                request.getSession().removeAttribute("CURRENT_PLAYER_ID");
                                response.setContentType("application/json");
                                response.setCharacterEncoding("UTF-8");
                                response.getWriter().write("{\"status\":\"ok\",\"message\":\"OdhlĂˇĹˇeno\"}");
                            })
                    );
        }

        return http.build();
    }

    // CORS pro React dev server a cookies
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(List.of("http://localhost:5173"));
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}


