Balíček (složka): config
Cesta: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config

Seznam souborů:
AppConfig.java
AuditAspect.java
CustomJsonLoginFilter.java
CustomUserDetailsService.java
DataInitializer.java
GlobalExceptionHandler.java
SecurityConfig.java



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\AppConfig.java
-----

package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class AppConfig {

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\AuditAspect.java
-----

package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

/**
 * AuditAspect
 *
 * CROSS-CUTTING CONCERN:
 * ----------------------
 * Tento aspekt slouĹľĂ­ k centrĂˇlnĂ­mu auditnĂ­mu logovĂˇnĂ­ volĂˇnĂ­
 * service vrstev aplikace.
 *
 * CO LOGUJE:
 * ----------
 * - zaÄŤĂˇtek volĂˇnĂ­ metody (nĂˇzev + argumenty)
 * - konec ĂşspÄ›ĹˇnĂ©ho volĂˇnĂ­ metody
 * - nĂˇvratovou hodnotu
 * - ÄŤasovĂ© razĂ­tko
 *
 * ROZSAH:
 * -------
 * - vĹˇechny metody ve vĹˇech tĹ™Ă­dĂˇch v balĂ­ÄŤku
 *   cz.phsoft.hokej.models.services..*
 *
 * PROÄŚ AOP:
 * ----------
 * - auditnĂ­ logika nenĂ­ roztrouĹˇena po sluĹľbĂˇch
 * - ĹľĂˇdnĂ© duplikace kĂłdu
 * - snadnĂ© zapnutĂ­ / vypnutĂ­ / Ăşpravy
 *
 * BEZPEÄŚNOST:
 * -----------
 * - aspekt NEMÄšNĂŤ chovĂˇnĂ­ aplikace
 * - pouze ÄŤte data a loguje
 * - v pĹ™Ă­padÄ› chyby v logovĂˇnĂ­ aplikace pokraÄŤuje dĂˇl
 */
@Component
@Aspect
public class AuditAspect {

    /**
     * SpeciĂˇlnĂ­ logger urÄŤenĂ˝ pouze pro auditnĂ­ zĂˇznamy.
     *
     * DoporuÄŤenĂ­:
     * - v logback.xml / log4j2.xml mĂ­t samostatnĂ˝ appender (soubor)
     * - oddÄ›lit auditnĂ­ logy od aplikaÄŤnĂ­ch logĹŻ
     */
    private static final Logger logger = LoggerFactory.getLogger("AUDIT_LOGGER");

    // =====================================================
    // POINTCUT
    // =====================================================

    /**
     * Pointcut definujĂ­cĂ­ vĹˇechny metody ve service vrstvÄ›.
     *
     * Zahrnuje:
     * - vĹˇechny tĹ™Ă­dy
     * - vĹˇechny metody
     * - vÄŤetnÄ› podbalĂ­ÄŤkĹŻ
     */
    @Pointcut("within(cz.phsoft.hokej.models.services..*)")
    public void serviceMethods() {
        // pouze marker metoda pro pointcut
    }

    // =====================================================
    // BEFORE ADVICE
    // =====================================================

    /**
     * SpustĂ­ se PĹED zavolĂˇnĂ­m jakĂ©koli service metody.
     *
     * SlouĹľĂ­ pro:
     * - zĂˇznam zaÄŤĂˇtku operace
     * - debug / audit ÄŤasovĂˇnĂ­
     *
     * @param joinPoint kontext volanĂ© metody
     */
    @Before("serviceMethods()")
    public void logBefore(JoinPoint joinPoint) {

        String methodName = joinPoint.getSignature().toShortString();
        String args = java.util.Arrays.toString(joinPoint.getArgs());

        logger.info(
                "START {} at {} with args {}",
                methodName,
                LocalDateTime.now(),
                args
        );
    }

    // =====================================================
    // AFTER RETURNING ADVICE
    // =====================================================

    /**
     * SpustĂ­ se PO ĂšSPÄšĹ NĂ‰M dokonÄŤenĂ­ metody
     * (NEspustĂ­ se pĹ™i vyhozenĂ­ vĂ˝jimky).
     *
     * SlouĹľĂ­ pro:
     * - audit ĂşspÄ›ĹˇnĂ˝ch operacĂ­
     * - logovĂˇnĂ­ nĂˇvratovĂ˝ch hodnot
     *
     * @param joinPoint kontext volanĂ© metody
     * @param result    nĂˇvratovĂˇ hodnota metody
     */
    @AfterReturning(
            pointcut = "serviceMethods()",
            returning = "result"
    )
    public void logAfterReturning(JoinPoint joinPoint, Object result) {

        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();

        Long userId = null;
        Long playerId = null;

        /*
         * Pokus o extrakci zajĂ­mavĂ˝ch business identifikĂˇtorĹŻ
         * z parametrĹŻ metody.
         *
         * CĂ­lem je mĂ­t auditnĂ­ stopu:
         * - KTERĂť HRĂÄŚ
         * - JAKĂ OPERACE
         */
        for (Object arg : args) {
            if (arg instanceof PlayerEntity player) {
                playerId = player.getId();
            } else if (arg instanceof MatchRegistrationEntity registration) {
                playerId = registration.getPlayer().getId();
            } else if (arg instanceof Long id) {
                // zde mĹŻĹľeĹˇ pĹ™Ă­padnÄ› rozliĹˇovat:
                // - prvnĂ­ Long = matchId
                // - druhĂ˝ Long = playerId
                // dle konvence signatur metod
            }
        }

        logger.info(
                "END {} - userId={} playerId={} returned [{}] at {}",
                methodName,
                userId,
                playerId,
                result,
                LocalDateTime.now()
        );
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\CustomJsonLoginFilter.java
-----

package cz.phsoft.hokej.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.context.HttpSessionSecurityContextRepository;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

/**
 * VlastnĂ­ autentizaÄŤnĂ­ filtr pro REST pĹ™ihlĂˇĹˇenĂ­ (JSON / FORM).
 *
 * ĂšÄŚEL:
 * <ul>
 *     <li>umoĹľĹuje pĹ™ihlĂˇĹˇenĂ­ pomocĂ­ JSON (application/json),</li>
 *     <li>zachovĂˇvĂˇ podporu klasickĂ©ho form loginu (x-www-form-urlencoded),</li>
 *     <li>nahrazuje standardnĂ­ redirect chovĂˇnĂ­ Spring Security JSON odpovÄ›ÄŹmi,</li>
 *     <li>vytvĂˇĹ™Ă­ HTTP session a uklĂˇdĂˇ SecurityContext (stateful autentizace).</li>
 * </ul>
 *
 * PROÄŚ JE POTĹEBA:
 * <ul>
 *     <li>{@link UsernamePasswordAuthenticationFilter} standardnÄ› oÄŤekĂˇvĂˇ
 *         pouze form data,</li>
 *     <li>SPA frontend (React / Vite) posĂ­lĂˇ JSON,</li>
 *     <li>REST API nemĂˇ pouĹľĂ­vat redirecty, ale strukturovanĂ© JSON odpovÄ›di.</li>
 * </ul>
 *
 * BEZPEÄŚNOST:
 * <ul>
 *     <li>autentizace probĂ­hĂˇ vĂ˝hradnÄ› pĹ™es {@link AuthenticationManager},</li>
 *     <li>heslo se nikdy neloguje ani nevracĂ­ klientovi,</li>
 *     <li>po ĂşspÄ›chu je vytvoĹ™en {@link org.springframework.security.core.context.SecurityContext}
 *         uloĹľenĂ˝ v HTTP session.</li>
 * </ul>
 *
 * POZNĂMKA:
 * <ul>
 *     <li>tento filtr je urÄŤen pro stateful (session-based) autentizaci,</li>
 *     <li>pro JWT / stateless pĹ™Ă­stup by byl nahrazen jinĂ˝m Ĺ™eĹˇenĂ­m.</li>
 * </ul>
 */
public class CustomJsonLoginFilter extends UsernamePasswordAuthenticationFilter {

    /**
     * Jackson ObjectMapper pro ÄŤtenĂ­ JSON z request body.
     */
    private final ObjectMapper objectMapper = new ObjectMapper();

    /**
     * Konstruktor filtru.
     *
     * @param loginUrl    URL endpointu pro login (napĹ™. /api/auth/login)
     * @param authManager Spring Security {@link AuthenticationManager}
     */
    public CustomJsonLoginFilter(String loginUrl, AuthenticationManager authManager) {
        setFilterProcessesUrl(loginUrl);
        setAuthenticationManager(authManager);
    }

    // =====================================================
    // POKUS O AUTENTIZACI (LOGIN)
    // =====================================================

    /**
     * PokusĂ­ se autentizovat uĹľivatele na zĂˇkladÄ› requestu.
     *
     * PodporovanĂ© formĂˇty:
     * <ul>
     *     <li>application/x-www-form-urlencoded</li>
     *     <li>application/json</li>
     * </ul>
     *
     * OÄŤekĂˇvanĂˇ pole:
     * <ul>
     *     <li>email (username)</li>
     *     <li>password</li>
     * </ul>
     *
     * @throws AuthenticationException pĹ™i chybÄ› pĹ™ihlĂˇĹˇenĂ­
     */
    @Override
    public Authentication attemptAuthentication(HttpServletRequest request,
                                                HttpServletResponse response)
            throws AuthenticationException {

        try {
            String email = null;
            String password = null;

            // -------------------------------------------------
            // FORM LOGIN (x-www-form-urlencoded)
            // -------------------------------------------------
            if (request.getContentType() != null &&
                    request.getContentType().contains("application/x-www-form-urlencoded")) {

                email = request.getParameter("username");
                password = request.getParameter("password");
            }

            // -------------------------------------------------
            // JSON LOGIN (application/json)
            // -------------------------------------------------
            if ((email == null || password == null) &&
                    request.getContentType() != null &&
                    request.getContentType().contains("application/json")) {

                Map<String, String> json =
                        objectMapper.readValue(request.getInputStream(), Map.class);

                email = json.get("email");
                password = json.get("password");
            }

            // -------------------------------------------------
            // VALIDACE VSTUPĹ®
            // -------------------------------------------------
            if (email == null || password == null ||
                    email.isBlank() || password.isBlank()) {

                throw new BadCredentialsException("BE - ChybĂ­ pĹ™ihlaĹˇovacĂ­ Ăşdaje");
            }

            // -------------------------------------------------
            // VYTVOĹENĂŤ AUTHENTICATION TOKENU
            // -------------------------------------------------
            UsernamePasswordAuthenticationToken authRequest =
                    new UsernamePasswordAuthenticationToken(email, password);

            setDetails(request, authRequest);

            // delegace autentizace na AuthenticationManager
            return this.getAuthenticationManager().authenticate(authRequest);

        } catch (IOException e) {
            // chyba pĹ™i ÄŤtenĂ­ JSON body (malformed JSON apod.)
            throw new RuntimeException(e);
        }
    }

    // =====================================================
    // ĂšSPÄšĹ NĂť LOGIN
    // =====================================================

    /**
     * ZavolĂˇ se po ĂşspÄ›ĹˇnĂ© autentizaci.
     *
     * Co se zde dÄ›je:
     * <ul>
     *     <li>uloĹľĂ­ se {@link Authentication} do {@link SecurityContextHolder},</li>
     *     <li>vytvoĹ™Ă­ se HTTP session (pokud neexistuje),</li>
     *     <li>do session se uloĹľĂ­ SPRING_SECURITY_CONTEXT,</li>
     *     <li>vrĂˇtĂ­ se JSON odpovÄ›ÄŹ mĂ­sto redirectu.</li>
     * </ul>
     */
    @Override
    protected void successfulAuthentication(HttpServletRequest request,
                                            HttpServletResponse response,
                                            FilterChain chain,
                                            Authentication authResult)
            throws IOException, ServletException {

        // nastavenĂ­ SecurityContext
        SecurityContextHolder.getContext().setAuthentication(authResult);

        // vytvoĹ™enĂ­ session a uloĹľenĂ­ kontextu
        request.getSession(true).setAttribute(
                HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY,
                SecurityContextHolder.getContext()
        );

        // JSON odpovÄ›ÄŹ
        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");

        Map<String, Object> result = new HashMap<>();
        result.put("status", "ok");
        result.put("user", authResult.getName());

        objectMapper.writeValue(response.getWriter(), result);
    }

    // =====================================================
    // NEĂšSPÄšĹ NĂť LOGIN
    // =====================================================

    /**
     * ZavolĂˇ se pĹ™i neĂşspÄ›ĹˇnĂ©m pĹ™ihlĂˇĹˇenĂ­.
     *
     * VracĂ­ JSON odpovÄ›ÄŹ s HTTP 401.
     *
     * RozliĹˇuje:
     * <ul>
     *     <li>neaktivovanĂ˝ ĂşÄŤet,</li>
     *     <li>neplatnĂ© pĹ™ihlaĹˇovacĂ­ Ăşdaje,</li>
     *     <li>ostatnĂ­ chyby autentizace.</li>
     * </ul>
     */
    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request,
                                              HttpServletResponse response,
                                              AuthenticationException failed)
            throws IOException, ServletException {

        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");

        Map<String, Object> result = new HashMap<>();
        result.put("status", "error");

        if (failed.getCause() instanceof cz.phsoft.hokej.exceptions.AccountNotActivatedException) {
            result.put("message", failed.getCause().getMessage());
        } else if (failed instanceof BadCredentialsException) {
            result.put("message", "BE - NeplatnĂ© pĹ™ihlaĹˇovacĂ­ Ăşdaje");
        } else {
            result.put("message", "BE - Chyba pĹ™i pĹ™ihlĂˇĹˇenĂ­");
        }

        objectMapper.writeValue(response.getWriter(), result);
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\CustomUserDetailsService.java
-----

package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.exceptions.AccountNotActivatedException;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

/**
 * {@link UserDetailsService} implementace napojujĂ­cĂ­ Spring Security
 * na vlastnĂ­ databĂˇzovĂ˝ model uĹľivatele ({@link AppUserEntity}).
 *
 * ĂšÄŚEL:
 * <ul>
 *     <li>pĹ™i pĹ™ihlĂˇĹˇenĂ­ naÄŤĂ­st uĹľivatele z DB podle emailu,</li>
 *     <li>ovÄ›Ĺ™it existenci ĂşÄŤtu a jeho aktivaci,</li>
 *     <li>namapovat {@link AppUserEntity} na {@link UserDetails} objekt,
 *         kterĂ˝ Spring Security pouĹľĂ­vĂˇ pĹ™i autentizaci.</li>
 * </ul>
 *
 * JAK JE TO POUĹ˝ITĂ‰ VE SPRING SECURITY:
 * <ul>
 *     <li>pĹ™i loginu Spring Security zavolĂˇ {@link #loadUserByUsername(String)},</li>
 *     <li>vrĂˇcenĂ˝ {@link UserDetails} obsahuje:</li>
 *     <ul>
 *         <li>username (email),</li>
 *         <li>heslo (hashovanĂ©),</li>
 *         <li>role / autority.</li>
 *     </ul>
 * </ul>
 *
 * BEZPEÄŚNOST:
 * <ul>
 *     <li>heslo se porovnĂˇvĂˇ automaticky pĹ™es {@code PasswordEncoder},</li>
 *     <li>pokud ĂşÄŤet nenĂ­ aktivovĂˇn ({@code enabled == false}),
 *         vyhodĂ­ se {@link AccountNotActivatedException},</li>
 *     <li>typ vyhozenĂ© vĂ˝jimky pĹ™Ă­mo ovlivĹuje vĂ˝sledek pĹ™ihlĂˇĹˇenĂ­
 *         (napĹ™. jinĂˇ hlĂˇĹˇka pro â€žneaktivovanĂ˝ ĂşÄŤetâ€ś vs. â€žuĹľivatel nenalezenâ€ś).</li>
 * </ul>
 */
@Service
public class CustomUserDetailsService implements UserDetailsService {

    /**
     * RepozitĂˇĹ™ uĹľivatelĹŻ â€“ pouĹľĂ­vĂˇ se pouze pro naÄŤtenĂ­ dat pro autentizaci.
     */
    private final AppUserRepository appUserRepository;

    public CustomUserDetailsService(AppUserRepository appUserRepository) {
        this.appUserRepository = appUserRepository;
    }

    // =====================================================
    // NAÄŚTENĂŤ UĹ˝IVATELE PRO SPRING SECURITY
    // =====================================================

    /**
     * NaÄŤte uĹľivatele podle emailu (username) pro potĹ™eby autentizace.
     * <p>
     * Tato metoda je volĂˇna Spring Security pĹ™i pĹ™ihlĂˇĹˇenĂ­.
     *
     * @param email email zadanĂ˝ uĹľivatelem pĹ™i loginu (username)
     * @return {@link UserDetails} objekt pouĹľitĂ˝ pro autentizaci
     *
     * @throws UsernameNotFoundException    pokud uĹľivatel s danĂ˝m emailem neexistuje
     * @throws AccountNotActivatedException pokud ĂşÄŤet existuje, ale nenĂ­ aktivnĂ­
     */
    @Override
    public UserDetails loadUserByUsername(String email)
            throws UsernameNotFoundException {

        // -------------------------------------------------
        // NAÄŚTENĂŤ UĹ˝IVATELE Z DB
        // -------------------------------------------------
        AppUserEntity user = appUserRepository.findByEmail(email)
                .orElseThrow(() ->
                        new UsernameNotFoundException("BE - UĹľivatel nenalezen")
                );

        // -------------------------------------------------
        // KONTROLA AKTIVACE ĂšÄŚTU
        // -------------------------------------------------
        if (!user.isEnabled()) {
            // vlastnĂ­ vĂ˝jimka â€“ typicky se zachytĂˇvĂˇ ve filtru pro login
            // a pĹ™eloĹľĂ­ se na vhodnou odpovÄ›ÄŹ pro FE
            throw new AccountNotActivatedException();
        }

        // -------------------------------------------------
        // MAPOVĂNĂŤ NA UserDetails
        // -------------------------------------------------
        return User.builder()
                .username(user.getEmail())
                .password(user.getPassword())
                /*
                 * role se uloĹľĂ­ bez prefixu (ADMIN / MANAGER / PLAYER),
                 * Spring si automaticky pĹ™idĂˇ prefix "ROLE_".
                 * PĹ™Ă­klad:
                 *   user.getRole() = "ROLE_ADMIN"
                 *   â†’ .roles("ADMIN")
                 *   â†’ vĂ˝slednĂˇ autorita: "ROLE_ADMIN"
                 */
                .roles(user.getRole().name().replace("ROLE_", ""))
                /*
                 * disabled = true â†’ ĂşÄŤet se nemĹŻĹľe pĹ™ihlĂˇsit.
                 * V praxi je to zde trochu redundantnĂ­ (uĹľ jsme ovÄ›Ĺ™ili enabled),
                 * ale drĹľĂ­me flag konzistentnĂ­ se stavem v DB.
                 */
                .disabled(!user.isEnabled())
                .build();
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\DataInitializer.java
-----

package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.*;
import cz.phsoft.hokej.data.enums.*;
import cz.phsoft.hokej.data.repositories.*;
import jakarta.annotation.PostConstruct;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Component;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.temporal.TemporalAdjusters;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

@Component
public class DataInitializer {


    private final PlayerRepository playerRepository;
    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository matchRegistrationRepository;
    private final AppUserRepository appUserRepository;
    private final SeasonRepository seasonRepository;
    private final JdbcTemplate jdbcTemplate;
    private final BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
    private int j;

    public DataInitializer(PlayerRepository playerRepository,
                           MatchRepository matchRepository,
                           MatchRegistrationRepository matchRegistrationRepository,
                           AppUserRepository appUserRepository,
                           SeasonRepository seasonRepository,
                           JdbcTemplate jdbcTemplate) {
        this.playerRepository = playerRepository;
        this.matchRepository = matchRepository;
        this.matchRegistrationRepository = matchRegistrationRepository;
        this.appUserRepository = appUserRepository;
        this.seasonRepository = seasonRepository;
        this.jdbcTemplate = jdbcTemplate;
    }

    @PostConstruct
    public void init() {
        initAdmin();
        initPlayersAndUsers();
        initSeasons();
        initMatches();
        initRegistrations();
        initTriggers();

        System.out.println("Data initialization completed.");
    }

    // =====================
    // ADMIN
    // =====================
    private void initAdmin() {
        appUserRepository.findByEmail("admin@example.com").ifPresentOrElse(
                existing -> System.out.println("Admin user already exists â€“ skipping."),
                () -> {
                    AppUserEntity admin = new AppUserEntity();
                    admin.setName("admin");
                    admin.setSurname("admin");
                    admin.setEmail("admin@example.com");
                    admin.setPassword(encoder.encode("Administrator123"));
                    admin.setRole(Role.ROLE_ADMIN);
                    admin.setEnabled(true);
                    appUserRepository.save(admin);
                    System.out.println("Default admin user created.");
                }
        );
    }

    // =====================
    // PLAYERS + USERS
    // =====================
    private void initPlayersAndUsers() {
        if (playerRepository.count() > 0) {
            System.out.println("Players already exist â€“ skipping player initialization.");
            return;
        }

        List<PlayerEntity> players = new ArrayList<>(List.of(
                new PlayerEntity("HrĂˇÄŤ_1", "Jedna", "", PlayerType.VIP, "+420776609956", Team.DARK, PlayerStatus.APPROVED),
                new PlayerEntity("HrĂˇÄŤ_2", "Dva", "", PlayerType.VIP, "+420776609956", Team.LIGHT, PlayerStatus.APPROVED),
                new PlayerEntity("HrĂˇÄŤ_3", "TĹ™i", "", PlayerType.VIP, "+420776609956", Team.LIGHT, PlayerStatus.APPROVED),
                new PlayerEntity("HrĂˇÄŤ_4", "ÄŚtyĹ™i", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT, PlayerStatus.APPROVED),
                new PlayerEntity("HrĂˇÄŤ_5", "PÄ›t", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT, PlayerStatus.APPROVED),
                new PlayerEntity("HrĂˇÄŤ_6", "Ĺ est", "", PlayerType.STANDARD, "+420776609956", Team.DARK, PlayerStatus.APPROVED),
                new PlayerEntity("HrĂˇÄŤ_7", "Sedm", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT, PlayerStatus.APPROVED),
                new PlayerEntity("HrĂˇÄŤ_8", "Osum", "", PlayerType.BASIC, "+420776609956", Team.DARK, PlayerStatus.APPROVED),
                new PlayerEntity("HrĂˇÄŤ_9", "DevÄ›t", "", PlayerType.BASIC, "+420776609956", Team.DARK, PlayerStatus.APPROVED),
                new PlayerEntity("HrĂˇÄŤ_10", "Deset", "", PlayerType.BASIC, "+420776609956", Team.DARK, PlayerStatus.PENDING)
        ));

        for (PlayerEntity player : players) {
            player.setNotifyByEmail(true);
            player.setNotifyBySms(true);
        }

        int playerCounter = 1;
        for (PlayerEntity player : players) {
            String email = "player" + playerCounter + "@example.com";
            String password = "Player123";

            AppUserEntity user = new AppUserEntity();
            user.setName("HrĂˇÄŤ" + playerCounter);
            user.setSurname("ÄŚĂ­slo_" + playerCounter);
            user.setEmail(email);
            user.setPassword(encoder.encode(password));

            switch (playerCounter) {
                case 1 -> user.setRole(Role.ROLE_ADMIN);
                case 2 -> user.setRole(Role.ROLE_MANAGER);
                default -> user.setRole(Role.ROLE_PLAYER);
            }
            user.setEnabled(true);

            // vztah user <-> player podle tvĂ©ho modelu
            player.setUser(user);

            appUserRepository.save(user); // nebo playerRepository.save(player) â€“ podle cascade
            playerCounter++;
        }

        // pokud cascade nenĂ­, mĹŻĹľeĹˇ explicitnÄ› uloĹľit i hrĂˇÄŤe:
        playerRepository.saveAll(players);

        System.out.println("Players and users initialized.");
    }

    // =====================
    // SEASONS
    // =====================

    private void initSeasons() {
        if (seasonRepository.count() > 0) {
            System.out.println("Seasons already exist â€“ skipping match initialization.");
            return;
        }
        System.out.println("Initializing seasons...");

        // SezĂłna 2024/2025: 1.11.2024 â€“ 31.3.2025
        SeasonEntity season2024_2025 = new SeasonEntity();
        season2024_2025.setName("2024/2025");
        season2024_2025.setStartDate(LocalDate.of(2024, 11, 20));
        season2024_2025.setEndDate(LocalDate.of(2025, 3, 31));
        season2024_2025.setActive(false);

        // SezĂłna 2025/2026: 1.11.2025 â€“ 31.3.2026 (aktuĂˇlnĂ­ â€“ nastavĂ­me jako active)
        SeasonEntity season2025_2026 = new SeasonEntity();
        season2025_2026.setName("2025/2026");
        season2025_2026.setStartDate(LocalDate.of(2025, 11, 21));
        season2025_2026.setEndDate(LocalDate.of(2026, 3, 31));
        season2025_2026.setActive(true);

        // SezĂłna 2026/2027: 1.11.2026 â€“ 31.3.2027
        SeasonEntity season2026_2027 = new SeasonEntity();
        season2026_2027.setName("2026/2027");
        season2026_2027.setStartDate(LocalDate.of(2026, 11, 1));
        season2026_2027.setEndDate(LocalDate.of(2027, 3, 31));
        season2026_2027.setActive(false);

        seasonRepository.saveAll(List.of(
                season2024_2025,
                season2025_2026,
                season2026_2027
        ));

        System.out.println("Seasons initialized.");
    }

    // =====================
    // MATCHES
    // =====================
    private void initMatches() {
        // Pokud uĹľ nÄ›jakĂ© zĂˇpasy existujĂ­, nic nevytvĂˇĹ™Ă­me
        if (matchRepository.count() > 0) {
            System.out.println("Matches already exist â€“ skipping match initialization.");
            return;
        }

        // SezĂłny MUSĂŤ existovat, jinak nemĂˇme co pĹ™iĹ™adit
        List<SeasonEntity> seasons = seasonRepository.findAll();
        if (seasons.isEmpty()) {
            throw new IllegalStateException("BE - Nelze inicializovat zĂˇpasy, neexistuje ĹľĂˇdnĂˇ sezĂłna.");
        }


        System.out.println("Initializing matches...");
        for (int j = 0; j < 2; j++) {
            SeasonEntity actualSeason = seasons.get(j);
            System.out.println("Nastavuji aktĂˇlnĂ­ sezonu" + j);
            LocalDate startSeasonDate = actualSeason.getStartDate();
            LocalDate endSeasonDate = actualSeason.getEndDate();
            LocalDateTime startDate = startSeasonDate
                    .with(TemporalAdjusters.nextOrSame(DayOfWeek.FRIDAY))
                    .atTime(18, 45);
            int fridaysCount = countFridays(startSeasonDate, endSeasonDate);

            System.out.println("jdu vytvĂˇĹ™et zĂˇpasy");
            for (int i = 0; i < fridaysCount; i++) {
                MatchEntity match = new MatchEntity();
                LocalDateTime dateTime = startDate.plusWeeks(i);
                match.setDateTime(dateTime);
                match.setLocation("WOODARĂ‰NA");
                match.setDescription("");
                match.setMaxPlayers(12);
                match.setPrice(2200);
                match.setMatchStatus(null);
                match.setCancelReason(null);
                match.setSeason(actualSeason);
                // uloĹľĂ­me zĂˇpas
                matchRepository.save(match);

            }
            System.out.println("ZĂˇpasy v sezonÄ› byly vytvoĹ™eny");
        }

        System.out.println("ZĂˇpasy vytvoĹ™eny");
    }
// POMOCNĂ PRO SPOÄŚĂŤTĂNĂŤ PĂTKU

   private int countFridays(LocalDate from, LocalDate to) {
        if (to.isBefore(from)) {return 0;}
        LocalDate firstFriday = from.with(TemporalAdjusters.nextOrSame(DayOfWeek.FRIDAY));

        if (firstFriday.isAfter(to)) {return 0; }
        int count = 0;
        for (LocalDate date = firstFriday;
             !date.isAfter(to);
             date = date.plusWeeks(1)) {
            count++;
        }

        return count;
    }
    // =====================
    // REGISTRATIONS
    // =====================
    private void initRegistrations() {
        if (matchRegistrationRepository.count() > 0) {
            System.out.println("Match registrations already exist â€“ skipping registration initialization.");
            return;
        }

        List<MatchEntity> matches = matchRepository.findAll();

        List<PlayerEntity> players = playerRepository.findAll().stream()
                .filter(p -> p.getId() != null)
                .filter(p -> p.getPlayerStatus() == PlayerStatus.APPROVED)
                .toList();

        if (matches.isEmpty() || players.size() < 6) {
            System.out.println("Nedostatek dat pro vytvoĹ™enĂ­ registracĂ­ â€“ skipping.");
            return;
        }

        for (MatchEntity match : matches) {

            // NĂˇhodnĂ˝ vĂ˝bÄ›r 8 unikĂˇtnĂ­ch hrĂˇÄŤĹŻ
            List<PlayerEntity> shuffledPlayers = new ArrayList<>(players);
            Collections.shuffle(shuffledPlayers);
            List<PlayerEntity> selectedPlayers = shuffledPlayers.subList(0, 8);

            // NĂˇhodnĂ© indexy pro statusy
            List<Integer> indexes = new ArrayList<>();
            for (int i = 0; i < selectedPlayers.size(); i++) {
                indexes.add(i);
            }
            Collections.shuffle(indexes);

            int excusedIndex = indexes.get(0);
            int unregisteredIndex1 = indexes.get(1);
            int unregisteredIndex2 = indexes.get(2);

            for (int i = 0; i < selectedPlayers.size(); i++) {
                PlayerEntity player = selectedPlayers.get(i);

                MatchRegistrationEntity reg = new MatchRegistrationEntity();
                reg.setMatch(match);
                reg.setPlayer(player);

                if (i == excusedIndex) {
                    reg.setStatus(PlayerMatchStatus.EXCUSED);
                    reg.setExcuseReason(ExcuseReason.NEMOC);
                    reg.setExcuseNote("chĹ™ipka");
                } else if (i == unregisteredIndex1 || i == unregisteredIndex2) {
                    reg.setStatus(PlayerMatchStatus.UNREGISTERED);
                    reg.setExcuseReason(null);
                    reg.setExcuseNote(null);
                } else {
                    reg.setStatus(PlayerMatchStatus.REGISTERED);
                    reg.setExcuseReason(null);
                    reg.setExcuseNote(null);
                }

                // ZachovĂˇna pĹŻvodnĂ­ logika tĂ˝mĹŻ
                reg.setTeam(i < 4 ? Team.DARK : Team.LIGHT);

                reg.setTimestamp(LocalDateTime.now());
                reg.setCreatedBy("initializer");

                matchRegistrationRepository.save(reg);
            }
        }

        System.out.println("Sample registrations initialized.");
    }

    // =====================
    // TRIGGERS
    // =====================
    private void initTriggers() {
        createTrigger("trg_match_reg_insert", """
                CREATE TRIGGER trg_match_reg_insert
                AFTER INSERT ON match_registrations
                FOR EACH ROW
                BEGIN
                    INSERT INTO match_registration_history
                    (match_registration_id, match_id, player_id, status, excuse_reason,
                     excuse_note, admin_note, team, original_timestamp, created_by,
                     action, changed_at)
                    VALUES
                    (NEW.id, NEW.match_id, NEW.player_id, NEW.status, NEW.excuse_reason,
                     NEW.excuse_note, NEW.admin_note, NEW.team, NEW.timestamp, NEW.created_by,
                     'INSERT', NOW());
                END
                """);

        createTrigger("trg_match_reg_update", """
                CREATE TRIGGER trg_match_reg_update
                AFTER UPDATE ON match_registrations
                FOR EACH ROW
                BEGIN
                    INSERT INTO match_registration_history
                    (match_registration_id, match_id, player_id, status, excuse_reason,
                     excuse_note, admin_note, team, original_timestamp, created_by,
                     action, changed_at)
                    VALUES
                    (NEW.id, NEW.match_id, NEW.player_id, NEW.status, NEW.excuse_reason,
                     NEW.excuse_note, NEW.admin_note, NEW.team, NEW.timestamp, NEW.created_by,
                     'UPDATE', NOW());
                END
                """);

        createTrigger("trg_match_reg_delete", """
                CREATE TRIGGER trg_match_reg_delete
                AFTER DELETE ON match_registrations
                FOR EACH ROW
                BEGIN
                    INSERT INTO match_registration_history
                    (match_registration_id, match_id, player_id, status, excuse_reason,
                     excuse_note, admin_note, team, original_timestamp, created_by,
                     action, changed_at)
                    VALUES
                    (OLD.id, OLD.match_id, OLD.player_id, OLD.status, OLD.excuse_reason,
                     OLD.excuse_note, OLD.admin_note, OLD.team, OLD.timestamp, OLD.created_by,
                     'DELETE', NOW());
                END
                """);
    }

    private void createTrigger(String name, String sql) {
        try {
            jdbcTemplate.execute(sql);
            System.out.println("Trigger " + name + " created successfully.");
        } catch (Exception e) {
            System.out.println("Trigger " + name + " already exists or error: " + e.getMessage());
        }
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\GlobalExceptionHandler.java
-----

package cz.phsoft.hokej.config;

import cz.phsoft.hokej.exceptions.ApiError;
import cz.phsoft.hokej.exceptions.BusinessException;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.Map;

/**
 * GlobĂˇlnĂ­ handler vĂ˝jimek pro REST API.
 * <p>
 * ĂšÄŤel:
 * <ul>
 *     <li>centralizovanÄ› zachytĂˇvat vĂ˝jimky z controllerĹŻ a service vrstvy,</li>
 *     <li>pĹ™evĂ©st je na jednotnou JSON odpovÄ›ÄŹ typu {@link ApiError},</li>
 *     <li>zajistit konzistentnĂ­ HTTP status kĂłd pro jednotlivĂ© typy chyb.</li>
 * </ul>
 *
 * Tato tĹ™Ă­da:
 * <ul>
 *     <li>neĹ™eĹˇĂ­ logovĂˇnĂ­ (to lze doplnit do jednotlivĂ˝ch handlerĹŻ),</li>
 *     <li>neĹ™eĹˇĂ­ business logiku â€“ pouze mapuje vĂ˝jimky na HTTP odpovÄ›di.</li>
 * </ul>
 */
@RestControllerAdvice
public class GlobalExceptionHandler {

    // ==========================================
    // 1) BUSINESS / DOMĂ‰NOVĂ‰ VĂťJIMKY
    // ==========================================

    /**
     * ZachytĂ­ vĹˇechny vĂ˝jimky dÄ›dĂ­cĂ­ z {@link BusinessException}.
     * <p>
     * Typicky:
     * <ul>
     *     <li>PlayerNotFoundException,</li>
     *     <li>InvalidPlayerStatusException,</li>
     *     <li>SeasonNotFoundException,</li>
     *     <li>MatchNotFoundException, â€¦</li>
     * </ul>
     *
     * KaĹľdĂˇ {@link BusinessException} sama nese:
     * <ul>
     *     <li>HTTP status ({@link BusinessException#getStatus()}),</li>
     *     <li>uĹľivatelskou chybovou zprĂˇvu (message),</li>
     *     <li>typ chyby (implicitnÄ› pĹ™es status a nĂˇzev vĂ˝jimky).</li>
     * </ul>
     */
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ApiError> handleBusinessException(
            BusinessException ex,
            HttpServletRequest request) {

        ApiError error = new ApiError(
                ex.getStatus().value(),
                ex.getStatus().getReasonPhrase(),
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()
        );

        return ResponseEntity
                .status(ex.getStatus())
                .body(error);
    }

    // ==========================================
    // 2) PĹĂŤSTUP ODEPĹEN (Spring Security)
    // ==========================================

    /**
     * ZachytĂ­ {@link AccessDeniedException} vyhozenou Spring Security.
     * <p>
     * Typicky jde o situace:
     * <ul>
     *     <li>uĹľivatel nemĂˇ roli ADMIN / MANAGER pro danĂ˝ endpoint,</li>
     *     <li>pokus o pĹ™Ă­stup k chrĂˇnÄ›nĂ©mu zdroji bez oprĂˇvnÄ›nĂ­.</li>
     * </ul>
     *
     * HTTP status: 403 Forbidden
     */
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ApiError> handleAccessDenied(AccessDeniedException ex,
                                                       HttpServletRequest request) {

        ApiError error = new ApiError(
                HttpStatus.FORBIDDEN.value(),
                "Forbidden",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()
        );

        return ResponseEntity
                .status(HttpStatus.FORBIDDEN)
                .body(error);
    }

    // ==========================================
    // 3) ILLEGAL ARGUMENT â€“ CHYBNĂ‰ VSTUPY
    // ==========================================

    /**
     * ZachytĂ­ {@link IllegalArgumentException}.
     * <p>
     * PouĹľitĂ­:
     * <ul>
     *     <li>obecnĂ© validaÄŤnĂ­ chyby vstupĹŻ,</li>
     *     <li>nesmyslnĂ© parametry pĹ™edanĂ© do service vrstvy.</li>
     * </ul>
     *
     * HTTP status: 400 Bad Request
     */
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ApiError> handleIllegalArgument(IllegalArgumentException ex,
                                                          HttpServletRequest request) {

        ApiError error = new ApiError(
                HttpStatus.BAD_REQUEST.value(),
                "Bad Request",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()
        );

        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(error);
    }

    // ==========================================
    // 4) ILLEGAL STATE â€“ NEPLATNĂť STAV APLIKACE
    // ==========================================

    /**
     * ZachytĂ­ {@link IllegalStateException}.
     * <p>
     * Typicky:
     * <ul>
     *     <li>operace nenĂ­ povolena v aktuĂˇlnĂ­m stavu (napĹ™. deaktivace poslednĂ­ aktivnĂ­ sezĂłny),</li>
     *     <li>poruĹˇenĂ­ vnitĹ™nĂ­ho invariantu aplikace.</li>
     * </ul>
     *
     * HTTP status: 409 Conflict
     */
    @ExceptionHandler(IllegalStateException.class)
    public ResponseEntity<ApiError> handleIllegalState(IllegalStateException ex,
                                                       HttpServletRequest request) {

        ApiError error = new ApiError(
                HttpStatus.CONFLICT.value(),
                "Conflict",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()
        );

        return ResponseEntity
                .status(HttpStatus.CONFLICT)
                .body(error);
    }

    // ==========================================
    // 5) DATA INTEGRITA (DB KONFLIKTY, RACE CONDITION)
    // ==========================================

    /**
     * ZachytĂ­ {@link DataIntegrityViolationException} z perzistentnĂ­ vrstvy.
     * <p>
     * Typicky:
     * <ul>
     *     <li>poruĹˇenĂ­ unikĂˇtnĂ­ch omezenĂ­ v DB (unique constraint),</li>
     *     <li>race condition pĹ™i paralelnĂ­m uklĂˇdĂˇnĂ­ stejnĂ˝ch dat.</li>
     * </ul>
     *
     * Z bezpeÄŤnostnĂ­ch dĹŻvodĹŻ:
     * <ul>
     *     <li>nevracĂ­ detailnĂ­ DB zprĂˇvu,</li>
     *     <li>pouĹľĂ­vĂˇ generickou, ale uĹľiteÄŤnou textovou hlĂˇĹˇku.</li>
     * </ul>
     *
     * HTTP status: 409 Conflict
     */
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ApiError> handleDataIntegrity(
            DataIntegrityViolationException ex,
            HttpServletRequest request
    ) {
        ApiError error = new ApiError(
                HttpStatus.CONFLICT.value(),
                "Conflict",
                "BE - ZĂˇznam poruĹˇuje unikĂˇtnĂ­ omezenĂ­ (pravdÄ›podobnÄ› duplicitnĂ­ hrĂˇÄŤ).",
                request.getRequestURI(),
                request.getRemoteAddr()
        );

        return ResponseEntity
                .status(HttpStatus.CONFLICT)
                .body(error);
    }

    // ==========================================
    // 6) FALLBACK â€“ NEÄŚEKANĂ‰ CHYBY
    // ==========================================

    /**
     * Fallback handler pro vĹˇechny ostatnĂ­ neoĹˇetĹ™enĂ© vĂ˝jimky.
     * <p>
     * PouĹľitĂ­:
     * <ul>
     *     <li>zachytĂ­ runtime chyby, kterĂ© nebyly explicitnÄ› oĹˇetĹ™eny,</li>
     *     <li>brĂˇnĂ­ pĂˇdu aplikace bez odpovÄ›di,</li>
     *     <li>vracĂ­ jednotnĂ˝ formĂˇt {@link ApiError} pro FE.</li>
     * </ul>
     *
     * HTTP status: 500 Internal Server Error
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiError> handleAll(Exception ex,
                                              HttpServletRequest request) {

        ApiError error = new ApiError(
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error",
                "BE - DoĹˇlo k neoÄŤekĂˇvanĂ© chybÄ› na serveru.",
                request.getRequestURI(),
                request.getRemoteAddr()
        );

        return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(error);
    }
    // ==========================================
    // 7) VALIDACE VSTUPĹ® (@Valid, Bean Validation)
    // ==========================================

    /**
     * ZachytĂ­ validaÄŤnĂ­ chyby z anotace {@code @Valid}.
     * <p>
     * TypickĂ© scĂ©nĂˇĹ™e:
     * <ul>
     *     <li>nevyplnÄ›nĂ© povinnĂ© pole,</li>
     *     <li>neplatnĂ˝ formĂˇt (napĹ™. e-mail),</li>
     *     <li>poruĹˇenĂ­ dĂ©lkovĂ˝ch nebo rozsahovĂ˝ch omezenĂ­.</li>
     * </ul>
     *
     * Do pole {@code details} se vracĂ­ mapa {@code field â†’ message},
     * kde klĂ­ÄŤem je nĂˇzev pole v DTO a hodnotou text validaÄŤnĂ­ chyby.
     *
     * HTTP status: 400 Bad Request
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiError> handleValidationException(
            MethodArgumentNotValidException ex,
            HttpServletRequest request
    ) {
        HttpStatus status = HttpStatus.BAD_REQUEST;

        // Mapa field â†’ message (pouĹľijeme LinkedHashMap pro zachovĂˇnĂ­ poĹ™adĂ­ chyb)
        Map<String, String> fieldErrors = new java.util.LinkedHashMap<>();

        for (FieldError fieldError : ex.getBindingResult().getFieldErrors()) {
            String fieldName = fieldError.getField();
            String errorMessage = fieldError.getDefaultMessage();

            // Pokud je pro jedno pole vĂ­ce chyb, mĹŻĹľeme je spojit do jednĂ© zprĂˇvy
            fieldErrors.merge(
                    fieldName,
                    errorMessage,
                    (existing, added) -> existing + "; " + added
            );
        }

        ApiError error = new ApiError(
                status.value(),
                status.getReasonPhrase(),
                "BE - NeplatnĂˇ vstupnĂ­ data.",
                request.getRequestURI(),
                request.getRemoteAddr(),
                fieldErrors
        );

        return ResponseEntity
                .status(status)
                .body(error);
    }
}



-----
# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\SecurityConfig.java
-----

package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

/**
 * HlavnĂ­ konfigurace Spring Security pro backend aplikace.
 *
 * ZODPOVÄšDNOST:
 * <ul>
 *     <li>nastavenĂ­ autentizace (CustomUserDetailsService + BCrypt),</li>
 *     <li>nastavenĂ­ autorizace endpointĹŻ (role / pĹ™ihlĂˇĹˇenĂ­),</li>
 *     <li>konfigurace login mechanismu (CustomJsonLoginFilter),</li>
 *     <li>session management (stateful pĹ™Ă­stup),</li>
 *     <li>CORS konfigurace pro SPA frontend (React / Vite).</li>
 * </ul>
 *
 * REĹ˝IMY PROVOZU:
 * <ul>
 *     <li><b>test-mode = true</b> â†’ vĹˇe povoleno, HTTP Basic (Postman, vĂ˝voj),</li>
 *     <li><b>test-mode = false</b> â†’ produkÄŤnĂ­ reĹľim, REST login + role.</li>
 * </ul>
 */
@Configuration
@EnableWebSecurity
@EnableMethodSecurity // povolĂ­ @PreAuthorize, @Secured, @RolesAllowed
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;

    /**
     * PĹ™epĂ­naÄŤ testovacĂ­ho reĹľimu:
     *
     * app.test-mode=true
     *
     * PouĹľitĂ­:
     * - lokĂˇlnĂ­ vĂ˝voj
     * - Postman bez Ĺ™eĹˇenĂ­ session / loginu
     */
    @Value("${app.test-mode:false}")
    private boolean isTestMode;

    public SecurityConfig(CustomUserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    // =====================================================
    // 1) PASSWORD ENCODER
    // =====================================================

    /**
     * BCrypt encoder pro uklĂˇdĂˇnĂ­ a ovÄ›Ĺ™ovĂˇnĂ­ hesel.
     *
     * PouĹľĂ­vĂˇ se:
     * - pĹ™i registraci
     * - pĹ™i zmÄ›nÄ› hesla
     * - pĹ™i autentizaci (login)
     */
    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    // =====================================================
    // 2) AUTHENTICATION PROVIDER
    // =====================================================

    /**
     * DaoAuthenticationProvider:
     *
     * - naÄŤĂ­tĂˇ uĹľivatele z databĂˇze pomocĂ­ CustomUserDetailsService
     * - ovÄ›Ĺ™uje heslo pomocĂ­ BCryptPasswordEncoder
     *
     * PouĹľĂ­vĂˇ se pĹ™i loginu pĹ™es AuthenticationManager.
     */
    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    // =====================================================
    // 3) AUTHENTICATION MANAGER
    // =====================================================

    /**
     * AuthenticationManager:
     *
     * - centrĂˇlnĂ­ bod autentizace ve Spring Security
     * - pouĹľĂ­vĂˇ se v CustomJsonLoginFilter
     */
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig)
            throws Exception {
        return authConfig.getAuthenticationManager();
    }

    // =====================================================
    // 4) SECURITY FILTER CHAIN
    // =====================================================

    /**
     * HlavnĂ­ bezpeÄŤnostnĂ­ konfigurace HTTP vrstvy.
     *
     * ĹeĹˇĂ­:
     * <ul>
     *     <li>CSRF / CORS</li>
     *     <li>autorizaci endpointĹŻ</li>
     *     <li>login (CustomJsonLoginFilter)</li>
     *     <li>logout</li>
     *     <li>session management</li>
     * </ul>
     */
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http,
                                                   AuthenticationManager authManager) throws Exception {

        // REST API â†’ CSRF vypnuto (Ĺ™eĹˇeno pĹ™es session + CORS)
        http.csrf(csrf -> csrf.disable())
                .cors(cors -> { /* pouĹľĂ­vĂˇ corsConfigurationSource() */ });

        if (isTestMode) {
            // =================================================
            // TEST MODE
            // =================================================
            //
            // - vĹˇechny endpointy povoleny
            // - HTTP Basic autentizace
            // - ĹľĂˇdnĂ˝ JSON login filtr
            //
            http.authorizeHttpRequests(auth -> auth.anyRequest().permitAll())
                    .httpBasic();

        } else {
            // =================================================
            // PRODUKÄŚNĂŤ REĹ˝IM
            // =================================================

            http
                    // napojenĂ­ na CustomUserDetailsService + BCrypt
                    .authenticationProvider(authenticationProvider())

                    // -------------------------------
                    // AUTORIZACE ENDPOINTĹ®
                    // -------------------------------
                    .authorizeHttpRequests(auth -> auth

                            // ===== VEĹEJNĂ‰ ENDPOINTY =====
                            .requestMatchers(
                                    "/api/auth/register",
                                    "/api/auth/verify",
                                    "/api/login",
                                    "/api/logout"
                            ).permitAll()

                            // ===== DEBUG / TEST =====
                            .requestMatchers(
                                    "/api/debug/me",
                                    "/api/test/**"
                            ).hasRole("ADMIN")

                            // testovacĂ­ emaily
                            .requestMatchers("/api/email/test/**").hasRole("ADMIN")

                            // ===== ADMIN / MANAGER =====
                            .requestMatchers("/api/admin/seasons/**").hasRole("ADMIN")
                            .requestMatchers("/api/matches/admin/**").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/players/admin/**").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/registrations/admin/**").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/inactivity/admin/**").hasAnyRole("ADMIN", "MANAGER")

                            // ===== ZBYTEK API =====
                            .requestMatchers("/api/**").authenticated()

                            .anyRequest().authenticated()
                    )

                    // -------------------------------
                    // SESSION MANAGEMENT
                    // -------------------------------
                    .sessionManagement(sm ->
                            sm.sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
                    )

                    // -------------------------------
                    // CUSTOM JSON LOGIN
                    // -------------------------------
                    .addFilterAt(
                            new CustomJsonLoginFilter("/api/login", authManager),
                            UsernamePasswordAuthenticationFilter.class
                    )

                    // -------------------------------
                    // LOGOUT
                    // -------------------------------
                    .logout(logout -> logout
                            .logoutUrl("/api/logout")
                            .deleteCookies("JSESSIONID")
                            .logoutSuccessHandler((request, response, auth) -> {
                                request.getSession().removeAttribute("CURRENT_PLAYER_ID");
                                request.getSession().removeAttribute("CURRENT_SEASON_ID");
                                request.getSession().removeAttribute("CURRENT_SEASON_CUSTOM");
                                response.setContentType("application/json");
                                response.setCharacterEncoding("UTF-8");
                                response.getWriter()
                                        .write("{\"status\":\"ok\",\"message\":\"OdhlĂˇĹˇeno\"}");
                            })
                    );
        }

        return http.build();
    }

    // =====================================================
    // 5) CORS KONFIGURACE
    // =====================================================

    /**
     * CORS konfigurace pro SPA frontend (React / Vite).
     *
     * - povoluje http://localhost:5173
     * - umoĹľĹuje cookies (JSESSIONID)
     * - povoluje bÄ›ĹľnĂ© HTTP metody
     */
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {

        CorsConfiguration configuration = new CorsConfiguration();

        configuration.setAllowedOrigins(List.of("http://localhost:5173"));
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source =
                new UrlBasedCorsConfigurationSource();

        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}


