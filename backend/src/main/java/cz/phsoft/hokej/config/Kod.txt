package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDate;

/**
 * Entita reprezentující sezónu.
 *
 * Sezóna vymezuje časové období, do kterého
 * spadají zápasy a související data.
 */
@Entity
@Table(name = "season")
public class SeasonEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Název sezóny (např. "2024/2025").
     */
    @Column(nullable = false)
    private String name;

    /**
     * Datum začátku sezóny.
     */
    @Column(nullable = false)
    private LocalDate startDate;

    /**
     * Datum konce sezóny.
     */
    @Column(nullable = false)
    private LocalDate endDate;

    /**
     * Příznak aktivní sezóny.
     */
    private boolean active;

    // gettery / settery

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public LocalDate getStartDate() { return startDate; }
    public void setStartDate(LocalDate startDate) { this.startDate = startDate; }

    public LocalDate getEndDate() { return endDate; }
    public void setEndDate(LocalDate endDate) { this.endDate = endDate; }

    public boolean isActive() { return active; }
    public void setActive(boolean active) { this.active = active; }
}

 package cz.phsoft.hokej.data.repositories;

 import cz.phsoft.hokej.data.entities.SeasonEntity;
 import org.springframework.data.jpa.repository.JpaRepository;

 import java.time.LocalDate;
 import java.util.List;
 import java.util.Optional;

 /**
  * Repozitář pro práci s entitou {@link SeasonEntity}.
  *
  * Slouží ke správě sezón, zejména k určení aktivní sezóny,
  * kontrole časových překryvů a načítání sezón
  * v chronologickém pořadí.
  */
 public interface SeasonRepository extends JpaRepository<SeasonEntity, Long> {

     /**
      * Vrátí aktuálně aktivní sezónu.
      *
      * V systému může být v daném okamžiku
      * aktivní maximálně jedna sezóna.
      *
      * @return aktivní sezóna zabalená v {@link Optional}, pokud existuje
      */
     Optional<SeasonEntity> findByActiveTrue();

     /**
      * Vrátí všechny sezóny seřazené
      * podle data začátku vzestupně.
      *
      * @return seznam sezón
      */
     List<SeasonEntity> findAllByOrderByStartDateAsc();

     /**
      * Ověří, zda existuje sezóna, která se časově
      * překrývá se zadaným intervalem.
      *
      * Používá se při vytváření nové sezóny
      * jako ochrana proti překrývajícím se obdobím.
      *
      * @param endDate   konec kontrolovaného intervalu
      * @param startDate začátek kontrolovaného intervalu
      * @return {@code true}, pokud existuje časový překryv
      */
     boolean existsByStartDateLessThanEqualAndEndDateGreaterThanEqual(
             LocalDate endDate,
             LocalDate startDate
     );

     /**
      * Ověří, zda existuje jiná sezóna (mimo zadané ID),
      * která se časově překrývá se zadaným intervalem.
      *
      * Používá se při aktualizaci existující sezóny,
      * aby nedošlo ke kolizi s jinou sezónou.
      *
      * @param endDate   konec kontrolovaného intervalu
      * @param startDate začátek kontrolovaného intervalu
      * @param id        ID sezóny, která má být z kontroly vynechána
      * @return {@code true}, pokud existuje časový překryv
      */
     boolean existsByStartDateLessThanEqualAndEndDateGreaterThanEqualAndIdNot(
             LocalDate endDate,
             LocalDate startDate,
             Long id
     );

     /**
      * Spočítá počet aktivních sezón.
      *
      * Slouží jako ochrana proti stavu,
      * kdy by bylo aktivních více sezón současně.
      *
      * @return počet aktivních sezón
      */
     long countByActiveTrue();
 }

package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.SeasonEntity;
import cz.phsoft.hokej.models.dto.SeasonDTO;

import java.util.List;

/**
 * Rozhraní pro správu sezón v aplikaci.
 * <p>
 * Definuje kontrakt pro práci se sezónami, které slouží
 * jako časový rámec pro organizaci zápasů, statistik
 * a dalších herních dat.
 * </p>
 *
 * Účel:
 * <ul>
 *     <li>správa životního cyklu sezón (vytvoření, úprava, aktivace),</li>
 *     <li>určení aktuálně aktivní sezóny,</li>
 *     <li>poskytnutí přehledu všech sezón v systému.</li>
 * </ul>
 *
 * Použití:
 * <ul>
 *     <li>využívá se v controllerech a business službách,</li>
 *     <li>slouží jako centrální zdroj informace o aktivní sezóně.</li>
 * </ul>
 *
 * Architektonické zásady:
 * <ul>
 *     <li>většina operací pracuje s DTO objekty,</li>
 *     <li>získání aktivní sezóny může vracet entitu
 *     (např. pro interní business logiku).</li>
 * </ul>
 */
public interface SeasonService {

    /**
     * Vytvoří novou sezónu.
     * <p>
     * Implementace je zodpovědná za validaci období sezóny
     * (např. že začátek je před koncem a že se sezóny nepřekrývají).
     * </p>
     *
     * @param season data nové sezóny
     * @return vytvořená sezóna
     */
    SeasonDTO createSeason(SeasonDTO season);

    /**
     * Aktualizuje existující sezónu.
     *
     * @param id     ID sezóny, která má být aktualizována
     * @param season nové hodnoty sezóny
     * @return aktualizovaná sezóna
     */
    SeasonDTO updateSeason(Long id, SeasonDTO season);

    /**
     * Vrátí aktuálně aktivní sezónu.
     * <p>
     * Aktivní sezóna představuje časový rámec,
     * ve kterém jsou zápasy považovány za platné.
     * </p>
     *
     * @return aktivní sezóna jako entita
     */
    SeasonEntity getActiveSeason();

    /**
     * Vrátí seznam všech sezón v systému.
     * <p>
     * Typicky slouží pro administrátorské přehledy.
     * </p>
     *
     * @return seznam všech sezón
     */
    List<SeasonDTO> getAllSeasons();

    /**
     * Nastaví zadanou sezónu jako aktivní.
     * <p>
     * Implementace zajistí, že v systému existuje
     * vždy maximálně jedna aktivní sezóna.
     * </p>
     *
     * @param seasonId ID sezóny, která má být nastavena jako aktivní
     */
    void setActiveSeason(Long seasonId);

    SeasonDTO getActiveSeasonOrNull();

    SeasonDTO getSeasonById(Long id);
}
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.SeasonEntity;
import cz.phsoft.hokej.data.repositories.SeasonRepository;
import cz.phsoft.hokej.exceptions.InvalidSeasonPeriodDateException;
import cz.phsoft.hokej.exceptions.InvalidSeasonStateException;
import cz.phsoft.hokej.exceptions.SeasonNotFoundException;
import cz.phsoft.hokej.exceptions.SeasonPeriodOverlapException;
import cz.phsoft.hokej.models.dto.SeasonDTO;
import cz.phsoft.hokej.models.dto.mappers.SeasonMapper;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;

/**
 * Service vrstva pro správu sezón ({@link SeasonEntity}).
 *
 * Zodpovídá za:
 * <ul>
 *     <li>vytvoření nové sezóny (včetně validace dat a překryvů),</li>
 *     <li>úpravu existující sezóny (včetně pravidel pro aktivní sezónu),</li>
 *     <li>získání aktuálně aktivní sezóny,</li>
 *     <li>návrat všech sezón v logickém pořadí,</li>
 *     <li>nastavení konkrétní sezóny jako aktivní (a deaktivaci ostatních).</li>
 * </ul>
 *
 * DŮLEŽITÉ INVARIANTY:
 * <ul>
 *     <li>datum začátku musí být před datem konce,</li>
 *     <li>nesmí existovat dvě sezóny, které se časově překrývají,</li>
 *     <li>systém by neměl zůstat bez aktivní sezóny,</li>
 *     <li>v jeden okamžik smí být aktivní právě jedna sezóna.</li>
 * </ul>
 *
 * Třída je čistě doménová:
 * <ul>
 *     <li>neřeší autentizaci/autorizaci (řeší controller + Security),</li>
 *     <li>neposílá notifikace,</li>
 *     <li>zajišťuje konzistentní stav kalendáře sezón pro zbytek aplikace.</li>
 * </ul>
 */
@Service
public class SeasonServiceImpl implements SeasonService {

    private final SeasonRepository seasonRepository;
    private final SeasonMapper mapper;

    public SeasonServiceImpl(SeasonRepository seasonRepository, SeasonMapper mapper) {
        this.seasonRepository = seasonRepository;
        this.mapper = mapper;
    }

    // ======================
    // CREATE
    // ======================

    /**
     * Vytvoří novou sezónu.
     * <p>
     * Kroky:
     * <ol>
     *     <li>zvaliduje datumové rozmezí a překryvy s jinými sezónami,</li>
     *     <li>uloží novou sezónu,</li>
     *     <li>zajistí, že v systému vždy existuje nějaká aktivní sezóna:
     *         <ul>
     *             <li>pokud {@code seasonDTO.isActive() == true} → nastaví ji jako jedinou aktivní,</li>
     *             <li>pokud je to úplně první sezóna v systému (activeCount == 0),
     *                 nastaví tuto novou sezónu jako aktivní i když DTO říká {@code active = false}.</li>
     *         </ul>
     *     </li>
     * </ol>
     *
     * @param seasonDTO vstupní data sezóny
     * @return vytvořená sezóna v podobě {@link SeasonDTO}
     *
     * @throws InvalidSeasonPeriodDateException pokud jsou neplatná data od/do
     * @throws SeasonPeriodOverlapException     pokud se sezóna překrývá s existující
     */
    @Override
    @Transactional
    public SeasonDTO createSeason(SeasonDTO seasonDTO) {
        // u create nemáme ID → předáváme null, validace bere v potaz všechny existující sezóny
        validateDates(seasonDTO, null);

        SeasonEntity entity = mapper.toEntity(seasonDTO);
        SeasonEntity saved = seasonRepository.save(entity);

        long activeCount = seasonRepository.countByActiveTrue();

        if (seasonDTO.isActive()) {
            // nová sezóna má být aktivní → uděláme z ní jedinou aktivní
            setOnlyActiveSeason(saved.getId());
        } else if (activeCount == 0) {
            // v systému není žádná aktivní sezóna → nesmíme zůstat bez aktivní
            // → automaticky tuto novou sezónu nastavíme jako jedinou aktivní
            setOnlyActiveSeason(saved.getId());
        }

        return mapper.toDTO(saved);
    }

    // ======================
    // UPDATE
    // ======================

    /**
     * Aktualizuje existující sezónu.
     * <p>
     * Kroky:
     * <ol>
     *     <li>ověří, že sezóna s daným ID existuje,</li>
     *     <li>zvaliduje datumy s ignorováním této jedné sezóny
     *         (aby se "nepřekrývala sama se sebou"),</li>
     *     <li>zkontroluje, že nelze deaktivovat „poslední“ aktivní sezónu v systému,</li>
     *     <li>promítne změny z DTO do entity a uloží je,</li>
     *     <li>pokud se sezóna z neaktivní stala aktivní, nastaví ji jako JEDINOU aktivní.</li>
     * </ol>
     *
     * @param id        ID upravované sezóny
     * @param seasonDTO nové hodnoty sezóny
     *
     * @throws SeasonNotFoundException      pokud sezóna s daným ID neexistuje
     * @throws InvalidSeasonPeriodDateException pokud jsou neplatná data od/do
     * @throws SeasonPeriodOverlapException pokud se sezóna překrývá s jinou
     * @throws InvalidSeasonStateException  pokud se pokoušíš deaktivovat jedinou aktivní sezónu
     */
    @Override
    @Transactional
    public SeasonDTO updateSeason(Long id, SeasonDTO seasonDTO) {
        // 1) najít existující sezónu
        SeasonEntity existing = seasonRepository.findById(id)
                .orElseThrow(() -> new SeasonNotFoundException(id));

        // 2) validace dat s ignorováním této sezóny (aby se nepočítala jako překryv sama se sebou)
        validateDates(seasonDTO, id);

        boolean wasActive = existing.isActive();
        boolean willBeActive = seasonDTO.isActive();

        // *** STRIKTNÍ REŽIM: nelze deaktivovat jedinou aktivní sezónu
        if (wasActive && !willBeActive) {
            long activeCount = seasonRepository.countByActiveTrue();
            if (activeCount <= 1) {
                throw new InvalidSeasonStateException(
                        "BE - Nelze deaktivovat jedinou aktivní sezónu. " +
                        "Nejprve nastavte jinou sezónu jako aktivní."
                );
            }
        }

        // 3) promítnout změny z DTO do entity a uložit
        mapper.updateEntityFromDTO(seasonDTO, existing);
        SeasonEntity saved = seasonRepository.save(existing);

        // pokud se sezóna z neaktivní stala aktivní → uděláme z ní jedinou aktivní
        if (!wasActive && saved.isActive()) {
            setOnlyActiveSeason(saved.getId());
        }

        return mapper.toDTO(saved);
    }

    // ======================
    // AKTIVNÍ SEZÓNA
    // ======================

    /**
     * Vrátí aktuálně aktivní sezónu ({@link SeasonEntity}).
     *
     * @return aktivní sezóna
     * @throws SeasonNotFoundException pokud není nastavena žádná aktivní sezóna
     */
    @Override
    public SeasonEntity getActiveSeason() {
        return seasonRepository.findByActiveTrue()
                .orElseThrow(() -> new SeasonNotFoundException(
                        "BE - Není nastavena žádná aktivní sezóna."
                ));
    }

    @Override
    public SeasonDTO getActiveSeasonOrNull() {
        return seasonRepository.findByActiveTrue()
                .map(mapper::toDTO)
                .orElse(null);
    }

    @Override
    public SeasonDTO getSeasonById(Long id) {
        SeasonEntity entity = seasonRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Season not found: " + id));
        return mapper.toDTO(entity);
    }

    // ======================
    // SEZNAM VŠECH SEZÓN
    // ======================

    /**
     * Vrátí všechny sezóny seřazené podle začátku ({@code startDate ASC}),
     * namapované na {@link SeasonDTO}.
     * <p>
     * Typické použití:
     * <ul>
     *     <li>administrace sezón,</li>
     *     <li>přehled v UI (tabulka sezón).</li>
     * </ul>
     */
    @Override
    public List<SeasonDTO> getAllSeasons() {
        return seasonRepository.findAllByOrderByStartDateAsc()
                .stream()
                .map(mapper::toDTO)
                .toList();
    }



    // ======================
    // NASTAVENÍ AKTIVNÍ SEZÓNY
    // ======================

    /**
     * Nastaví konkrétní sezónu jako aktivní.
     * <p>
     * Kroky:
     * <ol>
     *     <li>ověří, že sezóna s daným ID existuje,</li>
     *     <li>pomocí {@link #setOnlyActiveSeason(Long)} ji nastaví jako jedinou aktivní
     *         (všechny ostatní sezóny deaktivuje).</li>
     * </ol>
     *
     * @param seasonId ID sezóny, která má být aktivní
     *
     * @throws SeasonNotFoundException pokud sezóna s daným ID neexistuje
     */
    @Override
    @Transactional
    public void setActiveSeason(Long seasonId) {
        // 1) ověř, že existuje
        SeasonEntity toActivate = seasonRepository.findById(seasonId)
                .orElseThrow(() -> new SeasonNotFoundException(seasonId
                ));

        // 2) nastavíme ji jako jedinou aktivní
        setOnlyActiveSeason(toActivate.getId());
    }



    // ======================
    // PRIVÁTNÍ VALIDACE DAT
    // ======================

    /**
     * Validuje datumy sezóny a kontroluje překryvy s ostatními sezónami.
     *
     * @param seasonDTO       DTO s daty sezóny
     * @param currentSeasonId ID aktuální sezóny (u UPDATE), nebo {@code null} u CREATE
     *
     * Kontroluje:
     * <ul>
     *     <li>{@code startDate} != null a {@code endDate} != null,</li>
     *     <li>{@code startDate} &lt; {@code endDate},</li>
     *     <li>žádná jiná sezóna se nepřekrývá s intervalem &lt;=end, &gt;=start
     *         (při UPDATE ignoruje sezónu s id = currentSeasonId).</li>
     * </ul>
     *
     * @throws InvalidSeasonPeriodDateException pokud jsou neplatná data
     * @throws SeasonPeriodOverlapException     pokud dochází k překryvu s jinou sezónou
     */
    private void validateDates(SeasonDTO seasonDTO, Long currentSeasonId) {
        LocalDate start = seasonDTO.getStartDate();
        LocalDate end = seasonDTO.getEndDate();

        // základní null-check
        if (start == null || end == null) {
            throw new InvalidSeasonPeriodDateException("BE - Datum od a do nesmí být null.");
        }

        // logická kontrola pořadí
        if (!start.isBefore(end)) {
            throw new InvalidSeasonPeriodDateException("BE - Datum 'od' musí být před 'do'.");
        }

        boolean overlaps;

        if (currentSeasonId == null) {
            // CREATE – překryv s jakoukoli existující sezónou
            overlaps = seasonRepository
                    .existsByStartDateLessThanEqualAndEndDateGreaterThanEqual(end, start);
        } else {
            // UPDATE – překryv s jinou sezónou (id != currentSeasonId)
            overlaps = seasonRepository
                    .existsByStartDateLessThanEqualAndEndDateGreaterThanEqualAndIdNot(
                            end,
                            start,
                            currentSeasonId
                    );
        }

        if (overlaps) {
            throw new SeasonPeriodOverlapException("BE - Sezóna se překrývá s existující sezónou.");
        }
    }

    // ======================
    // PRIVÁTNÍ POMOCNÁ METODA
    // ======================

    /**
     * Nastaví danou sezónu jako JEDINOU aktivní.
     * <p>
     * Implementace:
     * <ul>
     *     <li>načte všechny sezóny z DB,</li>
     *     <li>té s {@code id == activeSeasonId} nastaví {@code active = true},</li>
     *     <li>všem ostatním nastaví {@code active = false},</li>
     *     <li>uloží změny pomocí {@link SeasonRepository#saveAll(Iterable)}.</li>
     * </ul>
     *
     * Tím garantujeme invariant:
     * <ul>
     *     <li>v aplikaci existuje v každém okamžiku právě jedna aktivní sezóna.</li>
     * </ul>
     */
    private void setOnlyActiveSeason(Long activeSeasonId) {
        List<SeasonEntity> all = seasonRepository.findAll();
        for (SeasonEntity season : all) {
            season.setActive(season.getId().equals(activeSeasonId));
        }
        seasonRepository.saveAll(all);
    }
}
package cz.phsoft.hokej.models.services;

public interface CurrentSeasonService {

    /**
     * Vrátí ID sezóny uložené v session, nebo:
     * - pokud není nic nastaveno, vezme globálně aktivní sezónu,
     *   uloží ji do session a vrátí její ID.
     */
    Long getCurrentSeasonIdOrDefault();

    /**
     * Nastaví sezónu pro aktuálního uživatele (session).
     */
    void setCurrentSeasonId(Long seasonId);

    /**
     * Volitelně – vymaže sezónu ze session (např. při logoutu).
     */
    void clearCurrentSeason();
}
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.SeasonDTO;
import jakarta.servlet.http.HttpSession;
import org.springframework.stereotype.Service;

@Service
public class CurrentSeasonServiceImpl implements CurrentSeasonService {

    private static final String CURRENT_SEASON_SESSION_ATTR = "CURRENT_SEASON_ID";

    private final HttpSession session;
    private final SeasonService seasonService;

    public CurrentSeasonServiceImpl(HttpSession session,
                                    SeasonService seasonService) {
        this.session = session;
        this.seasonService = seasonService;
    }

    @Override
    public Long getCurrentSeasonIdOrDefault() {
        Object value = session.getAttribute(CURRENT_SEASON_SESSION_ATTR);
        if (value instanceof Long id) {
            return id;
        }

        // Není nic v session → vezmu globálně aktivní sezónu
        SeasonDTO active = seasonService.getActiveSeasonOrNull(); // přidáš do SeasonService
        if (active != null) {
            Long id = active.getId();
            session.setAttribute(CURRENT_SEASON_SESSION_ATTR, id);
            return id;
        }

        // Když není ani globálně aktivní → můžeš vrátit null nebo hodit výjimku
        return null;
    }

    @Override
    public void setCurrentSeasonId(Long seasonId) {
        session.setAttribute(CURRENT_SEASON_SESSION_ATTR, seasonId);
    }

    @Override
    public void clearCurrentSeason() {
        session.removeAttribute(CURRENT_SEASON_SESSION_ATTR);
    }
}
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.enums.MatchCancelReason;
import cz.phsoft.hokej.models.dto.*;

import java.util.List;

/**
 * Rozhraní pro správu zápasů v aplikaci.
 * <p>
 * Definuje kontrakt pro práci se zápasy z pohledu business logiky –
 * vytváření, úpravu, mazání, získávání přehledů a práci s dostupností
 * pro konkrétního hráče.
 * </p>
 *
 * Účel:
 * <ul>
 *     <li>poskytnout jednotný vstupní bod pro práci se zápasy,</li>
 *     <li>oddělit business logiku zápasů od persistence vrstvy,</li>
 *     <li>nabídnout specializované přehledy pro hráče i administraci.</li>
 * </ul>
 *
 * Použití:
 * <ul>
 *     <li>využívá se v controllerech a plánovačích (scheduler),</li>
 *     <li>pracuje výhradně s DTO objekty pro přenos dat.</li>
 * </ul>
 */
public interface MatchService {

    /**
     * Vrátí seznam všech zápasů v systému.
     * <p>
     * Metoda typicky slouží pro administrátorské přehledy
     * nebo globální seznam zápasů.
     * </p>
     *
     * @return seznam všech zápasů ve formě {@link MatchDTO}
     */
    List<MatchDTO> getAllMatches();

    /**
     * Vrátí seznam všech nadcházejících zápasů.
     * <p>
     * Nadcházející zápasy jsou ty, které mají datum v budoucnosti
     * (podle interně zvolené definice – např. datum/čas &gt;= nyní).
     * </p>
     *
     * @return seznam nadcházejících zápasů
     */
    List<MatchDTO> getUpcomingMatches();

    /**
     * Vrátí seznam všech již odehraných zápasů.
     *
     * @return seznam minulých zápasů
     */
    List<MatchDTO> getPastMatches();

    /**
     * Vrátí nejbližší nadcházející zápas.
     * <p>
     * Typicky se používá pro rychlé zobrazení „dalšího zápasu“
     * na dashboardu nebo v notifikacích.
     * </p>
     *
     * @return nejbližší nadcházející zápas nebo {@code null},
     *         pokud žádný neexistuje
     */
    MatchDTO getNextMatch();

    /**
     * Vrátí detail zápasu podle jeho ID.
     *
     * @param id ID zápasu
     * @return zápas ve formě {@link MatchDTO}
     */
    MatchDTO getMatchById(Long id);

    /**
     * Vytvoří nový zápas.
     * <p>
     * Metoda typicky dostupná pouze pro administrátory / manažery.
     * </p>
     *
     * @param dto data nového zápasu
     * @return vytvořený zápas
     */
    MatchDTO createMatch(MatchDTO dto);

    /**
     * Aktualizuje existující zápas.
     *
     * @param id  ID zápasu, který má být upraven
     * @param dto nové hodnoty pro zápas
     * @return aktualizovaný zápas
     */
    MatchDTO updateMatch(Long id, MatchDTO dto);

    /**
     * Smaže zápas podle ID.
     * <p>
     * Typicky vrací informaci o úspěchu operace
     * ve formě {@link SuccessResponseDTO}.
     * </p>
     *
     * @param id ID zápasu, který má být smazán
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO deleteMatch(Long id);

    /**
     * Vrátí detailní informace o zápasu.
     * <p>
     * Na rozdíl od {@link #getMatchById(Long)} může obsahovat
     * rozšířené informace (např. registrace, statistiky, atd.).
     * </p>
     *
     * @param id ID zápasu
     * @return detail zápasu
     */
    MatchDetailDTO getMatchDetail(Long id);

    /**
     * Vrátí seznam zápasů, na které se daný hráč může registrovat.
     * <p>
     * Typicky filtruje:
     * </p>
     * <ul>
     *     <li>pouze nadcházející zápasy,</li>
     *     <li>zápasy, kde ještě není plná kapacita,</li>
     *     <li>zápasy v rámci povolené sezóny / pravidel.</li>
     * </ul>
     *
     * @param playerId ID hráče
     * @return seznam dostupných zápasů pro hráče
     */
    List<MatchDTO> getAvailableMatchesForPlayer(Long playerId);

    /**
     * Vrátí nadcházející zápasy pro konkrétního hráče.
     * <p>
     * Může zahrnovat:
     * </p>
     * <ul>
     *     <li>zápasy, na které je hráč přihlášen,</li>
     *     <li>případně další omezené podle business pravidel.</li>
     * </ul>
     *
     * @param playerId ID hráče
     * @return seznam nadcházejících zápasů pro daného hráče
     */
    List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId);

    /**
     * Najde ID hráče podle emailu uživatele.
     * <p>
     * Pomocná metoda pro případy, kdy je k dispozici email
     * přihlášeného uživatele a je potřeba zjistit navázaného hráče.
     * </p>
     *
     * @param email email uživatele
     * @return ID hráče nebo {@code null}, pokud neexistuje
     */
    Long getPlayerIdByEmail(String email);

    /**
     * Vrátí přehled nadcházejících zápasů pro hráče.
     * <p>
     * Na rozdíl od {@link #getUpcomingMatchesForPlayer(Long)} může
     * poskytovat zjednodušený nebo agregovaný pohled (overview)
     * vhodný pro seznamy a dashboardy.
     * </p>
     *
     * @param playerId ID hráče
     * @return přehled nadcházejících zápasů pro daného hráče
     */
    List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId);

    /**
     * Vrátí přehled všech odehraných zápasů pro hráče.
     * <p>
     * Využívá se pro statistiky, historii účasti a přehled
     * minulých zápasů daného hráče.
     * </p>
     *
     * @param playerId ID hráče
     * @return přehled všech odehraných zápasů pro daného hráče
     */
    List<MatchOverviewDTO> getAllPassedMatchesForPlayer(Long playerId);

    /**
     * Označí hráče u daného zápasu jako „neomluveného“.
     * <p>
     * Typicky používáno v administrátorském kontextu po zápase,
     * kdy je potřeba vyhodnotit docházku hráče.
     * </p>
     *
     * @param matchId   ID zápasu
     * @param playerId  ID hráče
     * @param adminNote poznámka administrátora
     * @return aktualizovaná registrace hráče k zápasu
     */
    MatchRegistrationDTO markNoExcused(Long matchId, Long playerId, String adminNote);

    /**
     * Zruší zápas a nastaví důvod zrušení.
     * <p>
     * Zápas je označen jako zrušený s uvedeným důvodem.
     * Implementace může navazovat další logiku
     * (např. notifikace hráčů).
     * </p>
     *
     * @param matchId ID zápasu
     * @param reason  důvod zrušení
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO cancelMatch(Long matchId, MatchCancelReason reason);

    /**
     * Obnoví dříve zrušený zápas.
     * <p>
     * Zápas se vrátí do stavu, kdy je opět platný a může se konat,
     * pokud to dovolují ostatní podmínky (např. datum, kapacita).
     * </p>
     *
     * @param matchId ID zápasu
     * @return odpověď s výsledkem operace
     */
    SuccessResponseDTO unCancelMatch(Long matchId);

}
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.*;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.models.dto.*;
import cz.phsoft.hokej.models.dto.mappers.MatchMapper;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import jakarta.transaction.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Service vrstva pro práci se zápasy.
 * <p>
 * Odpovědnosti:
 * <ul>
 *     <li>CRUD nad zápasy v rámci aktivní sezóny,</li>
 *     <li>filtrování zápasů podle data a typu hráče (VIP/STANDARD/BASIC),</li>
 *     <li>výpočet detailních statistik k zápasu (MatchDetailDTO),</li>
 *     <li>přístupová logika k detailu zápasu (hráč vs admin/manager),</li>
 *     <li>přehledy zápasů pro konkrétního hráče (overview),</li>
 *     <li>rušení a obnovení zápasů (CANCELLED / uncancel).</li>
 * </ul>
 *
 * Tato service:
 * <ul>
 *     <li>neřeší registrace (detailní stav hráče) – to řeší {@link MatchRegistrationService},</li>
 *     <li>neřeší výběr aktuálního hráče – to řeší {@link CurrentPlayerService} a controller.</li>
 * </ul>
 */
@Service
public class MatchServiceImpl implements MatchService {

    private static final Logger logger = LoggerFactory.getLogger(MatchServiceImpl.class);

    private static final String ROLE_ADMIN   = "ROLE_ADMIN";
    private static final String ROLE_MANAGER = "ROLE_MANAGER";

    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository matchRegistrationRepository;
    private final MatchMapper matchMapper;
    private final MatchRegistrationService registrationService;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodService playerInactivityPeriodService;
    private final PlayerMapper playerMapper;
    private final CurrentPlayerService currentPlayerService;
    private final SeasonService seasonService;


    public MatchServiceImpl(MatchRepository matchRepository,
                            MatchRegistrationRepository matchRegistrationRepository,
                            MatchMapper matchMapper,
                            MatchRegistrationService registrationService,
                            PlayerRepository playerRepository,
                            PlayerInactivityPeriodService playerInactivityPeriodService,
                            PlayerMapper playerMapper,
                            CurrentPlayerService currentPlayerService,
                            SeasonService seasonService) {
        this.matchRepository = matchRepository;
        this.matchRegistrationRepository = matchRegistrationRepository;
        this.matchMapper = matchMapper;
        this.registrationService = registrationService;
        this.playerRepository = playerRepository;
        this.playerInactivityPeriodService = playerInactivityPeriodService;
        this.playerMapper = playerMapper;
        this.currentPlayerService = currentPlayerService;
        this.seasonService = seasonService;
    }

    // ======================
    // ZÁKLADNÍ SEZNAMY ZÁPASŮ
    // ======================

    /**
     * Vrátí všechny zápasy v rámci aktivní sezóny
     * seřazené podle data vzestupně.
     */
    @Override
    public List<MatchDTO> getAllMatches() {
    Long seasonId = getCurrentSeasonIdOrActive();
        return matchRepository.findAllBySeasonIdOrderByDateTimeAsc(getActiveSeasonId())
                .stream()
                .map(matchMapper::toDTO)
                .toList();
    }

    /**
     * Vrátí všechny nadcházející zápasy v aktivní sezóně
     * (datum > aktuální čas), seřazené podle data vzestupně.
     */
    @Override
    public List<MatchDTO> getUpcomingMatches() {
        return findUpcomingMatchesForActiveSeason()
                .stream()
                .map(matchMapper::toDTO)
                .toList();
    }

    /**
     * Vrátí všechny již proběhlé zápasy v aktivní sezóně
     * (datum < aktuální čas), seřazené podle data sestupně
     * (nejnovější první).
     */
    @Override
    public List<MatchDTO> getPastMatches() {
        return findPastMatchesForActiveSeason()
                .stream()
                .map(matchMapper::toDTO)
                .toList();
    }

    /**
     * Vrátí nejbližší nadcházející zápas v aktivní sezóně
     * nebo {@code null}, pokud žádný neexistuje.
     */
    @Override
    public MatchDTO getNextMatch() {
        return findUpcomingMatchesForActiveSeason()
                .stream()
                .findFirst()
                .map(matchMapper::toDTO)
                .orElse(null);
    }

    /**
     * Vrátí konkrétní zápas podle ID.
     *
     * @throws MatchNotFoundException pokud zápas neexistuje
     */
    @Override
    public MatchDTO getMatchById(Long id) {
        return matchMapper.toDTO(findMatchOrThrow(id));
    }

    /**
     * Vytvoří nový zápas.
     * <ul>
     *     <li>namapuje DTO na entitu,</li>
     *     <li>ověří, že datum zápasu spadá do aktivní sezóny,</li>
     *     <li>přiřadí aktivní sezónu,</li>
     *     <li>uloží zápas a vrátí DTO.</li>
     * </ul>
     */
    @Override
    public MatchDTO createMatch(MatchDTO dto) {
        MatchEntity entity = matchMapper.toEntity(dto);
        validateMatchDateInActiveSeason(entity.getDateTime());

        entity.setSeason(seasonService.getActiveSeason());

        return matchMapper.toDTO(matchRepository.save(entity));
    }

    /**
     * Aktualizuje existující zápas.
     * <ul>
     *     <li>ověří, že zápas patří do aktivní sezóny,</li>
     *     <li>přenese změny z DTO do entity,</li>
     *     <li>znovu zvaliduje datum v rámci aktivní sezóny,</li>
     *     <li>uloží změny,</li>
     *     <li>pokud se změnil maxPlayers, přepočítá REGISTERED/RESERVED.</li>
     * </ul>
     *
     * @throws InvalidMatchStatusException pokud zápas nepatří do aktivní sezóny
     */
    @Override
    public MatchDTO updateMatch(Long id, MatchDTO dto) {
        MatchEntity entity = findMatchOrThrow(id);

        Long activeSeasonId = seasonService.getActiveSeason().getId();
        if (!entity.getSeason().getId().equals(activeSeasonId)) {
            throw new InvalidMatchStatusException(
                    id, " - Zápas nepatří do aktuální sezóny, nelze ho upravit."
            );
        }

        int oldMaxPlayers = entity.getMaxPlayers();
        matchMapper.updateEntity(dto, entity);

        validateMatchDateInActiveSeason(entity.getDateTime());

        MatchEntity saved = matchRepository.save(entity);

        if (saved.getMaxPlayers() != oldMaxPlayers) {
            registrationService.recalcStatusesForMatch(saved.getId());
        }

        return matchMapper.toDTO(saved);
    }

    /**
     * Smaže zápas podle ID.
     * <p>
     * Pokud zápas neexistuje, vyhodí {@link MatchNotFoundException}.
     *
     * @return {@link SuccessResponseDTO} s potvrzením smazání
     */
    @Override
    public SuccessResponseDTO deleteMatch(Long id) {
        MatchEntity match = findMatchOrThrow(id);
        matchRepository.delete(match);

        return new SuccessResponseDTO(
                "BE - Zápas " + match.getId() + match.getDateTime() + " byl úspěšně smazán",
                id,
                LocalDateTime.now().toString()
        );
    }

    // ======================
    // DETAIL ZÁPASU
    // ======================

    /**
     * Vrátí detail zápasu (MatchDetailDTO) včetně:
     * <ul>
     *     <li>seskupení hráčů podle statusu (REGISTERED/RESERVED/EXCUSED/...),</li>
     *     <li>počtů hráčů v zápase, mimo zápas, náhradníků, NO_EXCUSED, NO_RESPONSE,</li>
     *     <li>ceny na registrovaného hráče,</li>
     *     <li>stavu zápasu (MatchStatus + důvod zrušení),</li>
     *     <li>stavu aktuálního hráče (PlayerMatchStatus) a jeho omluvy.</li>
     * </ul>
     *
     * Obsahuje i přístupovou logiku:
     * <ul>
     *     <li>ADMIN/MANAGER vidí vždy,</li>
     *     <li>běžný uživatel:
     *          <ul>
     *              <li>nadcházející zápas → musí mít aktivního hráče k datu zápasu,</li>
     *              <li>proběhlý zápas → některý jeho hráč musel být REGISTERED.</li>
     *          </ul>
     *     </li>
     * </ul>
     */
    @Override
    public MatchDetailDTO getMatchDetail(Long id) {
        MatchEntity match = findMatchOrThrow(id);

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        boolean isAdminOrManager = hasAdminOrManagerRole(auth);

        // 1) přístupová logika
        checkAccessForPlayer(match, auth);

        // 2) sběr statistik a stavů hráčů
        MatchDetailDTO dto = collectPlayerStatus(match, isAdminOrManager);

        // 3) stav aktuálního hráče (pokud je zvolen)
        Long currentPlayerId = null;
        try {
            currentPlayerId = currentPlayerService.getCurrentPlayerId();
        } catch (Exception e) {
            logger.debug("Nebyl nalezen currentPlayerId pro match detail {}", id);
        }

        PlayerMatchStatus playerMatchStatus = resolveStatusForPlayer(dto, currentPlayerId);
        dto.setPlayerMatchStatus(playerMatchStatus);

        // 4) omluva aktuálního hráče (pokud existuje registrace)
        if (currentPlayerId != null) {
            matchRegistrationRepository.findByPlayerIdAndMatchId(currentPlayerId, match.getId())
                    .ifPresent(reg -> {
                        dto.setExcuseReason(reg.getExcuseReason());
                        dto.setExcuseNote(reg.getExcuseNote());
                    });
        } else {
            dto.setExcuseReason(null);
            dto.setExcuseNote(null);
        }

        // 5) stav zápasu
        dto.setMatchStatus(match.getMatchStatus());
        dto.setCancelReason(match.getCancelReason());

        return dto;
    }

    // --------------------------------------------------
    // Přístupová logika – kdo smí vidět detail zápasu
    // --------------------------------------------------

    /**
     * Ověří, zda má aktuální uživatel přístup k detailu zápasu.
     * <ul>
     *     <li>nepřihlášený → AccessDenied,</li>
     *     <li>ADMIN/MANAGER → vždy povoleno,</li>
     *     <li>běžný uživatel:
     *         <ul>
     *             <li>získá své hráče (ownedPlayers) podle emailu,</li>
     *             <li>bez hráčů → AccessDenied,</li>
     *             <li>nadcházející zápas → musí mít aktivního hráče k datu zápasu,</li>
     *             <li>uplynulý zápas → jeho hráč musel být REGISTERED.</li>
     *         </ul>
     *     </li>
     * </ul>
     *
     * @throws org.springframework.security.access.AccessDeniedException
     *         pokud uživatel nesplňuje podmínky
     */
    private void checkAccessForPlayer(MatchEntity match, Authentication auth) {
        if (auth == null || !auth.isAuthenticated()) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - Musíte být přihlášen."
            );
        }

        boolean isAdminOrManager = hasAdminOrManagerRole(auth);
        if (isAdminOrManager) {
            return;
        }

        Object principal = auth.getPrincipal();
        if (!(principal instanceof org.springframework.security.core.userdetails.UserDetails userDetails)) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - Nemáte přístup k detailu tohoto zápasu."
            );
        }

        List<PlayerEntity> ownedPlayers =
                playerRepository.findByUser_EmailOrderByIdAsc(userDetails.getUsername());

        if (ownedPlayers.isEmpty()) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - Nemáte přiřazeného žádného hráče."
            );
        }

        LocalDateTime now = now();
        boolean isPastOrNow = !match.getDateTime().isAfter(now);
        List<Long> ownedPlayerIds = ownedPlayers.stream()
                .map(PlayerEntity::getId)
                .toList();

        List<MatchRegistrationDTO> registrations =
                registrationService.getRegistrationsForMatch(match.getId());

        if (!isPastOrNow) {
            // nadcházející zápas – hráč musí být aktivní pro datum zápasu
            boolean hasActivePlayerForMatch = ownedPlayers.stream()
                    .anyMatch(p -> isPlayerActiveForMatch(p, match.getDateTime()));

            if (!hasActivePlayerForMatch) {
                throw new org.springframework.security.access.AccessDeniedException(
                        "BE - Nemáte aktivního hráče pro tento zápas."
                );
            }
            return;
        }

        // uplynulý zápas – hráč musí být mezi REGISTERED
        boolean wasRegistered = registrations.stream()
                .anyMatch(r ->
                        r.getStatus() == PlayerMatchStatus.REGISTERED
                                && ownedPlayerIds.contains(r.getPlayerId())
                );

        if (!wasRegistered) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "BE - K tomuto uplynulému zápasu nemáte oprávnění (nejste mezi registrovanými hráči)."
            );
        }
    }

    // --------------------------------------------------
    // Sběr statistik hráčů pro MatchDetailDTO
    // --------------------------------------------------

    /**
     * Sestaví {@link MatchDetailDTO} pro daný zápas:
     * <ul>
     *     <li>seskupí hráče podle statusu (REGISTERED/RESERVED/EXCUSED/...)</li>
     *     <li>spočítá počty hráčů v jednotlivých kategoriích,</li>
     *     <li>vypočítá cenu na registrovaného hráče,</li>
     *     <li>naplní seznamy hráčů k jednotlivým statusům,</li>
     *     <li>pole noResponsePlayers vyplní jen pro admin/manager.</li>
     * </ul>
     */
    private MatchDetailDTO collectPlayerStatus(MatchEntity match, boolean isAdminOrManager) {
        List<MatchRegistrationDTO> registrations =
                registrationService.getRegistrationsForMatch(match.getId());

        var statusToPlayersMap = registrations.stream()
                .map(r -> playerRepository.findById(r.getPlayerId())
                        .map(playerMapper::toDTO)
                        .map(dto -> new java.util.AbstractMap.SimpleEntry<>(r.getStatus(), dto))
                )
                .filter(Optional::isPresent)
                .map(Optional::get)
                .collect(Collectors.groupingBy(
                        java.util.Map.Entry::getKey,
                        Collectors.mapping(java.util.Map.Entry::getValue, Collectors.toList())
                ));

        List<PlayerDTO> noResponsePlayers =
                registrationService.getNoResponsePlayers(match.getId());

        int inGamePlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()).size();

        int inGamePlayersDark =
                (int) registrations.stream()
                        .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                        .filter(r -> r.getTeam() == Team.DARK)
                        .count();

        int inGamePlayersLight =
                (int) registrations.stream()
                        .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                        .filter(r -> r.getTeam() == Team.LIGHT)
                        .count();

        int outGamePlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()).size()
                        + statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()).size()
                        + statusToPlayersMap.getOrDefault(PlayerMatchStatus.NO_EXCUSED, List.of()).size();

        int waitingPlayers =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()).size();

        int noExcusedPlayersSum =
                statusToPlayersMap.getOrDefault(PlayerMatchStatus.NO_EXCUSED, List.of()).size();

        int noActionPlayers = noResponsePlayers.size();

        int remainingSlots = match.getMaxPlayers() - inGamePlayers;
        double pricePerRegistered = inGamePlayers > 0
                ? match.getPrice() / (double) inGamePlayers
                : match.getPrice();

        MatchDetailDTO dto = new MatchDetailDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setLocation(match.getLocation());
        dto.setDescription(match.getDescription());
        dto.setPrice(match.getPrice());
        dto.setMaxPlayers(match.getMaxPlayers());
        dto.setInGamePlayers(inGamePlayers);
        dto.setInGamePlayersDark(inGamePlayersDark);
        dto.setInGamePlayersLight(inGamePlayersLight);
        dto.setOutGamePlayers(outGamePlayers);
        dto.setWaitingPlayers(waitingPlayers);
        dto.setNoExcusedPlayersSum(noExcusedPlayersSum);
        dto.setNoActionPlayers(noActionPlayers);
        dto.setPricePerRegisteredPlayer(pricePerRegistered);
        dto.setRemainingSlots(remainingSlots);

        dto.setRegisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()));
        dto.setReservedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()));
        dto.setUnregisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()));
        dto.setExcusedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()));
        dto.setNoExcusedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.NO_EXCUSED, List.of()));

        dto.setNoResponsePlayers(isAdminOrManager ? noResponsePlayers : null);

        return dto;
    }

    /**
     * Z MatchDetailDTO odvodí status konkrétního hráče
     * na základě jeho členství v seznamu hráčů dle statusu.
     * Pokud není v žádném seznamu, vrací NO_RESPONSE.
     */
    private PlayerMatchStatus resolveStatusForPlayer(MatchDetailDTO dto, Long playerId) {
        if (dto == null || playerId == null) {
            return PlayerMatchStatus.NO_RESPONSE;
        }

        if (isIn(dto.getRegisteredPlayers(), playerId)) {
            return PlayerMatchStatus.REGISTERED;
        }
        if (isIn(dto.getReservedPlayers(), playerId)) {
            return PlayerMatchStatus.RESERVED;
        }
        if (isIn(dto.getExcusedPlayers(), playerId)) {
            return PlayerMatchStatus.EXCUSED;
        }
        if (isIn(dto.getUnregisteredPlayers(), playerId)) {
            return PlayerMatchStatus.UNREGISTERED;
        }
        if (isIn(dto.getNoExcusedPlayers(), playerId)) {
            return PlayerMatchStatus.NO_EXCUSED;
        }

        return PlayerMatchStatus.NO_RESPONSE;
    }

    /**
     * Pomocná metoda – zjistí, zda je hráč s daným ID v seznamu PlayerDTO.
     */
    private boolean isIn(List<PlayerDTO> players, Long playerId) {
        return players != null
                && players.stream().anyMatch(p -> p.getId().equals(playerId));
    }



    // ======================
    // DALŠÍ PUBLIC METODY
    // ======================

    /**
     * Vrátí všechny zápasy, ve kterých může daný hráč potenciálně hrát.
     * <ul>
     *     <li>vezme všechny zápasy (všechny sezóny),</li>
     *     <li>filtruje je podle aktivity hráče v daném datu
     *         (PlayerInactivityPeriodService.isActive).</li>
     * </ul>
     */
    @Override
    public List<MatchDTO> getAvailableMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        return matchRepository.findAll().stream()
                .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                .map(matchMapper::toDTO)
                .toList();
    }

    /**
     * Najde ID hráče podle emailu uživatele (User.email).
     *
     * @throws PlayerNotFoundException pokud uživatel nemá hráče
     */
    @Override
    public Long getPlayerIdByEmail(String email) {
        return playerRepository.findByUserEmail(email)
                .map(PlayerEntity::getId)
                .orElseThrow(() -> new PlayerNotFoundException(email));
    }

    /**
     * Vrátí přehled nadcházejících zápasů pro konkrétního hráče.
     * <ul>
     *     <li>zjistí PlayerType hráče,</li>
     *     <li>vezme všechny nadcházející zápasy v aktivní sezóně,</li>
     *     <li>omezí jejich počet podle PlayerType (VIP/STANDARD/BASIC),</li>
     *     <li>filtruje jen zápasy, kde je hráč aktivní,</li>
     *     <li>namapuje na MatchOverviewDTO včetně PlayerMatchStatus.</li>
     * </ul>
     */
    @Override
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        List<MatchEntity> upcomingAll = findUpcomingMatchesForActiveSeason();
        List<MatchEntity> limited = limitMatchesByPlayerType(upcomingAll, type);

        return limited.stream()
                .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                .map(match -> toOverviewDTO(match, playerId))
                .toList();
    }

    /**
     * Vrátí seznam nadcházejících zápasů pro konkrétního hráče
     * v plném MatchDTO formátu, s omezením podle PlayerType.
     */
    @Override
    public List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        List<MatchEntity> upcomingAll = findUpcomingMatchesForActiveSeason();
        List<MatchEntity> limited = limitMatchesByPlayerType(upcomingAll, type);

        return limited.stream()
                .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                .map(matchMapper::toDTO)
                .toList();
    }

    /**
     * Vrátí overview všech proběhlých zápasů aktivní sezóny,
     * kterých se hráč mohl účastnit.
     * <ul>
     *     <li>bere jen proběhlé zápasy v aktivní sezóně,</li>
     *     <li>filtruje podle aktivity hráče v datu zápasu,</li>
     *     <li>najednou načte všechny registrace k těmto zápasům,</li>
     *     <li>z nich sestaví mapu matchId → playerId → status,</li>
     *     <li>pro každý zápas sestaví MatchOverviewDTO a nastaví PlayerMatchStatus.</li>
     * </ul>
     */
    @Override
    public List<MatchOverviewDTO> getAllPassedMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        List<MatchEntity> availableMatches =
                findPastMatchesForActiveSeason().stream()
                        .filter(match -> isPlayerActiveForMatch(player, match.getDateTime()))
                        .toList();

        if (availableMatches.isEmpty()) {
            return List.of();
        }

        List<Long> matchIds = availableMatches.stream()
                .map(MatchEntity::getId)
                .toList();

        List<MatchRegistrationDTO> allRegistrations =
                registrationService.getRegistrationsForMatches(matchIds);

        var statusMap = allRegistrations.stream()
                .collect(Collectors.groupingBy(
                        MatchRegistrationDTO::getMatchId,
                        Collectors.toMap(
                                MatchRegistrationDTO::getPlayerId,
                                MatchRegistrationDTO::getStatus,
                                (a, b) -> a
                        )
                ));

        return availableMatches.stream()
                .map(match -> {
                    MatchOverviewDTO overview = toOverviewDTO(match);

                    PlayerMatchStatus playerMatchStatus = Optional.ofNullable(statusMap.get(match.getId()))
                            .map(m -> normalizePlayerStatus(m.get(playerId)))
                            .orElse(PlayerMatchStatus.NO_RESPONSE);

                    overview.setPlayerMatchStatus(playerMatchStatus);
                    return overview;
                })
                .toList();
    }

    /**
     * Delegace na {@link MatchRegistrationService#markNoExcused(Long, Long, String)}.
     * <p>
     * Speciální logika pro nastavení statusu NO_EXCUSED na registraci hráče.
     */
    @Override
    public MatchRegistrationDTO markNoExcused(Long matchId, Long playerId, String adminNote) {
        return registrationService.markNoExcused(matchId, playerId, adminNote);
    }

    /**
     * Zruší zápas s uvedeným důvodem.
     * <ul>
     *     <li>nastaví MatchStatus.CANCELLED,</li>
     *     <li>uloží důvod zrušení,</li>
     *     <li>pokud je již zrušen, vyhodí InvalidMatchStatusException.</li>
     * </ul>
     */
    @Override
    @Transactional
    public SuccessResponseDTO cancelMatch(Long matchId, MatchCancelReason reason) {
        MatchEntity match = findMatchOrThrow(matchId);
        String message = " je již zrušen";

        if (match.getMatchStatus() == MatchStatus.CANCELLED) {
            throw new InvalidMatchStatusException(matchId, message);
        }

        match.setMatchStatus(MatchStatus.CANCELLED);
        match.setCancelReason(reason);

        return new SuccessResponseDTO(
                "BE - Zápas " + match.getId() + match.getDateTime() + " byl úspěšně zrušen",
                match.getId(),
                LocalDateTime.now().toString()
        );
    }

    /**
     * Obnoví dříve zrušený zápas.
     * <ul>
     *     <li>MatchStatus nastaví na null,</li>
     *     <li>cancelReason nastaví na null,</li>
     *     <li>pokud zápas nebyl zrušen, vyhodí InvalidMatchStatusException.</li>
     * </ul>
     */
    @Override
    @Transactional
    public SuccessResponseDTO unCancelMatch(Long matchId) {
        MatchEntity match = findMatchOrThrow(matchId);
        String message = " ještě nebyl zrušen";

        if (match.getMatchStatus() != MatchStatus.CANCELLED) {
            throw new InvalidMatchStatusException(matchId, message);
        }

        match.setMatchStatus(null);
        match.setCancelReason(null);

        return new SuccessResponseDTO(
                "BE - Zápas " + match.getId() + match.getDateTime() + " byl úspěšně obnoven",
                match.getId(),
                LocalDateTime.now().toString()
        );
    }

    // ======================
    // POMOCNÉ METODY – ENTITY
    // ======================

    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    private MatchEntity findMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }

    private MatchRegistrationEntity findMatchRegistrationOrThrow(Long playerId, Long matchId) {
        return matchRegistrationRepository.findByPlayerIdAndMatchId(playerId, matchId)
                .orElseThrow(() -> new MatchRegistrationNotFoundException(playerId, matchId));
    }

    private Long getActiveSeasonId() {
        return seasonService.getActiveSeason().getId();
    }

    private LocalDateTime now() {
        return LocalDateTime.now();
    }

    // ======================
    // POMOCNÉ METODY – DTO MAPOVÁNÍ
    // ======================

    /**
     * Sestaví základní {@link MatchOverviewDTO} pro daný zápas
     * (bez ohledu na konkrétního hráče).
     * <ul>
     *     <li>vypočítá počet REGISTERED hráčů,</li>
     *     <li>vypočítá cenu na registrovaného hráče.</li>
     * </ul>
     */
    private MatchOverviewDTO toOverviewDTO(MatchEntity match) {
        MatchOverviewDTO dto = new MatchOverviewDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setLocation(match.getLocation());
        dto.setDescription(match.getDescription());
        dto.setPrice(match.getPrice());
        dto.setMaxPlayers(match.getMaxPlayers());

        int inGamePlayers = registrationService.getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .mapToInt(r -> 1)
                .sum();
        dto.setInGamePlayers(inGamePlayers);

        double pricePerPlayer = inGamePlayers > 0 && match.getPrice() != null
                ? match.getPrice() / (double) inGamePlayers
                : match.getPrice();
        dto.setPricePerRegisteredPlayer(pricePerPlayer);

        return dto;
    }

    /**
     * Rozšířená verze overview o stav konkrétního hráče v zápase.
     */
    private MatchOverviewDTO toOverviewDTO(MatchEntity match, Long playerId) {
        MatchOverviewDTO dto = toOverviewDTO(match);

        PlayerMatchStatus playerMatchStatus = registrationService
                .getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getPlayerId().equals(playerId))
                .map(MatchRegistrationDTO::getStatus)
                .findFirst()
                .map(this::normalizePlayerStatus)
                .orElse(PlayerMatchStatus.NO_RESPONSE);

        dto.setPlayerMatchStatus(playerMatchStatus);
        return dto;
    }

    // ======================
    // DALŠÍ POMOCNÉ METODY
    // ======================

    /**
     * Zjistí, zda má uživatel roli ADMIN nebo MANAGER.
     */
    private boolean hasAdminOrManagerRole(Authentication auth) {
        if (auth == null) {
            return false;
        }
        return auth.getAuthorities().stream()
                .anyMatch(a ->
                        ROLE_ADMIN.equals(a.getAuthority()) ||
                                ROLE_MANAGER.equals(a.getAuthority())
                );
    }

    /**
     * Všechny nadcházející zápasy v aktivní sezóně (datum > teď),
     * seřazené podle data vzestupně.
     */
    private List<MatchEntity> findUpcomingMatchesForActiveSeason() {
        return matchRepository.findBySeasonIdAndDateTimeAfterOrderByDateTimeAsc(
                getActiveSeasonId(),
                now()
        );
    }

    /**
     * Všechny proběhlé zápasy v aktivní sezóně (datum < teď),
     * seřazené podle data sestupně.
     */
    private List<MatchEntity> findPastMatchesForActiveSeason() {
        return matchRepository.findBySeasonIdAndDateTimeBeforeOrderByDateTimeDesc(
                getActiveSeasonId(),
                now()
        );
    }

    /**
     * Omezení seznamu nadcházejících zápasů podle typu hráče.
     * <ul>
     *     <li>VIP → všechny zápasy,</li>
     *     <li>STANDARD → max 2 zápasy,</li>
     *     <li>BASIC → pouze nejbližší zápas.</li>
     * </ul>
     */
    private List<MatchEntity> limitMatchesByPlayerType(List<MatchEntity> upcomingAll, PlayerType type) {
        if (upcomingAll == null || upcomingAll.isEmpty()) {
            return List.of();
        }

        return switch (type) {
            case VIP -> upcomingAll;
            case STANDARD -> upcomingAll.stream().limit(2).toList();
            case BASIC -> List.of(upcomingAll.get(0));
        };
    }

    /**
     * Ověří, zda je hráč aktivní pro dané datum zápasu,
     * pomocí {@link PlayerInactivityPeriodService}.
     */
    private boolean isPlayerActiveForMatch(PlayerEntity player, LocalDateTime dateTime) {
        return playerInactivityPeriodService.isActive(player, dateTime);
    }

    /**
     * Normalizuje status hráče.
     * <ul>
     *     <li>null → NO_RESPONSE,</li>
     *     <li>jinak vrací status, pokud je z podporovaného seznamu.</li>
     * </ul>
     */
    private PlayerMatchStatus normalizePlayerStatus(PlayerMatchStatus status) {
        if (status == null) {
            return PlayerMatchStatus.NO_RESPONSE;
        }

        return switch (status) {
            case REGISTERED,
                 UNREGISTERED,
                 EXCUSED,
                 RESERVED,
                 NO_EXCUSED -> status;
            default -> PlayerMatchStatus.NO_RESPONSE;
        };
    }

    /**
     * Ověří, že datum zápasu spadá do intervalu aktivní sezóny,
     * jinak vyhodí {@link InvalidSeasonPeriodDateException}.
     */
    private void validateMatchDateInActiveSeason(LocalDateTime dateTime) {
        var activeSeason = seasonService.getActiveSeason();
        var date = dateTime.toLocalDate();

        if (date.isBefore(activeSeason.getStartDate()) ||
                date.isAfter(activeSeason.getEndDate())) {

            throw new InvalidSeasonPeriodDateException(
                    "BE - Datum zápasu musí být v rozmezí aktivní sezóny (" +
                            activeSeason.getStartDate() + " - " + activeSeason.getEndDate() + ")."
            );
        }
    }
}

package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.time.LocalDateTime;
import java.util.List;

/**
 * Repozitář pro práci s entitou {@link MatchEntity}.
 *
 * Slouží k načítání zápasů podle času konání a sezóny,
 * zejména pro přehledy nadcházejících a odehraných zápasů.
 */
public interface MatchRepository extends JpaRepository<MatchEntity, Long> {

    // ==================================================
    // ZÁPASY PODLE DATA (NEZÁVISLE NA SEZÓNĚ)
    // ==================================================

    /**
     * Vrátí všechny zápasy konající se po zadaném čase.
     *
     * Zápasy jsou seřazeny vzestupně podle data konání
     * (nejbližší zápas jako první).
     *
     * @param dateTime referenční datum a čas
     * @return seznam nadcházejících zápasů
     */
    List<MatchEntity> findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime dateTime);

    /**
     * Vrátí všechny zápasy konající se před zadaným časem.
     *
     * Zápasy jsou seřazeny sestupně podle data konání
     * (nejnovější odehraný zápas jako první).
     *
     * @param dateTime referenční datum a čas
     * @return seznam odehraných zápasů
     */
    List<MatchEntity> findByDateTimeBeforeOrderByDateTimeDesc(LocalDateTime dateTime);

    // ==================================================
    // ZÁPASY V KONKRÉTNÍ SEZÓNĚ
    // ==================================================

    /**
     * Vrátí všechny zápasy v dané sezóně seřazené
     * vzestupně podle data konání.
     *
     * @param seasonId ID sezóny
     * @return seznam zápasů v sezóně
     */
    List<MatchEntity> findAllBySeasonIdOrderByDateTimeAsc(Long seasonId);

    /**
     * Vrátí všechny zápasy v dané sezóně seřazené
     * sestupně podle data konání.
     *
     * @param seasonId ID sezóny
     * @return seznam zápasů v sezóně
     */
    List<MatchEntity> findAllBySeasonIdOrderByDateTimeDesc(Long seasonId);

    // ==================================================
    // ZÁPASY V SEZÓNĚ S ČASOVÝM OMEZENÍM
    // ==================================================

    /**
     * Vrátí zápasy v dané sezóně, které se konají
     * po zadaném čase.
     *
     * Používá se zejména pro načítání nadcházejících
     * zápasů v aktivní sezóně.
     *
     * @param seasonId ID sezóny
     * @param from     referenční datum a čas
     * @return seznam nadcházejících zápasů v sezóně
     */
    List<MatchEntity> findBySeasonIdAndDateTimeAfterOrderByDateTimeAsc(
            Long seasonId,
            LocalDateTime from
    );

    /**
     * Vrátí zápasy v dané sezóně, které se konaly
     * před zadaným časem.
     *
     * Používá se zejména pro přehled odehraných
     * zápasů v sezóně.
     *
     * @param seasonId ID sezóny
     * @param to       referenční datum a čas
     * @return seznam odehraných zápasů v sezóně
     */
    List<MatchEntity> findBySeasonIdAndDateTimeBeforeOrderByDateTimeDesc(
            Long seasonId,
            LocalDateTime to
    );
}
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;
import cz.phsoft.hokej.models.dto.MatchOverviewDTO;
import cz.phsoft.hokej.models.services.CurrentPlayerService;
import cz.phsoft.hokej.models.services.MatchService;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller pro práci se zápasy z pohledu přihlášeného uživatele / hráče.
 * <p>
 * Controller poskytuje:
 * <ul>
 *     <li>detail zápasu,</li>
 *     <li>seznam nadcházejících zápasů pro aktuálního hráče,</li>
 *     <li>přehled nadcházejících zápasů (overview),</li>
 *     <li>seznam již odehraných zápasů aktuálního hráče.</li>
 * </ul>
 *
 * Controller pracuje vždy v kontextu „aktuálního hráče“,
 * který je spravován pomocí {@link CurrentPlayerService}.
 */
@RestController
@RequestMapping("/api/matches")
@CrossOrigin(origins = "*")
public class MatchController {

    private final MatchService matchService;
    private final CurrentPlayerService currentPlayerService;

    public MatchController(MatchService matchService,
                           CurrentPlayerService currentPlayerService) {
        this.matchService = matchService;
        this.currentPlayerService = currentPlayerService;
    }

    /**
     * Vrátí detail konkrétního zápasu.
     *
     * @param id ID zápasu
     * @return detail zápasu
     */
    @GetMapping("/matchDetail/{id}")
    @PreAuthorize("isAuthenticated()")
    public MatchDetailDTO getMatchDetail(@PathVariable Long id) {
        return matchService.getMatchDetail(id);
    }

    /**
     * Vrátí nejbližší nadcházející zápas.
     * <p>
     * Endpoint je zachován spíše pro interní nebo zpětnou kompatibilitu.
     * Pro práci v kontextu hráče se doporučuje používat endpointy
     * založené na „aktuálním hráči“.
     *
     * @return nejbližší nadcházející zápas
     */
    @GetMapping("/next")
    @PreAuthorize("isAuthenticated()")
    public MatchDTO getNextMatch() {
        return matchService.getNextMatch();
    }

    /**
     * Vrátí seznam nadcházejících zápasů pro aktuálně zvoleného hráče.
     * <p>
     * Vyžaduje, aby měl uživatel nastaveného aktuálního hráče.
     *
     * @param authentication autentizační kontext přihlášeného uživatele
     * @return seznam nadcházejících zápasů
     */
    @GetMapping("/me/upcoming")
    @PreAuthorize("isAuthenticated()")
    public List<MatchDTO> getUpcomingMatchesForMe(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getUpcomingMatchesForPlayer(currentPlayerId);
    }

    /**
     * Vrátí přehled (overview) nadcházejících zápasů pro aktuálního hráče.
     * <p>
     * Přehled obsahuje zjednodušená data určená pro seznamové zobrazení
     * na frontendu.
     *
     * @param authentication autentizační kontext přihlášeného uživatele
     * @return seznam přehledů nadcházejících zápasů
     */
    @GetMapping("/me/upcoming-overview")
    @PreAuthorize("isAuthenticated()")
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForMe(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getUpcomingMatchesOverviewForPlayer(currentPlayerId);
    }

    /**
     * Vrátí seznam všech již odehraných zápasů pro aktuálního hráče.
     *
     * @param authentication autentizační kontext přihlášeného uživatele
     * @return seznam odehraných zápasů (overview)
     */
    @GetMapping("/me/all-passed")
    @PreAuthorize("isAuthenticated()")
    public List<MatchOverviewDTO> getAllMatchesForPlayer(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getAllPassedMatchesForPlayer(currentPlayerId);
    }
}
package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

/**
 * Hlavní konfigurace Spring Security pro backend aplikace.
 *
 * ZODPOVĚDNOST:
 * <ul>
 *     <li>nastavení autentizace (CustomUserDetailsService + BCrypt),</li>
 *     <li>nastavení autorizace endpointů (role / přihlášení),</li>
 *     <li>konfigurace login mechanismu (CustomJsonLoginFilter),</li>
 *     <li>session management (stateful přístup),</li>
 *     <li>CORS konfigurace pro SPA frontend (React / Vite).</li>
 * </ul>
 *
 * REŽIMY PROVOZU:
 * <ul>
 *     <li><b>test-mode = true</b> → vše povoleno, HTTP Basic (Postman, vývoj),</li>
 *     <li><b>test-mode = false</b> → produkční režim, REST login + role.</li>
 * </ul>
 */
@Configuration
@EnableWebSecurity
@EnableMethodSecurity // povolí @PreAuthorize, @Secured, @RolesAllowed
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;

    /**
     * Přepínač testovacího režimu:
     *
     * app.test-mode=true
     *
     * Použití:
     * - lokální vývoj
     * - Postman bez řešení session / loginu
     */
    @Value("${app.test-mode:false}")
    private boolean isTestMode;

    public SecurityConfig(CustomUserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    // =====================================================
    // 1) PASSWORD ENCODER
    // =====================================================

    /**
     * BCrypt encoder pro ukládání a ověřování hesel.
     *
     * Používá se:
     * - při registraci
     * - při změně hesla
     * - při autentizaci (login)
     */
    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    // =====================================================
    // 2) AUTHENTICATION PROVIDER
    // =====================================================

    /**
     * DaoAuthenticationProvider:
     *
     * - načítá uživatele z databáze pomocí CustomUserDetailsService
     * - ověřuje heslo pomocí BCryptPasswordEncoder
     *
     * Používá se při loginu přes AuthenticationManager.
     */
    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    // =====================================================
    // 3) AUTHENTICATION MANAGER
    // =====================================================

    /**
     * AuthenticationManager:
     *
     * - centrální bod autentizace ve Spring Security
     * - používá se v CustomJsonLoginFilter
     */
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig)
            throws Exception {
        return authConfig.getAuthenticationManager();
    }

    // =====================================================
    // 4) SECURITY FILTER CHAIN
    // =====================================================

    /**
     * Hlavní bezpečnostní konfigurace HTTP vrstvy.
     *
     * Řeší:
     * <ul>
     *     <li>CSRF / CORS</li>
     *     <li>autorizaci endpointů</li>
     *     <li>login (CustomJsonLoginFilter)</li>
     *     <li>logout</li>
     *     <li>session management</li>
     * </ul>
     */
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http,
                                                   AuthenticationManager authManager) throws Exception {

        // REST API → CSRF vypnuto (řešeno přes session + CORS)
        http.csrf(csrf -> csrf.disable())
                .cors(cors -> { /* používá corsConfigurationSource() */ });

        if (isTestMode) {
            // =================================================
            // TEST MODE
            // =================================================
            //
            // - všechny endpointy povoleny
            // - HTTP Basic autentizace
            // - žádný JSON login filtr
            //
            http.authorizeHttpRequests(auth -> auth.anyRequest().permitAll())
                    .httpBasic();

        } else {
            // =================================================
            // PRODUKČNÍ REŽIM
            // =================================================

            http
                    // napojení na CustomUserDetailsService + BCrypt
                    .authenticationProvider(authenticationProvider())

                    // -------------------------------
                    // AUTORIZACE ENDPOINTŮ
                    // -------------------------------
                    .authorizeHttpRequests(auth -> auth

                            // ===== VEŘEJNÉ ENDPOINTY =====
                            .requestMatchers(
                                    "/api/auth/register",
                                    "/api/auth/verify",
                                    "/api/login",
                                    "/api/logout"
                            ).permitAll()

                            // ===== DEBUG / TEST =====
                            .requestMatchers(
                                    "/api/debug/me",
                                    "/api/test/**"
                            ).hasRole("ADMIN")

                            // testovací emaily
                            .requestMatchers("/api/email/test/**").hasRole("ADMIN")

                            // ===== ADMIN / MANAGER =====
                            .requestMatchers("/api/admin/seasons/**").hasRole("ADMIN")
                            .requestMatchers("/api/matches/admin/**").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/players/admin/**").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/registrations/admin/**").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/inactivity/admin/**").hasAnyRole("ADMIN", "MANAGER")

                            // ===== ZBYTEK API =====
                            .requestMatchers("/api/**").authenticated()

                            .anyRequest().authenticated()
                    )

                    // -------------------------------
                    // SESSION MANAGEMENT
                    // -------------------------------
                    .sessionManagement(sm ->
                            sm.sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
                    )

                    // -------------------------------
                    // CUSTOM JSON LOGIN
                    // -------------------------------
                    .addFilterAt(
                            new CustomJsonLoginFilter("/api/login", authManager),
                            UsernamePasswordAuthenticationFilter.class
                    )

                    // -------------------------------
                    // LOGOUT
                    // -------------------------------
                    .logout(logout -> logout
                            .logoutUrl("/api/logout")
                            .deleteCookies("JSESSIONID")
                            .logoutSuccessHandler((request, response, auth) -> {
                                request.getSession().removeAttribute("CURRENT_PLAYER_ID");
                                response.setContentType("application/json");
                                response.setCharacterEncoding("UTF-8");
                                response.getWriter()
                                        .write("{\"status\":\"ok\",\"message\":\"Odhlášeno\"}");
                            })
                    );
        }

        return http.build();
    }

    // =====================================================
    // 5) CORS KONFIGURACE
    // =====================================================

    /**
     * CORS konfigurace pro SPA frontend (React / Vite).
     *
     * - povoluje http://localhost:5173
     * - umožňuje cookies (JSESSIONID)
     * - povoluje běžné HTTP metody
     */
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {

        CorsConfiguration configuration = new CorsConfiguration();

        configuration.setAllowedOrigins(List.of("http://localhost:5173"));
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source =
                new UrlBasedCorsConfigurationSource();

        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}

package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

import java.time.LocalDate;

/**
 * DTO reprezentující sezónu v aplikaci.
 *
 * Slouží k přenosu informací o sezónách mezi backendem
 * a klientem (správa sezón, výběr aktivní sezóny).
 *
 * Sezóna vymezuje časové období, ve kterém
 * se konají zápasy a ke kterému se vztahují statistiky.
 */
public class SeasonDTO {

    private Long id;

    /**
     * Název sezóny (např. "2024/2025").
     */
    @NotBlank(message = "např. 2025/2026")
    private String name;

    @NotNull(message = "datum sezony OD musí být zadán")
    @JsonFormat(pattern = "yyyy-MM-dd")
    private LocalDate startDate;

    @NotNull(message = "datum sezony DO musí být zadán")
    @JsonFormat(pattern = "yyyy-MM-dd")
    private LocalDate endDate;

    /**
     * Určuje, zda je sezóna aktuálně aktivní.
     *
     * V systému může být v daném okamžiku
     * aktivní maximálně jedna sezóna.
     */
    private boolean active;

    // konstruktory

    public SeasonDTO() {}

    public SeasonDTO(Long id,
                     String name,
                     LocalDate startDate,
                     LocalDate endDate,
                     boolean active) {

        this.id = id;
        this.name = name;
        this.startDate = startDate;
        this.endDate = endDate;
        this.active = active;
    }

    // gettery / settery

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public LocalDate getStartDate() { return startDate; }
    public void setStartDate(LocalDate startDate) { this.startDate = startDate; }

    public LocalDate getEndDate() { return endDate; }
    public void setEndDate(LocalDate endDate) { this.endDate = endDate; }

    public boolean isActive() { return active; }
    public void setActive(boolean active) { this.active = active; }
}
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.SeasonEntity;
import cz.phsoft.hokej.models.dto.SeasonDTO;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;

/**
 * MapStruct mapper pro převod mezi entitou sezóny {@link SeasonEntity}
 * a jejím DTO {@link SeasonDTO}.
 *
 * <p>
 * Slouží k transformaci dat mezi perzistenční vrstvou a API vrstvou
 * pro správu hokejových sezón (časové vymezení, aktivní sezóna apod.).
 * </p>
 *
 * <h3>Architektonická role</h3>
 * <ul>
 *     <li>oddělení entitního modelu sezóny od DTO používaného v API,</li>
 *     <li>centralizace mapování sezón v aplikaci,</li>
 *     <li>zajištění konzistentní práce s daty sezón napříč vrstvami.</li>
 * </ul>
 *
 * <h3>Implementační poznámky</h3>
 * <ul>
 *     <li>mapování probíhá převážně automaticky na základě shodných názvů atributů,</li>
 *     <li>žádné vazby na jiné entity se zde explicitně neřeší,</li>
 *     <li>MapStruct generuje implementaci tohoto rozhraní jako Spring bean.</li>
 * </ul>
 */
@Mapper(componentModel = "spring")
public interface SeasonMapper {

    /**
     * Převede entitu sezóny na DTO reprezentaci.
     *
     * <p>
     * Používá se při vracení dat sezón do API (např. přehled sezón,
     * aktuální aktivní sezóna, detail sezóny).
     * </p>
     *
     * @param entity entita sezóny načtená z databáze
     * @return DTO reprezentace sezóny
     */
    SeasonDTO toDTO(SeasonEntity entity);

    /**
     * Převede DTO sezóny na novou entitu.
     *
     * <p>
     * Typicky se používá při vytváření nové sezóny. Identifikátor
     * sezóny je generován databází a není zde řešen explicitně.
     * </p>
     *
     * @param dto DTO reprezentace sezóny
     * @return nová entita sezóny připravená k uložení
     */
    SeasonEntity toEntity(SeasonDTO dto);

    /**
     * Aktualizuje existující entitu sezóny na základě hodnot z DTO.
     *
     * <p>
     * Metoda nemění identitu sezóny, pouze aktualizuje její atributy
     * (např. datumy, stav aktivace). Slouží pro editaci existující
     * sezóny v administrátorském rozhraní.
     * </p>
     *
     * @param dto    zdrojové DTO s novými hodnotami
     * @param entity cílová entita sezóny, která má být aktualizována
     */
    void updateEntityFromDTO(SeasonDTO dto, @MappingTarget SeasonEntity entity);
}

