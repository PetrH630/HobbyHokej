# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\AppConfig.java


package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class AppConfig {

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\AuditAspect.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

@Component
@Aspect
public class AuditAspect {

    private static final Logger logger = LoggerFactory.getLogger("AUDIT_LOGGER");

    // Pointcut pro vĹˇechny metody ve sluĹľbĂˇch
    @Pointcut("within(cz.phsoft.hokej.models.services..*)")
    public void serviceMethods() {}

    // SpustĂ­ se pĹ™ed metodou
    @Before("serviceMethods()")
    public void logBefore(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().toShortString();
        String args = java.util.Arrays.toString(joinPoint.getArgs());
        logger.info("START {} at {} with args {}", methodName, LocalDateTime.now(), args);
    }

    // SpustĂ­ se po ĂşspÄ›ĹˇnĂ©m dokonÄŤenĂ­ metody
    @AfterReturning(pointcut = "serviceMethods()", returning = "result")
    public void logAfterReturning(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();

        Long userId = null;
        Long playerId = null;

        for (Object arg : args) {
            if (arg instanceof PlayerEntity player) {
                playerId = player.getId();
            } else if (arg instanceof MatchRegistrationEntity registration) {
                playerId = registration.getPlayer().getId();
            } else if (arg instanceof Long id) {
                // pokud mĂˇ metoda Long parametry, mĹŻĹľeĹˇ urÄŤit podle poĹ™adĂ­
                // tĹ™eba prvnĂ­ Long = matchId, druhĂ˝ = playerId
            }
        }

        // logovĂˇnĂ­
        logger.info("END {} - userId={} playerId={} returned [{}] at {}",
                methodName, userId, playerId, result, LocalDateTime.now());
    }
}



# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\CustomJsonLoginFilter.java


package cz.phsoft.hokej.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.context.HttpSessionSecurityContextRepository;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

// filtr pro REST login
public class CustomJsonLoginFilter extends UsernamePasswordAuthenticationFilter {

    private final ObjectMapper objectMapper = new ObjectMapper();

    public CustomJsonLoginFilter(String loginUrl, AuthenticationManager authManager) {
        setFilterProcessesUrl(loginUrl);
        setAuthenticationManager(authManager);
    }

    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        try {
            // Podporujeme x-www-form-urlencoded i JSON
            String email = null;
            String password = null;

// Podporujeme x-www-form-urlencoded
            if ("application/x-www-form-urlencoded".equals(request.getContentType())) {
                email = request.getParameter("username");
                password = request.getParameter("password");
            }

// Podporujeme JSON
            if ((email == null || password == null) &&
                    request.getContentType() != null &&
                    request.getContentType().contains("application/json")) {
                Map<String, String> json = objectMapper.readValue(request.getInputStream(), Map.class);
                email = json.get("email");
                password = json.get("password");
            }


            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(email, password);
            setDetails(request, authRequest);

            return this.getAuthenticationManager().authenticate(authRequest);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }


    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
                                            FilterChain chain, Authentication authResult)
            throws IOException, ServletException {

        // UloĹľenĂ­ do SecurityContextHolder
        SecurityContextHolder.getContext().setAuthentication(authResult);

        // VytvoĹ™enĂ­ session a uloĹľenĂ­ SPRING_SECURITY_CONTEXT
        request.getSession(true).setAttribute(
                HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY,
                SecurityContextHolder.getContext()
        );

        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");

        Map<String, Object> result = new HashMap<>();
        result.put("status", "ok");
        result.put("user", authResult.getName());

        objectMapper.writeValue(response.getWriter(), result);
    }

    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException {
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");

        Map<String, Object> result = new HashMap<>();
        result.put("status", "error");
        result.put("message", "NeplatnĂ© pĹ™ihlaĹˇovacĂ­ Ăşdaje");

        objectMapper.writeValue(response.getWriter(), result);
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\CustomUserDetailsService.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.Set;
import java.util.stream.Collectors;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final AppUserRepository appUserRepository;

    public CustomUserDetailsService(AppUserRepository appUserRepository) {
        this.appUserRepository = appUserRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        AppUserEntity user = appUserRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        return org.springframework.security.core.userdetails.User.builder()
                .username(user.getEmail())
                .password(user.getPassword())
                .roles(user.getRole().name().replace("ROLE_", "")) // "ADMIN", "PLAYER", ...
                .build();
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\DataInitializer.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import jakarta.annotation.PostConstruct;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Component;
import org.springframework.jdbc.core.JdbcTemplate;


import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Component
public class DataInitializer {

    private final PlayerRepository playerRepository;
    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository matchRegistrationRepository;
    private final AppUserRepository appUserRepository;
    private final JdbcTemplate jdbcTemplate;

    public DataInitializer(PlayerRepository playerRepository,
                           MatchRepository matchRepository,
                           MatchRegistrationRepository matchRegistrationRepository,
                           AppUserRepository appUserRepository,
                           JdbcTemplate jdbcTemplate) {
        this.playerRepository = playerRepository;
        this.matchRepository = matchRepository;
        this.matchRegistrationRepository = matchRegistrationRepository;
        this.appUserRepository = appUserRepository;
        this.jdbcTemplate = jdbcTemplate;
    }

    @PostConstruct
    public void init() {
        // Pokud existuje alespoĹ 1 hrĂˇÄŤ, DB uĹľ byla inicializovanĂˇ
        if (playerRepository.count() > 0) {
            System.out.println("Data already initialized â€“ skipping DataInitializer.");
            return;
        }
        System.out.println("Initializing default data...");

        // --- Seznam hrĂˇÄŤĹŻ ---
        List<PlayerEntity> players = new ArrayList<>(List.of(
                new PlayerEntity("HrĂˇÄŤ_1", "Jedna", "", PlayerType.VIP, "+420776609956", Team.DARK),
                new PlayerEntity("HrĂˇÄŤ_2", "Dva", "", PlayerType.VIP, "+420776609956", Team.LIGHT),
                new PlayerEntity("HrĂˇÄŤ_3", "TĹ™i", "", PlayerType.VIP, "+420776609956", Team.LIGHT),
                new PlayerEntity("HrĂˇÄŤ_4", "ÄŚtyĹ™i", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT),
                new PlayerEntity("HrĂˇÄŤ_5", "PÄ›t", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT),
                new PlayerEntity("HrĂˇÄŤ_6", "Ĺ est", "", PlayerType.STANDARD, "+420776609956", Team.DARK),
                new PlayerEntity("HrĂˇÄŤ_7", "Sedm", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT),
                new PlayerEntity("HrĂˇÄŤ_8", "Osum", "", PlayerType.BASIC, "+420776609956", Team.DARK),
                new PlayerEntity("HrĂˇÄŤ_9", "DevÄ›t", "", PlayerType.BASIC, "+420776609956", Team.DARK),
                new PlayerEntity("HrĂˇÄŤ_10", "Deset", "", PlayerType.BASIC, "+420776609956", Team.DARK)
                // ... pĹ™Ă­padnÄ› dalĹˇĂ­ hrĂˇÄŤi
        ));

        // --- VytvoĹ™enĂ­ uĹľivatelĹŻ ke kaĹľdĂ©mu hrĂˇÄŤi ---

        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();

        // --- Default admin ---
        if (appUserRepository.findByEmail("admin@example.com").isEmpty()) {
            AppUserEntity admin = new AppUserEntity();
            admin.setEmail("admin@example.com");
            admin.setPassword(encoder.encode("Administrator123"));
            admin.setRole(Role.ROLE_ADMIN);
            appUserRepository.save(admin);
            System.out.println("Default admin user created.");
        } else {
            System.out.println("Admin user already exists â€“ skipping.");
        }

        System.out.println("Data initialization completed.");

        int playerCounter = 1;
        for (PlayerEntity player : players) {
            // vytvoĹ™enĂ­ uĹľivatele
            String email = "player" + playerCounter + "@example.com";
            String password = "Player123";

            AppUserEntity user = new AppUserEntity();
            user.setEmail(email);
            user.setPassword(encoder.encode(password));
            user.setRole(Role.ROLE_PLAYER);

            // pĹ™iĹ™adit hrĂˇÄŤe k uĹľivateli
            player.setUser(user);

            // uloĹľit uĹľivatele (cascade uloĹľĂ­ i hrĂˇÄŤe, pokud je sprĂˇvnÄ› nastaven)
            appUserRepository.save(user);

            playerCounter++;
        }

        // --- UloĹľit hrĂˇÄŤe (uĹľ uloĹľen pĹ™i cascade, ale pro jistotu) ---
        playerRepository.saveAll(players);

        // --- VytvoĹ™enĂ­ zĂˇpasĹŻ ---
        LocalDateTime startDate = LocalDateTime.of(2025, 11, 21, 18, 45);
        for (int i = 0; i < 10; i++) {
            MatchEntity match = new MatchEntity();
            match.setDateTime(startDate.plusWeeks(i));
            match.setLocation("Ostravice");
            match.setDescription("");
            match.setMaxPlayers(12);
            match.setPrice(2200);
            matchRepository.save(match);
        }

        // --- Registrace hrĂˇÄŤĹŻ na zĂˇpas id 3 ---
        MatchEntity match3 = matchRepository.findById(3L)
                .orElseThrow(() -> new RuntimeException("Match with id 3 not found"));

        for (long playerId = 1; playerId <= 6; playerId++) {
            final long pid = playerId;
            PlayerEntity player = playerRepository.findById(playerId)
                    .orElseThrow(() -> new RuntimeException("Player with id " + pid + " not found"));

            MatchRegistrationEntity reg = new MatchRegistrationEntity();
            reg.setMatch(match3);
            reg.setPlayer(player);
            reg.setStatus(PlayerMatchStatus.REGISTERED);
            reg.setTimestamp(LocalDateTime.now());
            reg.setCreatedBy("user");
            matchRegistrationRepository.save(reg);
        }

        // --- Default admin ---
        if (appUserRepository.findByEmail("admin@example.com").isEmpty()) {
            AppUserEntity admin = new AppUserEntity();
            admin.setEmail("admin@example.com");
            admin.setPassword(encoder.encode("Administrator123"));
            admin.setRole(Role.ROLE_ADMIN);
            appUserRepository.save(admin);
            System.out.println("Default admin user created.");
        } else {
            System.out.println("Admin user already exists â€“ skipping.");
        }

        // --- vytvoĹ™enĂ­ triggeru ---
        try {
            jdbcTemplate.execute("""
                           CREATE TRIGGER trg_match_reg_insert
                           AFTER INSERT ON match_registrations
                           FOR EACH ROW
                           BEGIN
                               INSERT INTO match_registration_history
                               (match_registration_id, match_id, player_id, status, excuse_reason,
                                excuse_note, admin_note, jersey_color, original_timestamp, created_by,
                                action, changed_at)
                               VALUES
                               (NEW.id, NEW.match_id, NEW.player_id, NEW.status, NEW.excuse_reason,
                                NEW.excuse_note, NEW.admin_note, NEW.jersey_color, NEW.timestamp, NEW.created_by,
                                'INSERT', NOW());
                           END
                    """);
            System.out.println("Trigger created successfully.");
        } catch (Exception e) {
            System.out.println("Trigger already exists or error: " + e.getMessage());
        }

        try {
            jdbcTemplate.execute("""
                    CREATE TRIGGER trg_match_reg_update
                    AFTER UPDATE ON match_registrations
                    FOR EACH ROW
                    BEGIN
                        INSERT INTO match_registration_history
                        (match_registration_id, match_id, player_id, status, excuse_reason,
                         excuse_note, admin_note, jersey_color, original_timestamp, created_by,
                         action, changed_at)
                        VALUES
                        (NEW.id, NEW.match_id, NEW.player_id, NEW.status, NEW.excuse_reason,
                         NEW.excuse_note, NEW.admin_note, NEW.jersey_color, NEW.timestamp, NEW.created_by,
                         'UPDATE', NOW());
                    END
                    """);
            System.out.println("Trigger created successfully.");
        } catch (Exception e) {
            System.out.println("Trigger already exists or error: " + e.getMessage());
        }

        try {
            jdbcTemplate.execute("""
        CREATE TRIGGER trg_match_reg_delete
        AFTER DELETE ON match_registrations
        FOR EACH ROW
                BEGIN
        INSERT INTO match_registration_history
                (match_registration_id, match_id, player_id, status, excuse_reason,
                        excuse_note, admin_note, jersey_color, original_timestamp, created_by,
                        action, changed_at)
        VALUES
                (OLD.id, OLD.match_id, OLD.player_id, OLD.status, OLD.excuse_reason,
                        OLD.excuse_note, OLD.admin_note, OLD.jersey_color, OLD.timestamp, OLD.created_by,
                        'DELETE', NOW());
        END
        """);
            System.out.println("Trigger created successfully.");
                } catch (Exception e) {
                    System.out.println("Trigger already exists or error: " + e.getMessage());
                }

        System.out.println("Data initialization completed.");


    }
}





# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\GlobalExceptionHandler.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.exceptions.ApiError;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import jakarta.servlet.http.HttpServletRequest;

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ApiError> handleAccessDenied(AccessDeniedException ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.FORBIDDEN.value(),
                "Forbidden",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // â† IP klienta);
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(error);
    }

    // --- NenalezenĂ© zdroje (404) ---
    @ExceptionHandler({
            MatchNotFoundException.class,
            PlayerNotFoundException.class,
            RegistrationNotFoundException.class
    })
    public ResponseEntity<ApiError> handleNotFound(RuntimeException ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.NOT_FOUND.value(),
                "Not Found",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // â† IP klienta
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    // --- Konflikty (409) ---
    @ExceptionHandler(DuplicateRegistrationException.class)
    public ResponseEntity<ApiError> handleConflict(DuplicateRegistrationException ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.CONFLICT.value(),
                "Conflict",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // â† IP klienta);
        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
    }

    // --- ObecnĂ© chyby (500) ---
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiError> handleAll(Exception ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // â† IP klienta);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\SecurityConfig.java


package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;



import java.util.List;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;

    @Value("${app.test-mode:false}")
    private boolean isTestMode;

    public SecurityConfig(CustomUserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    // Password encoder
    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    // Authentication provider
    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    // AuthenticationManager
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    // Security filter chain
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http, AuthenticationManager authManager) throws Exception {

        http.csrf(csrf -> csrf.disable())
                .cors(cors -> {});

        if (isTestMode) {
            // đź”ą Test mode - vĹˇechno povoleno a HTTP Basic pro Postman
            http.authorizeHttpRequests(auth -> auth.anyRequest().permitAll())
                    .httpBasic();
        } else {
            // đź”ą Produkce - REST login pĹ™es CustomJsonLoginFilter
            http.authorizeHttpRequests(auth -> auth
                            .requestMatchers("/api/matches").hasAnyRole("ADMIN","MANAGER")
                            .requestMatchers("/api/matches/upcoming", "/api/matches/past").hasAnyRole("ADMIN","MANAGER")
                            .requestMatchers("/api/matches/**").authenticated()
                            .requestMatchers("/api/players").hasAnyRole("ADMIN","MANAGER")
                            .requestMatchers("/api/players/**").authenticated()
                            .requestMatchers("/api/registrations/all",
                                    "/api/registrations/for-match/**",
                                    "/api/registrations/no-response/**").hasAnyRole("ADMIN","MANAGER")
                            .requestMatchers("/api/registrations/**").authenticated()
                            .requestMatchers("/api/inactivity/All",
                                    "/api/inactivity/**").hasAnyRole("ADMIN","MANAGER")
                            .requestMatchers("/api/inactivity/player/**").authenticated()
                            .anyRequest().authenticated()
                    )
                    //  TADY PĹESNÄš
                    .sessionManagement(sm ->
                            sm.sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
                    )
                    //  a TEPRVE PAK login filter
                    .addFilterAt(
                            new CustomJsonLoginFilter("/api/login", authManager),
                            UsernamePasswordAuthenticationFilter.class
                    )
                    .logout(logout -> logout
                            .logoutUrl("/logout")
                            .deleteCookies("JSESSIONID")
                            .logoutSuccessHandler((request, response, auth) -> {
                                response.setContentType("application/json");
                                response.setCharacterEncoding("UTF-8");
                                response.getWriter().write("{\"status\":\"ok\",\"message\":\"OdhlĂˇĹˇeno\"}");
                            })
                    );
        }

        return http.build();
    }

    // CORS pro React dev server a cookies
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(List.of("http://localhost:5173"));
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\DebugController.java


package cz.phsoft.hokej.controllers;

import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class DebugController {

    @GetMapping("/api/debug/me")
    public Object me(Authentication auth) {
        return auth;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\MatchController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;
import cz.phsoft.hokej.models.dto.MatchOverviewDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.services.MatchService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;


@RestController
@RequestMapping("/api/matches")
@CrossOrigin(origins = "*")
public class MatchController {

    private final MatchService matchService;


    public MatchController(MatchService matchService) {
        this.matchService = matchService;

    }

    // Detail zĂˇpasu
    @GetMapping("/matchDetail/{id}")
    public MatchDetailDTO getMatchDetail(@PathVariable Long id) {
        return matchService.getMatchDetail(id);
    }

    // VĹˇechny zĂˇpasy
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getAllMatches() {
        return matchService.getAllMatches();
    }

    // NadchĂˇzejĂ­cĂ­ zĂˇpas
    @PreAuthorize("isAuthenticated()")
    @GetMapping("/next")
    public MatchDTO getNextMatch() {
        return matchService.getNextMatch();
    }

    // VĹˇechny nadchĂˇzejĂ­cĂ­ zĂˇpasy
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #playerId)")
    @GetMapping("/upcoming")
    public List<MatchDTO> getUpcomingMatches() {
        return matchService.getUpcomingMatches();
    }

    // NadchĂˇzejĂ­cĂ­ zĂˇpasy pro pĹ™ihlĂˇĹˇenĂ©ho hrĂˇÄŤe
    @GetMapping("/me/upcoming")
    @PreAuthorize("isAuthenticated()")
    public List<MatchDTO> getUpcomingMatchesForMe(Authentication authentication) {
        // z UserDetails zĂ­skĂˇme username
        String email = authentication.getName();
        // najdeme hrĂˇÄŤe podle emailu
        Long playerId = matchService.getPlayerIdByEmail(email);
        return matchService.getUpcomingMatchesForPlayer(playerId);
    }

    @GetMapping("/me/upcoming-overview")
    @PreAuthorize("isAuthenticated()")
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForMe(Authentication authentication) {
        String email = authentication.getName();
        Long playerId = matchService.getPlayerIdByEmail(email);
        return matchService.getUpcomingMatchesOverviewForPlayer(playerId);
    }

    // NadchĂˇzejĂ­cĂ­ zĂˇpasy pro konkrĂ©tnĂ­ho hrĂˇÄŤe
    @GetMapping("/player/{playerId}/upcoming")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #playerId)")
    public List<MatchDTO> getUpcomingMatchesForPlayer(@PathVariable Long playerId) {
        return matchService.getUpcomingMatchesForPlayer(playerId);
    }

    // UĹľ uskuteÄŤnÄ›nĂ© zĂˇpasy
    @GetMapping("/past")
    public List<MatchDTO> getPastMatches() {
        return matchService.getPastMatches();
    }

    // VytvoĹ™enĂ­ zĂˇpasu
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public MatchDTO createMatch(@Valid @RequestBody MatchDTO matchDTO) {
        return matchService.createMatch(matchDTO);
    }

    // ZĂ­skĂˇnĂ­ zĂˇpasu podle ID
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO getMatch(@PathVariable Long id) {
        return matchService.getMatchById(id);
    }

    // Editace zĂˇpasu
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO updateMatch(@PathVariable Long id, @Valid @RequestBody MatchDTO dto) {
        return matchService.updateMatch(id, dto);
    }

    // SmazĂˇnĂ­ zĂˇpasu
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SuccessResponseDTO> deleteMatch(@PathVariable Long id) {
        SuccessResponseDTO response = matchService.deleteMatch(id);
        return ResponseEntity.ok(response);
    }

    // DostupnĂ© zĂˇpasy pro hrĂˇÄŤe
    @GetMapping("/available-for-player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #playerId)")
    public List<MatchDTO> getAvailableMatchesForPlayer(@PathVariable Long playerId) {
        return matchService.getAvailableMatchesForPlayer(playerId);
    }

}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\MatchRegistrationController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import cz.phsoft.hokej.security.PlayerSecurity;
import org.springframework.web.bind.annotation.*;
import org.springframework.security.access.prepost.PreAuthorize;

import java.util.List;

@RestController
@RequestMapping("/api/registrations")
@CrossOrigin(origins = "*")
public class MatchRegistrationController {

    private final MatchRegistrationService service;
    private final PlayerSecurity playerSecurity;

    public MatchRegistrationController(MatchRegistrationService service,
                                       PlayerSecurity playerSecurity) {
        this.service = service;
        this.playerSecurity = playerSecurity;
    }

    // -----------------------------------------------------
    // đź”Ą JEDINĂť UNIVERZĂLNĂŤ ENDPOINT PRO REGISTRACE
    // -----------------------------------------------------
    @PostMapping("/upsert")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #request.playerId)")
    public MatchRegistrationDTO upsert(@RequestBody MatchRegistrationRequest request) {
        return service.upsertRegistration(
                request.getMatchId(),
                request.getPlayerId(),
                request.getJerseyColor(),
                request.getAdminNote(),
                request.getExcuseReason(),
                request.getExcuseNote(),
                request.isUnregister()
        );
    }

    // -----------------------------------------------------
    // GET ENDPOINTY
    // -----------------------------------------------------

    @GetMapping("/all")
    public List<MatchRegistrationDTO> getAllRegistrations() {
        return service.getAllRegistrations();
    }

    @GetMapping("/for-player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #playerId)")
    public List<MatchRegistrationDTO> forPlayer(@PathVariable Long playerId) {
        return service.getRegistrationsForPlayer(playerId);
    }

    @GetMapping("/for-match/{matchId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> forMatch(@PathVariable Long matchId) {
        return service.getRegistrationsForMatch(matchId);
    }

    @GetMapping("/no-response/{matchId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getNoResponse(@PathVariable Long matchId) {
        return service.getNoResponsePlayers(matchId);
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.PlayerService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/players")
@CrossOrigin(origins = "*")
public class PlayerController {

    private final PlayerService playerService;

    public PlayerController(PlayerService playerService) {
        this.playerService = playerService;
    }

    // vĹˇichni hrĂˇÄŤi
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getAllPlayers() {
        return playerService.getAllPlayers();
    }

    // hrĂˇÄŤ dle id

    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #id)")
    public PlayerDTO getPlayerById(@PathVariable Long id) {
        return playerService.getPlayerById(id);
    }

    // vytvoĹ™enĂ­ hrĂˇÄŤe
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    @PostMapping
    public PlayerDTO createPlayer(@RequestBody PlayerDTO playerDTO) {
        return playerService.createPlayer(playerDTO);

    }

    // aktualizace hrĂˇÄŤe dle id hrĂˇÄŤe
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    @PutMapping("/{id}")
    public PlayerDTO updatePlayer(@PathVariable Long id, @RequestBody PlayerDTO dto) {
        return playerService.updatePlayer(id, dto);
    }

    // odstranĂ­ hrĂˇÄŤe
    @PreAuthorize("hasRole('ADMIN')")
    @DeleteMapping("/{id}")
    public ResponseEntity<SuccessResponseDTO> deletePlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.deletePlayer(id);
        return ResponseEntity.ok(response);
    }


}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerInactivityPeriodController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import cz.phsoft.hokej.models.services.PlayerInactivityPeriodService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/inactivity")
@CrossOrigin(origins = "*")
public class PlayerInactivityPeriodController {

    private final PlayerInactivityPeriodService service;

    public PlayerInactivityPeriodController(PlayerInactivityPeriodService service) {
        this.service = service;
    }

    // vĹˇechny zĂˇznamy o neaktivitÄ› hrĂˇÄŤĹŻ
    @GetMapping("/all")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getAll() {
        return service.getAll();
    }

    // neaktivita hrĂˇÄŤĹŻ dle id neaktivity
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<PlayerInactivityPeriodDTO> getById(@PathVariable Long id) {
        PlayerInactivityPeriodDTO dto = service.getById(id);
        return ResponseEntity.ok(dto);
    }

    // zĂ­skĂˇ zĂˇznamy o periodÄ› neaktivity dle id hrĂˇÄŤe
    @GetMapping("/player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getByPlayer(@PathVariable Long playerId) {
        return service.getByPlayer(playerId);
    }

    // vytvoĹ™Ă­ zĂˇznam o neaktivitÄ› hrĂˇÄŤe
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<PlayerInactivityPeriodDTO> create(@RequestBody PlayerInactivityPeriodDTO dto) {
        PlayerInactivityPeriodDTO created = service.create(dto);
        return ResponseEntity.ok(created);
    }

    // zmÄ›nĂ­ zĂˇznam o neaktivitÄ› hrĂˇÄŤe dle id
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<PlayerInactivityPeriodDTO> update(
            @PathVariable Long id,
            @RequestBody PlayerInactivityPeriodDTO dto) {

        PlayerInactivityPeriodDTO updated = service.update(id, dto);
        return ResponseEntity.ok(updated);
    }

    // vymaĹľe zĂˇznam o neaktivitÄ› hrĂˇÄŤe dle id zĂˇznamu
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        service.delete(id);
        return ResponseEntity.noContent().build();
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestController.java


package cz.phsoft.hokej.controllers;

import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/test")
@CrossOrigin(origins = "*")
public class TestController {

    @GetMapping
    public String hello() {
        return "Backend je online!";
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestSmsController.java


/*
package cz.phsoft.hokej.controllers;


import cz.phsoft.hokej.models.services.sms.SmsTextBeeService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TestSmsController {

    private final SmsTextBeeService smsTextBeeService;

    public TestSmsController(SmsTextBeeService smsTextBeeService) {
        this.smsTextBeeService = smsTextBeeService;
    }

    /**
     * TestovacĂ­ endpoint pro odeslĂˇnĂ­ SMS na testovacĂ­ ÄŤĂ­slo.
     * Zavolej: GET /api/test-sms
     */
/*
    @GetMapping("/api/test-sms")
    public String sendTestSms() {
        smsTextBeeService.sendSms("+420776609956", "testovacĂ­ sms app-sg");
        return "SMS byla odeslĂˇna na testovacĂ­ ÄŤĂ­slo +420776609956";
    }
}

        */


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\AppUserEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.Role;
import jakarta.persistence.*;

import java.util.Set;

@Entity
@Table(name = "app_users")
public class AppUserEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role;

    // One-to-Many: jeden uĹľivatel â†’ vĂ­ce hrĂˇÄŤĹŻ
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<PlayerEntity> players;

    // gettery/settery


    public Long getId() {return id;    }
    public void setId(Long id) {        this.id = id;    }

    public String getEmail() {        return email;    }
    public void setEmail(String email) {        this.email = email;    }

    public String getPassword() {        return password;    }
    public void setPassword(String password) {        this.password = password;    }

    public Role getRole() {        return role;    }
    public void setRole(Role role) {        this.role = role;    }

    public Set<PlayerEntity> getPlayers() {        return players;    }
    public void setPlayers(Set<PlayerEntity> players) {        this.players = players;    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchEntity.java


package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;
import java.time.LocalDateTime;

/**
 * tĹ™Ă­da pro vklĂˇdĂˇnĂ­ Entity zĂˇpasu do db
 */
@Entity
@Table(name = "matches")
public class MatchEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private LocalDateTime dateTime;

    @Column(nullable = false)
    private String location;

    private String description;

    // maximĂˇlnĂ­ poÄŤet hrĂˇÄŤĹŻ - vyuĹľĂ­vĂˇ se pro ovÄ›Ĺ™enĂ­ kapacity pĹ™i pĹ™ihlĂˇĹˇenĂ­
    @Column(nullable = false)
    private Integer maxPlayers;

    @Column(nullable = false)
    private Integer price;

    public MatchEntity() {}

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }

    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() { return price; }

    public void setPrice(Integer price) { this.price = price; }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * tĹ™Ă­da reprezentuje registracei hrĂˇÄŤe k zĂˇpasu
 */
@Entity
@Table(name = "match_registrations")
public class MatchRegistrationEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "match_id", nullable = false)
    private MatchEntity match;

    @ManyToOne
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerMatchStatus status;

    @Enumerated(EnumType.STRING)
    private ExcuseReason excuseReason;

    private String excuseNote;

    // admin mĹŻĹľe vloĹľit poznĂˇmku, napĹ™. kdyĹľ se nÄ›kdo zaregistruje a potĂ© nepĹ™Ă­jde
    private String adminNote;

    @Enumerated(EnumType.STRING)
    @Column(name = "jersey_color")
    private Team jerseyColor;

    // datÄŤas vytvoĹ™enĂ­ registrace - musĂ­ se mÄ›nit aby nebyl hrĂˇÄŤ i po zruĹˇenĂ­ registrace
    // v poĹ™adĂ­ pĹ™ed hrĂˇÄŤi kteĹ™Ă­ se registrovali po zruĹˇenĂ­ registrace
    @Column(nullable = false, updatable = true)
    private LocalDateTime timestamp = LocalDateTime.now();

    // systĂ©m automaticky vytvĂˇĹ™Ă­ reserved/registered dle kapacity - maxPlayers
    @Column(nullable = false, updatable = true)
    private String createdBy; // "user" nebo "system"

    public MatchRegistrationEntity() {
    }

    // Gettery a Settery


    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public MatchEntity getMatch() {
        return match;
    }

    public void setMatch(MatchEntity match) {
        this.match = match;
    }

    public PlayerEntity getPlayer() {
        return player;
    }

    public void setPlayer(PlayerEntity player) {
        this.player = player;
    }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }

    public ExcuseReason getExcuseReason() {
        return excuseReason;
    }

    public void setExcuseReason(ExcuseReason excuseReason) {
        this.excuseReason = excuseReason;
    }

    public String getExcuseNote() {
        return excuseNote;
    }

    public void setExcuseNote(String excuseNote) {
        this.excuseNote = excuseNote;
    }

    public String getAdminNote() {
        return adminNote;
    }

    public void setAdminNote(String adminNote) {
        this.adminNote = adminNote;
    }

    public Team getJerseyColor() {
        return jerseyColor;
    }

    public void setJerseyColor(Team jerseyColor) {
        this.jerseyColor = jerseyColor;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }
}





# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationHistoryEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.persistence.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "match_registration_history")
public class MatchRegistrationHistoryEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // ID z pĹŻvodnĂ­ hlavnĂ­ tabulky
    @Column(name = "match_registration_id", nullable = false)
    private Long matchRegistrationId;

    @Column(name = "match_id", nullable = false)
    private Long matchId;

    @Column(name = "player_id", nullable = false)
    private Long playerId;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerMatchStatus status;

    @Enumerated(EnumType.STRING)
    @Column(name = "excuse_reason")
    private ExcuseReason excuseReason;

    @Column(name = "excuse_note")
    private String excuseNote;

    @Column(name = "admin_note")
    private String adminNote;

    @Enumerated(EnumType.STRING)
    @Column(name = "jersey_color")
    private Team jerseyColor;

    // pĹŻvodnĂ­ timestamp
    @Column(name = "original_timestamp", nullable = false)
    private LocalDateTime originalTimestamp;

    @Column(name = "created_by", nullable = false)
    private String createdBy;

    @Column(nullable = false)
    private String action; // INSERT / UPDATE / DELETE

    @Column(name = "changed_at", nullable = false)
    private LocalDateTime changedAt;

    public MatchRegistrationHistoryEntity() {
    }

    // Gettery a settery


    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getMatchRegistrationId() {
        return matchRegistrationId;
    }

    public void setMatchRegistrationId(Long matchRegistrationId) {
        this.matchRegistrationId = matchRegistrationId;
    }

    public Long getMatchId() {
        return matchId;
    }

    public void setMatchId(Long matchId) {
        this.matchId = matchId;
    }

    public Long getPlayerId() {
        return playerId;
    }

    public void setPlayerId(Long playerId) {
        this.playerId = playerId;
    }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }

    public ExcuseReason getExcuseReason() {
        return excuseReason;
    }

    public void setExcuseReason(ExcuseReason excuseReason) {
        this.excuseReason = excuseReason;
    }

    public String getExcuseNote() {
        return excuseNote;
    }

    public void setExcuseNote(String excuseNote) {
        this.excuseNote = excuseNote;
    }

    public String getAdminNote() {
        return adminNote;
    }

    public void setAdminNote(String adminNote) {
        this.adminNote = adminNote;
    }

    public Team getJerseyColor() {
        return jerseyColor;
    }

    public void setJerseyColor(Team jerseyColor) {
        this.jerseyColor = jerseyColor;
    }

    public LocalDateTime getOriginalTimestamp() {
        return originalTimestamp;
    }

    public void setOriginalTimestamp(LocalDateTime originalTimestamp) {
        this.originalTimestamp = originalTimestamp;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }

    public String getAction() {
        return action;
    }

    public void setAction(String action) {
        this.action = action;
    }

    public LocalDateTime getChangedAt() {
        return changedAt;
    }

    public void setChangedAt(LocalDateTime changedAt) {
        this.changedAt = changedAt;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerType;
import jakarta.persistence.*;

@Entity
@Table(name = "player_entity")
public class PlayerEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String surname;

    private String nickName;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerType type; // VIP, STANDARD, BASIC

    private String fullName;
    private String phoneNumber;

    @Enumerated(EnumType.STRING)
    private Team team;

    // Many-to-One: kaĹľdĂ˝ hrĂˇÄŤ patĹ™Ă­ jednomu uĹľivateli
    @ManyToOne
    @JoinColumn(name = "user_id")
    private AppUserEntity user;

    // ----------------- Konstruktor -----------------
    public PlayerEntity() {
        this.type = PlayerType.BASIC;
    }

    public PlayerEntity(String name, String surname, String nickName, PlayerType type, String phoneNumber, Team team) {
        this.name = name;
        this.surname = surname;
        this.nickName = nickName;
        this.type = type;
        this.fullName = name + " " + surname;
        this.phoneNumber = phoneNumber;
        this.team = team;
    }

    // ----------------- Gettery a Settery -----------------
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
        updateFullName();
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
        updateFullName();
    }

    public String getNickname() { return nickName;}
    public void setNickname(String nickName) { this.nickName = nickName; }

    public String getFullName() {
        return fullName;
    }

    public PlayerType getType() {
        return type;
    }
    public void setType(PlayerType type) {
        this.type = type;
    }

    private void updateFullName() {
        this.fullName = name + " " + surname;
    }

    public String getPhoneNumber() {
        return phoneNumber;
    }
    public void setPhoneNumber(String phoneNumber) {
        this.phoneNumber = phoneNumber;
    }

    public Team getTeam() {
        return team;
    }
    public void setTeam(Team team) {
        this.team = team;
    }

    public AppUserEntity getUser() {
        return user;
    }
    public void setUser(AppUserEntity user) {
        this.user = user;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerInactivityPeriodEntity.java


package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "player_inactivity_period")
public class PlayerInactivityPeriodEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    // neaktivnĂ­ od
    @Column(name = "inactive_from", nullable = false)
    private LocalDateTime inactiveFrom;

    // neaktivnĂ­ do
    @Column(name = "inactive_to", nullable = false)
    private LocalDateTime inactiveTo;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public PlayerEntity getPlayer() {
        return player;
    }

    public void setPlayer(PlayerEntity player) {
        this.player = player;
    }

    public LocalDateTime getInactiveFrom() {
        return inactiveFrom;
    }

    public void setInactiveFrom(LocalDateTime inactiveFrom) {
        this.inactiveFrom = inactiveFrom;
    }

    public LocalDateTime getInactiveTo() {
        return inactiveTo;
    }

    public void setInactiveTo(LocalDateTime inactiveTo) {
        this.inactiveTo = inactiveTo;
    }

}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\ExcuseReason.java


package cz.phsoft.hokej.data.enums;

public enum ExcuseReason {
    NEMOC,
    PRACE,
    NECHE_SE_MI,
    JINE
}



# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\PlayerMatchStatus.java


package cz.phsoft.hokej.data.enums;

public enum PlayerMatchStatus {
    REGISTERED,
    UNREGISTERED,
    EXCUSED,  // omluven
    RESERVED, // nĂˇhradnĂ­k

}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\PlayerType.java


package cz.phsoft.hokej.data.enums;

public enum PlayerType {
    VIP,
    STANDARD,
    BASIC
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\Role.java


package cz.phsoft.hokej.data.enums;

public enum Role {
    ROLE_PLAYER,
    ROLE_MANAGER,
    ROLE_ADMIN
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\Team.java


package cz.phsoft.hokej.data.enums;

public enum Team {
    DARK,
    LIGHT

}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\AppUserRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface AppUserRepository extends JpaRepository<AppUserEntity, Long> {
    Optional<AppUserEntity> findByEmail(String email);
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRegistrationHistoryRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchRegistrationHistoryEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface MatchRegistrationHistoryRepository extends JpaRepository<MatchRegistrationHistoryEntity, Long> {

    // vĹˇechny registrace na zĂˇpas
    List<MatchRegistrationHistoryEntity> findByMatchRegistrationIdOrderByChangedAtDesc(Long matchRegistrationId);

    // Historie pro konkrĂ©tnĂ­ zĂˇpas
    List<MatchRegistrationHistoryEntity> findByMatchIdOrderByChangedAtDesc(Long matchId);

    // Historie zmÄ›n hrĂˇÄŤe
    List<MatchRegistrationHistoryEntity> findByPlayerIdOrderByChangedAtDesc(Long playerId);

}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRegistrationRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

    @Repository
    public interface MatchRegistrationRepository extends JpaRepository<MatchRegistrationEntity, Long> {

        // VrĂˇtĂ­ poslednĂ­ status pro danĂ©ho hrĂˇÄŤe a zĂˇpas
        Boolean existsByPlayerIdAndMatchId(Long playerId, Long matchId);

        // VolitelnÄ›: vĹˇechny registrace pro urÄŤitĂ˝ zĂˇpas
        List<MatchRegistrationEntity> findByMatchId(Long matchId);

        // VolitelnÄ›: vĹˇechny registrace pro urÄŤitĂ©ho hrĂˇÄŤe
        List<MatchRegistrationEntity> findByPlayerId(Long playerId);

        // --- NovĂˇ metoda pro hledĂˇnĂ­ konkrĂ©tnĂ­ registrace ---
        Optional<MatchRegistrationEntity> findByPlayerIdAndMatchId(Long playerId, Long matchId);

        long countByMatchIdAndStatus(Long matchId, PlayerMatchStatus status);
    }


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import java.time.LocalDateTime;
import java.util.List;

public interface MatchRepository extends JpaRepository<MatchEntity, Long> {
    List<MatchEntity> findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime dateTime);
    List<MatchEntity> findByDateTimeBeforeOrderByDateTimeDesc(LocalDateTime dateTime);
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\PlayerInactivityPeriodRepository.java



package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface PlayerInactivityPeriodRepository extends JpaRepository<PlayerInactivityPeriodEntity, Long> {

    // zjistĂ­, zda hrĂˇÄŤ je aktuĂˇlnÄ› neaktivnĂ­
    boolean existsByPlayerAndInactiveFromLessThanEqualAndInactiveToGreaterThanEqual(
            PlayerEntity player, LocalDateTime from, LocalDateTime to);

    // zĂ­skĂˇ vĹˇechny neaktivnĂ­ obdobĂ­ hrĂˇÄŤe, kterĂ© spadajĂ­ do intervalu
    List<PlayerInactivityPeriodEntity> findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
            PlayerEntity player, LocalDateTime from, LocalDateTime to);

    List<PlayerInactivityPeriodEntity> findByPlayerOrderByInactiveFromAsc(PlayerEntity player);
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\PlayerRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface PlayerRepository extends JpaRepository<PlayerEntity, Long> {
    Optional<PlayerEntity> findById(Long id);

    List<PlayerEntity> findByIdNotIn(List<Long> ids);
    boolean existsByNameAndSurname(String name, String surname);

    Optional<PlayerEntity> findByNameAndSurname(String name, String surname);
    Optional<PlayerEntity> findByUserEmail(String email);

}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\ApiError.java


package cz.phsoft.hokej.exceptions;

import com.fasterxml.jackson.annotation.JsonFormat;
import java.time.LocalDateTime;

public class ApiError {

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime timestamp;
    private int status;
    private String error;
    private String message;
    private String path;
    private String clientIp; // â† novÄ›

    public ApiError(int status, String error, String message, String path, String clientIp) {
        this.timestamp = LocalDateTime.now();
        this.status = status;
        this.error = error;
        this.message = message;
        this.path = path;
        this.clientIp = clientIp;
    }

    public LocalDateTime getTimestamp() { return timestamp; }
    public int getStatus() { return status; }
    public String getError() { return error; }
    public String getMessage() { return message; }
    public String getPath() { return path; }
    public String getClientIp() { return clientIp; }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\DuplicateRegistrationException.java


package cz.phsoft.hokej.exceptions;

public class DuplicateRegistrationException extends RuntimeException {
    public DuplicateRegistrationException(Long matchId, Long playerId) {
        super("HrĂˇÄŤ " + playerId + " jiĹľ mĂˇ aktivnĂ­ registraci na zĂˇpas " + matchId);
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\MatchNotFoundException.java


package cz.phsoft.hokej.exceptions;

public class MatchNotFoundException extends RuntimeException {
    public MatchNotFoundException(Long matchId) {
        super("ZĂˇpas s ID " + matchId + " nenalezen.");;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\PlayerNotFoundException.java


package cz.phsoft.hokej.exceptions;

public class PlayerNotFoundException extends RuntimeException {
    public PlayerNotFoundException(Long playerId) {
        super("HrĂˇÄŤ s ID " + playerId + " nenalezen.");}
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\RegistrationNotFoundException.java


package cz.phsoft.hokej.exceptions;

public class RegistrationNotFoundException extends RuntimeException {
    public RegistrationNotFoundException(Long matchId, Long playerId) {
        super("HrĂˇÄŤ " + playerId + " nemĂˇ registraci na zĂˇpas " + matchId);
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\AppUserMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.PlayerSummaryDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

import java.util.List;

@Mapper(componentModel = "spring")
public interface AppUserMapper {
    @Mapping(target = "players", source = "players")
    AppUserDTO toDto(AppUserEntity entity);

    List<AppUserDTO> toDtoList(List<AppUserEntity> entities);

    PlayerSummaryDTO toPlayerSummary(PlayerEntity entity);
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\MatchMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;

@Mapper(componentModel = "spring")
public interface MatchMapper {

    MatchDTO toDTO(MatchEntity entity);

    MatchEntity toEntity(MatchDTO dto);

    void updateEntity(MatchDTO dto, @MappingTarget MatchEntity entity);
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\MatchRegistrationMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

import java.util.List;

@Mapper(componentModel = "spring")
public interface MatchRegistrationMapper {

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "match", source = "match")
    @Mapping(target = "player", source = "player")
    @Mapping(target = "status", source = "status")
    @Mapping(target = "excuseReason", source = "excuseReason")
    @Mapping(target = "excuseNote", source = "note")
    @Mapping(target = "jerseyColor", source = "jerseyColor")
    @Mapping(target = "adminNote", source = "adminNote")
    @Mapping(target = "createdBy", source = "createdBy")
    @Mapping(target = "timestamp", expression = "java(java.time.LocalDateTime.now())")
    MatchRegistrationEntity toEntity(
            MatchEntity match,
            PlayerEntity player,
            PlayerMatchStatus status,
            ExcuseReason excuseReason,
            String note,
            Team jerseyColor,
            String adminNote,
            String createdBy
    );

    // entity â†’ DTO (volitelnĂ©)
    @Mapping(target = "matchId", source = "match.id")
    @Mapping(target = "playerId", source = "player.id")
    MatchRegistrationDTO toDTO(MatchRegistrationEntity entity);

    List<MatchRegistrationDTO> toDTOList(List<MatchRegistrationEntity> entities);
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\PlayerInactivityPeriodMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import org.mapstruct.*;

@Mapper(componentModel = "spring")
public interface PlayerInactivityPeriodMapper {

    // Entity -> DTO (OK)
    @Mapping(target = "playerId", source = "player.id")
    PlayerInactivityPeriodDTO toDTO(PlayerInactivityPeriodEntity entity);

    // DTO -> Entity (player Ĺ™eĹˇĂ­ @ObjectFactory)
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "player", ignore = true)
    PlayerInactivityPeriodEntity toEntity(PlayerInactivityPeriodDTO dto, @Context PlayerEntity player);

    // UPDATE DTO -> existujĂ­cĂ­ entity (bez zmÄ›ny player)
    @Mapping(target = "player", ignore = true)
    void updateEntityFromDto(PlayerInactivityPeriodDTO dto, @MappingTarget PlayerInactivityPeriodEntity entity);

    // FACTORY â€“ jedinĂ˝ sprĂˇvnĂ˝ zpĹŻsob, jak nastavit player z @Context
    @ObjectFactory
    default PlayerInactivityPeriodEntity createEntity(PlayerInactivityPeriodDTO dto, @Context PlayerEntity player) {
        PlayerInactivityPeriodEntity entity = new PlayerInactivityPeriodEntity();
        entity.setPlayer(player);
        return entity;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\PlayerMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

import java.util.List;

@Mapper(componentModel = "spring")
public interface PlayerMapper {

        // Entity â†’ DTO (heslo se neposĂ­lĂˇ)
        @Mapping(target = "fullName", ignore = true) // generuje se v DTO
        PlayerDTO toDTO(PlayerEntity entity);

        // DTO â†’ Entity (heslo se mapuje, pokud existuje)
        PlayerEntity toEntity(PlayerDTO dto);

        // Aktualizace existujĂ­cĂ­ho DTO (ignorujeme fullName)
        @Mapping(target = "fullName", ignore = true)
        void updatePlayerDTO(PlayerDTO source, @MappingTarget PlayerDTO target);

        // Aktualizace existujĂ­cĂ­ Entity (heslo se mapuje, fullName nenĂ­ pole v Entity)
        void updatePlayerEntity(PlayerDTO source, @MappingTarget PlayerEntity target);

    List<PlayerDTO> toDTOList(List<PlayerEntity> players);


}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\requests\MatchRegistrationRequest.java


package cz.phsoft.hokej.models.dto.requests;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.validation.constraints.*;


public class MatchRegistrationRequest {
    @NotNull
    @Positive
    private Long matchId;

    @NotNull
    @Positive
    private Long playerId;

    private Team jerseyColor;
    private ExcuseReason excuseReason;
    private String excuseNote;
    private String adminNote;
    private boolean unregister;

    public Long getMatchId() { return matchId; }
    public Long getPlayerId() { return playerId; }
    public Team getJerseyColor() { return jerseyColor; }
    public ExcuseReason getExcuseReason() { return excuseReason; }
    public String getExcuseNote() { return excuseNote; }
    public String getAdminNote() { return adminNote; }
    public boolean isUnregister() { return unregister; }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\AppUserDTO.java


package cz.phsoft.hokej.models.dto;

import java.util.Set;

public class AppUserDTO {
    private Long id;
    private String email;
    private String role;
    private Set<PlayerSummaryDTO> players; // jednostrannĂ©

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getRole() {
        return role;
    }

    public void setRole(String role) {
        this.role = role;
    }

    public Set<PlayerSummaryDTO> getPlayers() {
        return players;
    }

    public void setPlayers(Set<PlayerSummaryDTO> players) {
        this.players = players;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchDetailDTO.java


package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;

import java.time.LocalDateTime;
import java.util.List;

public class MatchDetailDTO {
    private Long id;
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime dateTime;
    private int maxPlayers;
    private int inGamePlayers;
    private int outGamePlayers;
    private int waitingPlayers;
    private int noActionPlayers;
    private double pricePerRegisteredPlayer;
    private int remainingSlots;

    List<PlayerDTO> registeredPlayers;
    List<PlayerDTO> reservedPlayers;
    List<PlayerDTO> unregisteredPlayers;
    List<PlayerDTO> excusedPlayers;
    List<PlayerDTO> noResponsePlayers;

    // Gettery a settery

    public Long getId() {       return id;    }
    public void setId(Long id) {
        this.id = id;
    }
    public LocalDateTime getDateTime() {
        return dateTime;
    }

    public void setDateTime(LocalDateTime dateTime) {
        this.dateTime = dateTime;
    }

    public int getMaxPlayers() {
        return maxPlayers;
    }
    public void setMaxPlayers(int maxPlayers) {
        this.maxPlayers = maxPlayers;
    }

    public int getInGamePlayers() {
        return inGamePlayers;
    }
    public void setInGamePlayers(int inGamePlayers) {
        this.inGamePlayers = inGamePlayers;
    }

    public void setOutGamePlayers(int outGamePlayers) {
        this.outGamePlayers = outGamePlayers;
    }

    public int getWaitingPlayers() {
        return waitingPlayers;
    }
    public void setWaitingPlayers(int waitingPlayers) {
        this.waitingPlayers = waitingPlayers;
    }

    public int getNoActionPlayers() {
        return noActionPlayers;
    }
    public void setNoActionPlayers(int noActionPlayers) {
        this.noActionPlayers = noActionPlayers;
    }

    public double getPricePerRegisteredPlayer() {
        return pricePerRegisteredPlayer;
    }
    public void setPricePerRegisteredPlayer(double pricePerRegisteredPlayer) {
        this.pricePerRegisteredPlayer = pricePerRegisteredPlayer;
    }

    public int getRemainingSlots() {
        return remainingSlots;
    }
    public void setRemainingSlots(int remainingSlots) {
        this.remainingSlots = remainingSlots;
    }

    public List<PlayerDTO> getRegisteredPlayers() {
        return registeredPlayers;
    }
    public void setRegisteredPlayers(List<PlayerDTO> registeredPlayers) {
        this.registeredPlayers = registeredPlayers;
    }

    public List<PlayerDTO> getReservedPlayers() {
        return reservedPlayers;
    }
    public void setReservedPlayers(List<PlayerDTO> reservedPlayers) {
        this.reservedPlayers = reservedPlayers;
    }

    public List<PlayerDTO> getUnregisteredPlayers() {
        return unregisteredPlayers;
    }

    public void setUnregisteredPlayers(List<PlayerDTO> unregisteredPlayers) {
        this.unregisteredPlayers = unregisteredPlayers;
    }
    public List<PlayerDTO> getExcusedPlayers() {
        return excusedPlayers;
    }
    public void setExcusedPlayers(List<PlayerDTO> excusedPlayers) {
        this.excusedPlayers = excusedPlayers;
    }

    public List<PlayerDTO> getNoResponsePlayers() {
        return noResponsePlayers;
    }
    public void setNoResponsePlayers(List<PlayerDTO> noResponsePlayers) {
        this.noResponsePlayers = noResponsePlayers;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchDTO.java


package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import jakarta.validation.constraints.FutureOrPresent;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

import java.time.LocalDateTime;

public class MatchDTO {

    private Long id;
    @NotNull(message = "Datum a ÄŤas zĂˇpasu je povinnĂ©.")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime dateTime;

    @NotBlank(message = "MĂ­sto zĂˇpasu je povinnĂ©.")
    @Size(min = 3, max = 100)
    private String location;

    @Size(max = 255, message = "Popis mĹŻĹľe mĂ­t max 255 znakĹŻ.")
    private String description;

    @NotNull(message = "MaximĂˇlnĂ­ poÄŤet hrĂˇÄŤĹŻ je povinnĂ˝")
    private Integer maxPlayers;

    @NotNull(message = "Cena je povinnĂˇ")
    private Integer price;

    // gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }
    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() {
        return price;
    }

    public void setPrice(Integer price) {
        this.price = price;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchOverviewDTO.java


package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import java.time.LocalDateTime;

public class MatchOverviewDTO {

    private Long id;

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime dateTime;

    private String location;
    private String description;
    private Integer price;
    private int maxPlayers;
    private int inGamePlayers;
    private double pricePerRegisteredPlayer;

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getPrice() { return price; }
    public void setPrice(Integer price) { this.price = price; }

    public int getMaxPlayers() { return maxPlayers; }
    public void setMaxPlayers(int maxPlayers) { this.maxPlayers = maxPlayers; }

    public int getInGamePlayers() { return inGamePlayers; }
    public void setInGamePlayers(int inGamePlayers) { this.inGamePlayers = inGamePlayers; }

    public double getPricePerRegisteredPlayer() { return pricePerRegisteredPlayer; }
    public void setPricePerRegisteredPlayer(double pricePerRegisteredPlayer) { this.pricePerRegisteredPlayer = pricePerRegisteredPlayer; }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchRegistrationDTO.java


package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;

public class MatchRegistrationDTO {
    private Long id; // volitelnĂ©, pĹ™i GET

    @NotNull(message = "ID zĂˇpasu je povinnĂ©.")
    @Positive(message = "ID zĂˇpasu musĂ­ bĂ˝t kladnĂ©.")
    private Long matchId;

    @NotNull(message = "ID hrĂˇÄŤe je povinnĂ©.")
    @Positive(message = "ID hrĂˇÄŤe musĂ­ bĂ˝t kladnĂ©.")
    private Long playerId;

    private PlayerMatchStatus status;
    private ExcuseReason excuseReason; // pouze pokud status = EXCUSED
    private String excuseNote;
    private String adminNote;
    private Team jerseyColor;

    @NotNull
    private String createdBy; // "user" nebo "system"

    private PlayerDTO playerDTO;

    public MatchRegistrationDTO() {}

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public Long getMatchId() { return matchId; }
    public void setMatchId(Long matchId) { this.matchId = matchId; }

    public Long getPlayerId() { return playerId; }
    public void setPlayerId(Long playerId) { this.playerId = playerId; }

    public PlayerMatchStatus getStatus() { return status; }
    public void setStatus(PlayerMatchStatus status) { this.status = status; }

    public ExcuseReason getExcuseReason() { return excuseReason; }
    public void setExcuseReason(ExcuseReason excuseReason) { this.excuseReason = excuseReason; }

    public String getExcuseNote() { return excuseNote; }
    public void setExcuseNote(String excuseNote) { this.excuseNote = excuseNote; }

    public String getAdminNote() { return adminNote; }
    public void setAdminNote(String adminNote) { this.adminNote = adminNote; }

    public Team getJerseyColor() { return jerseyColor; }
    public void setJerseyColor(Team jerseyColor) { this.jerseyColor = jerseyColor; }

    public String getCreatedBy() { return createdBy; }
    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }
}



# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerDTO.java


package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerType;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class PlayerDTO {


    private Long id; // autogenerated, nullable pĹ™i create

    @NotBlank(message = "KĹ™estnĂ­ jmĂ©no je povinnĂ©.")
    @Size(min = 2, max = 50)
    private String name; // not null

    @NotBlank(message = "PĹ™Ă­jmenĂ­ je povinnĂ©.")
    @Size(min = 2, max = 50)
    private String surname; // not null
    private String nickName;
    private String fullName; // derived
    private String phoneNumber;
    private PlayerType type; // not null, default BASIC
    private Team team;


    public PlayerDTO() {
        this.type = PlayerType.BASIC;
   }

    public PlayerDTO(Long id, String name, String surname, String nickName, PlayerType type, Team team) {
        this.id = id;
        this.name = name;
        this.surname = surname;
        this.nickName = nickName;
        this.type = type != null ? type : PlayerType.BASIC;
        this.updateFullName();
        this.team = team;
    }

    // --- Gettery a Settery ---

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; updateFullName(); }

    public String getSurname() { return surname; }
    public void setSurname(String surname) { this.surname = surname; updateFullName(); }

    public String getNickName() { return nickName; }

    public void setNickName(String nickName) { this.nickName = nickName; }

    public String getFullName() { return fullName; }

    public PlayerType getType() { return type; }
    public void setType(PlayerType type) { this.type = type != null ? type : PlayerType.BASIC; }

    private void updateFullName() { this.fullName = name + " " + surname; }

    public Team getTeam() { return team; }
    public void setTeam(Team team) { this.team = team; }

    public String getPhoneNumber() { return phoneNumber; }
    public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerInactivityPeriodDTO.java


package cz.phsoft.hokej.models.dto;

import java.time.LocalDateTime;

public class PlayerInactivityPeriodDTO {

    private Long id;
    private Long playerId;
    private LocalDateTime inactiveFrom;
    private LocalDateTime inactiveTo;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getPlayerId() {
        return playerId;
    }

    public void setPlayerId(Long playerId) {
        this.playerId = playerId;
    }

    public LocalDateTime getInactiveFrom() {
        return inactiveFrom;
    }

    public void setInactiveFrom(LocalDateTime inactiveFrom) {
        this.inactiveFrom = inactiveFrom;
    }

    public LocalDateTime getInactiveTo() {
        return inactiveTo;
    }

    public void setInactiveTo(LocalDateTime inactiveTo) {
        this.inactiveTo = inactiveTo;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerSummaryDTO.java


package cz.phsoft.hokej.models.dto;

public class PlayerSummaryDTO {
    private Long id;
    private String name;
    private String jerseyColor;
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\SuccessResponseDTO.java


package cz.phsoft.hokej.models.dto;

public class SuccessResponseDTO {
    private  String message;
    private Long id;
    private String timestamp;

    public SuccessResponseDTO(String message, Long id, String timestamp) {
        this.message = message;
        this.id = id;
        this.timestamp = timestamp;
    }

    public String getMessage() { return message; }
    public Long getId() { return id; }
    public String getTimestamp() { return timestamp; }

}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsMessageBuilder.java


package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import org.springframework.stereotype.Component;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;

import java.time.format.DateTimeFormatter;

@Component
public class SmsMessageBuilder {

    private final MatchRegistrationRepository matchRegistrationRepository;
    private final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");

    public SmsMessageBuilder(MatchRegistrationRepository matchRegistrationRepository) {
        this.matchRegistrationRepository = matchRegistrationRepository;
    }

    // --------------------------
    // zprĂˇva po registraci/odhlĂˇĹˇenĂ­/omluvenĂ­
    // --------------------------
    public String buildMessageRegistration(MatchRegistrationEntity registration) {
        PlayerMatchStatus status = registration.getStatus();
        String statusText = switch (status) {
            case REGISTERED -> "pĹ™ihlĂˇsil se k zĂˇpasu";
            case UNREGISTERED -> "odhlĂˇsil se ze zĂˇpasu";
            case EXCUSED -> "omluven";
            default -> "neznĂˇmĂ˝ stav";
        };

        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(registration.getMatch().getId(), PlayerMatchStatus.REGISTERED);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - datum: ")
                .append(registration.getMatch().getDateTime().toLocalDate());

        if (status != PlayerMatchStatus.EXCUSED) {
            sb.append(", ").append(registeredCount)
                    .append("/").append(registration.getMatch().getMaxPlayers());
        }

        sb.append(", hrĂˇÄŤ: ").append(registration.getPlayer().getFullName())
                .append(", status: ").append(statusText);

        return sb.toString();
    }

    // --------------------------
    // zprĂˇva pro hrĂˇÄŤe, kteĹ™Ă­ jeĹˇtÄ› nereagovali
    // --------------------------
    public String buildMessageNoResponse(PlayerDTO player, MatchEntity match) {
        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - upozornÄ›nĂ­: zĂˇpas ")
                .append(match.getDateTime().format(dateFormatter))
                .append(" - volnĂˇ mĂ­sta: ")
                .append(match.getMaxPlayers() - registeredCount)
                .append(". JeĹˇtÄ› jste nereagoval.");

        return sb.toString();
    }

    // --------------------------
    // finĂˇlnĂ­ pĹ™ipomĂ­nka pro pĹ™ihlĂˇĹˇenĂ© hrĂˇÄŤe v den zĂˇpasu
    // --------------------------
    public String buildMessageFinal(MatchRegistrationEntity registration) {
        MatchEntity match = registration.getMatch();
        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);

        double pricePerPlayer = match.getPrice() / Math.max(registeredCount, 1);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - pĹ™ipomĂ­nka zĂˇpasu ")
                .append(match.getDateTime().format(dateFormatter))
                .append(", pĹ™ihlĂˇĹˇeno: ").append(registeredCount).append("/").append(match.getMaxPlayers())
                .append(", cena na hrĂˇÄŤe: ").append(String.format("%.2f KÄŤ", pricePerPlayer));

        return sb.toString();
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsSchedulerService.java


package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import jakarta.transaction.Transactional;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.List;

@Service
public class SmsSchedulerService {

    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository registrationRepository;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;
    private final MatchRegistrationService matchRegistrationService;

    public SmsSchedulerService(
            MatchRepository matchRepository,
            MatchRegistrationRepository registrationRepository,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder,
            MatchRegistrationService matchRegistrationService) {

        this.matchRepository = matchRepository;
        this.registrationRepository = registrationRepository;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
        this.matchRegistrationService = matchRegistrationService;
    }

    // PoslĂˇnĂ­ SMS v den zĂˇpasu
    // SpustĂ­ se kaĹľdĂ˝ den v 12:30
    @Scheduled(cron = "0 30 12 * * *")
    @Transactional
    public void sendFinalSmsForTodayMatches() {

        LocalDate today = LocalDate.now();

        // najdeme vĹˇechny dneĹˇnĂ­ zĂˇpasy
        List<MatchEntity> todaysMatches = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().toLocalDate().isEqual(today))
                .toList();

        for (MatchEntity match : todaysMatches) {

            // naÄŤteme vĹˇechny registrace k danĂ©mu zĂˇpasu (BEZ zmÄ›n entit)
            List<MatchRegistrationEntity> registrations =
                    registrationRepository.findByMatchId(match.getId());

            for (MatchRegistrationEntity reg : registrations) {

                // pouĹľijeĹˇ svĹŻj pĹŻvodnĂ­ builder
                String smsMsg = smsMessageBuilder.buildMessageFinal(reg);

                try {
                    smsService.sendSms(reg.getPlayer().getPhoneNumber(), smsMsg);
                    System.out.println("FinĂˇlnĂ­ SMS poslĂˇna hrĂˇÄŤi "
                            + reg.getPlayer().getFullName() + ": " + smsMsg);

                } catch (Exception e) {
                    System.err.println("Chyba SMS pro hrĂˇÄŤe "
                            + reg.getPlayer().getFullName() + ": " + e.getMessage());
                }
            }
        }
    }

    // poslĂˇnĂ­ SMS 3 dny pĹ™ed zĂˇpasem - noresponse player
    @Scheduled(cron = "0 40 14 * * *") // kaĹľdĂ˝ den ve 12:30
    @Transactional
    public void sendNoResponseSmsForMatchesIn3Days() {

        LocalDate targetDate = LocalDate.now().plusDays(3);

        // vĹˇechny zĂˇpasy, kterĂ© jsou za 3 dny
        List<MatchEntity> matchesInThreeDays = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().toLocalDate().isEqual(targetDate))
                .toList();

        for (MatchEntity match : matchesInThreeDays) {

            // pouĹľijeme tvĹŻj existujĂ­cĂ­ helper
            List<PlayerDTO> noResponsePlayers =
                    matchRegistrationService.getNoResponsePlayers(match.getId());

            for (PlayerDTO player : noResponsePlayers) {

                String smsMsg = smsMessageBuilder.buildMessageNoResponse(player, match);

                try {
                    smsService.sendSms(player.getPhoneNumber(), smsMsg);
                    System.out.println("NORESPONSE SMS poslĂˇna hrĂˇÄŤi "
                            + player.getFullName() + ": " + smsMsg);
                } catch (Exception e) {
                    System.err.println("Chyba NORESPONSE SMS pro hrĂˇÄŤe "
                            + player.getFullName() + ": " + e.getMessage());
                }
            }
        }
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsService.java


package cz.phsoft.hokej.models.services.sms;

public interface SmsService {
    void sendSms(String phoneNumber, String message);
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsServiceImpl.java


/* package cz.phsoft.hokej.models.services.sms;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;

@Service
public class SmsServiceImpl {

   // private final RestTemplate restTemplate = new RestTemplate();

    @Value("${textbee.api-url}")
    private String apiUrl;

    @Value("${textbee.api-key}")
    private String apiKey;

    // testovacĂ­ ÄŤĂ­slo
    //private final String testNumber = "+420776609956";

    /**
     * OdeĹˇle SMS na testovacĂ­ ÄŤĂ­slo.
     * @param message text zprĂˇvy
     */

/*
    public void sendSms(String phoneNumber, String message) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("x-api-key", apiKey);

        Map<String, Object> body = Map.of(
                "recipients", List.of(phoneNumber),
                "message", message
        );

        HttpEntity<Map<String,Object>> request = new HttpEntity<>(body, headers);

        try {
            ResponseEntity<String> response = restTemplate.postForEntity(apiUrl, request, String.class);
            System.out.println("SMS poslĂˇna na testovacĂ­ ÄŤĂ­slo  xxx   : " + response.getBody());
        } catch (Exception e) {
            System.err.println("Chyba pĹ™i odesĂ­lĂˇnĂ­ SMS: " + e.getMessage());
        }
    }

*/


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsTextBeeService.java


package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.models.services.sms.SmsService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;

// textbee - free s omezenĂ­m na 50 sms / den
@Service
public class SmsTextBeeService implements SmsService {

    @Value("${sms.enabled:true}")
    private boolean smsEnabled;

    @Value("${textbee.api-url}")
    private String apiUrl;

    @Value("${textbee.api-key}")
    private String apiKey;

    private final RestTemplate restTemplate = new RestTemplate();

    @Override
    public void sendSms(String phoneNumber, String message) {
        if (!smsEnabled) {
            System.out.println("SMS disabled, message not sent: " + message);
            return;
        }

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("x-api-key", apiKey);

        Map<String, Object> body = Map.of(
                "recipients", List.of(phoneNumber),
                "message", message
        );

        HttpEntity<Map<String,Object>> request = new HttpEntity<>(body, headers);

        try {
            ResponseEntity<String> response = restTemplate.postForEntity(apiUrl, request, String.class);
            System.out.println("SMS odeslĂˇna hrĂˇÄŤi: " + phoneNumber + ", response: " + response.getBody());
        } catch (Exception e) {
            System.err.println("Chyba pĹ™i odesĂ­lĂˇnĂ­ SMS: " + e.getMessage());
        }
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;

import java.util.List;

public interface MatchRegistrationService {

    // đź”Ą VracĂ­ DTO mĂ­sto entity
    MatchRegistrationDTO upsertRegistration(
            Long matchId,
            Long playerId,
            Team jerseyColor,
            String adminNote,
            ExcuseReason excuseReason,
            String excuseNote,
            boolean unregister
    );

    List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId);

    List<MatchRegistrationDTO> getAllRegistrations();

    List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId);

    List<PlayerDTO> getNoResponsePlayers(Long matchId);

    void recalcStatusesForMatch(Long matchId);
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.DuplicateRegistrationException;
import cz.phsoft.hokej.exceptions.MatchNotFoundException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.exceptions.RegistrationNotFoundException;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.mappers.MatchRegistrationMapper;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.sms.SmsMessageBuilder;
import cz.phsoft.hokej.models.services.sms.SmsService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
public class MatchRegistrationServiceImpl implements MatchRegistrationService {

    Logger logger = LoggerFactory.getLogger(MatchServiceImpl.class);
    private final MatchRegistrationRepository registrationRepository;
    private final MatchRepository matchRepository;
    private final PlayerRepository playerRepository;
    private final MatchRegistrationMapper matchRegistrationMapper;
    private final PlayerMapper playerMapper;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;

    public MatchRegistrationServiceImpl(
            MatchRegistrationRepository registrationRepository,
            MatchRepository matchRepository,
            PlayerRepository playerRepository,
            MatchRegistrationMapper matchRegistrationMapper,
            PlayerMapper playerMapper,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder) {
        this.registrationRepository = registrationRepository;
        this.matchRepository = matchRepository;
        this.playerRepository = playerRepository;
        this.matchRegistrationMapper = matchRegistrationMapper;
        this.playerMapper = playerMapper;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
    }
    private MatchEntity getMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }
    private PlayerEntity getPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }
    private boolean isSlotAvailable(MatchEntity match) {
        long registeredCount = registrationRepository.countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);
        return registeredCount < match.getMaxPlayers();
    }
    private void sendSms(MatchRegistrationEntity registration, String message) {
        if (registration == null || registration.getPlayer() == null) return;
        try {
            smsService.sendSms(registration.getPlayer().getPhoneNumber(), message);
        } catch (Exception e) {
            System.err.println("Chyba SMS: " + e.getMessage());
        }
    }
    private MatchRegistrationEntity updateRegistrationStatus(
            MatchRegistrationEntity registration, PlayerMatchStatus status, String updatedBy, boolean updateTimestamp) {

        registration.setStatus(PlayerMatchStatus.valueOf(status.name()));
        registration.setCreatedBy(updatedBy);
        if (updateTimestamp) {
            registration.setTimestamp(LocalDateTime.now());
        }
        return registrationRepository.saveAndFlush(registration);
    }
    // -------------------- REGISTRATION --------------------
    @Transactional
    @Override
    public MatchRegistrationDTO upsertRegistration(
            Long matchId,
            Long playerId,
            Team jerseyColor,
            String adminNote,
            ExcuseReason excuseReason,
            String excuseNote,
            boolean unregister) {

        // TEST: poĹˇli ERROR zprĂˇvu pro otestovĂˇnĂ­ emailu
        logger.error("Test ERROR zprĂˇva pro email");

        MatchEntity match = getMatchOrThrow(matchId);
        PlayerEntity player = getPlayerOrThrow(playerId);

        MatchRegistrationEntity registration = registrationRepository
                .findByPlayerIdAndMatchId(playerId, matchId)
                .orElse(null);

        PlayerMatchStatus newStatus;

        // UNREGISTER: lze pouze kdyĹľ hrĂˇÄŤ mĂˇ aktuĂˇlnÄ› REGISTERED
        if (unregister) {
            if (registration == null || registration.getStatus() != PlayerMatchStatus.REGISTERED) {
                throw new RegistrationNotFoundException(matchId, playerId);
            }
            registration.setExcuseReason(null);
            newStatus = PlayerMatchStatus.UNREGISTERED;

            // EXCUSE: lze vytvoĹ™it pouze pokud hrĂˇÄŤ NEMĂ status REGISTERED
        } else if (excuseReason != null) {
            if (registration != null && registration.getStatus() == PlayerMatchStatus.REGISTERED) {
                throw new DuplicateRegistrationException(matchId, playerId);
            }
            // pokud neexistuje, vytvoĹ™Ă­me pozici; pokud existuje a nenĂ­ REGISTERED, povolĂ­me EXCUSED
            if (registration == null) {
                registration = new MatchRegistrationEntity();
                registration.setMatch(match);
                registration.setPlayer(player);
            }
            registration.setExcuseReason(excuseReason);
            newStatus = PlayerMatchStatus.EXCUSED;

            // REGISTER / RESERVE: lze vytvoĹ™it pokud hrĂˇÄŤ NEMĂ status REGISTERED (tedy i kdyĹľ mĂˇ EXCUSED)
        } else {
            // pokud uĹľ je registrovĂˇn, nepovolĂ­me duplicitu
            if (registration != null && registration.getStatus() == PlayerMatchStatus.REGISTERED) {
                throw new DuplicateRegistrationException(matchId, playerId);
            }

            newStatus = isSlotAvailable(match) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;

            if (registration == null) {
                registration = new MatchRegistrationEntity();
                registration.setMatch(match);
                registration.setPlayer(player);
            } else {
                // pĹ™i pĹ™echodu na register/reserve zruĹˇĂ­me pĹ™Ă­padnou vĂ˝mluvu
                registration.setExcuseReason(null);
            }
        }

        registration.setStatus(newStatus);
        registration.setTimestamp(LocalDateTime.now());
        registration.setCreatedBy("user");

        if (jerseyColor != null) registration.setJerseyColor(jerseyColor);
        if (adminNote != null) registration.setAdminNote(adminNote);
        // excuseReason uĹľ jsme nastavili vĂ˝Ĺˇe (pokud to byl EXCUSED pĹ™Ă­pad)
        if (excuseReason != null) registration.setExcuseReason(excuseReason);

        registration = registrationRepository.save(registration);

        if (unregister) recalcStatusesForMatch(matchId);

        sendSms(registration, smsMessageBuilder.buildMessageRegistration(registration));

        return matchRegistrationMapper.toDTO(registration);
    }
    // -------------------- FETCH --------------------
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId) {
        return matchRegistrationMapper.toDTOList(registrationRepository.findByMatchId(matchId));
    }

    @Override
    public List<MatchRegistrationDTO> getAllRegistrations() {
        return matchRegistrationMapper.toDTOList(registrationRepository.findAll());
    }

    @Override
    public List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId) {
        return matchRegistrationMapper.toDTOList(registrationRepository.findByPlayerId(playerId));
    }

    @Override
    public List<PlayerDTO> getNoResponsePlayers(Long matchId) {
        List<Long> responded = registrationRepository.findByMatchId(matchId).stream()
                .map(r -> r.getPlayer().getId())
                .toList();

        List<PlayerEntity> noResponsePlayers = playerRepository.findAll().stream()
                .filter(p -> !responded.contains(p.getId()))
                .toList();

        return noResponsePlayers.stream()
                .map(playerMapper::toDTO)
                .toList();
    }
    // -------------------- RECALC --------------------
    @Override
    @Transactional
    public void recalcStatusesForMatch(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);
        int maxPlayers = match.getMaxPlayers();

        List<MatchRegistrationEntity> regs = registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED
                        || r.getStatus() == PlayerMatchStatus.RESERVED)
                .sorted((a, b) -> a.getTimestamp().compareTo(b.getTimestamp()))
                .toList();

        for (int i = 0; i < regs.size(); i++) {
            MatchRegistrationEntity reg = regs.get(i);
            PlayerMatchStatus newStatus = (i < maxPlayers) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;
            if (reg.getStatus() != newStatus) updateRegistrationStatus(reg, newStatus, "system", false);
        }
    }

    // -------------------- SMS --------------------
    @Transactional
    public void sendSmsToRegisteredPlayers(Long matchId) {
        registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .forEach(r -> sendSms(r, smsMessageBuilder.buildMessageFinal(r)));
    }

    public void sendNoResponseSmsForMatch(Long matchId) {
        var match = getMatchOrThrow(matchId);

        getNoResponsePlayers(matchId).forEach(player -> {
            String smsMsg = smsMessageBuilder.buildMessageNoResponse(player, match);

            try {
                smsService.sendSms(player.getPhoneNumber(), smsMsg);
            } catch (Exception e) {
                System.err.println("Chyba SMS pro hrĂˇÄŤe "
                        + player.getFullName() + ": " + e.getMessage());
                logger.error("Chyba pĹ™i odeslĂˇnĂ­ SMS hrĂˇÄŤi {}: {}", player.getFullName(), e.getMessage());
            }
        });
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;
import cz.phsoft.hokej.models.dto.MatchOverviewDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;

import java.util.List;

public interface MatchService {
    List<MatchDTO> getAllMatches();
    List<MatchDTO> getUpcomingMatches();
    List<MatchDTO> getPastMatches();
    MatchDTO getNextMatch();
    MatchDTO getMatchById(Long id);
    MatchDTO createMatch(MatchDTO dto);
    MatchDTO updateMatch(Long id, MatchDTO dto);
    SuccessResponseDTO deleteMatch(Long id);
    MatchDetailDTO getMatchDetail(Long id);
    List<MatchDTO> getAvailableMatchesForPlayer(Long playerId);
    List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId);
    Long getPlayerIdByEmail(String email);
    List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId);


}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.MatchNotFoundException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.models.dto.*;
import cz.phsoft.hokej.models.dto.mappers.MatchMapper;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class MatchServiceImpl implements MatchService {

    private final MatchRepository matchRepository;
    private final MatchMapper matchMapper;
    private final MatchRegistrationService registrationService;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodService playerInactivityPeriodService;
    private final PlayerMapper playerMapper;
    private static final String ROLE_ADMIN = "ROLE_ADMIN";
    private static final String ROLE_MANAGER = "ROLE_MANAGER";

    public MatchServiceImpl(MatchRepository matchRepository,
                            MatchMapper matchMapper,
                            MatchRegistrationService registrationService,
                            PlayerRepository playerRepository,
                            PlayerInactivityPeriodService playerInactivityPeriodService,
                            PlayerMapper playerMapper) {
        this.matchRepository = matchRepository;
        this.matchMapper = matchMapper;
        this.registrationService = registrationService;
        this.playerRepository = playerRepository;
        this.playerInactivityPeriodService = playerInactivityPeriodService;
        this.playerMapper = playerMapper;
    }
    // metoda pro zĂ­skĂˇnĂ­ vĹˇech zĂˇpasĹŻ
    @Override
    public List<MatchDTO> getAllMatches() {
        return matchRepository.findAll().stream()
                .map(matchMapper::toDTO)
                .toList();
    }
    // metoda pro zĂ­skĂˇnĂ­ vĹˇech nadchĂˇzejĂ­cĂ­ch zĂˇpasĹŻ
    @Override
    public List<MatchDTO> getUpcomingMatches() {
        return matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now())
                .stream()
                .map(matchMapper::toDTO)
                .toList();
    }
    // metoda pro zĂ­skĂˇnĂ­ uplynulĂ˝ch zĂˇpasĹŻ
    public List<MatchDTO> getPastMatches() {
        return matchRepository.findByDateTimeBeforeOrderByDateTimeDesc(LocalDateTime.now())
                .stream()
                .map(matchMapper::toDTO)
                .toList();
    }
    // metoda pro zĂ­skĂˇnĂ­ prvnĂ­ho nadchĂˇzejĂ­cĂ­ho zĂˇpasu
    @Override
    public MatchDTO getNextMatch() {
        return matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now())
                .stream()
                .findFirst()
                .map(matchMapper::toDTO)
                .orElse(null);
    }
    // metoda pro zĂˇpas dle ID
    @Override
    public MatchDTO getMatchById(Long id) {
        return matchMapper.toDTO(findMatchOrThrow(id));
    }

    // metoda pro vytvoĹ™enĂ­ zĂˇpasu
    @Override
    public MatchDTO createMatch(MatchDTO dto) {
        MatchEntity entity = matchMapper.toEntity(dto);
        return matchMapper.toDTO(matchRepository.save(entity));
    }

    // metoda pro Ăşpravu zĂˇpasu
    @Override
    public MatchDTO updateMatch(Long id, MatchDTO dto) {
        MatchEntity match = findMatchOrThrow(id);

        int oldMaxPlayers = match.getMaxPlayers();
        matchMapper.updateEntity(dto, match);
        MatchEntity saved = matchRepository.save(match);

        // PĹ™epoÄŤet registracĂ­ pokud doĹˇlo ke zmÄ›nÄ› maxPlayers
        if (saved.getMaxPlayers() != oldMaxPlayers) {
            registrationService.recalcStatusesForMatch(saved.getId());
        }

        return matchMapper.toDTO(saved);
    }

    // metoda pro odstranÄ›nĂ­ zĂˇpasu
    @Override
    public SuccessResponseDTO deleteMatch(Long id) {
        MatchEntity match = findMatchOrThrow(id);

        // 2) Pokud existuje, smaĹľeme ho
        matchRepository.delete(match);

        return new SuccessResponseDTO(
                "ZĂˇpas " + match.getId() + match.getDateTime() + " byl ĂşspÄ›ĹˇnÄ› smazĂˇn",
                id,
                LocalDateTime.now().toString()
        );
    }

    // metoda pro detail zĂˇpasu - omezen vĂ˝pis pro ADMIN, MANAGER, PLAYER
    @Override
    public MatchDetailDTO getMatchDetail(Long id) {
        MatchEntity match = findMatchOrThrow(id);
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();

        boolean isAdminOrManager = auth != null && auth.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals(ROLE_ADMIN) || a.getAuthority().equals(ROLE_MANAGER));

        // oddÄ›lena logika pĹ™Ă­stupu hrĂˇÄŤe do privĂˇtnĂ­ metody
        checkAccessForPlayer(match, auth);

        // sbÄ›r statistik hrĂˇÄŤĹŻ pĹ™es privĂˇtnĂ­ metodu
        return collectPlayerStatus(match, isAdminOrManager);
    }

    // privĂˇtnĂ­ metoda pro kontrolu pĹ™Ă­stupu hrĂˇÄŤe - jen pokud byl registrovĂˇn na zĂˇpas
    private void checkAccessForPlayer(MatchEntity match, Authentication auth) {
        if (auth == null || !auth.isAuthenticated()) return;

        boolean isAdminOrManager = auth.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals(ROLE_ADMIN) || a.getAuthority().equals(ROLE_MANAGER));

        if (isAdminOrManager) return;

        Object principal = auth.getPrincipal();
        if (!(principal instanceof org.springframework.security.core.userdetails.UserDetails userDetails)) return;

        List<PlayerEntity> ownedPlayers = playerRepository.findAll().stream()
                .filter(p -> p.getUser() != null && p.getUser().getEmail().equals(userDetails.getUsername()))
                .toList();

        boolean hasRestrictedPlayer = ownedPlayers.stream()
                .anyMatch(p -> {
                    List<MatchRegistrationDTO> registrations = registrationService.getRegistrationsForMatch(match.getId());

                    boolean noResponse = registrations.stream()
                            .noneMatch(r -> r.getPlayerId().equals(p.getId()));

                    boolean inactiveForMatch = !playerInactivityPeriodService.isActive(p, match.getDateTime());

                    return noResponse || inactiveForMatch;
                });

        if (hasRestrictedPlayer) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "NemĂˇte pĹ™Ă­stup k detailu tohoto zĂˇpasu."
            );
        }
    }

    // privĂˇtnĂ­ metoda pro sbÄ›r statistik hrĂˇÄŤĹŻ
    private MatchDetailDTO collectPlayerStatus(MatchEntity match, boolean isAdminOrManager) {
        List<MatchRegistrationDTO> registrations = registrationService.getRegistrationsForMatch(match.getId());

        // PĹ™evod vĹˇech registracĂ­ na Map<PlayerMatchStatus, List<PlayerDTO>>
        var statusToPlayersMap = registrations.stream()
                .map(r -> playerRepository.findById(r.getPlayerId())
                        .map(playerMapper::toDTO)
                        .map(dto -> new java.util.AbstractMap.SimpleEntry<>(r.getStatus(), dto))
                )
                .filter(java.util.Optional::isPresent) // odstranĂ­me chybÄ›jĂ­cĂ­ hrĂˇÄŤe
                .map(java.util.Optional::get)
                .collect(Collectors.groupingBy(
                        java.util.Map.Entry::getKey,
                        Collectors.mapping(java.util.Map.Entry::getValue, Collectors.toList())
                ));

        List<PlayerEntity> allPlayers = playerRepository.findAll();
        Set<Long> respondedIds = registrations.stream()
                .map(MatchRegistrationDTO::getPlayerId)
                .collect(Collectors.toSet());

        List<PlayerDTO> noResponsePlayers = allPlayers.stream()
                .filter(p -> !respondedIds.contains(p.getId()))
                .map(playerMapper::toDTO)
                .toList();

        // PoÄŤty hrĂˇÄŤĹŻ podle statusu
        int inGamePlayers = statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()).size();
        int outGamePlayers = statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()).size()
                + statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()).size();
        int waitingPlayers = statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()).size();
        int noActionPlayers = noResponsePlayers.size();
        int remainingSlots = match.getMaxPlayers() - inGamePlayers;
        double pricePerRegistered = inGamePlayers > 0 ? match.getPrice() / (double) inGamePlayers : 0;

        MatchDetailDTO dto = new MatchDetailDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setMaxPlayers(match.getMaxPlayers());
        dto.setInGamePlayers(inGamePlayers);
        dto.setOutGamePlayers(outGamePlayers);
        dto.setWaitingPlayers(waitingPlayers);
        dto.setNoActionPlayers(noActionPlayers);
        dto.setPricePerRegisteredPlayer(pricePerRegistered);
        dto.setRemainingSlots(remainingSlots);

        // NastavenĂ­ hrĂˇÄŤĹŻ podle statusu z mapy
        dto.setRegisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()));
        dto.setReservedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()));
        dto.setUnregisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()));
        dto.setExcusedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()));

        // pouze admin/manager uvidĂ­ no-response hrĂˇÄŤe
        dto.setNoResponsePlayers(isAdminOrManager ? noResponsePlayers : null);

        return dto;
    }


    // dostupnĂ© zĂˇpasy pro hrĂˇÄŤe - byl nebo je aktivnĂ­
    @Override
    public List<MatchDTO> getAvailableMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        // Filtrace pĹ™es stream bez mezivĂ˝sledkĹŻ
        return matchRepository.findAll().stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .map(matchMapper::toDTO)
                .toList();
    }

    // zĂ­skĂˇnĂ­ hrĂˇÄŤe dle emailu
    public Long getPlayerIdByEmail(String email) {
        return playerRepository.findByUserEmail(email)
                .map(PlayerEntity::getId)
                .orElseThrow(() -> new RuntimeException("HrĂˇÄŤ s emailem " + email + " nenalezen"));
    }

    // nĂˇhled nadchĂˇzejĂ­cĂ­ch zĂˇpasu pro hrĂˇÄŤe - dle PlayerType
    @Override
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        // 1) NejbliĹľĹˇĂ­ nadchĂˇzejĂ­cĂ­ zĂˇpasy podle data
        List<MatchEntity> upcomingAll = matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now());

        // 2) OmezenĂ­ podle typu hrĂˇÄŤe
        List<MatchEntity> limited = switch (type) {
            case VIP -> upcomingAll;
            case STANDARD -> upcomingAll.stream().limit(2).toList();
            case BASIC -> upcomingAll.isEmpty() ? List.of() : List.of(upcomingAll.get(0));
        };

        // 3) FiltrovĂˇnĂ­ podle aktivity hrĂˇÄŤe a mapovĂˇnĂ­ na MatchOverviewDTO
        return limited.stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .map(this::toOverviewDTO)   // mapujeme pĹ™Ă­mo ve sluĹľbÄ›
                .toList();
    }
    // nadchĂˇzejĂ­cĂ­ zĂˇpasy pro hrĂˇÄŤe
    @Override
    public List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        // 1) NejbliĹľĹˇĂ­ nadchĂˇzejĂ­cĂ­ zĂˇpasy podle data
        List<MatchEntity> upcomingAll = matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now());

        List<MatchEntity> limited = switch (type) {
            case VIP -> upcomingAll;
            case STANDARD -> upcomingAll.stream().limit(2).toList();
            case BASIC -> upcomingAll.isEmpty() ? List.of() : List.of(upcomingAll.get(0));
        };

        // 2) FiltrovĂˇnĂ­ podle aktivity hrĂˇÄŤe
        return limited.stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .map(matchMapper::toDTO)
                .toList();
    }

    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    private MatchEntity findMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }

    private MatchOverviewDTO toOverviewDTO(MatchEntity match) {
        MatchOverviewDTO dto = new MatchOverviewDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setLocation(match.getLocation());
        dto.setDescription(match.getDescription());
        dto.setPrice(match.getPrice());
        dto.setMaxPlayers(match.getMaxPlayers());

        // poÄŤet registrovanĂ˝ch hrĂˇÄŤĹŻ
        int inGamePlayers = registrationService.getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .mapToInt(r -> 1)
                .sum();
        dto.setInGamePlayers(inGamePlayers);

        // cena na registrovanĂ©ho hrĂˇÄŤe
        double pricePerPlayer = inGamePlayers > 0 && match.getPrice() != null
                ? match.getPrice() / (double) inGamePlayers : 0;
        dto.setPricePerRegisteredPlayer(pricePerPlayer);

        return dto;
    }


}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;

import java.time.LocalDateTime;
import java.util.List;

public interface PlayerInactivityPeriodService {

    List<PlayerInactivityPeriodDTO> getAll();

    PlayerInactivityPeriodDTO getById(Long id);

    List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId);

    PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto);

    PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto);

    void delete(Long id);

    public boolean isActive(PlayerEntity player, LocalDateTime dateTime);
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.data.repositories.PlayerInactivityPeriodRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.dto.mappers.PlayerInactivityPeriodMapper;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import java.util.List;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

@Service
public class PlayerInactivityPeriodServiceImpl implements PlayerInactivityPeriodService {

    private final PlayerInactivityPeriodRepository inactivityRepository;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodMapper mapper;

    public PlayerInactivityPeriodServiceImpl(PlayerInactivityPeriodRepository inactivityRepository,
                                             PlayerRepository playerRepository,
                                             PlayerInactivityPeriodMapper mapper) {
        this.inactivityRepository = inactivityRepository;
        this.playerRepository = playerRepository;
        this.mapper = mapper;
    }

    @Override
    public List<PlayerInactivityPeriodDTO> getAll() {
        return inactivityRepository.findAll().stream()
                .map(mapper::toDTO)
                .toList();
    }

    @Override
    public PlayerInactivityPeriodDTO getById(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException(
                        "ObdobĂ­ neaktivity s ID " + id + " neexistuje."
                ));
        return mapper.toDTO(entity);
    }

    @Override
    public List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId) {
        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new RuntimeException("Player not found"));

        return inactivityRepository.findByPlayerOrderByInactiveFromAsc(player)
                .stream()
                .map(mapper::toDTO)
                .toList();
    }

    // --- TRANSACTIONAL pro zĂˇpis dat ---
    @Override
    @Transactional
    public PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto) {
        PlayerEntity player = playerRepository.findById(dto.getPlayerId())
                .orElseThrow(() -> new IllegalArgumentException("HrĂˇÄŤ s ID " + dto.getPlayerId() + " neexistuje."));

        validateDates(dto);

        // kontrola pĹ™ekryvu existujĂ­cĂ­ch obdobĂ­
        boolean overlaps = !inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        player, dto.getInactiveFrom(), dto.getInactiveTo()
                ).isEmpty();

        if (overlaps) {
            throw new IllegalStateException("NovĂ© obdobĂ­ se pĹ™ekrĂ˝vĂˇ s existujĂ­cĂ­m obdobĂ­m neaktivity hrĂˇÄŤe.");
        }

        PlayerInactivityPeriodEntity entity = mapper.toEntity(dto, player);
        return mapper.toDTO(inactivityRepository.save(entity));
    }

    @Override
    @Transactional
    public PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("ObdobĂ­ neaktivity s ID " + id + " neexistuje."));

        validateDates(dto);

        // kontrola pĹ™ekryvu, ignoruje aktuĂˇlnĂ­ zĂˇznam
        boolean overlaps = inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        entity.getPlayer(), dto.getInactiveFrom(), dto.getInactiveTo()
                ).stream()
                .anyMatch(p -> !p.getId().equals(id));

        if (overlaps) {
            throw new IllegalStateException("UpravenĂ© obdobĂ­ se pĹ™ekrĂ˝vĂˇ s jinĂ˝m obdobĂ­m neaktivity hrĂˇÄŤe.");
        }

        mapper.updateEntityFromDto(dto, entity);
        return mapper.toDTO(inactivityRepository.save(entity));
    }

    @Override
    @Transactional
    public void delete(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("ObdobĂ­ neaktivity s ID " + id + " neexistuje."));
        inactivityRepository.delete(entity);
    }

    // --- true = aktivnĂ­, false = neaktivnĂ­ ---
    public boolean isActive(PlayerEntity player, LocalDateTime dateTime) {
        return !inactivityRepository.existsByPlayerAndInactiveFromLessThanEqualAndInactiveToGreaterThanEqual(
                player, dateTime, dateTime);
    }

    // --- privĂˇtnĂ­ metoda pro validaci dat ---
    private void validateDates(PlayerInactivityPeriodDTO dto) {
        if (dto.getInactiveFrom() == null || dto.getInactiveTo() == null) {
            throw new IllegalArgumentException("Datum od a do nesmĂ­ bĂ˝t null.");
        }
        if (!dto.getInactiveFrom().isBefore(dto.getInactiveTo())) {
            throw new IllegalArgumentException("inactiveFrom musĂ­ bĂ˝t pĹ™ed inactiveTo.");
        }
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;

import java.util.List;


public interface PlayerService {
    List<PlayerDTO> getAllPlayers();
    PlayerDTO getPlayerById(Long id);
    PlayerDTO createPlayer(PlayerDTO player);
    PlayerDTO updatePlayer(Long id, PlayerDTO player);
    SuccessResponseDTO deletePlayer(Long id);
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;
import cz.phsoft.hokej.models.dto.PlayerDTO;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
public class PlayerServiceImpl implements PlayerService {

    private final PlayerRepository playerRepository;
    private final PlayerMapper playerMapper;

    public PlayerServiceImpl(PlayerRepository playerRepository, PlayerMapper playerMapper) {
        this.playerRepository = playerRepository;
        this.playerMapper = playerMapper;
    }

    @Override
    public List<PlayerDTO> getAllPlayers() {
        return playerRepository.findAll().stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    @Override
    public PlayerDTO getPlayerById(Long id) {
        PlayerEntity player = playerRepository.findById(id)
                .orElseThrow(() -> new PlayerNotFoundException(id)); // mĂ­sto RuntimeException
        return playerMapper.toDTO(player);
    }

    // --- TRANSACTIONAL pro zĂˇpis dat ---
    @Override
    @Transactional
    public PlayerDTO createPlayer(PlayerDTO dto) {
        checkDuplicateNameSurname(dto.getName(), dto.getSurname(), null);

        PlayerEntity entity = playerMapper.toEntity(dto);
        PlayerEntity saved = playerRepository.save(entity);
        return playerMapper.toDTO(saved);
    }

    @Override
    @Transactional
    public PlayerDTO updatePlayer(Long id, PlayerDTO dto) {
        PlayerEntity existing = findPlayerOrThrow(id);

        // pokud se jmĂ©no/pĹ™Ă­jmenĂ­ mÄ›nĂ­, ovÄ›Ĺ™ duplicitu
        if (!existing.getName().equals(dto.getName()) || !existing.getSurname().equals(dto.getSurname())) {
            checkDuplicateNameSurname(dto.getName(), dto.getSurname(), id);
        }

        existing.setName(dto.getName());
        existing.setSurname(dto.getSurname());
        existing.setType(dto.getType());
        existing.setTeam(dto.getTeam());

        PlayerEntity saved = playerRepository.save(existing);
        return playerMapper.toDTO(saved);
    }

    @Override
    @Transactional
    public SuccessResponseDTO deletePlayer(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);
        playerRepository.delete(player);

        return new SuccessResponseDTO(
                "HrĂˇÄŤ " + player.getFullName() + " byl ĂşspÄ›ĹˇnÄ› smazĂˇn",
                id,
                LocalDateTime.now().toString()
        );
    }

    // --- privĂˇtnĂ­ metoda pro kontrolu duplicity jmĂ©na a pĹ™Ă­jmenĂ­ ---
    private void checkDuplicateNameSurname(String name, String surname, Long ignoreId) {
        Optional<PlayerEntity> duplicateOpt = playerRepository.findByNameAndSurname(name, surname);

        if (duplicateOpt.isPresent()) {
            if (ignoreId == null || !duplicateOpt.get().getId().equals(ignoreId)) {
                throw new RuntimeException("HrĂˇÄŤ se jmĂ©nem " + name + " " + surname + " jiĹľ existuje.");
            }
        }
    }

    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\PlayerSecurity.java


package cz.phsoft.hokej.security;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

@Component("playerSecurity") // nĂˇzev pro pouĹľitĂ­ v SpEL (@PreAuthorize)
public class PlayerSecurity {

    private static final Logger logger = LoggerFactory.getLogger(PlayerSecurity.class);

    private final PlayerRepository playerRepository;

    public PlayerSecurity(PlayerRepository playerRepository) {
        this.playerRepository = playerRepository;
    }

    /**
     * ZjistĂ­, zda je aktuĂˇlnÄ› pĹ™ihlĂˇĹˇenĂ˝ uĹľivatel vlastnĂ­kem hrĂˇÄŤe
     *
     * @param authentication aktuĂˇlnĂ­ authentication objekt
     * @param playerId       ID hrĂˇÄŤe
     * @return true pokud je vlastnĂ­kem, jinak false
     */
    public boolean isOwner(Authentication authentication, Long playerId) {
        try {
            if (authentication == null || !authentication.isAuthenticated()) {
                logger.warn("NeautorizovanĂ˝ pĹ™Ă­stup: ĹľĂˇdnĂˇ autentizace pro playerId {}", playerId);
                return false;
            }

            Object principal = authentication.getPrincipal();
            if (!(principal instanceof UserDetails userDetails)) {
                logger.warn("NeautorizovanĂ˝ pĹ™Ă­stup: principal nenĂ­ UserDetails pro playerId {}", playerId);
                return false;
            }

            boolean isOwner = playerRepository.findById(playerId)
                    .map(player -> player.getUser() != null &&
                            player.getUser().getEmail().equals(userDetails.getUsername()))
                    .orElse(false);

            if (!isOwner) {
                logger.warn("NeautorizovanĂ˝ pĹ™Ă­stup: uĹľivatel {} nenĂ­ vlastnĂ­kem hrĂˇÄŤe {}", userDetails.getUsername(), playerId);
            }

            return isOwner;

        } catch (Exception e) {
            logger.error("Chyba pĹ™i kontrole vlastnĂ­ka hrĂˇÄŤe {}: {}", playerId, e.getMessage(), e);
            // nikdy nepropustit vĂ˝jimku do SpEL
            return false;
        }
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\StaraGardaApplication.java


package cz.phsoft.hokej;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableJpaRepositories // JPA v naĹˇem Spring Boot projektu
@EnableScheduling
public class StaraGardaApplication {
    public static void main(String[] args) {
        SpringApplication.run(StaraGardaApplication.class, args);


        }
    }


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\test\java\cz\phsoft\hokej\controllers\MatchControllerTest.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.StaraGardaApplication;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.security.test.context.support.WithAnonymousUser;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest(
        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
        classes = StaraGardaApplication.class
)
@AutoConfigureMockMvc
public class MatchControllerTest {

    @Autowired
    private MockMvc mockMvc;

    // ---------------------------------------------------------
    // GET /api/matches â€“ pouze MANAGER + ADMIN
    // ---------------------------------------------------------

    @Test
    @WithMockUser(roles = {"ADMIN"})
    void getAllMatches_asAdmin_shouldReturn200() throws Exception {
        mockMvc.perform(get("/api/matches"))
                .andExpect(status().isOk());
    }

    @Test
    @WithMockUser(roles = {"MANAGER"})
    void getAllMatches_asManager_shouldReturn200() throws Exception {
        mockMvc.perform(get("/api/matches"))
                .andExpect(status().isOk());
    }

    @Test
    @WithMockUser(roles = {"PLAYER"})
    void getAllMatches_asPlayer_shouldReturn403() throws Exception {
        mockMvc.perform(get("/api/matches"))
                .andExpect(status().isForbidden());
    }

    @Test
    @WithAnonymousUser
    void getAllMatches_unauthenticated_shouldReturn401() throws Exception {
        mockMvc.perform(get("/api/matches"))
                .andExpect(status().isUnauthorized());
    }

    // ---------------------------------------------------------
    // GET /api/matches/next â€“ musĂ­ bĂ˝t pĹ™ihlĂˇĹˇenĂ˝ kdokoliv
    // ---------------------------------------------------------

    @Test
    @WithMockUser
    void getNextMatch_authenticated_shouldReturn200() throws Exception {
        mockMvc.perform(get("/api/matches/next"))
                .andExpect(status().isOk());
    }

    @Test
    @WithAnonymousUser
    void getNextMatch_unauthenticated_shouldReturn401() throws Exception {
        mockMvc.perform(get("/api/matches/next"))
                .andExpect(status().isUnauthorized());
    }

    // ---------------------------------------------------------
    // POST /api/matches â€“ ADMIN
    // ---------------------------------------------------------

    @Test
    @WithMockUser(roles = {"ADMIN"})
    void createMatch_asAdmin_shouldReturn200() throws Exception {

        String json = """
                {
                    "dateTime": "2030-01-01T18:00:00",
                    "location": "Brno",
                    "description": "TestovacĂ­ zĂˇpas",
                    "maxPlayers": 20,
                    "price": 150
                }
                """;

        mockMvc.perform(post("/api/matches")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(json))
                .andExpect(status().isOk());
    }

    @Test
    @WithMockUser(roles = {"MANAGER"})
    void createMatch_asManager_shouldReturn403() throws Exception {

        String json = """
                {
                    "dateTime": "2030-01-01T18:00:00",
                    "location": "Brno",
                    "description": "TestovacĂ­ zĂˇpas",
                    "maxPlayers": 20,
                    "price": 150
                }
                """;

        mockMvc.perform(post("/api/matches")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(json))
                .andExpect(status().isForbidden());
    }

    @Test
    @WithAnonymousUser
    void createMatch_unauthenticated_shouldReturn401() throws Exception {
        mockMvc.perform(post("/api/matches")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{}"))
                .andExpect(status().isUnauthorized());
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\AppUserMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.PlayerSummaryDTO;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-15T14:57:09+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class AppUserMapperImpl implements AppUserMapper {

    @Override
    public AppUserDTO toDto(AppUserEntity entity) {
        if ( entity == null ) {
            return null;
        }

        AppUserDTO appUserDTO = new AppUserDTO();

        appUserDTO.setPlayers( playerEntitySetToPlayerSummaryDTOSet( entity.getPlayers() ) );
        appUserDTO.setId( entity.getId() );
        appUserDTO.setEmail( entity.getEmail() );
        if ( entity.getRole() != null ) {
            appUserDTO.setRole( entity.getRole().name() );
        }

        return appUserDTO;
    }

    @Override
    public List<AppUserDTO> toDtoList(List<AppUserEntity> entities) {
        if ( entities == null ) {
            return null;
        }

        List<AppUserDTO> list = new ArrayList<AppUserDTO>( entities.size() );
        for ( AppUserEntity appUserEntity : entities ) {
            list.add( toDto( appUserEntity ) );
        }

        return list;
    }

    @Override
    public PlayerSummaryDTO toPlayerSummary(PlayerEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerSummaryDTO playerSummaryDTO = new PlayerSummaryDTO();

        return playerSummaryDTO;
    }

    protected Set<PlayerSummaryDTO> playerEntitySetToPlayerSummaryDTOSet(Set<PlayerEntity> set) {
        if ( set == null ) {
            return null;
        }

        Set<PlayerSummaryDTO> set1 = new LinkedHashSet<PlayerSummaryDTO>( Math.max( (int) ( set.size() / .75f ) + 1, 16 ) );
        for ( PlayerEntity playerEntity : set ) {
            set1.add( toPlayerSummary( playerEntity ) );
        }

        return set1;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-15T14:57:10+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchMapperImpl implements MatchMapper {

    @Override
    public MatchDTO toDTO(MatchEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchDTO matchDTO = new MatchDTO();

        matchDTO.setId( entity.getId() );
        matchDTO.setDateTime( entity.getDateTime() );
        matchDTO.setLocation( entity.getLocation() );
        matchDTO.setDescription( entity.getDescription() );
        matchDTO.setMaxPlayers( entity.getMaxPlayers() );
        matchDTO.setPrice( entity.getPrice() );

        return matchDTO;
    }

    @Override
    public MatchEntity toEntity(MatchDTO dto) {
        if ( dto == null ) {
            return null;
        }

        MatchEntity matchEntity = new MatchEntity();

        matchEntity.setId( dto.getId() );
        matchEntity.setDateTime( dto.getDateTime() );
        matchEntity.setLocation( dto.getLocation() );
        matchEntity.setDescription( dto.getDescription() );
        matchEntity.setMaxPlayers( dto.getMaxPlayers() );
        matchEntity.setPrice( dto.getPrice() );

        return matchEntity;
    }

    @Override
    public void updateEntity(MatchDTO dto, MatchEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setDateTime( dto.getDateTime() );
        entity.setLocation( dto.getLocation() );
        entity.setDescription( dto.getDescription() );
        entity.setMaxPlayers( dto.getMaxPlayers() );
        entity.setPrice( dto.getPrice() );
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchRegistrationMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-15T14:57:09+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchRegistrationMapperImpl implements MatchRegistrationMapper {

    @Override
    public MatchRegistrationEntity toEntity(MatchEntity match, PlayerEntity player, PlayerMatchStatus status, ExcuseReason excuseReason, String note, Team jerseyColor, String adminNote, String createdBy) {
        if ( match == null && player == null && status == null && excuseReason == null && note == null && jerseyColor == null && adminNote == null && createdBy == null ) {
            return null;
        }

        MatchRegistrationEntity matchRegistrationEntity = new MatchRegistrationEntity();

        matchRegistrationEntity.setMatch( match );
        matchRegistrationEntity.setPlayer( player );
        matchRegistrationEntity.setStatus( status );
        matchRegistrationEntity.setExcuseReason( excuseReason );
        matchRegistrationEntity.setExcuseNote( note );
        matchRegistrationEntity.setJerseyColor( jerseyColor );
        matchRegistrationEntity.setAdminNote( adminNote );
        matchRegistrationEntity.setCreatedBy( createdBy );
        matchRegistrationEntity.setTimestamp( java.time.LocalDateTime.now() );

        return matchRegistrationEntity;
    }

    @Override
    public MatchRegistrationDTO toDTO(MatchRegistrationEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchRegistrationDTO matchRegistrationDTO = new MatchRegistrationDTO();

        matchRegistrationDTO.setMatchId( entityMatchId( entity ) );
        matchRegistrationDTO.setPlayerId( entityPlayerId( entity ) );
        matchRegistrationDTO.setId( entity.getId() );
        matchRegistrationDTO.setStatus( entity.getStatus() );
        matchRegistrationDTO.setExcuseReason( entity.getExcuseReason() );
        matchRegistrationDTO.setExcuseNote( entity.getExcuseNote() );
        matchRegistrationDTO.setAdminNote( entity.getAdminNote() );
        matchRegistrationDTO.setJerseyColor( entity.getJerseyColor() );
        matchRegistrationDTO.setCreatedBy( entity.getCreatedBy() );

        return matchRegistrationDTO;
    }

    @Override
    public List<MatchRegistrationDTO> toDTOList(List<MatchRegistrationEntity> entities) {
        if ( entities == null ) {
            return null;
        }

        List<MatchRegistrationDTO> list = new ArrayList<MatchRegistrationDTO>( entities.size() );
        for ( MatchRegistrationEntity matchRegistrationEntity : entities ) {
            list.add( toDTO( matchRegistrationEntity ) );
        }

        return list;
    }

    private Long entityMatchId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        MatchEntity match = matchRegistrationEntity.getMatch();
        if ( match == null ) {
            return null;
        }
        Long id = match.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }

    private Long entityPlayerId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        PlayerEntity player = matchRegistrationEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerInactivityPeriodMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-15T14:57:09+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerInactivityPeriodMapperImpl implements PlayerInactivityPeriodMapper {

    @Override
    public PlayerInactivityPeriodDTO toDTO(PlayerInactivityPeriodEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerInactivityPeriodDTO playerInactivityPeriodDTO = new PlayerInactivityPeriodDTO();

        playerInactivityPeriodDTO.setPlayerId( entityPlayerId( entity ) );
        playerInactivityPeriodDTO.setId( entity.getId() );
        playerInactivityPeriodDTO.setInactiveFrom( entity.getInactiveFrom() );
        playerInactivityPeriodDTO.setInactiveTo( entity.getInactiveTo() );

        return playerInactivityPeriodDTO;
    }

    @Override
    public PlayerInactivityPeriodEntity toEntity(PlayerInactivityPeriodDTO dto, PlayerEntity player) {
        if ( dto == null ) {
            return null;
        }

        PlayerInactivityPeriodEntity playerInactivityPeriodEntity = createEntity( dto, player );

        playerInactivityPeriodEntity.setInactiveFrom( dto.getInactiveFrom() );
        playerInactivityPeriodEntity.setInactiveTo( dto.getInactiveTo() );

        return playerInactivityPeriodEntity;
    }

    @Override
    public void updateEntityFromDto(PlayerInactivityPeriodDTO dto, PlayerInactivityPeriodEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setInactiveFrom( dto.getInactiveFrom() );
        entity.setInactiveTo( dto.getInactiveTo() );
    }

    private Long entityPlayerId(PlayerInactivityPeriodEntity playerInactivityPeriodEntity) {
        if ( playerInactivityPeriodEntity == null ) {
            return null;
        }
        PlayerEntity player = playerInactivityPeriodEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-15T14:57:09+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerMapperImpl implements PlayerMapper {

    @Override
    public PlayerDTO toDTO(PlayerEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerDTO playerDTO = new PlayerDTO();

        playerDTO.setId( entity.getId() );
        playerDTO.setName( entity.getName() );
        playerDTO.setSurname( entity.getSurname() );
        playerDTO.setType( entity.getType() );
        playerDTO.setTeam( entity.getTeam() );
        playerDTO.setPhoneNumber( entity.getPhoneNumber() );

        return playerDTO;
    }

    @Override
    public PlayerEntity toEntity(PlayerDTO dto) {
        if ( dto == null ) {
            return null;
        }

        PlayerEntity playerEntity = new PlayerEntity();

        playerEntity.setId( dto.getId() );
        playerEntity.setName( dto.getName() );
        playerEntity.setSurname( dto.getSurname() );
        playerEntity.setType( dto.getType() );
        playerEntity.setPhoneNumber( dto.getPhoneNumber() );
        playerEntity.setTeam( dto.getTeam() );

        return playerEntity;
    }

    @Override
    public void updatePlayerDTO(PlayerDTO source, PlayerDTO target) {
        if ( source == null ) {
            return;
        }

        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setNickName( source.getNickName() );
        target.setType( source.getType() );
        target.setTeam( source.getTeam() );
        target.setPhoneNumber( source.getPhoneNumber() );
    }

    @Override
    public void updatePlayerEntity(PlayerDTO source, PlayerEntity target) {
        if ( source == null ) {
            return;
        }

        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setType( source.getType() );
        target.setPhoneNumber( source.getPhoneNumber() );
        target.setTeam( source.getTeam() );
    }

    @Override
    public List<PlayerDTO> toDTOList(List<PlayerEntity> players) {
        if ( players == null ) {
            return null;
        }

        List<PlayerDTO> list = new ArrayList<PlayerDTO>( players.size() );
        for ( PlayerEntity playerEntity : players ) {
            list.add( toDTO( playerEntity ) );
        }

        return list;
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\AppConfig.java


package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class AppConfig {

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\AuditAspect.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

@Component
@Aspect
public class AuditAspect {

    private static final Logger logger = LoggerFactory.getLogger("AUDIT_LOGGER");

    // Pointcut pro vÄąË‡echny metody ve sluÄąÄľbÄ‚Ë‡ch
    @Pointcut("within(cz.phsoft.hokej.models.services..*)")
    public void serviceMethods() {}

    // SpustÄ‚Â­ se pÄąâ„˘ed metodou
    @Before("serviceMethods()")
    public void logBefore(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().toShortString();
        String args = java.util.Arrays.toString(joinPoint.getArgs());
        logger.info("START {} at {} with args {}", methodName, LocalDateTime.now(), args);
    }

    // SpustÄ‚Â­ se po Ä‚ĹźspĂ„â€şÄąË‡nÄ‚Â©m dokonĂ„Ĺ¤enÄ‚Â­ metody
    @AfterReturning(pointcut = "serviceMethods()", returning = "result")
    public void logAfterReturning(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();

        Long userId = null;
        Long playerId = null;

        for (Object arg : args) {
            if (arg instanceof PlayerEntity player) {
                playerId = player.getId();
            } else if (arg instanceof MatchRegistrationEntity registration) {
                playerId = registration.getPlayer().getId();
            } else if (arg instanceof Long id) {
                // pokud mÄ‚Ë‡ metoda Long parametry, mÄąĹ»ÄąÄľeÄąË‡ urĂ„Ĺ¤it podle poÄąâ„˘adÄ‚Â­
                // tÄąâ„˘eba prvnÄ‚Â­ Long = matchId, druhÄ‚Ëť = playerId
            }
        }

        // logovÄ‚Ë‡nÄ‚Â­
        logger.info("END {} - userId={} playerId={} returned [{}] at {}",
                methodName, userId, playerId, result, LocalDateTime.now());
    }
}



# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\CustomJsonLoginFilter.java


package cz.phsoft.hokej.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.context.HttpSessionSecurityContextRepository;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

// filtr pro REST login
public class CustomJsonLoginFilter extends UsernamePasswordAuthenticationFilter {

    private final ObjectMapper objectMapper = new ObjectMapper();

    public CustomJsonLoginFilter(String loginUrl, AuthenticationManager authManager) {
        setFilterProcessesUrl(loginUrl);
        setAuthenticationManager(authManager);
    }

    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        try {
            // x-www-form-urlencoded i JSON
            String email = null;
            String password = null;

// x-www-form-urlencoded
            if (request.getContentType() != null &&
                    request.getContentType().contains("application/x-www-form-urlencoded")) {
                email = request.getParameter("username");
                password = request.getParameter("password");
            }

// JSON
            if ((email == null || password == null) &&
                    request.getContentType() != null &&
                    request.getContentType().contains("application/json")) {
                Map<String, String> json = objectMapper.readValue(request.getInputStream(), Map.class);
                email = json.get("email");
                password = json.get("password");
            }

            if (email == null || password == null || email.isBlank() || password.isBlank()) {
                throw new BadCredentialsException("ChybÄ‚Â­ pÄąâ„˘ihlaÄąË‡ovacÄ‚Â­ Ä‚Ĺźdaje");
            }

            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(email, password);
            setDetails(request, authRequest);

            return this.getAuthenticationManager().authenticate(authRequest);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    // Ä‚ĹˇspĂ„â€şÄąË‡nÄ‚Ëť login
    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
                                            FilterChain chain, Authentication authResult)
            throws IOException, ServletException {

        // UloÄąÄľenÄ‚Â­ do SecurityContextHolder
        SecurityContextHolder.getContext().setAuthentication(authResult);

        // VytvoÄąâ„˘enÄ‚Â­ session a uloÄąÄľenÄ‚Â­ SPRING_SECURITY_CONTEXT
        request.getSession(true).setAttribute(
                HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY,
                SecurityContextHolder.getContext()
        );

        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");

        Map<String, Object> result = new HashMap<>();
        result.put("status", "ok");
        result.put("user", authResult.getName());

        objectMapper.writeValue(response.getWriter(), result);
    }

    // NeÄ‚ĹźspĂ„â€şÄąË‡nÄ‚Ëť login
    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException {
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");

        Map<String, Object> result = new HashMap<>();
        result.put("status", "error");

        // RozliÄąË‡enÄ‚Â­ neaktivovanÄ‚Â©ho Ä‚ĹźĂ„Ĺ¤tu
        if (failed.getCause() instanceof cz.phsoft.hokej.exceptions.AccountNotActivatedException) {
            result.put("message", failed.getCause().getMessage()); // napÄąâ„˘. "Ä‚ĹˇĂ„Ĺ¤et nenÄ‚Â­ aktivovÄ‚Ë‡n. Zkontrolujte email."
        } else if (failed instanceof BadCredentialsException) {
            result.put("message", "NeplatnÄ‚Â© pÄąâ„˘ihlaÄąË‡ovacÄ‚Â­ Ä‚Ĺźdaje");
        } else {
            result.put("message", "Chyba pÄąâ„˘i pÄąâ„˘ihlÄ‚Ë‡ÄąË‡enÄ‚Â­");
        }

        objectMapper.writeValue(response.getWriter(), result);
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\CustomUserDetailsService.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import cz.phsoft.hokej.exceptions.AccountNotActivatedException;

import java.util.Set;
import java.util.stream.Collectors;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final AppUserRepository appUserRepository;

    public CustomUserDetailsService(AppUserRepository appUserRepository) {
        this.appUserRepository = appUserRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        AppUserEntity user = appUserRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("UÄąÄľivatel nenalezen"));

        if (!user.isEnabled()) { // nebo podle status == PENDING
            throw new AccountNotActivatedException();
        }

        return org.springframework.security.core.userdetails.User.builder()
                .username(user.getEmail())
                .password(user.getPassword())
                .roles(user.getRole().name().replace("ROLE_", "")) // "ADMIN", "PLAYER", ...
                .disabled(!user.isEnabled()) // neaktivnÄ‚Â­ - nelze se pÄąâ„˘Ä‚Â­hlÄ‚Ë‡sit
                .build();
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\DataInitializer.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.*;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import jakarta.annotation.PostConstruct;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Component;
import org.springframework.jdbc.core.JdbcTemplate;


import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Component
public class DataInitializer {

    private final PlayerRepository playerRepository;
    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository matchRegistrationRepository;
    private final AppUserRepository appUserRepository;
    private final JdbcTemplate jdbcTemplate;

    public DataInitializer(PlayerRepository playerRepository,
                           MatchRepository matchRepository,
                           MatchRegistrationRepository matchRegistrationRepository,
                           AppUserRepository appUserRepository,
                           JdbcTemplate jdbcTemplate) {
        this.playerRepository = playerRepository;
        this.matchRepository = matchRepository;
        this.matchRegistrationRepository = matchRegistrationRepository;
        this.appUserRepository = appUserRepository;
        this.jdbcTemplate = jdbcTemplate;
    }

    @PostConstruct
    public void init() {
        // Pokud existuje alespoÄąÂ 1 hrÄ‚Ë‡Ă„Ĺ¤, DB uÄąÄľ byla inicializovanÄ‚Ë‡
        if (playerRepository.count() > 0) {
            System.out.println("Data already initialized Ă˘â‚¬â€ś skipping DataInitializer.");
            return;
        }
        System.out.println("Initializing default data...");

        // --- Seznam hrÄ‚Ë‡Ă„Ĺ¤ÄąĹ» ---
        List<PlayerEntity> players = new ArrayList<>(List.of(
                new PlayerEntity("HrÄ‚Ë‡Ă„Ĺ¤_1", "Jedna", "", PlayerType.VIP, "+420776609956", Team.DARK, PlayerStatus.APPROVED),
                new PlayerEntity("HrÄ‚Ë‡Ă„Ĺ¤_2", "Dva", "", PlayerType.VIP, "+420776609956", Team.LIGHT, PlayerStatus.APPROVED),
                new PlayerEntity("HrÄ‚Ë‡Ă„Ĺ¤_3", "TÄąâ„˘i", "", PlayerType.VIP, "+420776609956", Team.LIGHT, PlayerStatus.APPROVED),
                new PlayerEntity("HrÄ‚Ë‡Ă„Ĺ¤_4", "Ă„ĹštyÄąâ„˘i", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT, PlayerStatus.APPROVED),
                new PlayerEntity("HrÄ‚Ë‡Ă„Ĺ¤_5", "PĂ„â€şt", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT, PlayerStatus.PENDING),
                new PlayerEntity("HrÄ‚Ë‡Ă„Ĺ¤_6", "ÄąÂ est", "", PlayerType.STANDARD, "+420776609956", Team.DARK, PlayerStatus.PENDING),
                new PlayerEntity("HrÄ‚Ë‡Ă„Ĺ¤_7", "Sedm", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT, PlayerStatus.PENDING),
                new PlayerEntity("HrÄ‚Ë‡Ă„Ĺ¤_8", "Osum", "", PlayerType.BASIC, "+420776609956", Team.DARK, PlayerStatus.PENDING),
                new PlayerEntity("HrÄ‚Ë‡Ă„Ĺ¤_9", "DevĂ„â€şt", "", PlayerType.BASIC, "+420776609956", Team.DARK, PlayerStatus.PENDING),
                new PlayerEntity("HrÄ‚Ë‡Ă„Ĺ¤_10", "Deset", "", PlayerType.BASIC, "+420776609956", Team.DARK, PlayerStatus.PENDING)
                // ... pÄąâ„˘Ä‚Â­padnĂ„â€ş dalÄąË‡Ä‚Â­ hrÄ‚Ë‡Ă„Ĺ¤i
        ));

        // --- VytvoÄąâ„˘enÄ‚Â­ uÄąÄľivatelÄąĹ» ke kaÄąÄľdÄ‚Â©mu hrÄ‚Ë‡Ă„Ĺ¤i ---

        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();

        // --- Default admin ---
        if (appUserRepository.findByEmail("admin@example.com").isEmpty()) {
            AppUserEntity admin = new AppUserEntity();
            admin.setName("admin");
            admin.setSurname("admin");
            admin.setEmail("admin@example.com");
            admin.setPassword(encoder.encode("Administrator123"));
            admin.setRole(Role.ROLE_ADMIN);
            admin.setEnabled(true);
            appUserRepository.save(admin);
            System.out.println("Default admin user created.");
        } else {
            System.out.println("Admin user already exists Ă˘â‚¬â€ś skipping.");
        }

        System.out.println("Data initialization completed.");

        int playerCounter = 1;
        for (PlayerEntity player : players) {
            // vytvoÄąâ„˘enÄ‚Â­ uÄąÄľivatele
            String email = "player" + playerCounter + "@example.com";
            String password = "Player123";

            AppUserEntity user = new AppUserEntity();
            user.setName("HrÄ‚Ë‡Ă„Ĺ¤" + playerCounter);
            user.setSurname("Ă„ĹšÄ‚Â­slo_" + playerCounter);
            user.setEmail(email);
            user.setPassword(encoder.encode(password));

            switch (playerCounter){
                case 1:
                    user.setRole(Role.ROLE_ADMIN);
                    System.out.println("Nastavena role: admin");
                    break;
                case 2:
                    user.setRole(Role.ROLE_MANAGER);
                    System.out.println("Nastavena role: manager");
                    break;
                default:
                    user.setRole(Role.ROLE_PLAYER);
                    System.out.println("Nastavena role: player");
            }
            user.setEnabled(true);
            // pÄąâ„˘iÄąâ„˘adit hrÄ‚Ë‡Ă„Ĺ¤e k uÄąÄľivateli
            System.out.println("VytvÄ‚Ë‡Äąâ„˘Ä‚Â­m uÄąÄľivatele Ă„Ĺ¤. " + playerCounter);
            player.setUser(user);

            // uloÄąÄľit uÄąÄľivatele (cascade uloÄąÄľÄ‚Â­ i hrÄ‚Ë‡Ă„Ĺ¤e, pokud je sprÄ‚Ë‡vnĂ„â€ş nastaven)
            appUserRepository.save(user);

            playerCounter++;
        }

        // --- UloÄąÄľit hrÄ‚Ë‡Ă„Ĺ¤e (uÄąÄľ uloÄąÄľen pÄąâ„˘i cascade, ale pro jistotu) ---
        playerRepository.saveAll(players);

        // --- VytvoÄąâ„˘enÄ‚Â­ zÄ‚Ë‡pasÄąĹ» ---
        LocalDateTime startDate = LocalDateTime.of(2025, 11, 21, 18, 45);
        for (int i = 0; i < 10; i++) {
            MatchEntity match = new MatchEntity();
            match.setDateTime(startDate.plusWeeks(i));
            match.setLocation("Ostravice");
            match.setDescription("");
            match.setMaxPlayers(12);
            match.setPrice(2200);
            matchRepository.save(match);
        }

        // --- Registrace hrÄ‚Ë‡Ă„Ĺ¤ÄąĹ» na zÄ‚Ë‡pas id 3 ---
        MatchEntity match3 = matchRepository.findById(3L)
                .orElseThrow(() -> new RuntimeException("Match with id 3 not found"));

        for (long playerId = 1; playerId <= 6; playerId++) {
            final long pid = playerId;
            PlayerEntity player = playerRepository.findById(playerId)
                    .orElseThrow(() -> new RuntimeException("Player with id " + pid + " not found"));

            MatchRegistrationEntity reg = new MatchRegistrationEntity();
            reg.setMatch(match3);
            reg.setPlayer(player);
            reg.setStatus(PlayerMatchStatus.REGISTERED);
            if (playerId <=3){
                reg.setTeam(Team.DARK);
            }else {
                reg.setTeam(Team.LIGHT);
            }
            reg.setTimestamp(LocalDateTime.now());
            reg.setCreatedBy("user");
            matchRegistrationRepository.save(reg);
        }

        // --- Default admin ---
        if (appUserRepository.findByEmail("admin@example.com").isEmpty()) {
            AppUserEntity admin = new AppUserEntity();
            admin.setEmail("admin@example.com");
            admin.setPassword(encoder.encode("Administrator123"));
            admin.setRole(Role.ROLE_ADMIN);
            appUserRepository.save(admin);
            System.out.println("Default admin user created.");
        } else {
            System.out.println("Admin user already exists Ă˘â‚¬â€ś skipping.");
        }

        // --- vytvoÄąâ„˘enÄ‚Â­ triggeru ---
        try {
            jdbcTemplate.execute("""
                           CREATE TRIGGER trg_match_reg_insert
                           AFTER INSERT ON match_registrations
                           FOR EACH ROW
                           BEGIN
                               INSERT INTO match_registration_history
                               (match_registration_id, match_id, player_id, status, excuse_reason,
                                excuse_note, admin_note, team, original_timestamp, created_by,
                                action, changed_at)
                               VALUES
                               (NEW.id, NEW.match_id, NEW.player_id, NEW.status, NEW.excuse_reason,
                                NEW.excuse_note, NEW.admin_note, NEW.team, NEW.timestamp, NEW.created_by,
                                'INSERT', NOW());
                           END
                    """);
            System.out.println("Trigger created successfully.");
        } catch (Exception e) {
            System.out.println("Trigger already exists or error: " + e.getMessage());
        }

        try {
            jdbcTemplate.execute("""
                    CREATE TRIGGER trg_match_reg_update
                    AFTER UPDATE ON match_registrations
                    FOR EACH ROW
                    BEGIN
                        INSERT INTO match_registration_history
                        (match_registration_id, match_id, player_id, status, excuse_reason,
                         excuse_note, admin_note, team, original_timestamp, created_by,
                         action, changed_at)
                        VALUES
                        (NEW.id, NEW.match_id, NEW.player_id, NEW.status, NEW.excuse_reason,
                         NEW.excuse_note, NEW.admin_note, NEW.team, NEW.timestamp, NEW.created_by,
                         'UPDATE', NOW());
                    END
                    """);
            System.out.println("Trigger created successfully.");
        } catch (Exception e) {
            System.out.println("Trigger already exists or error: " + e.getMessage());
        }

        try {
            jdbcTemplate.execute("""
        CREATE TRIGGER trg_match_reg_delete
        AFTER DELETE ON match_registrations
        FOR EACH ROW
                BEGIN
        INSERT INTO match_registration_history
                (match_registration_id, match_id, player_id, status, excuse_reason,
                        excuse_note, admin_note, team, original_timestamp, created_by,
                        action, changed_at)
        VALUES
                (OLD.id, OLD.match_id, OLD.player_id, OLD.status, OLD.excuse_reason,
                        OLD.excuse_note, OLD.admin_note, OLD.team, OLD.timestamp, OLD.created_by,
                        'DELETE', NOW());
        END
        """);
            System.out.println("Trigger created successfully.");
                } catch (Exception e) {
                    System.out.println("Trigger already exists or error: " + e.getMessage());
                }

        System.out.println("Data initialization completed.");


    }
}





# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\GlobalExceptionHandler.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.exceptions.ApiError;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import jakarta.servlet.http.HttpServletRequest;

@ControllerAdvice
public class GlobalExceptionHandler {

    // VlastnÄ‚Â­ business vyjÄ‚Â­mky - BusinessException
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ApiError> handleBusinessException(
            BusinessException ex,
            HttpServletRequest request) {

        ApiError error = new ApiError(
                ex.getStatus().value(),
                ex.getStatus().getReasonPhrase(),
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()
        );
        return ResponseEntity.status(ex.getStatus()).body(error);
    }

    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ApiError> handleAccessDenied(AccessDeniedException ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.FORBIDDEN.value(),
                "Forbidden",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // Ă˘â€ Â IP klienta);
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(error);
    }

    // --- NenalezenÄ‚Â© zdroje (404) ---
    @ExceptionHandler({
            MatchNotFoundException.class,
            PlayerNotFoundException.class,
            RegistrationNotFoundException.class
    })
    public ResponseEntity<ApiError> handleNotFound(RuntimeException ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.NOT_FOUND.value(),
                "Not Found",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // Ă˘â€ Â IP klienta
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    // --- Konflikty (409) ---
    @ExceptionHandler(DuplicateRegistrationException.class)
    public ResponseEntity<ApiError> handleConflict(DuplicateRegistrationException ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.CONFLICT.value(),
                "Conflict",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // Ă˘â€ Â IP klienta);
        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
    }

    // --- ObecnÄ‚Â© chyby (500) ---
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiError> handleAll(Exception ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // Ă˘â€ Â IP klienta);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\SecurityConfig.java


package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.security.config.http.SessionCreationPolicy;


import java.util.List;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;

    @Value("${app.test-mode:false}")
    private boolean isTestMode;

    public SecurityConfig(CustomUserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    // Password encoder
    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    // Authentication provider
    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    // AuthenticationManager
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    // Security filter chain
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http, AuthenticationManager authManager) throws Exception {

        http.csrf(csrf -> csrf.disable())
                .cors(cors -> {
                });

        if (isTestMode) {
            // Test mode - vÄąË‡echno povoleno a HTTP Basic pro Postman
            http.authorizeHttpRequests(auth -> auth.anyRequest().permitAll())
                    .httpBasic();
        } else {
            // Produkce - REST login pÄąâ„˘es CustomJsonLoginFilter
            http
                    .authenticationProvider(authenticationProvider())
                    .authorizeHttpRequests(auth -> auth
                            .requestMatchers("/api/auth/register", "/api/auth/verify").permitAll()
                            .requestMatchers("/api/login").permitAll()
                            .requestMatchers("/api/logout").permitAll()
                            .requestMatchers("/api/matches").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/matches/upcoming", "/api/matches/past").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/matches/**").authenticated()
                            .requestMatchers("/api/players").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/players/**").authenticated()
                            .requestMatchers("/api/registrations/all",
                                    "/api/registrations/for-match/**",
                                    "/api/registrations/no-response/**").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/registrations/**").authenticated()
                            .requestMatchers("/api/inactivity/All",
                                    "/api/inactivity/**").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/inactivity/player/**").authenticated()
                            .anyRequest().authenticated()
                    )
                    //  TADY PÄąÂESNĂ„Ĺˇ
                    .sessionManagement(sm ->
                            sm.sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
                    )
                    //  a TEPRVE PAK login filter
                    .addFilterAt(
                            new CustomJsonLoginFilter("/api/login", authManager),
                            UsernamePasswordAuthenticationFilter.class
                    )
                    .logout(logout -> logout
                            .logoutUrl("/api/logout")
                            .deleteCookies("JSESSIONID")
                            .logoutSuccessHandler((request, response, auth) -> {
                                request.getSession().removeAttribute("CURRENT_PLAYER_ID");
                                response.setContentType("application/json");
                                response.setCharacterEncoding("UTF-8");
                                response.getWriter().write("{\"status\":\"ok\",\"message\":\"OdhlÄ‚Ë‡ÄąË‡eno\"}");
                            })
                    );
        }

        return http.build();
    }

    // CORS pro React dev server a cookies
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(List.of("http://localhost:5173"));
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AdminMatchController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.services.MatchService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/matches/admin")
@CrossOrigin(origins = "*")
public class AdminMatchController {
    private final MatchService matchService;
    private final CurrentPlayerService currentPlayerService;


    public AdminMatchController(MatchService matchService,
                           CurrentPlayerService currentPlayerService) {
        this.matchService = matchService;
        this.currentPlayerService = currentPlayerService;
    }

    // VÄąË‡echny zÄ‚Ë‡pasy
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getAllMatches() {
        return matchService.getAllMatches();
    }

    // VÄąË‡echny nadchÄ‚Ë‡zejÄ‚Â­cÄ‚Â­ zÄ‚Ë‡pasy
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    @GetMapping("/upcoming")
    public List<MatchDTO> getUpcomingMatches() {
        return matchService.getUpcomingMatches();
    }

    // UÄąÄľ uskuteĂ„Ĺ¤nĂ„â€şnÄ‚Â© zÄ‚Ë‡pasy
    @GetMapping("/past")
    public List<MatchDTO> getPastMatches() {
        return matchService.getPastMatches();
    }

    // VytvoÄąâ„˘enÄ‚Â­ zÄ‚Ë‡pasu
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public MatchDTO createMatch(@Valid @RequestBody MatchDTO matchDTO) {
        return matchService.createMatch(matchDTO);
    }

    // ZÄ‚Â­skÄ‚Ë‡nÄ‚Â­ zÄ‚Ë‡pasu podle ID
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO getMatch(@PathVariable Long id) {
        return matchService.getMatchById(id);
    }

    // Editace zÄ‚Ë‡pasu
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO updateMatch(@PathVariable Long id, @Valid @RequestBody MatchDTO dto) {
        return matchService.updateMatch(id, dto);
    }

    // SmazÄ‚Ë‡nÄ‚Â­ zÄ‚Ë‡pasu
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SuccessResponseDTO> deleteMatch(@PathVariable Long id) {
        SuccessResponseDTO response = matchService.deleteMatch(id);
        return ResponseEntity.ok(response);
    }

    // DostupnÄ‚Â© zÄ‚Ë‡pasy pro hrÄ‚Ë‡Ă„Ĺ¤e
    @GetMapping("/available-for-player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getAvailableMatchesForPlayer(@PathVariable Long playerId) {
        return matchService.getAvailableMatchesForPlayer(playerId);
    }

}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AdminMatchRegistrationController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/registrations/admin")
@CrossOrigin(origins = "*")
public class AdminMatchRegistrationController {
    private final MatchRegistrationService service;
    private final CurrentPlayerService currentPlayerService;

    public AdminMatchRegistrationController(MatchRegistrationService service,
                                       CurrentPlayerService currentPlayerService) {
        this.service = service;
        this.currentPlayerService = currentPlayerService;
    }

    @GetMapping("/all")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> getAllRegistrations() {
        return service.getAllRegistrations();
    }
    @GetMapping("/for-match/{matchId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> forMatch(@PathVariable Long matchId) {
        return service.getRegistrationsForMatch(matchId);
    }

    @GetMapping("/for-player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> forPlayer(@PathVariable Long playerId) {
        return service.getRegistrationsForPlayer(playerId);
    }
    @GetMapping("/no-response/{matchId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getNoResponse(@PathVariable Long matchId) {
        return service.getNoResponsePlayers(matchId);
    }


    // UNIVERZÄ‚ÂLNÄ‚Ĺ¤ ENDPOINT PRO REGISTRACE - za hrÄ‚Ë‡Ă„Ĺ¤e


    @PostMapping("/upsert/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchRegistrationDTO upsert(@PathVariable Long playerId, @RequestBody MatchRegistrationRequest request) {

        return service.upsertRegistration(
                request.getMatchId(),
                request.getPlayerId(), // vybranÄ‚Ëť hrÄ‚Ë‡Ă„Ĺ¤
                request.getTeam(),
                request.getAdminNote(),
                request.getExcuseReason(),
                request.getExcuseNote(),
                request.isUnregister()
        );
    }

}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AdminPlayerController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.services.PlayerService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/players/admin")
@CrossOrigin(origins = "*")
public class AdminPlayerController {

    private final PlayerService playerService;
    private final CurrentPlayerService currentPlayerService;

    public AdminPlayerController(PlayerService playerService, CurrentPlayerService currentPlayerService) {
        this.playerService = playerService;
        this.currentPlayerService = currentPlayerService;
    }
    // vÄąË‡ichni hrÄ‚Ë‡Ă„Ĺ¤i
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getAllPlayers() {
        return playerService.getAllPlayers();
    }

    // hrÄ‚Ë‡Ă„Ĺ¤ dle id

    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public PlayerDTO getPlayerById(@PathVariable Long id) {
        return playerService.getPlayerById(id);
    }

    // vytvoÄąâ„˘enÄ‚Â­ hrÄ‚Ë‡Ă„Ĺ¤e
    @PostMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
        public PlayerDTO createPlayer(@RequestBody PlayerDTO playerDTO) {
        return playerService.createPlayer(playerDTO);
    }

    // Ä‚Ĺźprava hrÄ‚Ë‡Ă„Ĺ¤e administrÄ‚Ë‡torem dle id hrÄ‚Ë‡Ă„Ĺ¤e
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public PlayerDTO upatePlayerAdmin(@PathVariable Long id,  @RequestBody PlayerDTO dto) {

        return playerService.updatePlayer(id, dto);
    }
    // odstranÄ‚Â­ hrÄ‚Ë‡Ă„Ĺ¤e
    @PreAuthorize("hasRole('ADMIN')")
    @DeleteMapping("/{id}")
    public ResponseEntity<SuccessResponseDTO> deletePlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.deletePlayer(id);
        return ResponseEntity.ok(response);
    }

    //
    // SCHVÄ‚ÂLENÄ‚Ĺ¤ HRÄ‚ÂĂ„ĹšE
    @PreAuthorize("hasRole('ADMIN')")
    @PutMapping("/approve/{id}")
    public ResponseEntity<SuccessResponseDTO> approvePlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.approvePlayer(id);
        return ResponseEntity.ok(response);

    }
    // ZAMÄ‚Ĺ¤TNUTÄ‚Ĺ¤ HRÄ‚ÂĂ„ĹšE
    @PreAuthorize("hasRole('ADMIN')")
    @PutMapping("/reject/{id}")
    public ResponseEntity<SuccessResponseDTO> rejectPlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.rejectPlayer(id);
        return ResponseEntity.ok(response);

    }





}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AppUserController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.ChangePasswordDTO;
import cz.phsoft.hokej.models.services.AppUserService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/users")
@CrossOrigin(origins = "*")
public class AppUserController {

    private final AppUserService appUserService;

    public AppUserController(AppUserService appUserService) {
        this.appUserService = appUserService;
    }

    // PÄąâ„˘ihlÄ‚Ë‡ÄąË‡enÄ‚Ëť uÄąÄľivatel Ă˘â‚¬â€ś bezpeĂ„Ĺ¤nÄ‚Â©
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public AppUserDTO getCurrentUser(Authentication authentication) {
        return appUserService.getCurrentUser(authentication.getName());
    }

    // ZmĂ„â€şna hesla pÄąâ„˘ihlÄ‚Ë‡ÄąË‡enÄ‚Â©ho uÄąÄľivatele
    @PostMapping("/me/change-password")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> changePassword(Authentication authentication,
                                                 @RequestBody ChangePasswordDTO dto) {
        String email = authentication.getName();
        appUserService.changePassword(email, dto.getOldPassword(), dto.getNewPassword(), dto.getNewPasswordConfirm());
        return ResponseEntity.ok("Heslo Ä‚ĹźspĂ„â€şÄąË‡nĂ„â€ş zmĂ„â€şnĂ„â€şno");
    }

    // ZmĂ„â€şna pÄąâ„˘ihlÄ‚Ë‡ÄąË‡enÄ‚Â©ho uÄąÄľivatele
    @PutMapping("/me/update")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> updateUser(Authentication authentication,
                                                 @RequestBody AppUserDTO dto) {
        String email = authentication.getName();
        appUserService.updateUser(email, dto);

        return ResponseEntity.ok("uÄąÄľivatel byl zmĂ„â€şnĂ„â€şn");
    }


    // reset hesla uÄąÄľivatele
    @PostMapping("/{id}/reset-password")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<String> resetPassword(@PathVariable Long id) {
        appUserService.resetPassword(id);
        return ResponseEntity.ok("Heslo resetovÄ‚Ë‡no na 'Player123'");
    }

    // Seznam vÄąË‡ech uÄąÄľivatelÄąĹ» Ă˘â‚¬â€ś jen ADMIN
    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    public List<AppUserDTO> getAllUsers() {
        return appUserService.getAllUsers();
    }


}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AuthController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.EmailVerificationTokenEntity;
import cz.phsoft.hokej.data.repositories.EmailVerificationTokenRepository;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;
import cz.phsoft.hokej.models.services.AppUserService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/api/auth")
@CrossOrigin(origins = "*")
public class AuthController {

    private final AppUserService appUserService;
    private final AppUserRepository userRepository;
    private final EmailVerificationTokenRepository tokenRepository;

    public AuthController(AppUserService appUserService,
                          AppUserRepository userRepository,
                          EmailVerificationTokenRepository tokenRepository) {
        this.appUserService = appUserService;
        this.userRepository = userRepository;
        this.tokenRepository = tokenRepository;
    }

    // ===== Registrace =====
    @PostMapping("/register")
    public ResponseEntity<?> register(@Valid @RequestBody RegisterUserDTO dto) {
        appUserService.register(dto);
        return ResponseEntity.ok(
                Map.of("status", "ok", "message", "Registrace Ä‚ĹźspĂ„â€şÄąË‡nÄ‚Ë‡. Zkontrolujte email pro aktivaci Ä‚ĹźĂ„Ĺ¤tu.")
        );
    }

    // ===== ZÄ‚Â­skÄ‚Ë‡nÄ‚Â­ aktuÄ‚Ë‡lnÄ‚Â­ho uÄąÄľivatele =====
    @GetMapping("/me")
    public ResponseEntity<AppUserDTO> getCurrentUser(Authentication authentication) {
        AppUserDTO dto = appUserService.getCurrentUser(authentication.getName());
        return ResponseEntity.ok(dto);
    }

    // ===== Aktivace Ä‚ĹźĂ„Ĺ¤tu =====
    @GetMapping("/verify")
    public ResponseEntity<String> verifyEmail(@RequestParam String token) {
        Optional<EmailVerificationTokenEntity> optionalToken = tokenRepository.findByToken(token);

        if (optionalToken.isEmpty()) {
            return ResponseEntity.badRequest().body("NeplatnÄ‚Ëť aktivaĂ„Ĺ¤nÄ‚Â­ odkaz.");
        }

        EmailVerificationTokenEntity verificationToken = optionalToken.get();

        if (verificationToken.getExpiresAt().isBefore(LocalDateTime.now())) {
            return ResponseEntity.badRequest().body("AktivaĂ„Ĺ¤nÄ‚Â­ odkaz vyprÄąË‡el.");
        }

        AppUserEntity user = verificationToken.getUser();
        user.setEnabled(true);
        userRepository.save(user);

        tokenRepository.delete(verificationToken);

        return ResponseEntity.ok("Ä‚ĹˇĂ„Ĺ¤et byl Ä‚ĹźspĂ„â€şÄąË‡nĂ„â€ş aktivovÄ‚Ë‡n.");
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\CurrentPlayerController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.services.PlayerService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import jakarta.servlet.http.HttpSession;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

// aktuÄ‚Ë‡lnÄ‚Â­ hrÄ‚Ë‡Ă„Ĺ¤
@RestController
@RequestMapping("/api/current-player")
public class CurrentPlayerController {

    private final PlayerRepository playerRepository;
    private final AppUserRepository appUserRepository;
    private final CurrentPlayerService currentPlayerService;
    private final PlayerService playerService;

    public CurrentPlayerController(PlayerRepository playerRepository,
                                   AppUserRepository appUserRepository,
                                   CurrentPlayerService currentPlayerService,
                                   PlayerService playerService) {
        this.playerRepository = playerRepository;
        this.appUserRepository = appUserRepository;
        this.currentPlayerService = currentPlayerService;
        this.playerService = playerService;
    }

    // -----------------------------------------------------
    // NastavenÄ‚Â­ aktuÄ‚Ë‡lnÄ‚Â­ho hrÄ‚Ë‡Ă„Ĺ¤e Ă˘â‚¬â€ś pokud uÄąÄľivatel mÄ‚Ë‡ jen jednoho, vybere se automaticky
    // -----------------------------------------------------
    @PostMapping("/{playerId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> setCurrentPlayer(@PathVariable Long playerId,
                                 Authentication auth,
                                 HttpSession session) {

        AppUserEntity user = appUserRepository.findByEmail(auth.getName())
                .orElseThrow(() -> new RuntimeException("User not found"));

        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new RuntimeException("Player not found"));

        if (!player.getUser().getId().equals(user.getId())) {
            throw new RuntimeException("Player does not belong to user");
        }

        currentPlayerService.setCurrentPlayerId(player.getId());
        return ResponseEntity.ok("AktuÄ‚Ë‡lnÄ‚Â­ hrÄ‚Ë‡Ă„Ĺ¤ nastaven na ID: " + player.getId());
    }

    // -----------------------------------------------------
    // AutomatickÄ‚Ëť vÄ‚ËťbĂ„â€şr aktuÄ‚Ë‡lnÄ‚Â­ho hrÄ‚Ë‡Ă„Ĺ¤e po loginu
    // Zavolat z frontendu /api/current-player/auto-select po pÄąâ„˘ihlÄ‚Ë‡ÄąË‡enÄ‚Â­
    // -----------------------------------------------------
    @PostMapping("/auto-select")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> autoSelectCurrentPlayer(Authentication auth) {
        AppUserEntity user = appUserRepository.findByEmail(auth.getName())
                .orElseThrow(() -> new RuntimeException("User not found"));

        List<PlayerDTO> players = playerService.getPlayersByUser(user.getEmail());

        if (players.size() == 1) {
            PlayerDTO player = players.get(0);
            currentPlayerService.setCurrentPlayerId(player.getId());
            return ResponseEntity.ok("Automaticky nastaven hrÄ‚Ë‡Ă„Ĺ¤ nastaven na ID: " + player.getId());
        } else {
            return ResponseEntity.ok("UÄąÄľivatel mÄ‚Ë‡ vÄ‚Â­ce hrÄ‚Ë‡Ă„Ĺ¤ÄąĹ», vÄ‚ËťbĂ„â€şr nutnÄ‚Ëť ruĂ„Ĺ¤nĂ„â€ş");
        }
    }

    // -----------------------------------------------------
    // ZÄ‚Â­skÄ‚Ë‡nÄ‚Â­ aktuÄ‚Ë‡lnÄ‚Â­ho hrÄ‚Ë‡Ă„Ĺ¤e
    // -----------------------------------------------------
    @GetMapping
    @PreAuthorize("isAuthenticated()")
    public PlayerDTO getCurrentPlayer(HttpSession session) {

        Long playerId = currentPlayerService.getCurrentPlayerId();
        if (playerId == null) {
            System.out.println("ÄąËťÄ‚Ë‡dnÄ‚Ëť aktuÄ‚Ë‡lnÄ‚Â­ hrÄ‚Ë‡Ă„Ĺ¤");
            return null;
        }

        PlayerDTO player = playerService.getPlayerById(playerId);
        System.out.println("AktuÄ‚Ë‡lnÄ‚Â­ hrÄ‚Ë‡Ă„Ĺ¤ ID: " + playerId);
        return player;
    }

    // -----------------------------------------------------
    // PomocnÄ‚Ëť endpoint Ă˘â‚¬â€ś seznam hrÄ‚Ë‡Ă„Ĺ¤ÄąĹ» aktuÄ‚Ë‡lnÄ‚Â­ho uÄąÄľivatele
    // -----------------------------------------------------
    @GetMapping("/my-players")
    @PreAuthorize("isAuthenticated()")
    public List<PlayerDTO> getMyPlayers(Authentication auth, HttpSession session) {
        AppUserEntity user = appUserRepository.findByEmail(auth.getName())
                .orElseThrow(() -> new RuntimeException("User not found"));

        List<PlayerDTO> players = playerService.getPlayersByUser(user.getEmail());

        System.out.println("Seznam hrÄ‚Ë‡Ă„Ĺ¤ÄąĹ» uÄąÄľivatele " + user.getEmail() + ": " +
                players.stream().map(PlayerDTO::getId).toList());

        return players;
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\DebugController.java


package cz.phsoft.hokej.controllers;

import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class DebugController {

    @GetMapping("/api/debug/me")
    public Object me(Authentication auth) {
        return auth;
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\MatchController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;
import cz.phsoft.hokej.models.dto.MatchOverviewDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.services.MatchService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;


@RestController
@RequestMapping("/api/matches")
@CrossOrigin(origins = "*")
public class MatchController {

    private final MatchService matchService;
    private final CurrentPlayerService currentPlayerService;


    public MatchController(MatchService matchService,
                           CurrentPlayerService currentPlayerService) {
        this.matchService = matchService;
        this.currentPlayerService = currentPlayerService;
    }

    // Detail zÄ‚Ë‡pasu
    @PreAuthorize("isAuthenticated()")
    @GetMapping("/matchDetail/{id}")
    public MatchDetailDTO getMatchDetail(@PathVariable Long id) {
        return matchService.getMatchDetail(id);
    }

    // NadchÄ‚Ë‡zejÄ‚Â­cÄ‚Â­ zÄ‚Ë‡pas - NEPOUÄąËťÄ‚Ĺ¤VAT - NENÄ‚Ĺ¤ TAM PLAYER TYPE
    @PreAuthorize("isAuthenticated()")
    @GetMapping("/next")
    public MatchDTO getNextMatch() {
        return matchService.getNextMatch();
    }

    // NadchÄ‚Ë‡zejÄ‚Â­cÄ‚Â­ zÄ‚Ë‡pasy pro pÄąâ„˘ihlÄ‚Ë‡ÄąË‡enÄ‚Â©ho hrÄ‚Ë‡Ă„Ĺ¤e
    @GetMapping("/me/upcoming")
    @PreAuthorize("isAuthenticated()")
    public List<MatchDTO> getUpcomingMatchesForMe(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getUpcomingMatchesForPlayer(currentPlayerId);
    }

    @GetMapping("/me/upcoming-overview")
    @PreAuthorize("isAuthenticated()")
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForMe(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getUpcomingMatchesOverviewForPlayer(currentPlayerId);
    }

    @GetMapping("/me/all-passed")
    @PreAuthorize("isAuthenticated()")
    public List<MatchOverviewDTO> getAllMatchesForPlayer(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getAllPassedMatchesForPlayer(currentPlayerId);
    }





}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\MatchRegistrationController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import org.springframework.web.bind.annotation.*;
import org.springframework.security.access.prepost.PreAuthorize;

import java.util.List;

@RestController
@RequestMapping("/api/registrations")
@CrossOrigin(origins = "*")
public class MatchRegistrationController {

    private final MatchRegistrationService service;
    private final CurrentPlayerService currentPlayerService;

    public MatchRegistrationController(MatchRegistrationService service,
                                       CurrentPlayerService currentPlayerService) {
        this.service = service;
        this.currentPlayerService = currentPlayerService;
    }


    // UNIVERZÄ‚ÂLNÄ‚Ĺ¤ ENDPOINT PRO REGISTRACE


    @PostMapping("/me/upsert")
    @PreAuthorize("isAuthenticated()")
    public MatchRegistrationDTO upsert(@RequestBody MatchRegistrationRequest request) {
        // automaticky bere vybranÄ‚Â©ho hrÄ‚Ë‡Ă„Ĺ¤e
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        return service.upsertRegistration(
                request.getMatchId(),
                currentPlayerId, // vÄąÄľdy aktuÄ‚Ë‡lnÄ‚Â­ hrÄ‚Ë‡Ă„Ĺ¤
                request.getTeam(),
                request.getAdminNote(),
                request.getExcuseReason(),
                request.getExcuseNote(),
                request.isUnregister()
        );
    }

    // registrace na zÄ‚Ë‡pasy pÄąâ„˘ihlÄ‚Ë‡ÄąË‡enÄ‚Â©ho hrÄ‚Ë‡Ă„Ĺ¤e
    @GetMapping("/me/for-current-player")
    @PreAuthorize("isAuthenticated()")
    public List<MatchRegistrationDTO> forCurrentPlayer() {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return service.getRegistrationsForPlayer(currentPlayerId);
    }


}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.PlayerService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/players")
@CrossOrigin(origins = "*")
public class PlayerController {

    private final PlayerService playerService;
    private final CurrentPlayerService currentPlayerService;

    public PlayerController(PlayerService playerService, CurrentPlayerService currentPlayerService) {
        this.playerService = playerService;
        this.currentPlayerService = currentPlayerService;
    }

    // vytvoÄąâ„˘enÄ‚Â­ hrÄ‚Ë‡Ă„Ĺ¤e pro pÄąâ„˘ihlÄ‚Ë‡ÄąË‡enÄ‚Â©ho uÄąÄľivatele
    @PostMapping("/me")
    @PreAuthorize("isAuthenticated()") // kaÄąÄľdÄ‚Ëť pÄąâ„˘ihlÄ‚Ë‡ÄąË‡enÄ‚Ëť uÄąÄľivatel
    public PlayerDTO createMyPlayer(@RequestBody PlayerDTO playerDTO, Authentication authentication) {
        String email = authentication.getName(); // email pÄąâ„˘ihlÄ‚Ë‡ÄąË‡enÄ‚Â©ho uÄąÄľivatele
        return playerService.createPlayerForUser(playerDTO, email);
    }

    // zÄ‚Â­skÄ‚Ë‡nÄ‚Â­ hrÄ‚Ë‡Ă„Ĺ¤ÄąĹ» pÄąâ„˘ihlÄ‚Ë‡ÄąË‡enÄ‚Â©ho uÄąÄľivatele
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public List<PlayerDTO> getMyPlayers(Authentication authentication) {
        String email = authentication.getName();
        return playerService.getPlayersByUser(email);
    }

    // Ä‚Ĺźprava hrÄ‚Ë‡Ă„Ĺ¤e pÄąâ„˘ihlÄ‚Ë‡ÄąË‡enÄ‚Â©ho uÄąÄľivatele
    @PutMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public PlayerDTO updatePlayer(@RequestBody PlayerDTO dto) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        return playerService.updatePlayer(currentPlayerId, dto);
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerInactivityPeriodController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import cz.phsoft.hokej.models.services.PlayerInactivityPeriodService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/inactivity/Admin")
@CrossOrigin(origins = "*")
public class PlayerInactivityPeriodController {

    private final PlayerInactivityPeriodService service;

    public PlayerInactivityPeriodController(PlayerInactivityPeriodService service) {
        this.service = service;
    }

    // vÄąË‡echny zÄ‚Ë‡znamy o neaktivitĂ„â€ş hrÄ‚Ë‡Ă„Ĺ¤ÄąĹ»
    @GetMapping("/all")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getAll() {
        return service.getAll();
    }

    // neaktivita hrÄ‚Ë‡Ă„Ĺ¤ÄąĹ» dle id neaktivity
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<PlayerInactivityPeriodDTO> getById(@PathVariable Long id) {
        PlayerInactivityPeriodDTO dto = service.getById(id);
        return ResponseEntity.ok(dto);
    }

    // zÄ‚Â­skÄ‚Ë‡ zÄ‚Ë‡znamy o periodĂ„â€ş neaktivity dle id hrÄ‚Ë‡Ă„Ĺ¤e
    @GetMapping("/player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getByPlayer(@PathVariable Long playerId) {
        return service.getByPlayer(playerId);
    }

    // vytvoÄąâ„˘Ä‚Â­ zÄ‚Ë‡znam o neaktivitĂ„â€ş hrÄ‚Ë‡Ă„Ĺ¤e
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<PlayerInactivityPeriodDTO> create(@RequestBody PlayerInactivityPeriodDTO dto) {
        PlayerInactivityPeriodDTO created = service.create(dto);
        return ResponseEntity.ok(created);
    }

    // zmĂ„â€şnÄ‚Â­ zÄ‚Ë‡znam o neaktivitĂ„â€ş hrÄ‚Ë‡Ă„Ĺ¤e dle id
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<PlayerInactivityPeriodDTO> update(
            @PathVariable Long id,
            @RequestBody PlayerInactivityPeriodDTO dto) {

        PlayerInactivityPeriodDTO updated = service.update(id, dto);
        return ResponseEntity.ok(updated);
    }

    // vymaÄąÄľe zÄ‚Ë‡znam o neaktivitĂ„â€ş hrÄ‚Ë‡Ă„Ĺ¤e dle id zÄ‚Ë‡znamu
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        service.delete(id);
        return ResponseEntity.noContent().build();
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestController.java


package cz.phsoft.hokej.controllers;

import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/test")
@CrossOrigin(origins = "*")
public class TestController {

    @GetMapping
    public String hello() {
        return "Backend je online!";
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestEmailController.java


package cz.phsoft.hokej.controllers;


import cz.phsoft.hokej.models.services.email.EmailService;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/email/test")
public class TestEmailController {
    private final EmailService emailService;

    public TestEmailController(EmailService emailService) {
        this.emailService = emailService;
    }

    @PostMapping("/send-mail")
    public String sendTestMail() {
        emailService.sendSimpleEmail(
                "petrhlista@seznam.cz",
                "APP - TestovacÄ‚Â­ email",
                "Ahoj, toto je test z backendu."
        );
        return "Email odeslÄ‚Ë‡n";
    }

}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestSmsController.java


/*
package cz.phsoft.hokej.controllers;


import cz.phsoft.hokej.models.services.sms.SmsTextBeeService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TestSmsController {

    private final SmsTextBeeService smsTextBeeService;

    public TestSmsController(SmsTextBeeService smsTextBeeService) {
        this.smsTextBeeService = smsTextBeeService;
    }

    /**
     * TestovacÄ‚Â­ endpoint pro odeslÄ‚Ë‡nÄ‚Â­ SMS na testovacÄ‚Â­ Ă„Ĺ¤Ä‚Â­slo.
     * Zavolej: GET /api/test-sms
     */
/*
    @GetMapping("/api/test-sms")
    public String sendTestSms() {
        smsTextBeeService.sendSms("+420776609956", "testovacÄ‚Â­ sms app-sg");
        return "SMS byla odeslÄ‚Ë‡na na testovacÄ‚Â­ Ă„Ĺ¤Ä‚Â­slo +420776609956";
    }
}

        */


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\AppUserEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.Role;
import jakarta.persistence.*;

import java.util.Set;

@Entity
@Table(name = "app_users")
public class AppUserEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String surname;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role;

    @Column(nullable = false)
    private boolean enabled = false; // vÄ‚ËťchozÄ‚Â­ hodnota false


    // One-to-Many: jeden uÄąÄľivatel Ă˘â€ â€™ vÄ‚Â­ce hrÄ‚Ë‡Ă„Ĺ¤ÄąĹ»
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<PlayerEntity> players;

    // gettery/settery


    public Long getId() {return id;}

    public void setId(Long id) {this.id = id;}

    public String getName() {return name;}

    public void setName(String name) {this.name = name;}

    public String getSurname() { return surname; }

    public void setSurname(String surname) { this.surname = surname; }

    public String getEmail() {return email;}

    public void setEmail(String email) {this.email = email;}

    public String getPassword() {return password;}

    public void setPassword(String password) {this.password = password;}

    public Role getRole() {return role;}

    public void setRole(Role role) {this.role = role;}

    public boolean isEnabled() {    return enabled;    }

    public void setEnabled(boolean enabled) {  this.enabled = enabled;    }

    public Set<PlayerEntity> getPlayers() {return players;}

    public void setPlayers(Set<PlayerEntity> players) {this.players = players;}
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\EmailVerificationTokenEntity.java


package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDateTime;


@Entity
@Table(name = "email_verification_tokens")
public class EmailVerificationTokenEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 64)
    private String token;

    @Column(nullable = false)
    private LocalDateTime expiresAt;

    @OneToOne
    @JoinColumn(name = "user_id", nullable = false)
    private AppUserEntity user;

    // gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getToken() { return token; }
    public void setToken(String token) { this.token = token; }

    public LocalDateTime getExpiresAt() { return expiresAt; }
    public void setExpiresAt(LocalDateTime expiresAt) { this.expiresAt = expiresAt; }

    public AppUserEntity getUser() { return user; }
    public void setUser(AppUserEntity user) { this.user = user; }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchEntity.java


package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;
import java.time.LocalDateTime;

/**
 * tÄąâ„˘Ä‚Â­da pro vklÄ‚Ë‡dÄ‚Ë‡nÄ‚Â­ Entity zÄ‚Ë‡pasu do db
 */
@Entity
@Table(name = "matches")
public class MatchEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private LocalDateTime dateTime;

    @Column(nullable = false)
    private String location;

    private String description;

    // maximÄ‚Ë‡lnÄ‚Â­ poĂ„Ĺ¤et hrÄ‚Ë‡Ă„Ĺ¤ÄąĹ» - vyuÄąÄľÄ‚Â­vÄ‚Ë‡ se pro ovĂ„â€şÄąâ„˘enÄ‚Â­ kapacity pÄąâ„˘i pÄąâ„˘ihlÄ‚Ë‡ÄąË‡enÄ‚Â­
    @Column(nullable = false)
    private Integer maxPlayers;

    @Column(nullable = false)
    private Integer price;

    public MatchEntity() {}

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }

    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() { return price; }

    public void setPrice(Integer price) { this.price = price; }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * tÄąâ„˘Ä‚Â­da reprezentuje registracei hrÄ‚Ë‡Ă„Ĺ¤e k zÄ‚Ë‡pasu
 */
@Entity
@Table(name = "match_registrations")
public class MatchRegistrationEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "match_id", nullable = false)
    private MatchEntity match;

    @ManyToOne
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerMatchStatus status;

    @Enumerated(EnumType.STRING)
    private ExcuseReason excuseReason;

    private String excuseNote;

    // admin mÄąĹ»ÄąÄľe vloÄąÄľit poznÄ‚Ë‡mku, napÄąâ„˘. kdyÄąÄľ se nĂ„â€şkdo zaregistruje a potÄ‚Â© nepÄąâ„˘Ä‚Â­jde
    private String adminNote;

    @Enumerated(EnumType.STRING)
    @Column(name = "team")
    private Team team;

    // datĂ„Ĺ¤as vytvoÄąâ„˘enÄ‚Â­ registrace - musÄ‚Â­ se mĂ„â€şnit aby nebyl hrÄ‚Ë‡Ă„Ĺ¤ i po zruÄąË‡enÄ‚Â­ registrace
    // v poÄąâ„˘adÄ‚Â­ pÄąâ„˘ed hrÄ‚Ë‡Ă„Ĺ¤i kteÄąâ„˘Ä‚Â­ se registrovali po zruÄąË‡enÄ‚Â­ registrace
    @Column(nullable = false, updatable = true)
    private LocalDateTime timestamp = LocalDateTime.now();

    // systÄ‚Â©m automaticky vytvÄ‚Ë‡Äąâ„˘Ä‚Â­ reserved/registered dle kapacity - maxPlayers
    @Column(nullable = false, updatable = true)
    private String createdBy; // "user" nebo "system"

    public MatchRegistrationEntity() {
    }

    // Gettery a Settery


    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public MatchEntity getMatch() {
        return match;
    }

    public void setMatch(MatchEntity match) {
        this.match = match;
    }

    public PlayerEntity getPlayer() {
        return player;
    }

    public void setPlayer(PlayerEntity player) {
        this.player = player;
    }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }

    public ExcuseReason getExcuseReason() {
        return excuseReason;
    }

    public void setExcuseReason(ExcuseReason excuseReason) {
        this.excuseReason = excuseReason;
    }

    public String getExcuseNote() {
        return excuseNote;
    }

    public void setExcuseNote(String excuseNote) {
        this.excuseNote = excuseNote;
    }

    public String getAdminNote() {
        return adminNote;
    }

    public void setAdminNote(String adminNote) {
        this.adminNote = adminNote;
    }

    public Team getTeam() {
        return team;
    }

    public void setTeam(Team team) {
        this.team = team;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }
}





# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationHistoryEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.persistence.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "match_registration_history")
public class MatchRegistrationHistoryEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // ID z pÄąĹ»vodnÄ‚Â­ hlavnÄ‚Â­ tabulky
    @Column(name = "match_registration_id", nullable = false)
    private Long matchRegistrationId;

    @Column(name = "match_id", nullable = false)
    private Long matchId;

    @Column(name = "player_id", nullable = false)
    private Long playerId;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerMatchStatus status;

    @Enumerated(EnumType.STRING)
    @Column(name = "excuse_reason")
    private ExcuseReason excuseReason;

    @Column(name = "excuse_note")
    private String excuseNote;

    @Column(name = "admin_note")
    private String adminNote;

    @Enumerated(EnumType.STRING)
    @Column(name = "team")
    private Team team;

    // pÄąĹ»vodnÄ‚Â­ timestamp
    @Column(name = "original_timestamp", nullable = false)
    private LocalDateTime originalTimestamp;

    @Column(name = "created_by", nullable = false)
    private String createdBy;

    @Column(nullable = false)
    private String action; // INSERT / UPDATE / DELETE

    @Column(name = "changed_at", nullable = false)
    private LocalDateTime changedAt;

    public MatchRegistrationHistoryEntity() {
    }

    // Gettery a settery


    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getMatchRegistrationId() {
        return matchRegistrationId;
    }

    public void setMatchRegistrationId(Long matchRegistrationId) {
        this.matchRegistrationId = matchRegistrationId;
    }

    public Long getMatchId() {
        return matchId;
    }

    public void setMatchId(Long matchId) {
        this.matchId = matchId;
    }

    public Long getPlayerId() {
        return playerId;
    }

    public void setPlayerId(Long playerId) {
        this.playerId = playerId;
    }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }

    public ExcuseReason getExcuseReason() {
        return excuseReason;
    }

    public void setExcuseReason(ExcuseReason excuseReason) {
        this.excuseReason = excuseReason;
    }

    public String getExcuseNote() {
        return excuseNote;
    }

    public void setExcuseNote(String excuseNote) {
        this.excuseNote = excuseNote;
    }

    public String getAdminNote() {
        return adminNote;
    }

    public void setAdminNote(String adminNote) {
        this.adminNote = adminNote;
    }

    public Team getTeam() {
        return team;
    }

    public void setTeam(Team team) {
        this.team = team;
    }

    public LocalDateTime getOriginalTimestamp() {
        return originalTimestamp;
    }

    public void setOriginalTimestamp(LocalDateTime originalTimestamp) {
        this.originalTimestamp = originalTimestamp;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }

    public String getAction() {
        return action;
    }

    public void setAction(String action) {
        this.action = action;
    }

    public LocalDateTime getChangedAt() {
        return changedAt;
    }

    public void setChangedAt(LocalDateTime changedAt) {
        this.changedAt = changedAt;
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerType;
import jakarta.persistence.*;

@Entity
@Table(name = "player_entity")
public class PlayerEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String surname;

    private String nickName;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerType type; // VIP, STANDARD, BASIC

    private String fullName;
    private String phoneNumber;

    @Enumerated(EnumType.STRING)
    private Team team;

    @Enumerated(EnumType.STRING)
    private PlayerStatus status = PlayerStatus.PENDING;


    // Many-to-One: kaÄąÄľdÄ‚Ëť hrÄ‚Ë‡Ă„Ĺ¤ patÄąâ„˘Ä‚Â­ jednomu uÄąÄľivateli
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private AppUserEntity user;

    // ----------------- Konstruktor -----------------
    public PlayerEntity() {
        this.type = PlayerType.BASIC;
    }

    public PlayerEntity(String name, String surname, String nickName, PlayerType type, String phoneNumber, Team team, PlayerStatus status) {
        this.name = name;
        this.surname = surname;
        this.nickName = nickName;
        this.type = type;
        this.fullName = name + " " + surname;
        this.phoneNumber = phoneNumber;
        this.team = team;
        this.status = status;
    }

    // ----------------- Gettery a Settery -----------------
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
        updateFullName();
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
        updateFullName();
    }

    public String getNickname() { return nickName;}
    public void setNickname(String nickName) { this.nickName = nickName; }

    public String getFullName() {
        return fullName;
    }

    public PlayerType getType() {
        return type;
    }
    public void setType(PlayerType type) {
        this.type = type;
    }

    private void updateFullName() {
        this.fullName = name + " " + surname;
    }

    public String getPhoneNumber() {
        return phoneNumber;
    }
    public void setPhoneNumber(String phoneNumber) {
        this.phoneNumber = phoneNumber;
    }

    public Team getTeam() {
        return team;
    }
    public void setTeam(Team team) {
        this.team = team;
    }

    public AppUserEntity getUser() {
        return user;
    }
    public void setUser(AppUserEntity user) {
        this.user = user;
    }

    public PlayerStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerStatus status) {
        this.status = status;
    }

    public String getNickName() {
        return nickName;
    }

    public void setNickName(String nickName) {
        this.nickName = nickName;
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerInactivityPeriodEntity.java


package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "player_inactivity_period")
public class PlayerInactivityPeriodEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    // neaktivnÄ‚Â­ od
    @Column(name = "inactive_from", nullable = false)
    private LocalDateTime inactiveFrom;

    // neaktivnÄ‚Â­ do
    @Column(name = "inactive_to", nullable = false)
    private LocalDateTime inactiveTo;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public PlayerEntity getPlayer() {
        return player;
    }

    public void setPlayer(PlayerEntity player) {
        this.player = player;
    }

    public LocalDateTime getInactiveFrom() {
        return inactiveFrom;
    }

    public void setInactiveFrom(LocalDateTime inactiveFrom) {
        this.inactiveFrom = inactiveFrom;
    }

    public LocalDateTime getInactiveTo() {
        return inactiveTo;
    }

    public void setInactiveTo(LocalDateTime inactiveTo) {
        this.inactiveTo = inactiveTo;
    }

}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\ExcuseReason.java


package cz.phsoft.hokej.data.enums;

public enum ExcuseReason {
    NEMOC,
    PRACE,
    NECHE_SE_MI,
    JINE
}



# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\PlayerMatchStatus.java


package cz.phsoft.hokej.data.enums;

public enum PlayerMatchStatus {
    REGISTERED, // registrovÄ‚Ë‡n
    UNREGISTERED, // odhlÄ‚Ë‡ÄąË‡en
    EXCUSED,  // omluven
    RESERVED, // nÄ‚Ë‡hradnÄ‚Â­k
    NO_RESPONSE, // bez odpovĂ„â€şdi
    NO_EXCUSED, // neomluven - byl registrovÄ‚Ë‡n a nepÄąâ„˘iÄąË‡el

}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\PlayerStatus.java


package cz.phsoft.hokej.data.enums;

public enum PlayerStatus {
    PENDING, // Ă„Ĺ¤ekÄ‚Ë‡ na schvÄ‚Ë‡lenÄ‚Â­
    APPROVED, // schvÄ‚Ë‡leno administrÄ‚Ë‡torem
    REJECTED // zamÄ‚Â­tnuto
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\PlayerType.java


package cz.phsoft.hokej.data.enums;

public enum PlayerType {
    VIP,
    STANDARD,
    BASIC
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\Role.java


package cz.phsoft.hokej.data.enums;

public enum Role {
    ROLE_PLAYER,
    ROLE_MANAGER,
    ROLE_ADMIN
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\Team.java


package cz.phsoft.hokej.data.enums;

public enum Team {
    DARK,
    LIGHT

}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\AppUserRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface AppUserRepository extends JpaRepository<AppUserEntity, Long> {
    Optional<AppUserEntity> findByEmail(String email);
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\EmailVerificationTokenRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.EmailVerificationTokenEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface EmailVerificationTokenRepository extends JpaRepository<EmailVerificationTokenEntity, Long> {
    Optional<EmailVerificationTokenEntity> findByToken(String token);
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRegistrationHistoryRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchRegistrationHistoryEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface MatchRegistrationHistoryRepository extends JpaRepository<MatchRegistrationHistoryEntity, Long> {

    // vÄąË‡echny registrace na zÄ‚Ë‡pas
    List<MatchRegistrationHistoryEntity> findByMatchRegistrationIdOrderByChangedAtDesc(Long matchRegistrationId);

    // Historie pro konkrÄ‚Â©tnÄ‚Â­ zÄ‚Ë‡pas
    List<MatchRegistrationHistoryEntity> findByMatchIdOrderByChangedAtDesc(Long matchId);

    // Historie zmĂ„â€şn hrÄ‚Ë‡Ă„Ĺ¤e
    List<MatchRegistrationHistoryEntity> findByPlayerIdOrderByChangedAtDesc(Long playerId);

}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRegistrationRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

    @Repository
    public interface MatchRegistrationRepository extends JpaRepository<MatchRegistrationEntity, Long> {

        // VrÄ‚Ë‡tÄ‚Â­ poslednÄ‚Â­ status pro danÄ‚Â©ho hrÄ‚Ë‡Ă„Ĺ¤e a zÄ‚Ë‡pas
        Boolean existsByPlayerIdAndMatchId(Long playerId, Long matchId);

        // VolitelnĂ„â€ş: vÄąË‡echny registrace pro urĂ„Ĺ¤itÄ‚Ëť zÄ‚Ë‡pas
        List<MatchRegistrationEntity> findByMatchId(Long matchId);

        // VolitelnĂ„â€ş: vÄąË‡echny registrace pro urĂ„Ĺ¤itÄ‚Â©ho hrÄ‚Ë‡Ă„Ĺ¤e
        List<MatchRegistrationEntity> findByPlayerId(Long playerId);

        // --- NovÄ‚Ë‡ metoda pro hledÄ‚Ë‡nÄ‚Â­ konkrÄ‚Â©tnÄ‚Â­ registrace ---
        Optional<MatchRegistrationEntity> findByPlayerIdAndMatchId(Long playerId, Long matchId);

        long countByMatchIdAndStatus(Long matchId, PlayerMatchStatus status);

        List<MatchRegistrationEntity> findByMatchIdIn(List<Long> matchIds);
    }


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import java.time.LocalDateTime;
import java.util.List;

public interface MatchRepository extends JpaRepository<MatchEntity, Long> {
    List<MatchEntity> findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime dateTime);
    List<MatchEntity> findByDateTimeBeforeOrderByDateTimeDesc(LocalDateTime dateTime);
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\PlayerInactivityPeriodRepository.java



package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface PlayerInactivityPeriodRepository extends JpaRepository<PlayerInactivityPeriodEntity, Long> {

    // zjistÄ‚Â­, zda hrÄ‚Ë‡Ă„Ĺ¤ je aktuÄ‚Ë‡lnĂ„â€ş neaktivnÄ‚Â­
    boolean existsByPlayerAndInactiveFromLessThanEqualAndInactiveToGreaterThanEqual(
            PlayerEntity player, LocalDateTime from, LocalDateTime to);

    // zÄ‚Â­skÄ‚Ë‡ vÄąË‡echny neaktivnÄ‚Â­ obdobÄ‚Â­ hrÄ‚Ë‡Ă„Ĺ¤e, kterÄ‚Â© spadajÄ‚Â­ do intervalu
    List<PlayerInactivityPeriodEntity> findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
            PlayerEntity player, LocalDateTime from, LocalDateTime to);

    List<PlayerInactivityPeriodEntity> findByPlayerOrderByInactiveFromAsc(PlayerEntity player);
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\PlayerRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface PlayerRepository extends JpaRepository<PlayerEntity, Long> {
    Optional<PlayerEntity> findById(Long id);

    List<PlayerEntity> findByIdNotIn(List<Long> ids);
    boolean existsByNameAndSurname(String name, String surname);

    Optional<PlayerEntity> findByNameAndSurname(String name, String surname);
    Optional<PlayerEntity> findByUserEmail(String email);
    List<PlayerEntity> findAllByUserEmail(String email);
    List<PlayerEntity> findByUser_EmailOrderByIdAsc(String email);
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\AccountNotActivatedException.java


package cz.phsoft.hokej.exceptions;

import org.springframework.http.HttpStatus;

public class AccountNotActivatedException extends BusinessException {

    public AccountNotActivatedException() {
        super("PrvnÄ‚Â­ musÄ‚Â­te aktivovat Ä‚ĹźĂ„Ĺ¤et pomocÄ‚Â­ odkazu v emailu", HttpStatus.FORBIDDEN); // 403
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\ApiError.java


package cz.phsoft.hokej.exceptions;

import com.fasterxml.jackson.annotation.JsonFormat;
import java.time.LocalDateTime;
import java.util.Map;

public class ApiError {

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime timestamp;
    private int status;
    private String error;
    private String message;
    private String path;
    private String clientIp; // Ă˘â€ Â novĂ„â€ş

    // VolitelnÄ‚Â©: podrobnosti (validace, vÄ‚Â­ce chyb, atd.)
    private Map<String, String> details;

    public ApiError(int status, String error, String message, String path,
                    String clientIp) {
        this.timestamp = LocalDateTime.now();
        this.status = status;
        this.error = error;
        this.message = message;
        this.path = path;
        this.clientIp = clientIp;
    }

    public ApiError(int status,
                            String error,
                            String message,
                            String path,
                            String clientIp,
                            Map<String, String> details) {
        this(status, error, message, path, clientIp);
        this.details = details;
    }

    public LocalDateTime getTimestamp() { return timestamp; }
    public int getStatus() { return status; }
    public String getError() { return error; }
    public String getMessage() { return message; }
    public String getPath() { return path; }
    public String getClientIp() { return clientIp; }
    public Map<String, String> getDetails() { return details; }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\BusinessException.java


package cz.phsoft.hokej.exceptions;

import org.springframework.http.HttpStatus;

public class BusinessException extends RuntimeException {

    private final HttpStatus status;

    protected BusinessException(String message, HttpStatus status) {
        super(message);
        this.status = status;
    }

    public HttpStatus getStatus() {
        return status;
    }
}



# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\DuplicateNameSurnameException.java


package cz.phsoft.hokej.exceptions;

public class DuplicateNameSurnameException extends RuntimeException {
    public DuplicateNameSurnameException(String message) {
        super(message);
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\DuplicateRegistrationException.java


package cz.phsoft.hokej.exceptions;

public class DuplicateRegistrationException extends RuntimeException {
    public DuplicateRegistrationException(Long matchId, Long playerId) {
        super("HrÄ‚Ë‡Ă„Ĺ¤ " + playerId + " jiÄąÄľ mÄ‚Ë‡ aktivnÄ‚Â­ registraci na zÄ‚Ë‡pas " + matchId);
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\InvalidPlayerStatusException.java


package cz.phsoft.hokej.exceptions;

public class InvalidPlayerStatusException extends RuntimeException {
    public InvalidPlayerStatusException(String message) {
        super(message);
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\MatchNotFoundException.java


package cz.phsoft.hokej.exceptions;

public class MatchNotFoundException extends RuntimeException {
    public MatchNotFoundException(Long matchId) {
        super("ZÄ‚Ë‡pas s ID " + matchId + " nenalezen.");;
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\PlayerNotFoundException.java


package cz.phsoft.hokej.exceptions;

import org.springframework.http.HttpStatus;

public class PlayerNotFoundException extends BusinessException {
    public PlayerNotFoundException(Long playerId) {
        super("HrÄ‚Ë‡Ă„Ĺ¤ s ID " + playerId + " nenalezen.", HttpStatus.NOT_FOUND);}
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\RegistrationNotFoundException.java


package cz.phsoft.hokej.exceptions;

public class RegistrationNotFoundException extends RuntimeException {
    public RegistrationNotFoundException(Long matchId, Long playerId) {
        super("HrÄ‚Ë‡Ă„Ĺ¤ " + playerId + " nemÄ‚Ë‡ registraci na zÄ‚Ë‡pas " + matchId);
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\UserAlreadyExistsException.java


package cz.phsoft.hokej.exceptions;

import org.springframework.http.HttpStatus;

public class UserAlreadyExistsException extends BusinessException {

    public UserAlreadyExistsException(String message) {
        super(message, HttpStatus.CONFLICT); // 409
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\AppUserMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.PlayerSummaryDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

import java.util.List;

@Mapper(componentModel = "spring")
public interface AppUserMapper {
    @Mapping(target = "players", source = "players")
    AppUserDTO toDTO(AppUserEntity entity);

    List<AppUserDTO> toDtoList(List<AppUserEntity> entities);

    @Mapping(source = "nickname", target = "nickName")
    @Mapping(target = "fullName", ignore = true)
    PlayerDTO toPlayerDTO(PlayerEntity entity);
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\MatchMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchOverviewDTO;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;

@Mapper(componentModel = "spring")
public interface MatchMapper {

    MatchDTO toDTO(MatchEntity entity);

    MatchEntity toEntity(MatchDTO dto);

    void updateEntity(MatchDTO dto, @MappingTarget MatchEntity entity);
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\MatchRegistrationMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

import java.util.List;

@Mapper(componentModel = "spring")
public interface MatchRegistrationMapper {

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "match", source = "match")
    @Mapping(target = "player", source = "player")
    @Mapping(target = "status", source = "status")
    @Mapping(target = "excuseReason", source = "excuseReason")
    @Mapping(target = "excuseNote", source = "note")
    @Mapping(target = "team", source = "team")
    @Mapping(target = "adminNote", source = "adminNote")
    @Mapping(target = "createdBy", source = "createdBy")
    @Mapping(target = "timestamp", expression = "java(java.time.LocalDateTime.now())")
    MatchRegistrationEntity toEntity(
            MatchEntity match,
            PlayerEntity player,
            PlayerMatchStatus status,
            ExcuseReason excuseReason,
            String note,
            Team team,
            String adminNote,
            String createdBy
    );

    // entity Ă˘â€ â€™ DTO (volitelnÄ‚Â©)
    @Mapping(target = "matchId", source = "match.id")
    @Mapping(target = "playerId", source = "player.id")
    MatchRegistrationDTO toDTO(MatchRegistrationEntity entity);

    List<MatchRegistrationDTO> toDTOList(List<MatchRegistrationEntity> entities);
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\PlayerInactivityPeriodMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import org.mapstruct.*;

@Mapper(componentModel = "spring")
public interface PlayerInactivityPeriodMapper {

    // Entity -> DTO (OK)
    @Mapping(target = "playerId", source = "player.id")
    PlayerInactivityPeriodDTO toDTO(PlayerInactivityPeriodEntity entity);

    // DTO -> Entity (player Äąâ„˘eÄąË‡Ä‚Â­ @ObjectFactory)
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "player", ignore = true)
    PlayerInactivityPeriodEntity toEntity(PlayerInactivityPeriodDTO dto, @Context PlayerEntity player);

    // UPDATE DTO -> existujÄ‚Â­cÄ‚Â­ entity (bez zmĂ„â€şny player)
    @Mapping(target = "player", ignore = true)
    void updateEntityFromDto(PlayerInactivityPeriodDTO dto, @MappingTarget PlayerInactivityPeriodEntity entity);

    // FACTORY Ă˘â‚¬â€ś jedinÄ‚Ëť sprÄ‚Ë‡vnÄ‚Ëť zpÄąĹ»sob, jak nastavit player z @Context
    @ObjectFactory
    default PlayerInactivityPeriodEntity createEntity(PlayerInactivityPeriodDTO dto, @Context PlayerEntity player) {
        PlayerInactivityPeriodEntity entity = new PlayerInactivityPeriodEntity();
        entity.setPlayer(player);
        return entity;
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\PlayerMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

import java.util.List;

@Mapper(componentModel = "spring")
public interface PlayerMapper {

        // Entity Ă˘â€ â€™ DTO (heslo se neposÄ‚Â­lÄ‚Ë‡)
        @Mapping(source = "nickname", target = "nickName")
        @Mapping(target = "fullName", ignore = true) // generuje se v DTO
        PlayerDTO toDTO(PlayerEntity entity);

        // DTO Ă˘â€ â€™ Entity (heslo se mapuje, pokud existuje)
        @Mapping(source = "nickName", target = "nickname")   // KLÄ‚Ĺ¤Ă„ĹšOVÄ‚â€°
        @Mapping(target = "fullName", ignore = true)         // generuje si Entity sama
        @Mapping(target = "user", ignore = true)             // nastavujeÄąË‡ v service
        @Mapping(
                target = "status",
                expression = "java(dto.getStatus() != null ? dto.getStatus() : cz.phsoft.hokej.data.enums.PlayerStatus.PENDING)"
        )
        PlayerEntity toEntity(PlayerDTO dto);

        // Aktualizace existujÄ‚Â­cÄ‚Â­ho DTO (ignorujeme fullName)
        @Mapping(target = "fullName", ignore = true)
        @Mapping(target = "id", ignore = true)
        void updatePlayerDTO(PlayerDTO source, @MappingTarget PlayerDTO target);

        // Aktualizace existujÄ‚Â­cÄ‚Â­ Entity (heslo se mapuje, fullName nenÄ‚Â­ pole v Entity)
        @Mapping(source = "nickName", target = "nickname")   // i tady je dÄąĹ»leÄąÄľitÄ‚Â©
        @Mapping(target = "fullName", ignore = true)
        @Mapping(target = "user", ignore = true)
        @Mapping(
                target = "status",
                expression = "java(source.getStatus() != null ? source.getStatus() : target.getStatus())"
        )
        void updatePlayerEntity(PlayerDTO source, @MappingTarget PlayerEntity target);

    List<PlayerDTO> toDTOList(List<PlayerEntity> players);


}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\requests\MatchRegistrationRequest.java


package cz.phsoft.hokej.models.dto.requests;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.validation.constraints.*;


public class MatchRegistrationRequest {
    @NotNull
    @Positive
    private Long matchId;

    @NotNull
    @Positive
    private Long playerId;

    private Team team;
    private ExcuseReason excuseReason;
    private String excuseNote;
    private String adminNote;
    private boolean unregister;

    public Long getMatchId() { return matchId; }
    public Long getPlayerId() { return playerId; }
    public Team getTeam() { return team; }
    public ExcuseReason getExcuseReason() { return excuseReason; }
    public String getExcuseNote() { return excuseNote; }
    public String getAdminNote() { return adminNote; }
    public boolean isUnregister() { return unregister; }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\AppUserDTO.java


package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.util.Set;

public class AppUserDTO {
    private Long id;
    private String name; // not null
    private String surname;
    private String email;
    private Role role;
    private boolean enabled;
    private Set<PlayerDTO> players; // jednostrannÄ‚Â©


    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public Role getRole() {
        return role;
    }

    public void setRole(Role role) {
        this.role = role;
    }

    public boolean isEnabled() { return enabled; }

    public void setEnabled(boolean enabled) { this.enabled = enabled;}

    public Set<PlayerDTO> getPlayers() {
        return players;
    }

    public void setPlayers(Set<PlayerDTO> players) {
        this.players = players;
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\ChangePasswordDTO.java


package cz.phsoft.hokej.models.dto;

public class ChangePasswordDTO {
    private String oldPassword;
    private String newPassword;
    private String newPasswordConfirm;

    // gettery a settery
    public String getOldPassword() { return oldPassword; }
    public void setOldPassword(String oldPassword) { this.oldPassword = oldPassword; }
    public String getNewPassword() { return newPassword; }
    public void setNewPassword(String newPassword) { this.newPassword = newPassword; }
    public String getNewPasswordConfirm() { return newPasswordConfirm; }
    public void setNewPasswordConfirm(String newPasswordConfirm) { this.newPasswordConfirm = newPasswordConfirm; }
}



# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchDetailDTO.java


package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;

import java.time.LocalDateTime;
import java.util.List;

public class MatchDetailDTO {
    private Long id;
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime dateTime;
    private int maxPlayers;
    private int inGamePlayers;
    private int outGamePlayers;
    private int waitingPlayers;
    private int noActionPlayers;
    private double pricePerRegisteredPlayer;
    private int remainingSlots;

    List<PlayerDTO> registeredPlayers;
    List<PlayerDTO> reservedPlayers;
    List<PlayerDTO> unregisteredPlayers;
    List<PlayerDTO> excusedPlayers;
    List<PlayerDTO> noResponsePlayers;

    // Gettery a settery

    public Long getId() {       return id;    }
    public void setId(Long id) {
        this.id = id;
    }
    public LocalDateTime getDateTime() {
        return dateTime;
    }

    public void setDateTime(LocalDateTime dateTime) {
        this.dateTime = dateTime;
    }

    public int getMaxPlayers() {
        return maxPlayers;
    }
    public void setMaxPlayers(int maxPlayers) {
        this.maxPlayers = maxPlayers;
    }

    public int getInGamePlayers() {
        return inGamePlayers;
    }
    public void setInGamePlayers(int inGamePlayers) {
        this.inGamePlayers = inGamePlayers;
    }

    public void setOutGamePlayers(int outGamePlayers) {
        this.outGamePlayers = outGamePlayers;
    }

    public int getWaitingPlayers() {
        return waitingPlayers;
    }
    public void setWaitingPlayers(int waitingPlayers) {
        this.waitingPlayers = waitingPlayers;
    }

    public int getNoActionPlayers() {
        return noActionPlayers;
    }
    public void setNoActionPlayers(int noActionPlayers) {
        this.noActionPlayers = noActionPlayers;
    }

    public double getPricePerRegisteredPlayer() {
        return pricePerRegisteredPlayer;
    }
    public void setPricePerRegisteredPlayer(double pricePerRegisteredPlayer) {
        this.pricePerRegisteredPlayer = pricePerRegisteredPlayer;
    }

    public int getRemainingSlots() {
        return remainingSlots;
    }
    public void setRemainingSlots(int remainingSlots) {
        this.remainingSlots = remainingSlots;
    }

    public List<PlayerDTO> getRegisteredPlayers() {
        return registeredPlayers;
    }
    public void setRegisteredPlayers(List<PlayerDTO> registeredPlayers) {
        this.registeredPlayers = registeredPlayers;
    }

    public List<PlayerDTO> getReservedPlayers() {
        return reservedPlayers;
    }
    public void setReservedPlayers(List<PlayerDTO> reservedPlayers) {
        this.reservedPlayers = reservedPlayers;
    }

    public List<PlayerDTO> getUnregisteredPlayers() {
        return unregisteredPlayers;
    }

    public void setUnregisteredPlayers(List<PlayerDTO> unregisteredPlayers) {
        this.unregisteredPlayers = unregisteredPlayers;
    }
    public List<PlayerDTO> getExcusedPlayers() {
        return excusedPlayers;
    }
    public void setExcusedPlayers(List<PlayerDTO> excusedPlayers) {
        this.excusedPlayers = excusedPlayers;
    }

    public List<PlayerDTO> getNoResponsePlayers() {
        return noResponsePlayers;
    }
    public void setNoResponsePlayers(List<PlayerDTO> noResponsePlayers) {
        this.noResponsePlayers = noResponsePlayers;
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchDTO.java


package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import jakarta.validation.constraints.FutureOrPresent;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

import java.time.LocalDateTime;

public class MatchDTO {

    private Long id;
    @NotNull(message = "Datum a Ă„Ĺ¤as zÄ‚Ë‡pasu je povinnÄ‚Â©.")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime dateTime;

    @NotBlank(message = "MÄ‚Â­sto zÄ‚Ë‡pasu je povinnÄ‚Â©.")
    @Size(min = 3, max = 100)
    private String location;

    @Size(max = 255, message = "Popis mÄąĹ»ÄąÄľe mÄ‚Â­t max 255 znakÄąĹ».")
    private String description;

    @NotNull(message = "MaximÄ‚Ë‡lnÄ‚Â­ poĂ„Ĺ¤et hrÄ‚Ë‡Ă„Ĺ¤ÄąĹ» je povinnÄ‚Ëť")
    private Integer maxPlayers;

    @NotNull(message = "Cena je povinnÄ‚Ë‡")
    private Integer price;

    // gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }
    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() {
        return price;
    }

    public void setPrice(Integer price) {
        this.price = price;
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchOverviewDTO.java


package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;

import java.time.LocalDateTime;

public class MatchOverviewDTO {

    private Long id;

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime dateTime;

    private String location;
    private String description;
    private Integer price;
    private int maxPlayers;
    private int inGamePlayers;
    private double pricePerRegisteredPlayer;
    private PlayerMatchStatus status;

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getPrice() { return price; }
    public void setPrice(Integer price) { this.price = price; }

    public int getMaxPlayers() { return maxPlayers; }
    public void setMaxPlayers(int maxPlayers) { this.maxPlayers = maxPlayers; }

    public int getInGamePlayers() { return inGamePlayers; }
    public void setInGamePlayers(int inGamePlayers) { this.inGamePlayers = inGamePlayers; }

    public double getPricePerRegisteredPlayer() { return pricePerRegisteredPlayer; }
    public void setPricePerRegisteredPlayer(double pricePerRegisteredPlayer) { this.pricePerRegisteredPlayer = pricePerRegisteredPlayer; }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchRegistrationDTO.java


package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;

public class MatchRegistrationDTO {
    private Long id; // volitelnÄ‚Â©, pÄąâ„˘i GET

    @NotNull(message = "ID zÄ‚Ë‡pasu je povinnÄ‚Â©.")
    @Positive(message = "ID zÄ‚Ë‡pasu musÄ‚Â­ bÄ‚Ëťt kladnÄ‚Â©.")
    private Long matchId;

    @NotNull(message = "ID hrÄ‚Ë‡Ă„Ĺ¤e je povinnÄ‚Â©.")
    @Positive(message = "ID hrÄ‚Ë‡Ă„Ĺ¤e musÄ‚Â­ bÄ‚Ëťt kladnÄ‚Â©.")
    private Long playerId;

    private PlayerMatchStatus status;
    private ExcuseReason excuseReason; // pouze pokud status = EXCUSED
    private String excuseNote;
    private String adminNote;
    private Team team;

    @NotNull
    private String createdBy; // "user" nebo "system"

    private PlayerDTO playerDTO;

    public MatchRegistrationDTO() {}

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public Long getMatchId() { return matchId; }
    public void setMatchId(Long matchId) { this.matchId = matchId; }

    public Long getPlayerId() { return playerId; }
    public void setPlayerId(Long playerId) { this.playerId = playerId; }

    public PlayerMatchStatus getStatus() { return status; }
    public void setStatus(PlayerMatchStatus status) { this.status = status; }

    public ExcuseReason getExcuseReason() { return excuseReason; }
    public void setExcuseReason(ExcuseReason excuseReason) { this.excuseReason = excuseReason; }

    public String getExcuseNote() { return excuseNote; }
    public void setExcuseNote(String excuseNote) { this.excuseNote = excuseNote; }

    public String getAdminNote() { return adminNote; }
    public void setAdminNote(String adminNote) { this.adminNote = adminNote; }

    public Team getTeam() { return team; }
    public void setTeam (Team team) { this.team = team; }

    public String getCreatedBy() { return createdBy; }
    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }
}



# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerDTO.java


package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerType;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class PlayerDTO {


    private Long id; // autogenerated, nullable pÄąâ„˘i create

    @NotBlank(message = "KÄąâ„˘estnÄ‚Â­ jmÄ‚Â©no je povinnÄ‚Â©.")
    @Size(min = 2, max = 50)
    private String name; // not null

    @NotBlank(message = "PÄąâ„˘Ä‚Â­jmenÄ‚Â­ je povinnÄ‚Â©.")
    @Size(min = 2, max = 50)
    private String surname; // not null
    private String nickName;
    private String fullName; // derived
    private String phoneNumber;
    private PlayerType type; // not null, default BASIC
    private Team team;
    private PlayerStatus status;


    public PlayerDTO() {
        this.type = PlayerType.BASIC;
   }

    public PlayerDTO(Long id, String name, String surname, String nickName, PlayerType type, Team team, PlayerStatus status) {
        this.id = id;
        this.name = name;
        this.surname = surname;
        this.nickName = nickName;
        this.type = type != null ? type : PlayerType.BASIC;
        this.updateFullName();
        this.team = team;
        this.status = status != null ? status : PlayerStatus.PENDING;
    }

    // --- Gettery a Settery ---

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; updateFullName(); }

    public String getSurname() { return surname; }
    public void setSurname(String surname) { this.surname = surname; updateFullName(); }

    public String getNickName() { return nickName; }

    public void setNickName(String nickName) { this.nickName = nickName; }

    public String getFullName() { return fullName; }

    private void updateFullName() { this.fullName = name + " " + surname; }

    public PlayerType getType() { return type; }
    public void setType(PlayerType type) { this.type = type != null ? type : PlayerType.BASIC; }

    public Team getTeam() { return team; }
    public void setTeam(Team team) { this.team = team; }

    public String getPhoneNumber() { return phoneNumber; }
    public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }

    public PlayerStatus getStatus() { return status; }
    public void setStatus(PlayerStatus status) { this.status = status != null ? status : PlayerStatus.PENDING;
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerInactivityPeriodDTO.java


package cz.phsoft.hokej.models.dto;

import java.time.LocalDateTime;

public class PlayerInactivityPeriodDTO {

    private Long id;
    private Long playerId;
    private LocalDateTime inactiveFrom;
    private LocalDateTime inactiveTo;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getPlayerId() {
        return playerId;
    }

    public void setPlayerId(Long playerId) {
        this.playerId = playerId;
    }

    public LocalDateTime getInactiveFrom() {
        return inactiveFrom;
    }

    public void setInactiveFrom(LocalDateTime inactiveFrom) {
        this.inactiveFrom = inactiveFrom;
    }

    public LocalDateTime getInactiveTo() {
        return inactiveTo;
    }

    public void setInactiveTo(LocalDateTime inactiveTo) {
        this.inactiveTo = inactiveTo;
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerSummaryDTO.java


package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.enums.Team;

public class PlayerSummaryDTO {
    private Long id;
    private String name;
    private String surname;
    private String fullName;
    private String nickName;
    private PlayerType type;
    private Team team;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public String getFullName() {
        return fullName;
    }

    public void setFullName(String fullName) {
        this.fullName = fullName;
    }

    public String getNickName() {
        return nickName;
    }

    public void setNickName(String nickName) {
        this.nickName = nickName;
    }

    public PlayerType getType() {
        return type;
    }

    public void setType(PlayerType type) {
        this.type = type;
    }

    public Team getTeam() {
        return team;
    }

    public void setTeam(Team team) {
        this.team = team;
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\RegisterUserDTO.java


package cz.phsoft.hokej.models.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class RegisterUserDTO {

    @NotBlank(message = "KÄąâ„˘estnÄ‚Â­ jmÄ‚Â©no je povinnÄ‚Â©.")
    @Size(min = 2, max = 50)
    private String name; // not null

    @NotBlank(message = "PÄąâ„˘Ä‚Â­jmenÄ‚Â­ je povinnÄ‚Â©.")
    @Size(min = 2, max = 50)
    private String surname;

    @NotBlank(message = "email je povinnÄ‚Ëť.")
    @Email
    private String email;

    @NotBlank
    @Size(min = 8, max = 64)
    private String password;

    @NotBlank
    private String passwordConfirm;


    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getPasswordConfirm() {
        return passwordConfirm;
    }

    public void setPasswordConfirm(String passwordConfirm) {
        this.passwordConfirm = passwordConfirm;
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\SuccessResponseDTO.java


package cz.phsoft.hokej.models.dto;

public class SuccessResponseDTO {
    private  String message;
    private Long id;
    private String timestamp;

    public SuccessResponseDTO(String message, Long id, String timestamp) {
        this.message = message;
        this.id = id;
        this.timestamp = timestamp;
    }

    public String getMessage() { return message; }
    public Long getId() { return id; }
    public String getTimestamp() { return timestamp; }

}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\email\EmailService.java


package cz.phsoft.hokej.models.services.email;

import jakarta.mail.MessagingException;
import jakarta.mail.internet.MimeMessage;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

@Service
public class EmailService {
    private final JavaMailSender mailSender;

    @Value("${spring.mail.from}")
    private String fromEmail;

    @Value("${email.enabled:true}")   //
    private boolean emailEnabled;

    public EmailService(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    // ===== 1) JEDNODUCHÄ‚ĹĄ TEXTOVÄ‚ĹĄ EMAIL =====
    @Async
    public void sendSimpleEmail(String to, String subject, String text) {

        if (!emailEnabled) {
            System.out.println("MAIL JE VYPNUTÄ‚ĹĄ Ă˘â‚¬â€ś email nebyl odeslÄ‚Ë‡n na: " + to);
            return;
        }


        try {
            SimpleMailMessage message = new SimpleMailMessage();
            message.setTo(to);
            message.setSubject(subject);
            message.setText(text);
            message.setFrom(fromEmail);

            mailSender.send(message);
        } catch (Exception e) {
            // DoporuĂ„Ĺ¤eno: logovat do souboru
            throw new RuntimeException("Chyba pÄąâ„˘i odesÄ‚Â­lÄ‚Ë‡nÄ‚Â­ emailu: " + e.getMessage(), e);
        }
    }

    // ===== 2) HTML EMAIL (HEZĂ„ĹšÄ‚Ĺ¤) =====
    @Async
    public void sendHtmlEmail(String to, String subject, String htmlContent) {

        if (!emailEnabled) {
            System.out.println("MAIL JE VYPNUTÄ‚ĹĄ Ă˘â‚¬â€ś email nebyl odeslÄ‚Ë‡n na: " + to);
            return;
        }

        try {
            MimeMessage mimeMessage = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true, "UTF-8");

            helper.setTo(to);
            helper.setSubject(subject);
            helper.setText(htmlContent, true); // true = HTML
            helper.setFrom(fromEmail);

            mailSender.send(mimeMessage);
        } catch (MessagingException e) {
            throw new RuntimeException("Chyba pÄąâ„˘i odesÄ‚Â­lÄ‚Ë‡nÄ‚Â­ HTML emailu: " + e.getMessage(), e);
        }
    }
    public void sendActivationEmail(String to, String activationLink) {
        String subject = "PotvrĂ„Ĺąte svÄąĹ»j Ä‚ĹźĂ„Ĺ¤et";
        String text = "DobrÄ‚Ëť den,\n\n"
                + "KliknĂ„â€şte na tento odkaz pro aktivaci Ä‚ĹźĂ„Ĺ¤tu:\n"
                + activationLink + "\n\n"
                + "Platnost odkazu: 24 hodin.\n\n"
                + "DĂ„â€şkujeme!";
        sendSimpleEmail(to, subject, text);
    }

    @Async
    public void sendActivationEmailHTML(String to, String activationLink) {
        String subject = "PotvrzenÄ‚Â­ registrace - App - Hokej StarÄ‚Ë‡ Garda";
        String html = "<p>DĂ„â€şkujeme za registraci.</p>" +
                "<p>KliknĂ„â€şte na odkaz pro aktivaci Ä‚ĹźĂ„Ĺ¤tu:</p>" +
                "<a href=\"" + activationLink + "\">Aktivovat Ä‚ĹźĂ„Ĺ¤et</a>";

        sendHtmlEmail(to, subject, html);
    }

}



# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsMessageBuilder.java


package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import org.springframework.stereotype.Component;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;

import java.time.format.DateTimeFormatter;

@Component
public class SmsMessageBuilder {

    private final MatchRegistrationRepository matchRegistrationRepository;
    private final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");

    public SmsMessageBuilder(MatchRegistrationRepository matchRegistrationRepository) {
        this.matchRegistrationRepository = matchRegistrationRepository;
    }

    // --------------------------
    // zprÄ‚Ë‡va po registraci/odhlÄ‚Ë‡ÄąË‡enÄ‚Â­/omluvenÄ‚Â­
    // --------------------------
    public String buildMessageRegistration(MatchRegistrationEntity registration) {
        PlayerMatchStatus status = registration.getStatus();
        String statusText = switch (status) {
            case REGISTERED -> "pÄąâ„˘ihlÄ‚Ë‡sil se k zÄ‚Ë‡pasu";
            case UNREGISTERED -> "odhlÄ‚Ë‡sil se ze zÄ‚Ë‡pasu";
            case EXCUSED -> "omluven";
            default -> "neznÄ‚Ë‡mÄ‚Ëť stav";
        };

        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(registration.getMatch().getId(), PlayerMatchStatus.REGISTERED);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - datum: ")
                .append(registration.getMatch().getDateTime().toLocalDate());

        if (status != PlayerMatchStatus.EXCUSED) {
            sb.append(", ").append(registeredCount)
                    .append("/").append(registration.getMatch().getMaxPlayers());
        }

        sb.append(", hrÄ‚Ë‡Ă„Ĺ¤: ").append(registration.getPlayer().getFullName())
                .append(", status: ").append(statusText);

        return sb.toString();
    }

    // --------------------------
    // zprÄ‚Ë‡va pro hrÄ‚Ë‡Ă„Ĺ¤e, kteÄąâ„˘Ä‚Â­ jeÄąË‡tĂ„â€ş nereagovali
    // --------------------------
    public String buildMessageNoResponse(PlayerDTO player, MatchEntity match) {
        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - upozornĂ„â€şnÄ‚Â­: zÄ‚Ë‡pas ")
                .append(match.getDateTime().format(dateFormatter))
                .append(" - volnÄ‚Ë‡ mÄ‚Â­sta: ")
                .append(match.getMaxPlayers() - registeredCount)
                .append(". JeÄąË‡tĂ„â€ş jste nereagoval.");

        return sb.toString();
    }

    // --------------------------
    // finÄ‚Ë‡lnÄ‚Â­ pÄąâ„˘ipomÄ‚Â­nka pro pÄąâ„˘ihlÄ‚Ë‡ÄąË‡enÄ‚Â© hrÄ‚Ë‡Ă„Ĺ¤e v den zÄ‚Ë‡pasu
    // --------------------------
    public String buildMessageFinal(MatchRegistrationEntity registration) {
        MatchEntity match = registration.getMatch();
        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);

        double pricePerPlayer = match.getPrice() / Math.max(registeredCount, 1);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - pÄąâ„˘ipomÄ‚Â­nka zÄ‚Ë‡pasu ")
                .append(match.getDateTime().format(dateFormatter))
                .append(", pÄąâ„˘ihlÄ‚Ë‡ÄąË‡eno: ").append(registeredCount).append("/").append(match.getMaxPlayers())
                .append(", cena na hrÄ‚Ë‡Ă„Ĺ¤e: ").append(String.format("%.2f KĂ„Ĺ¤", pricePerPlayer));

        return sb.toString();
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsSchedulerService.java


package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import jakarta.transaction.Transactional;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.List;

@Service
public class SmsSchedulerService {

    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository registrationRepository;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;
    private final MatchRegistrationService matchRegistrationService;

    public SmsSchedulerService(
            MatchRepository matchRepository,
            MatchRegistrationRepository registrationRepository,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder,
            MatchRegistrationService matchRegistrationService) {

        this.matchRepository = matchRepository;
        this.registrationRepository = registrationRepository;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
        this.matchRegistrationService = matchRegistrationService;
    }

    // PoslÄ‚Ë‡nÄ‚Â­ SMS v den zÄ‚Ë‡pasu
    // SpustÄ‚Â­ se kaÄąÄľdÄ‚Ëť den v 12:30
    @Scheduled(cron = "0 30 12 * * *")
    @Transactional
    public void sendFinalSmsForTodayMatches() {

        LocalDate today = LocalDate.now();

        // najdeme vÄąË‡echny dneÄąË‡nÄ‚Â­ zÄ‚Ë‡pasy
        List<MatchEntity> todaysMatches = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().toLocalDate().isEqual(today))
                .toList();

        for (MatchEntity match : todaysMatches) {

            // naĂ„Ĺ¤teme vÄąË‡echny registrace k danÄ‚Â©mu zÄ‚Ë‡pasu (BEZ zmĂ„â€şn entit)
            List<MatchRegistrationEntity> registrations =
                    registrationRepository.findByMatchId(match.getId());

            for (MatchRegistrationEntity reg : registrations) {

                // pouÄąÄľijeÄąË‡ svÄąĹ»j pÄąĹ»vodnÄ‚Â­ builder
                String smsMsg = smsMessageBuilder.buildMessageFinal(reg);

                try {
                    smsService.sendSms(reg.getPlayer().getPhoneNumber(), smsMsg);
                    System.out.println("FinÄ‚Ë‡lnÄ‚Â­ SMS poslÄ‚Ë‡na hrÄ‚Ë‡Ă„Ĺ¤i "
                            + reg.getPlayer().getFullName() + ": " + smsMsg);

                } catch (Exception e) {
                    System.err.println("Chyba SMS pro hrÄ‚Ë‡Ă„Ĺ¤e "
                            + reg.getPlayer().getFullName() + ": " + e.getMessage());
                }
            }
        }
    }

    // poslÄ‚Ë‡nÄ‚Â­ SMS 3 dny pÄąâ„˘ed zÄ‚Ë‡pasem - noresponse player
    @Scheduled(cron = "0 40 14 * * *") // kaÄąÄľdÄ‚Ëť den ve 12:30
    @Transactional
    public void sendNoResponseSmsForMatchesIn3Days() {

        LocalDate targetDate = LocalDate.now().plusDays(3);

        // vÄąË‡echny zÄ‚Ë‡pasy, kterÄ‚Â© jsou za 3 dny
        List<MatchEntity> matchesInThreeDays = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().toLocalDate().isEqual(targetDate))
                .toList();

        for (MatchEntity match : matchesInThreeDays) {

            // pouÄąÄľijeme tvÄąĹ»j existujÄ‚Â­cÄ‚Â­ helper
            List<PlayerDTO> noResponsePlayers =
                    matchRegistrationService.getNoResponsePlayers(match.getId());

            for (PlayerDTO player : noResponsePlayers) {

                String smsMsg = smsMessageBuilder.buildMessageNoResponse(player, match);

                try {
                    smsService.sendSms(player.getPhoneNumber(), smsMsg);
                    System.out.println("NORESPONSE SMS poslÄ‚Ë‡na hrÄ‚Ë‡Ă„Ĺ¤i "
                            + player.getFullName() + ": " + smsMsg);
                } catch (Exception e) {
                    System.err.println("Chyba NORESPONSE SMS pro hrÄ‚Ë‡Ă„Ĺ¤e "
                            + player.getFullName() + ": " + e.getMessage());
                }
            }
        }
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsService.java


package cz.phsoft.hokej.models.services.sms;

public interface SmsService {
    void sendSms(String phoneNumber, String message);
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsServiceImpl.java


/* package cz.phsoft.hokej.models.services.sms;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;

@Service
public class SmsServiceImpl {

   // private final RestTemplate restTemplate = new RestTemplate();

    @Value("${textbee.api-url}")
    private String apiUrl;

    @Value("${textbee.api-key}")
    private String apiKey;

    // testovacÄ‚Â­ Ă„Ĺ¤Ä‚Â­slo
    //private final String testNumber = "+420776609956";

    /**
     * OdeÄąË‡le SMS na testovacÄ‚Â­ Ă„Ĺ¤Ä‚Â­slo.
     * @param message text zprÄ‚Ë‡vy
     */

/*
    public void sendSms(String phoneNumber, String message) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("x-api-key", apiKey);

        Map<String, Object> body = Map.of(
                "recipients", List.of(phoneNumber),
                "message", message
        );

        HttpEntity<Map<String,Object>> request = new HttpEntity<>(body, headers);

        try {
            ResponseEntity<String> response = restTemplate.postForEntity(apiUrl, request, String.class);
            System.out.println("SMS poslÄ‚Ë‡na na testovacÄ‚Â­ Ă„Ĺ¤Ä‚Â­slo  xxx   : " + response.getBody());
        } catch (Exception e) {
            System.err.println("Chyba pÄąâ„˘i odesÄ‚Â­lÄ‚Ë‡nÄ‚Â­ SMS: " + e.getMessage());
        }
    }

*/


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsTextBeeService.java


package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.models.services.sms.SmsService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;

// textbee - free s omezenÄ‚Â­m na 50 sms / den
@Service
public class SmsTextBeeService implements SmsService {

    @Value("${sms.enabled:true}")
    private boolean smsEnabled;

    @Value("${textbee.api-url}")
    private String apiUrl;

    @Value("${textbee.api-key}")
    private String apiKey;

    private final RestTemplate restTemplate = new RestTemplate();

    @Override
    public void sendSms(String phoneNumber, String message) {
        if (!smsEnabled) {
            System.out.println("SMS disabled, message not sent: " + message);
            return;
        }

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("x-api-key", apiKey);

        Map<String, Object> body = Map.of(
                "recipients", List.of(phoneNumber),
                "message", message
        );

        HttpEntity<Map<String,Object>> request = new HttpEntity<>(body, headers);

        try {
            ResponseEntity<String> response = restTemplate.postForEntity(apiUrl, request, String.class);
            System.out.println("SMS odeslÄ‚Ë‡na hrÄ‚Ë‡Ă„Ĺ¤i: " + phoneNumber + ", response: " + response.getBody());
        } catch (Exception e) {
            System.err.println("Chyba pÄąâ„˘i odesÄ‚Â­lÄ‚Ë‡nÄ‚Â­ SMS: " + e.getMessage());
        }
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;

import java.util.List;

public interface AppUserService {
    /**
     * Registrace novÄ‚Â©ho uÄąÄľivatele
     *
     * @param registerUserDTO data pro registraci
     * @throws IllegalArgumentException pokud email existuje nebo hesla se neshodujÄ‚Â­
     */
    void register(RegisterUserDTO registerUserDTO);

    AppUserDTO getCurrentUser(String email);

    List<AppUserDTO> getAllUsers();

    void changePassword(String email, String oldPassword, String newPassword, String newPasswordConfirm);

    void resetPassword(Long userId);

    void updateUser(String email, AppUserDTO dto);

    boolean activateUser(String token);
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.EmailVerificationTokenEntity;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.EmailVerificationTokenRepository;
import cz.phsoft.hokej.exceptions.UserAlreadyExistsException;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;
import cz.phsoft.hokej.models.dto.mappers.AppUserMapper;
import cz.phsoft.hokej.models.services.email.EmailService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class AppUserServiceImpl implements AppUserService {

    @Value("${app.base-url}")
    private String baseUrl;

    private final AppUserRepository userRepository;
    private final BCryptPasswordEncoder passwordEncoder;
    private final AppUserMapper appUserMapper;
    private final EmailService emailService;
    private final EmailVerificationTokenRepository tokenRepository;

    public AppUserServiceImpl(AppUserRepository userRepository,
                              BCryptPasswordEncoder passwordEncoder, AppUserMapper appUserMapper,
                              EmailService emailService, EmailVerificationTokenRepository tokenRepository) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
        this.appUserMapper = appUserMapper;
        this.emailService = emailService;
        this.tokenRepository = tokenRepository;
    }

    @Override
    public void register(RegisterUserDTO dto) {
        if (!dto.getPassword().equals(dto.getPasswordConfirm())) {
            throw new IllegalArgumentException("Hesla se neshodujÄ‚Â­");
        }

        if (userRepository.findByEmail(dto.getEmail()).isPresent()) {
            throw new UserAlreadyExistsException("UÄąÄľivatel s tÄ‚Â­mto emailem jiÄąÄľ existuje");
        }

        AppUserEntity user = new AppUserEntity();
        user.setName(dto.getName());
        user.setSurname(dto.getSurname());
        user.setEmail(dto.getEmail());
        user.setPassword(passwordEncoder.encode(dto.getPassword()));
        user.setRole(Role.ROLE_PLAYER);
        user.setEnabled(false); // NEaktivnÄ‚Â­ pÄąâ„˘i registraci

        AppUserEntity savedUser = userRepository.save(user);

        // GenerovÄ‚Ë‡nÄ‚Â­ tokenu
        String token = java.util.UUID.randomUUID().toString();
        EmailVerificationTokenEntity verificationToken = new EmailVerificationTokenEntity();
        verificationToken.setToken(token);
        verificationToken.setUser(savedUser);
        verificationToken.setExpiresAt(java.time.LocalDateTime.now().plusHours(24));

        tokenRepository.save(verificationToken);


        // OdeslÄ‚Ë‡nÄ‚Â­ aktivaĂ„Ĺ¤nÄ‚Â­ho emailu
        String activationLink = baseUrl + "/api/auth/verify?token=" + token;
        // Pro test lokÄ‚Ë‡lnĂ„â€ş: vypÄ‚Â­ÄąË‡e odkaz do konzole
        System.out.println("AktivaĂ„Ĺ¤nÄ‚Â­ odkaz: " + activationLink);

        emailService.sendActivationEmailHTML(savedUser.getEmail(), activationLink);
    }

    @Override
    public boolean activateUser(String token) {
        EmailVerificationTokenEntity verificationToken = tokenRepository.findByToken(token)
                .orElse(null);

        if (verificationToken == null || verificationToken.getExpiresAt().isBefore(java.time.LocalDateTime.now())) {
            return false; // neplatnÄ‚Ëť token nebo vyprÄąË‡el
        }

        AppUserEntity user = verificationToken.getUser();
        user.setEnabled(true); // aktivujeme uÄąÄľivatele
        userRepository.save(user);

        // Po aktivaci token smaÄąÄľeme (nenÄ‚Â­ potÄąâ„˘eba jej uchovÄ‚Ë‡vat)
        tokenRepository.delete(verificationToken);

        return true;
    }

    @Override
    public void updateUser(String email, AppUserDTO dto) {

        AppUserEntity user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("UÄąÄľivatel nenalezen"));

        // NastavenÄ‚Â­ novÄ‚Â©ho hesla
        user.setName(dto.getName());
        user.setSurname(dto.getSurname());
        user.setEmail(dto.getEmail());
        userRepository.save(user);
    }

    @Override
    public AppUserDTO getCurrentUser(String email) {
        AppUserEntity user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("User not found"));

        // Ă˘â€ Â vyuÄąÄľitÄ‚Â­ mapperu
        return appUserMapper.toDTO(user);
    }

    @Override
    public List<AppUserDTO> getAllUsers() {
        return userRepository.findAll().stream()
                .map(appUserMapper::toDTO)
                .toList();
    }

    @Override
    public void changePassword(String email, String oldPassword, String newPassword, String newPasswordConfirm) {
        if (!newPassword.equals(newPasswordConfirm)) {
            throw new IllegalArgumentException("NovÄ‚Ë‡ hesla se neshodujÄ‚Â­");
        }

        AppUserEntity user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("UÄąÄľivatel nenalezen"));

        // OvĂ„â€şÄąâ„˘enÄ‚Â­ starÄ‚Â©ho hesla
        if (!passwordEncoder.matches(oldPassword, user.getPassword())) {
            throw new IllegalArgumentException("StarÄ‚Â© heslo je nesprÄ‚Ë‡vnÄ‚Â©");
        }

        // NastavenÄ‚Â­ novÄ‚Â©ho hesla
        user.setPassword(passwordEncoder.encode(newPassword));
        userRepository.save(user);
    }

    // reset hesla
    @Override
    public void resetPassword(Long userId) {
        AppUserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("UÄąÄľivatel nenalezen"));

        // NastavenÄ‚Â­ novÄ‚Â©ho hesla na "Player123"
        user.setPassword(passwordEncoder.encode("Player123"));
        userRepository.save(user);
    }


}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;

import java.util.List;

public interface MatchRegistrationService {

    // Ä‘Ĺşâ€ťÄ„ VracÄ‚Â­ DTO mÄ‚Â­sto entity
    MatchRegistrationDTO upsertRegistration(
            Long matchId,
            Long playerId,
            Team team,
            String adminNote,
            ExcuseReason excuseReason,
            String excuseNote,
            boolean unregister
    );

    List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId);

    List<MatchRegistrationDTO> getRegistrationsForMatches(List<Long> matchIds);

    List<MatchRegistrationDTO> getAllRegistrations();

    List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId);

    List<PlayerDTO> getNoResponsePlayers(Long matchId);

    void recalcStatusesForMatch(Long matchId);
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.DuplicateRegistrationException;
import cz.phsoft.hokej.exceptions.MatchNotFoundException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.exceptions.RegistrationNotFoundException;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.mappers.MatchRegistrationMapper;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.sms.SmsMessageBuilder;
import cz.phsoft.hokej.models.services.sms.SmsService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
public class MatchRegistrationServiceImpl implements MatchRegistrationService {

    Logger logger = LoggerFactory.getLogger(MatchServiceImpl.class);
    private final MatchRegistrationRepository registrationRepository;
    private final MatchRepository matchRepository;
    private final PlayerRepository playerRepository;
    private final MatchRegistrationMapper matchRegistrationMapper;
    private final PlayerMapper playerMapper;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;

    public MatchRegistrationServiceImpl(
            MatchRegistrationRepository registrationRepository,
            MatchRepository matchRepository,
            PlayerRepository playerRepository,
            MatchRegistrationMapper matchRegistrationMapper,
            PlayerMapper playerMapper,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder) {
        this.registrationRepository = registrationRepository;
        this.matchRepository = matchRepository;
        this.playerRepository = playerRepository;
        this.matchRegistrationMapper = matchRegistrationMapper;
        this.playerMapper = playerMapper;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
    }
    private MatchEntity getMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }
    private PlayerEntity getPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }
    private boolean isSlotAvailable(MatchEntity match) {
        long registeredCount = registrationRepository.countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);
        return registeredCount < match.getMaxPlayers();
    }
    private void sendSms(MatchRegistrationEntity registration, String message) {
        if (registration == null || registration.getPlayer() == null) return;
        try {
            smsService.sendSms(registration.getPlayer().getPhoneNumber(), message);
        } catch (Exception e) {
            System.err.println("Chyba SMS: " + e.getMessage());
        }
    }
    private MatchRegistrationEntity updateRegistrationStatus(
            MatchRegistrationEntity registration, PlayerMatchStatus status, String updatedBy, boolean updateTimestamp) {

        registration.setStatus(PlayerMatchStatus.valueOf(status.name()));
        registration.setCreatedBy(updatedBy);
        if (updateTimestamp) {
            registration.setTimestamp(LocalDateTime.now());
        }
        return registrationRepository.saveAndFlush(registration);
    }
    // -------------------- REGISTRATION --------------------
    @Transactional
    @Override
    public MatchRegistrationDTO upsertRegistration(
            Long matchId,
            Long playerId,
            Team team,
            String adminNote,
            ExcuseReason excuseReason,
            String excuseNote,
            boolean unregister) {

        // TEST: poÄąË‡li ERROR zprÄ‚Ë‡vu pro otestovÄ‚Ë‡nÄ‚Â­ emailu
        logger.error("Test ERROR zprÄ‚Ë‡va pro email");

        MatchEntity match = getMatchOrThrow(matchId);
        PlayerEntity player = getPlayerOrThrow(playerId);

        MatchRegistrationEntity registration = registrationRepository
                .findByPlayerIdAndMatchId(playerId, matchId)
                .orElse(null);

        PlayerMatchStatus newStatus;

        // UNREGISTER: lze pouze kdyÄąÄľ hrÄ‚Ë‡Ă„Ĺ¤ mÄ‚Ë‡ aktuÄ‚Ë‡lnĂ„â€ş REGISTERED
        if (unregister) {
            if (registration == null || registration.getStatus() != PlayerMatchStatus.REGISTERED) {
                throw new RegistrationNotFoundException(matchId, playerId);
            }
            registration.setExcuseReason(null);
            newStatus = PlayerMatchStatus.UNREGISTERED;

            // EXCUSE: lze vytvoÄąâ„˘it pouze pokud hrÄ‚Ë‡Ă„Ĺ¤ NEMÄ‚Â status REGISTERED
        } else if (excuseReason != null) {
            if (registration != null && registration.getStatus() == PlayerMatchStatus.REGISTERED) {
                throw new DuplicateRegistrationException(matchId, playerId);
            }
            // pokud neexistuje, vytvoÄąâ„˘Ä‚Â­me pozici; pokud existuje a nenÄ‚Â­ REGISTERED, povolÄ‚Â­me EXCUSED
            if (registration == null) {
                registration = new MatchRegistrationEntity();
                registration.setMatch(match);
                registration.setPlayer(player);
            }
            registration.setExcuseReason(excuseReason);
            newStatus = PlayerMatchStatus.EXCUSED;

            // REGISTER / RESERVE: lze vytvoÄąâ„˘it pokud hrÄ‚Ë‡Ă„Ĺ¤ NEMÄ‚Â status REGISTERED (tedy i kdyÄąÄľ mÄ‚Ë‡ EXCUSED)
        } else {
            // pokud uÄąÄľ je registrovÄ‚Ë‡n, nepovolÄ‚Â­me duplicitu
            if (registration != null && registration.getStatus() == PlayerMatchStatus.REGISTERED) {
                throw new DuplicateRegistrationException(matchId, playerId);
            }

            newStatus = isSlotAvailable(match) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;

            if (registration == null) {
                registration = new MatchRegistrationEntity();
                registration.setMatch(match);
                registration.setPlayer(player);
            } else {
                // pÄąâ„˘i pÄąâ„˘echodu na register/reserve zruÄąË‡Ä‚Â­me pÄąâ„˘Ä‚Â­padnou vÄ‚Ëťmluvu
                registration.setExcuseReason(null);
            }
        }

        registration.setStatus(newStatus);
        registration.setTimestamp(LocalDateTime.now());
        registration.setCreatedBy("user");

        if (team != null) registration.setTeam(team);
        if (adminNote != null) registration.setAdminNote(adminNote);
        // excuseReason uÄąÄľ jsme nastavili vÄ‚ËťÄąË‡e (pokud to byl EXCUSED pÄąâ„˘Ä‚Â­pad)
        if (excuseReason != null) registration.setExcuseReason(excuseReason);

        registration = registrationRepository.save(registration);

        if (unregister) recalcStatusesForMatch(matchId);

        sendSms(registration, smsMessageBuilder.buildMessageRegistration(registration));

        return matchRegistrationMapper.toDTO(registration);
    }
    // -------------------- FETCH --------------------
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId) {
        return matchRegistrationMapper.toDTOList(registrationRepository.findByMatchId(matchId));
    }

    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatches(List<Long> matchIds) {
        if (matchIds == null || matchIds.isEmpty()) {
            return List.of();
        }

        return matchRegistrationMapper.toDTOList(
                registrationRepository.findByMatchIdIn(matchIds)
        );
    }

    @Override
    public List<MatchRegistrationDTO> getAllRegistrations() {
        return matchRegistrationMapper.toDTOList(registrationRepository.findAll());
    }

    @Override
    public List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId) {
        return matchRegistrationMapper.toDTOList(registrationRepository.findByPlayerId(playerId));
    }

    @Override
    public List<PlayerDTO> getNoResponsePlayers(Long matchId) {
        List<Long> responded = registrationRepository.findByMatchId(matchId).stream()
                .map(r -> r.getPlayer().getId())
                .toList();

        List<PlayerEntity> noResponsePlayers = playerRepository.findAll().stream()
                .filter(p -> !responded.contains(p.getId()))
                .toList();

        return noResponsePlayers.stream()
                .map(playerMapper::toDTO)
                .toList();
    }
    // -------------------- RECALC --------------------
    @Override
    @Transactional
    public void recalcStatusesForMatch(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);
        int maxPlayers = match.getMaxPlayers();

        List<MatchRegistrationEntity> regs = registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED
                        || r.getStatus() == PlayerMatchStatus.RESERVED)
                .sorted((a, b) -> a.getTimestamp().compareTo(b.getTimestamp()))
                .toList();

        for (int i = 0; i < regs.size(); i++) {
            MatchRegistrationEntity reg = regs.get(i);
            PlayerMatchStatus newStatus = (i < maxPlayers) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;
            if (reg.getStatus() != newStatus) updateRegistrationStatus(reg, newStatus, "system", false);
        }
    }

    // -------------------- SMS --------------------
    @Transactional
    public void sendSmsToRegisteredPlayers(Long matchId) {
        registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .forEach(r -> sendSms(r, smsMessageBuilder.buildMessageFinal(r)));
    }

    public void sendNoResponseSmsForMatch(Long matchId) {
        var match = getMatchOrThrow(matchId);

        getNoResponsePlayers(matchId).forEach(player -> {
            String smsMsg = smsMessageBuilder.buildMessageNoResponse(player, match);

            try {
                smsService.sendSms(player.getPhoneNumber(), smsMsg);
            } catch (Exception e) {
                System.err.println("Chyba SMS pro hrÄ‚Ë‡Ă„Ĺ¤e "
                        + player.getFullName() + ": " + e.getMessage());
                logger.error("Chyba pÄąâ„˘i odeslÄ‚Ë‡nÄ‚Â­ SMS hrÄ‚Ë‡Ă„Ĺ¤i {}: {}", player.getFullName(), e.getMessage());
            }
        });
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;
import cz.phsoft.hokej.models.dto.MatchOverviewDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;

import java.util.List;

public interface MatchService {
    List<MatchDTO> getAllMatches();
    List<MatchDTO> getUpcomingMatches();
    List<MatchDTO> getPastMatches();
    MatchDTO getNextMatch();
    MatchDTO getMatchById(Long id);
    MatchDTO createMatch(MatchDTO dto);
    MatchDTO updateMatch(Long id, MatchDTO dto);
    SuccessResponseDTO deleteMatch(Long id);
    MatchDetailDTO getMatchDetail(Long id);
    List<MatchDTO> getAvailableMatchesForPlayer(Long playerId);
    List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId);
    Long getPlayerIdByEmail(String email);
    List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId);
    public List<MatchOverviewDTO> getAllPassedMatchesForPlayer(Long playerId);


}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.MatchNotFoundException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.models.dto.*;
import cz.phsoft.hokej.models.dto.mappers.MatchMapper;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class MatchServiceImpl implements MatchService {

    private final MatchRepository matchRepository;
    private final MatchMapper matchMapper;
    private final MatchRegistrationService registrationService;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodService playerInactivityPeriodService;
    private final PlayerMapper playerMapper;
    private static final String ROLE_ADMIN = "ROLE_ADMIN";
    private static final String ROLE_MANAGER = "ROLE_MANAGER";

    public MatchServiceImpl(MatchRepository matchRepository,
                            MatchMapper matchMapper,
                            MatchRegistrationService registrationService,
                            PlayerRepository playerRepository,
                            PlayerInactivityPeriodService playerInactivityPeriodService,
                            PlayerMapper playerMapper) {
        this.matchRepository = matchRepository;
        this.matchMapper = matchMapper;
        this.registrationService = registrationService;
        this.playerRepository = playerRepository;
        this.playerInactivityPeriodService = playerInactivityPeriodService;
        this.playerMapper = playerMapper;
    }
    // metoda pro zÄ‚Â­skÄ‚Ë‡nÄ‚Â­ vÄąË‡ech zÄ‚Ë‡pasÄąĹ»
    @Override
    public List<MatchDTO> getAllMatches() {
        return matchRepository.findAll().stream()
                .map(matchMapper::toDTO)
                .toList();
    }
    // metoda pro zÄ‚Â­skÄ‚Ë‡nÄ‚Â­ vÄąË‡ech nadchÄ‚Ë‡zejÄ‚Â­cÄ‚Â­ch zÄ‚Ë‡pasÄąĹ»
    @Override
    public List<MatchDTO> getUpcomingMatches() {
        return matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now())
                .stream()
                .map(matchMapper::toDTO)
                .toList();
    }
    // metoda pro zÄ‚Â­skÄ‚Ë‡nÄ‚Â­ uplynulÄ‚Ëťch zÄ‚Ë‡pasÄąĹ»
    public List<MatchDTO> getPastMatches() {
        return matchRepository.findByDateTimeBeforeOrderByDateTimeDesc(LocalDateTime.now())
                .stream()
                .map(matchMapper::toDTO)
                .toList();
    }
    // metoda pro zÄ‚Â­skÄ‚Ë‡nÄ‚Â­ prvnÄ‚Â­ho nadchÄ‚Ë‡zejÄ‚Â­cÄ‚Â­ho zÄ‚Ë‡pasu
    @Override
    public MatchDTO getNextMatch() {
        return matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now())
                .stream()
                .findFirst()
                .map(matchMapper::toDTO)
                .orElse(null);
    }
    // metoda pro zÄ‚Ë‡pas dle ID
    @Override
    public MatchDTO getMatchById(Long id) {
        return matchMapper.toDTO(findMatchOrThrow(id));
    }

    // metoda pro vytvoÄąâ„˘enÄ‚Â­ zÄ‚Ë‡pasu
    @Override
    public MatchDTO createMatch(MatchDTO dto) {
        MatchEntity entity = matchMapper.toEntity(dto);
        return matchMapper.toDTO(matchRepository.save(entity));
    }

    // metoda pro Ä‚Ĺźpravu zÄ‚Ë‡pasu
    @Override
    public MatchDTO updateMatch(Long id, MatchDTO dto) {
        MatchEntity match = findMatchOrThrow(id);

        int oldMaxPlayers = match.getMaxPlayers();
        matchMapper.updateEntity(dto, match);
        MatchEntity saved = matchRepository.save(match);

        // PÄąâ„˘epoĂ„Ĺ¤et registracÄ‚Â­ pokud doÄąË‡lo ke zmĂ„â€şnĂ„â€ş maxPlayers
        if (saved.getMaxPlayers() != oldMaxPlayers) {
            registrationService.recalcStatusesForMatch(saved.getId());
        }

        return matchMapper.toDTO(saved);
    }

    // metoda pro odstranĂ„â€şnÄ‚Â­ zÄ‚Ë‡pasu
    @Override
    public SuccessResponseDTO deleteMatch(Long id) {
        MatchEntity match = findMatchOrThrow(id);

        // 2) Pokud existuje, smaÄąÄľeme ho
        matchRepository.delete(match);

        return new SuccessResponseDTO(
                "ZÄ‚Ë‡pas " + match.getId() + match.getDateTime() + " byl Ä‚ĹźspĂ„â€şÄąË‡nĂ„â€ş smazÄ‚Ë‡n",
                id,
                LocalDateTime.now().toString()
        );
    }

    // metoda pro detail zÄ‚Ë‡pasu - omezen vÄ‚Ëťpis pro ADMIN, MANAGER, PLAYER
    @Override
    public MatchDetailDTO getMatchDetail(Long id) {
        MatchEntity match = findMatchOrThrow(id);
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();

        boolean isAdminOrManager = auth != null && auth.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals(ROLE_ADMIN) || a.getAuthority().equals(ROLE_MANAGER));

        // oddĂ„â€şlena logika pÄąâ„˘Ä‚Â­stupu hrÄ‚Ë‡Ă„Ĺ¤e do privÄ‚Ë‡tnÄ‚Â­ metody
        checkAccessForPlayer(match, auth);

        // sbĂ„â€şr statistik hrÄ‚Ë‡Ă„Ĺ¤ÄąĹ» pÄąâ„˘es privÄ‚Ë‡tnÄ‚Â­ metodu
        return collectPlayerStatus(match, isAdminOrManager);
    }

    // privÄ‚Ë‡tnÄ‚Â­ metoda pro kontrolu pÄąâ„˘Ä‚Â­stupu hrÄ‚Ë‡Ă„Ĺ¤e - jen pokud byl registrovÄ‚Ë‡n na zÄ‚Ë‡pas
    private void checkAccessForPlayer(MatchEntity match, Authentication auth) {
        if (auth == null || !auth.isAuthenticated()) return;

        boolean isAdminOrManager = auth.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals(ROLE_ADMIN) || a.getAuthority().equals(ROLE_MANAGER));

        if (isAdminOrManager) return;

        Object principal = auth.getPrincipal();
        if (!(principal instanceof org.springframework.security.core.userdetails.UserDetails userDetails)) return;

        List<PlayerEntity> ownedPlayers = playerRepository.findAll().stream()
                .filter(p -> p.getUser() != null && p.getUser().getEmail().equals(userDetails.getUsername()))
                .toList();

        boolean hasRestrictedPlayer = ownedPlayers.stream()
                .anyMatch(p -> {
                    List<MatchRegistrationDTO> registrations = registrationService.getRegistrationsForMatch(match.getId());

                    boolean noResponse = registrations.stream()
                            .noneMatch(r -> r.getPlayerId().equals(p.getId()));

                    boolean inactiveForMatch = !playerInactivityPeriodService.isActive(p, match.getDateTime());

                    return noResponse || inactiveForMatch;
                });

        if (hasRestrictedPlayer) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "NemÄ‚Ë‡te pÄąâ„˘Ä‚Â­stup k detailu tohoto zÄ‚Ë‡pasu."
            );
        }
    }

    // privÄ‚Ë‡tnÄ‚Â­ metoda pro sbĂ„â€şr statistik hrÄ‚Ë‡Ă„Ĺ¤ÄąĹ»
    private MatchDetailDTO collectPlayerStatus(MatchEntity match, boolean isAdminOrManager) {
        List<MatchRegistrationDTO> registrations = registrationService.getRegistrationsForMatch(match.getId());

        // PÄąâ„˘evod vÄąË‡ech registracÄ‚Â­ na Map<PlayerMatchStatus, List<PlayerDTO>>
        var statusToPlayersMap = registrations.stream()
                .map(r -> playerRepository.findById(r.getPlayerId())
                        .map(playerMapper::toDTO)
                        .map(dto -> new java.util.AbstractMap.SimpleEntry<>(r.getStatus(), dto))
                )
                .filter(java.util.Optional::isPresent) // odstranÄ‚Â­me chybĂ„â€şjÄ‚Â­cÄ‚Â­ hrÄ‚Ë‡Ă„Ĺ¤e
                .map(java.util.Optional::get)
                .collect(Collectors.groupingBy(
                        java.util.Map.Entry::getKey,
                        Collectors.mapping(java.util.Map.Entry::getValue, Collectors.toList())
                ));

        List<PlayerEntity> allPlayers = playerRepository.findAll();
        Set<Long> respondedIds = registrations.stream()
                .map(MatchRegistrationDTO::getPlayerId)
                .collect(Collectors.toSet());

        List<PlayerDTO> noResponsePlayers = allPlayers.stream()
                .filter(p -> !respondedIds.contains(p.getId()))
                .map(playerMapper::toDTO)
                .toList();

        // PoĂ„Ĺ¤ty hrÄ‚Ë‡Ă„Ĺ¤ÄąĹ» podle statusu
        int inGamePlayers = statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()).size();
        int outGamePlayers = statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()).size()
                + statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()).size();
        int waitingPlayers = statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()).size();
        int noActionPlayers = noResponsePlayers.size();
        int remainingSlots = match.getMaxPlayers() - inGamePlayers;
        double pricePerRegistered = inGamePlayers > 0 ? match.getPrice() / (double) inGamePlayers : 0;

        MatchDetailDTO dto = new MatchDetailDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setMaxPlayers(match.getMaxPlayers());
        dto.setInGamePlayers(inGamePlayers);
        dto.setOutGamePlayers(outGamePlayers);
        dto.setWaitingPlayers(waitingPlayers);
        dto.setNoActionPlayers(noActionPlayers);
        dto.setPricePerRegisteredPlayer(pricePerRegistered);
        dto.setRemainingSlots(remainingSlots);

        // NastavenÄ‚Â­ hrÄ‚Ë‡Ă„Ĺ¤ÄąĹ» podle statusu z mapy
        dto.setRegisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()));
        dto.setReservedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()));
        dto.setUnregisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()));
        dto.setExcusedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()));

        // pouze admin/manager uvidÄ‚Â­ no-response hrÄ‚Ë‡Ă„Ĺ¤e
        dto.setNoResponsePlayers(isAdminOrManager ? noResponsePlayers : null);

        return dto;
    }

    // dostupnÄ‚Â© zÄ‚Ë‡pasy pro hrÄ‚Ë‡Ă„Ĺ¤e - byl nebo je aktivnÄ‚Â­
    @Override
    public List<MatchDTO> getAvailableMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        // Filtrace pÄąâ„˘es stream bez mezivÄ‚ËťsledkÄąĹ»
        return matchRepository.findAll().stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .map(matchMapper::toDTO)
                .toList();
    }

    // zÄ‚Â­skÄ‚Ë‡nÄ‚Â­ hrÄ‚Ë‡Ă„Ĺ¤e dle emailu
    public Long getPlayerIdByEmail(String email) {
        return playerRepository.findByUserEmail(email)
                .map(PlayerEntity::getId)
                .orElseThrow(() -> new RuntimeException("HrÄ‚Ë‡Ă„Ĺ¤ s emailem " + email + " nenalezen"));
    }


    // nÄ‚Ë‡hled nadchÄ‚Ë‡zejÄ‚Â­cÄ‚Â­ch zÄ‚Ë‡pasu pro hrÄ‚Ë‡Ă„Ĺ¤e - dle PlayerType
    @Override
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        // 1) NejbliÄąÄľÄąË‡Ä‚Â­ nadchÄ‚Ë‡zejÄ‚Â­cÄ‚Â­ zÄ‚Ë‡pasy podle data
        List<MatchEntity> upcomingAll = matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now());

        // 2) OmezenÄ‚Â­ podle typu hrÄ‚Ë‡Ă„Ĺ¤e
        List<MatchEntity> limited = switch (type) {
            case VIP -> upcomingAll;
            case STANDARD -> upcomingAll.stream().limit(2).toList();
            case BASIC -> upcomingAll.isEmpty() ? List.of() : List.of(upcomingAll.get(0));
        };

        // 3) FiltrovÄ‚Ë‡nÄ‚Â­ podle aktivity hrÄ‚Ë‡Ă„Ĺ¤e a mapovÄ‚Ë‡nÄ‚Â­ na MatchOverviewDTO
        return limited.stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .map(match -> toOverviewDTO(match, playerId))
                .toList();
    }

    // nadchÄ‚Ë‡zejÄ‚Â­cÄ‚Â­ zÄ‚Ë‡pas
    @Override
    public List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        // 1) NejbliÄąÄľÄąË‡Ä‚Â­ nadchÄ‚Ë‡zejÄ‚Â­cÄ‚Â­ zÄ‚Ë‡pasy podle data
        List<MatchEntity> upcomingAll = matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now());

        List<MatchEntity> limited = switch (type) {
            case VIP -> upcomingAll;
            case STANDARD -> upcomingAll.stream().limit(2).toList();
            case BASIC -> upcomingAll.isEmpty() ? List.of() : List.of(upcomingAll.get(0));
        };

        // 2) FiltrovÄ‚Ë‡nÄ‚Â­ podle aktivity hrÄ‚Ë‡Ă„Ĺ¤e
        return limited.stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .map(matchMapper::toDTO)
                .toList();
    }

    // pomocnÄ‚Â© metody
    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    private MatchEntity findMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }

    private MatchOverviewDTO toOverviewDTO(MatchEntity match) {
        MatchOverviewDTO dto = new MatchOverviewDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setLocation(match.getLocation());
        dto.setDescription(match.getDescription());
        dto.setPrice(match.getPrice());
        dto.setMaxPlayers(match.getMaxPlayers());


        // poĂ„Ĺ¤et registrovanÄ‚Ëťch hrÄ‚Ë‡Ă„Ĺ¤ÄąĹ»
        int inGamePlayers = registrationService.getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .mapToInt(r -> 1)
                .sum();
        dto.setInGamePlayers(inGamePlayers);

        // cena na registrovanÄ‚Â©ho hrÄ‚Ë‡Ă„Ĺ¤e
        double pricePerPlayer = inGamePlayers > 0 && match.getPrice() != null
                ? match.getPrice() / (double) inGamePlayers : 0;
        dto.setPricePerRegisteredPlayer(pricePerPlayer);



        return dto;
    }

    private MatchOverviewDTO toOverviewDTO(MatchEntity match, Long playerId) {

        MatchOverviewDTO dto = toOverviewDTO(match); // Ă˘â€ Â znovupouÄąÄľitÄ‚Â­ tvÄ‚Â© pÄąĹ»vodnÄ‚Â­ metody

        PlayerMatchStatus status = registrationService
                .getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getPlayerId().equals(playerId))
                .map(MatchRegistrationDTO::getStatus)
                .findFirst()
                .filter(s ->
                        s == PlayerMatchStatus.REGISTERED ||
                                s == PlayerMatchStatus.UNREGISTERED ||
                                s == PlayerMatchStatus.EXCUSED ||
                                s == PlayerMatchStatus.RESERVED
                )
                .orElse(PlayerMatchStatus.NO_RESPONSE);

        dto.setStatus(status);
        return dto;
    }

    @Override
    public List<MatchOverviewDTO> getAllPassedMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        // Vezmeme dostupnÄ‚Â© zÄ‚Ë‡pasy jako entity (bez DTO)
        List<MatchEntity> availableMatches = matchRepository.findAll().stream()
                .filter(match -> match.getDateTime().isBefore(LocalDateTime.now()) || match.getDateTime().isEqual(LocalDateTime.now()))
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .toList();

        if (availableMatches.isEmpty()) {
            return List.of();
        }

        // VÄąË‡echny ID zÄ‚Ë‡pasÄąĹ»
        List<Long> matchIds = availableMatches.stream()
                .map(MatchEntity::getId)
                .toList();

        // Jeden jedinÄ‚Ëť dotaz na vÄąË‡echny registrace
        List<MatchRegistrationDTO> allRegistrations =
                registrationService.getRegistrationsForMatches(matchIds);

        // Mapa: matchId -> (playerId -> status)
        var statusMap = allRegistrations.stream()
                .collect(Collectors.groupingBy(
                        MatchRegistrationDTO::getMatchId,
                        Collectors.toMap(
                                MatchRegistrationDTO::getPlayerId,
                                MatchRegistrationDTO::getStatus,
                                (a, b) -> a
                        )
                ));

        // MapovÄ‚Ë‡nÄ‚Â­ na MatchOverviewDTO + nastavenÄ‚Â­ statusu
        return availableMatches.stream()
                .map(match -> {
                    MatchOverviewDTO overview = toOverviewDTO(match);

                    PlayerMatchStatus status = Optional.ofNullable(statusMap.get(match.getId()))
                            .map(m -> m.get(playerId))
                            .filter(s ->
                                    s == PlayerMatchStatus.REGISTERED ||
                                            s == PlayerMatchStatus.UNREGISTERED ||
                                            s == PlayerMatchStatus.EXCUSED ||
                                            s == PlayerMatchStatus.RESERVED
                            )
                            .orElse(PlayerMatchStatus.NO_RESPONSE);

                    overview.setStatus(status);
                    return overview;
                })
                .toList();
    }



}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;

import java.time.LocalDateTime;
import java.util.List;

public interface PlayerInactivityPeriodService {

    List<PlayerInactivityPeriodDTO> getAll();

    PlayerInactivityPeriodDTO getById(Long id);

    List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId);

    PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto);

    PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto);

    void delete(Long id);

    public boolean isActive(PlayerEntity player, LocalDateTime dateTime);
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.data.repositories.PlayerInactivityPeriodRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.dto.mappers.PlayerInactivityPeriodMapper;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import java.util.List;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

@Service
public class PlayerInactivityPeriodServiceImpl implements PlayerInactivityPeriodService {

    private final PlayerInactivityPeriodRepository inactivityRepository;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodMapper mapper;

    public PlayerInactivityPeriodServiceImpl(PlayerInactivityPeriodRepository inactivityRepository,
                                             PlayerRepository playerRepository,
                                             PlayerInactivityPeriodMapper mapper) {
        this.inactivityRepository = inactivityRepository;
        this.playerRepository = playerRepository;
        this.mapper = mapper;
    }

    @Override
    public List<PlayerInactivityPeriodDTO> getAll() {
        return inactivityRepository.findAll().stream()
                .map(mapper::toDTO)
                .toList();
    }

    @Override
    public PlayerInactivityPeriodDTO getById(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException(
                        "ObdobÄ‚Â­ neaktivity s ID " + id + " neexistuje."
                ));
        return mapper.toDTO(entity);
    }

    @Override
    public List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId) {
        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new RuntimeException("Player not found"));

        return inactivityRepository.findByPlayerOrderByInactiveFromAsc(player)
                .stream()
                .map(mapper::toDTO)
                .toList();
    }

    // --- TRANSACTIONAL pro zÄ‚Ë‡pis dat ---
    @Override
    @Transactional
    public PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto) {
        PlayerEntity player = playerRepository.findById(dto.getPlayerId())
                .orElseThrow(() -> new IllegalArgumentException("HrÄ‚Ë‡Ă„Ĺ¤ s ID " + dto.getPlayerId() + " neexistuje."));

        validateDates(dto);

        // kontrola pÄąâ„˘ekryvu existujÄ‚Â­cÄ‚Â­ch obdobÄ‚Â­
        boolean overlaps = !inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        player, dto.getInactiveFrom(), dto.getInactiveTo()
                ).isEmpty();

        if (overlaps) {
            throw new IllegalStateException("NovÄ‚Â© obdobÄ‚Â­ se pÄąâ„˘ekrÄ‚ËťvÄ‚Ë‡ s existujÄ‚Â­cÄ‚Â­m obdobÄ‚Â­m neaktivity hrÄ‚Ë‡Ă„Ĺ¤e.");
        }

        PlayerInactivityPeriodEntity entity = mapper.toEntity(dto, player);
        return mapper.toDTO(inactivityRepository.save(entity));
    }

    @Override
    @Transactional
    public PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("ObdobÄ‚Â­ neaktivity s ID " + id + " neexistuje."));

        validateDates(dto);

        // kontrola pÄąâ„˘ekryvu, ignoruje aktuÄ‚Ë‡lnÄ‚Â­ zÄ‚Ë‡znam
        boolean overlaps = inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        entity.getPlayer(), dto.getInactiveFrom(), dto.getInactiveTo()
                ).stream()
                .anyMatch(p -> !p.getId().equals(id));

        if (overlaps) {
            throw new IllegalStateException("UpravenÄ‚Â© obdobÄ‚Â­ se pÄąâ„˘ekrÄ‚ËťvÄ‚Ë‡ s jinÄ‚Ëťm obdobÄ‚Â­m neaktivity hrÄ‚Ë‡Ă„Ĺ¤e.");
        }

        mapper.updateEntityFromDto(dto, entity);
        return mapper.toDTO(inactivityRepository.save(entity));
    }

    @Override
    @Transactional
    public void delete(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("ObdobÄ‚Â­ neaktivity s ID " + id + " neexistuje."));
        inactivityRepository.delete(entity);
    }

    // --- true = aktivnÄ‚Â­, false = neaktivnÄ‚Â­ ---
    public boolean isActive(PlayerEntity player, LocalDateTime dateTime) {
        return !inactivityRepository.existsByPlayerAndInactiveFromLessThanEqualAndInactiveToGreaterThanEqual(
                player, dateTime, dateTime);
    }

    // --- privÄ‚Ë‡tnÄ‚Â­ metoda pro validaci dat ---
    private void validateDates(PlayerInactivityPeriodDTO dto) {
        if (dto.getInactiveFrom() == null || dto.getInactiveTo() == null) {
            throw new IllegalArgumentException("Datum od a do nesmÄ‚Â­ bÄ‚Ëťt null.");
        }
        if (!dto.getInactiveFrom().isBefore(dto.getInactiveTo())) {
            throw new IllegalArgumentException("inactiveFrom musÄ‚Â­ bÄ‚Ëťt pÄąâ„˘ed inactiveTo.");
        }
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;

import java.util.List;


public interface PlayerService {
    List<PlayerDTO> getAllPlayers();
    PlayerDTO getPlayerById(Long id);
    PlayerDTO createPlayer(PlayerDTO player);
    PlayerDTO createPlayerForUser(PlayerDTO dto, String userEmail);
    PlayerDTO updatePlayer(Long id, PlayerDTO player);
    SuccessResponseDTO deletePlayer(Long id);
    public List<PlayerDTO> getPlayersByUser(String email);
    SuccessResponseDTO approvePlayer (Long id);
    SuccessResponseDTO rejectPlayer (Long id);
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.DuplicateNameSurnameException;
import cz.phsoft.hokej.exceptions.InvalidPlayerStatusException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;
import cz.phsoft.hokej.models.dto.PlayerDTO;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class PlayerServiceImpl implements PlayerService {

    private final PlayerRepository playerRepository;
    private final PlayerMapper playerMapper;
    private final AppUserRepository appUserRepository;

    public PlayerServiceImpl(PlayerRepository playerRepository, PlayerMapper playerMapper, AppUserRepository appUserRepository) {
        this.playerRepository = playerRepository;
        this.playerMapper = playerMapper;
        this.appUserRepository = appUserRepository;
    }

    @Override
    public List<PlayerDTO> getAllPlayers() {
        return playerRepository.findAll().stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    @Override
    public PlayerDTO getPlayerById(Long id) {
        PlayerEntity player = playerRepository.findById(id)
                .orElseThrow(() -> new PlayerNotFoundException(id)); // mÄ‚Â­sto RuntimeException
        return playerMapper.toDTO(player);
    }


    // --- TRANSACTIONAL pro zÄ‚Ë‡pis dat ---
    @Override
    @Transactional
    public PlayerDTO createPlayer(PlayerDTO dto) {
        checkDuplicateNameSurname(dto.getName(), dto.getSurname(), null);

        PlayerEntity entity = playerMapper.toEntity(dto);
        PlayerEntity saved = playerRepository.save(entity);
        return playerMapper.toDTO(saved);
    }

    @Override
    @Transactional
    public PlayerDTO createPlayerForUser(PlayerDTO dto, String userEmail) {
        AppUserEntity user = appUserRepository.findByEmail(userEmail)
                .orElseThrow(() -> new RuntimeException("User not found"));

        PlayerEntity player = playerMapper.toEntity(dto);
        player.setUser(user); // pÄąâ„˘iÄąâ„˘azenÄ‚Â­ hrÄ‚Ë‡Ă„Ĺ¤e k uÄąÄľivateli


        PlayerEntity saved = playerRepository.save(player);
        return playerMapper.toDTO(saved);
    }

    @Override
    public List<PlayerDTO> getPlayersByUser(String email) {
        return playerRepository.findByUser_EmailOrderByIdAsc(email).stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    @Override
    @Transactional
    public PlayerDTO updatePlayer(Long id, PlayerDTO dto) {
        PlayerEntity existing = findPlayerOrThrow(id);

        // pokud se jmÄ‚Â©no/pÄąâ„˘Ä‚Â­jmenÄ‚Â­ mĂ„â€şnÄ‚Â­, ovĂ„â€şÄąâ„˘ duplicitu
        if (!existing.getName().equals(dto.getName())
                || !existing.getSurname().equals(dto.getSurname())) {
            checkDuplicateNameSurname(dto.getName(), dto.getSurname(), id);
        }

        existing.setName(dto.getName());
        existing.setSurname(dto.getSurname());
        existing.setNickname(dto.getNickName());
        existing.setPhoneNumber(dto.getPhoneNumber());
        existing.setType(dto.getType());
        existing.setTeam(dto.getTeam());
        existing.setStatus(dto.getStatus());

        PlayerEntity saved = playerRepository.save(existing);
        return playerMapper.toDTO(saved);
    }

    @Override
    @Transactional
    public SuccessResponseDTO deletePlayer(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);
        playerRepository.delete(player);

        return new SuccessResponseDTO(
                "HrÄ‚Ë‡Ă„Ĺ¤ " + player.getFullName() + " byl Ä‚ĹźspĂ„â€şÄąË‡nĂ„â€ş smazÄ‚Ë‡n",
                id,
                LocalDateTime.now().toString()
        );
    }

    // --- privÄ‚Ë‡tnÄ‚Â­ metoda pro kontrolu duplicity jmÄ‚Â©na a pÄąâ„˘Ä‚Â­jmenÄ‚Â­ ---
    private void checkDuplicateNameSurname(String name, String surname, Long ignoreId) {
        Optional<PlayerEntity> duplicateOpt = playerRepository.findByNameAndSurname(name, surname);

        if (duplicateOpt.isPresent()) {
            if (ignoreId == null || !duplicateOpt.get().getId().equals(ignoreId)) {
                throw new DuplicateNameSurnameException("HrÄ‚Ë‡Ă„Ĺ¤ se jmÄ‚Â©nem " + name + " " + surname + " jiÄąÄľ existuje.");
            }
        }
    }

    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    @Override
    @Transactional
    public SuccessResponseDTO approvePlayer(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);

        if (player.getStatus() == PlayerStatus.APPROVED) {
            throw new InvalidPlayerStatusException("HrÄ‚Ë‡Ă„Ĺ¤ uÄąÄľ je schvÄ‚Ë‡len.");
        }
        player.setStatus(PlayerStatus.APPROVED);
        playerRepository.save(player);
        return new SuccessResponseDTO(
                "HrÄ‚Ë‡Ă„Ĺ¤ " + player.getFullName() + " byl Ä‚ĹźspĂ„â€şÄąË‡nĂ„â€ş aktivovÄ‚Ë‡n",
                id,
                LocalDateTime.now().toString()
        );
    }

    @Override
    @Transactional
    public SuccessResponseDTO rejectPlayer(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);

        if (player.getStatus() == PlayerStatus.REJECTED) {
            throw new InvalidPlayerStatusException("HrÄ‚Ë‡Ă„Ĺ¤ uÄąÄľ je zamÄ‚Â­tnut.");
        }
        player.setStatus(PlayerStatus.REJECTED);
        playerRepository.save(player);

        return new SuccessResponseDTO(
                "HrÄ‚Ë‡Ă„Ĺ¤ " + player.getFullName() + " byl Ä‚ĹźspĂ„â€şÄąË‡nĂ„â€ş zamÄ‚Â­tnut",
                id,
                LocalDateTime.now().toString()
        );
    }


}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\CurrentPlayerContext.java


package cz.phsoft.hokej.security;


import cz.phsoft.hokej.data.entities.PlayerEntity;

// pro vÄ‚ËťbĂ„â€şr hrÄ‚Ë‡Ă„Ĺ¤e
public class CurrentPlayerContext {

        private static final ThreadLocal<PlayerEntity> currentPlayer = new ThreadLocal<>();

        public static void set(PlayerEntity player) {
            currentPlayer.set(player);
        }

        public static PlayerEntity get() {
            return currentPlayer.get();
        }

        public static void clear() {
            currentPlayer.remove();
        }
    }


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\CurrentPlayerFilter.java


package cz.phsoft.hokej.security;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;

@Component
public class CurrentPlayerFilter extends OncePerRequestFilter {

    private final PlayerRepository playerRepository;
    private final CurrentPlayerService currentPlayerService;

    public CurrentPlayerFilter(PlayerRepository playerRepository,
                               CurrentPlayerService currentPlayerService) {
        this.playerRepository = playerRepository;
        this.currentPlayerService = currentPlayerService;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {

        Long playerId = currentPlayerService.getCurrentPlayerId();

        if (playerId != null) {
            playerRepository.findById(playerId)
                    .ifPresent(CurrentPlayerContext::set);
        }

        try {
            filterChain.doFilter(request, response);
        } finally {
            CurrentPlayerContext.clear();
        }
    }
}



# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\CurrentPlayerService.java


package cz.phsoft.hokej.security;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import jakarta.servlet.http.HttpSession;
import org.springframework.stereotype.Service;

@Service
public class CurrentPlayerService {

    private final HttpSession session;
    private final PlayerRepository playerRepository;

    public CurrentPlayerService(HttpSession session, PlayerRepository playerRepository) {
        this.session = session;
        this.playerRepository = playerRepository;
    }

    public Long getCurrentPlayerId() {
        return (Long) session.getAttribute(SessionKeys.CURRENT_PLAYER_ID);
    }

    public void setCurrentPlayerId(Long playerId) {
        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));

        if (player.getStatus() != PlayerStatus.APPROVED) {
            throw new IllegalStateException(
                    "Nelze zvolit hrÄ‚Ë‡Ă„Ĺ¤e, kterÄ‚Ëť nenÄ‚Â­ schvÄ‚Ë‡len administrÄ‚Ë‡torem."
            );
        }

        session.setAttribute(SessionKeys.CURRENT_PLAYER_ID, playerId);
    }

    public void requireCurrentPlayer() {
        if (getCurrentPlayerId() == null) {
            throw new IllegalStateException("NenÄ‚Â­ zvolen aktuÄ‚Ë‡lnÄ‚Â­ hrÄ‚Ë‡Ă„Ĺ¤");
        }
    }

    public void clear() {
        session.removeAttribute(SessionKeys.CURRENT_PLAYER_ID);
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\PlayerSecurity.java


package cz.phsoft.hokej.security;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;
// - ZatÄ‚Â­m nepouÄąÄľÄ‚Â­vÄ‚Ë‡m - pouÄąÄľÄ‚Â­vÄ‚Ë‡m /me
@Component("playerSecurity") // nÄ‚Ë‡zev pro pouÄąÄľitÄ‚Â­ v SpEL (@PreAuthorize)
public class PlayerSecurity {

    private static final Logger logger = LoggerFactory.getLogger(PlayerSecurity.class);

    private final PlayerRepository playerRepository;

    public PlayerSecurity(PlayerRepository playerRepository) {
        this.playerRepository = playerRepository;
    }

    /**
     * ZjistÄ‚Â­, zda je aktuÄ‚Ë‡lnĂ„â€ş pÄąâ„˘ihlÄ‚Ë‡ÄąË‡enÄ‚Ëť uÄąÄľivatel vlastnÄ‚Â­kem hrÄ‚Ë‡Ă„Ĺ¤e
     *
     * @param authentication aktuÄ‚Ë‡lnÄ‚Â­ authentication objekt
     * @param playerId       ID hrÄ‚Ë‡Ă„Ĺ¤e
     * @return true pokud je vlastnÄ‚Â­kem, jinak false
     */
    public boolean isOwner(Authentication authentication, Long playerId) {
        try {
            if (authentication == null || !authentication.isAuthenticated()) {
                logger.warn("NeautorizovanÄ‚Ëť pÄąâ„˘Ä‚Â­stup: ÄąÄľÄ‚Ë‡dnÄ‚Ë‡ autentizace pro playerId {}", playerId);
                return false;
            }

            Object principal = authentication.getPrincipal();
            if (!(principal instanceof UserDetails userDetails)) {
                logger.warn("NeautorizovanÄ‚Ëť pÄąâ„˘Ä‚Â­stup: principal nenÄ‚Â­ UserDetails pro playerId {}", playerId);
                return false;
            }

            boolean isOwner = playerRepository.findById(playerId)
                    .map(player -> player.getUser() != null &&
                            player.getUser().getEmail().equals(userDetails.getUsername()))
                    .orElse(false);

            if (!isOwner) {
                logger.warn("NeautorizovanÄ‚Ëť pÄąâ„˘Ä‚Â­stup: uÄąÄľivatel {} nenÄ‚Â­ vlastnÄ‚Â­kem hrÄ‚Ë‡Ă„Ĺ¤e {}", userDetails.getUsername(), playerId);
            }

            return isOwner;

        } catch (Exception e) {
            logger.error("Chyba pÄąâ„˘i kontrole vlastnÄ‚Â­ka hrÄ‚Ë‡Ă„Ĺ¤e {}: {}", playerId, e.getMessage(), e);
            // nikdy nepropustit vÄ‚Ëťjimku do SpEL
            return false;
        }
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\SessionKeys.java


package cz.phsoft.hokej.security;

public final class SessionKeys {
    private SessionKeys() {}

    public static final String CURRENT_PLAYER_ID = "CURRENT_PLAYER_ID";
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\StaraGardaApplication.java


package cz.phsoft.hokej;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableJpaRepositories // JPA v naÄąË‡em Spring Boot projektu
@EnableScheduling
@EnableAsync
public class StaraGardaApplication {
    public static void main(String[] args) {
        SpringApplication.run(StaraGardaApplication.class, args);


        }
    }


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\AppUserMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2026-01-20T13:10:47+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class AppUserMapperImpl implements AppUserMapper {

    @Override
    public AppUserDTO toDTO(AppUserEntity entity) {
        if ( entity == null ) {
            return null;
        }

        AppUserDTO appUserDTO = new AppUserDTO();

        appUserDTO.setPlayers( playerEntitySetToPlayerDTOSet( entity.getPlayers() ) );
        appUserDTO.setId( entity.getId() );
        appUserDTO.setName( entity.getName() );
        appUserDTO.setSurname( entity.getSurname() );
        appUserDTO.setEmail( entity.getEmail() );
        appUserDTO.setRole( entity.getRole() );
        appUserDTO.setEnabled( entity.isEnabled() );

        return appUserDTO;
    }

    @Override
    public List<AppUserDTO> toDtoList(List<AppUserEntity> entities) {
        if ( entities == null ) {
            return null;
        }

        List<AppUserDTO> list = new ArrayList<AppUserDTO>( entities.size() );
        for ( AppUserEntity appUserEntity : entities ) {
            list.add( toDTO( appUserEntity ) );
        }

        return list;
    }

    @Override
    public PlayerDTO toPlayerDTO(PlayerEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerDTO playerDTO = new PlayerDTO();

        playerDTO.setNickName( entity.getNickname() );
        playerDTO.setId( entity.getId() );
        playerDTO.setName( entity.getName() );
        playerDTO.setSurname( entity.getSurname() );
        playerDTO.setType( entity.getType() );
        playerDTO.setTeam( entity.getTeam() );
        playerDTO.setPhoneNumber( entity.getPhoneNumber() );
        playerDTO.setStatus( entity.getStatus() );

        return playerDTO;
    }

    protected Set<PlayerDTO> playerEntitySetToPlayerDTOSet(Set<PlayerEntity> set) {
        if ( set == null ) {
            return null;
        }

        Set<PlayerDTO> set1 = new LinkedHashSet<PlayerDTO>( Math.max( (int) ( set.size() / .75f ) + 1, 16 ) );
        for ( PlayerEntity playerEntity : set ) {
            set1.add( toPlayerDTO( playerEntity ) );
        }

        return set1;
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2026-01-20T13:10:46+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchMapperImpl implements MatchMapper {

    @Override
    public MatchDTO toDTO(MatchEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchDTO matchDTO = new MatchDTO();

        matchDTO.setId( entity.getId() );
        matchDTO.setDateTime( entity.getDateTime() );
        matchDTO.setLocation( entity.getLocation() );
        matchDTO.setDescription( entity.getDescription() );
        matchDTO.setMaxPlayers( entity.getMaxPlayers() );
        matchDTO.setPrice( entity.getPrice() );

        return matchDTO;
    }

    @Override
    public MatchEntity toEntity(MatchDTO dto) {
        if ( dto == null ) {
            return null;
        }

        MatchEntity matchEntity = new MatchEntity();

        matchEntity.setId( dto.getId() );
        matchEntity.setDateTime( dto.getDateTime() );
        matchEntity.setLocation( dto.getLocation() );
        matchEntity.setDescription( dto.getDescription() );
        matchEntity.setMaxPlayers( dto.getMaxPlayers() );
        matchEntity.setPrice( dto.getPrice() );

        return matchEntity;
    }

    @Override
    public void updateEntity(MatchDTO dto, MatchEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setDateTime( dto.getDateTime() );
        entity.setLocation( dto.getLocation() );
        entity.setDescription( dto.getDescription() );
        entity.setMaxPlayers( dto.getMaxPlayers() );
        entity.setPrice( dto.getPrice() );
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchRegistrationMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2026-01-20T13:10:47+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchRegistrationMapperImpl implements MatchRegistrationMapper {

    @Override
    public MatchRegistrationEntity toEntity(MatchEntity match, PlayerEntity player, PlayerMatchStatus status, ExcuseReason excuseReason, String note, Team team, String adminNote, String createdBy) {
        if ( match == null && player == null && status == null && excuseReason == null && note == null && team == null && adminNote == null && createdBy == null ) {
            return null;
        }

        MatchRegistrationEntity matchRegistrationEntity = new MatchRegistrationEntity();

        matchRegistrationEntity.setMatch( match );
        matchRegistrationEntity.setPlayer( player );
        matchRegistrationEntity.setStatus( status );
        matchRegistrationEntity.setExcuseReason( excuseReason );
        matchRegistrationEntity.setExcuseNote( note );
        matchRegistrationEntity.setTeam( team );
        matchRegistrationEntity.setAdminNote( adminNote );
        matchRegistrationEntity.setCreatedBy( createdBy );
        matchRegistrationEntity.setTimestamp( java.time.LocalDateTime.now() );

        return matchRegistrationEntity;
    }

    @Override
    public MatchRegistrationDTO toDTO(MatchRegistrationEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchRegistrationDTO matchRegistrationDTO = new MatchRegistrationDTO();

        matchRegistrationDTO.setMatchId( entityMatchId( entity ) );
        matchRegistrationDTO.setPlayerId( entityPlayerId( entity ) );
        matchRegistrationDTO.setId( entity.getId() );
        matchRegistrationDTO.setStatus( entity.getStatus() );
        matchRegistrationDTO.setExcuseReason( entity.getExcuseReason() );
        matchRegistrationDTO.setExcuseNote( entity.getExcuseNote() );
        matchRegistrationDTO.setAdminNote( entity.getAdminNote() );
        matchRegistrationDTO.setTeam( entity.getTeam() );
        matchRegistrationDTO.setCreatedBy( entity.getCreatedBy() );

        return matchRegistrationDTO;
    }

    @Override
    public List<MatchRegistrationDTO> toDTOList(List<MatchRegistrationEntity> entities) {
        if ( entities == null ) {
            return null;
        }

        List<MatchRegistrationDTO> list = new ArrayList<MatchRegistrationDTO>( entities.size() );
        for ( MatchRegistrationEntity matchRegistrationEntity : entities ) {
            list.add( toDTO( matchRegistrationEntity ) );
        }

        return list;
    }

    private Long entityMatchId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        MatchEntity match = matchRegistrationEntity.getMatch();
        if ( match == null ) {
            return null;
        }
        Long id = match.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }

    private Long entityPlayerId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        PlayerEntity player = matchRegistrationEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerInactivityPeriodMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2026-01-20T13:10:47+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerInactivityPeriodMapperImpl implements PlayerInactivityPeriodMapper {

    @Override
    public PlayerInactivityPeriodDTO toDTO(PlayerInactivityPeriodEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerInactivityPeriodDTO playerInactivityPeriodDTO = new PlayerInactivityPeriodDTO();

        playerInactivityPeriodDTO.setPlayerId( entityPlayerId( entity ) );
        playerInactivityPeriodDTO.setId( entity.getId() );
        playerInactivityPeriodDTO.setInactiveFrom( entity.getInactiveFrom() );
        playerInactivityPeriodDTO.setInactiveTo( entity.getInactiveTo() );

        return playerInactivityPeriodDTO;
    }

    @Override
    public PlayerInactivityPeriodEntity toEntity(PlayerInactivityPeriodDTO dto, PlayerEntity player) {
        if ( dto == null ) {
            return null;
        }

        PlayerInactivityPeriodEntity playerInactivityPeriodEntity = createEntity( dto, player );

        playerInactivityPeriodEntity.setInactiveFrom( dto.getInactiveFrom() );
        playerInactivityPeriodEntity.setInactiveTo( dto.getInactiveTo() );

        return playerInactivityPeriodEntity;
    }

    @Override
    public void updateEntityFromDto(PlayerInactivityPeriodDTO dto, PlayerInactivityPeriodEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setInactiveFrom( dto.getInactiveFrom() );
        entity.setInactiveTo( dto.getInactiveTo() );
    }

    private Long entityPlayerId(PlayerInactivityPeriodEntity playerInactivityPeriodEntity) {
        if ( playerInactivityPeriodEntity == null ) {
            return null;
        }
        PlayerEntity player = playerInactivityPeriodEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2026-01-20T13:10:47+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerMapperImpl implements PlayerMapper {

    @Override
    public PlayerDTO toDTO(PlayerEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerDTO playerDTO = new PlayerDTO();

        playerDTO.setNickName( entity.getNickname() );
        playerDTO.setId( entity.getId() );
        playerDTO.setName( entity.getName() );
        playerDTO.setSurname( entity.getSurname() );
        playerDTO.setType( entity.getType() );
        playerDTO.setTeam( entity.getTeam() );
        playerDTO.setPhoneNumber( entity.getPhoneNumber() );
        playerDTO.setStatus( entity.getStatus() );

        return playerDTO;
    }

    @Override
    public PlayerEntity toEntity(PlayerDTO dto) {
        if ( dto == null ) {
            return null;
        }

        PlayerEntity playerEntity = new PlayerEntity();

        playerEntity.setNickname( dto.getNickName() );
        playerEntity.setId( dto.getId() );
        playerEntity.setName( dto.getName() );
        playerEntity.setSurname( dto.getSurname() );
        playerEntity.setType( dto.getType() );
        playerEntity.setPhoneNumber( dto.getPhoneNumber() );
        playerEntity.setTeam( dto.getTeam() );
        playerEntity.setNickName( dto.getNickName() );

        playerEntity.setStatus( dto.getStatus() != null ? dto.getStatus() : cz.phsoft.hokej.data.enums.PlayerStatus.PENDING );

        return playerEntity;
    }

    @Override
    public void updatePlayerDTO(PlayerDTO source, PlayerDTO target) {
        if ( source == null ) {
            return;
        }

        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setNickName( source.getNickName() );
        target.setType( source.getType() );
        target.setTeam( source.getTeam() );
        target.setPhoneNumber( source.getPhoneNumber() );
        target.setStatus( source.getStatus() );
    }

    @Override
    public void updatePlayerEntity(PlayerDTO source, PlayerEntity target) {
        if ( source == null ) {
            return;
        }

        target.setNickname( source.getNickName() );
        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setType( source.getType() );
        target.setPhoneNumber( source.getPhoneNumber() );
        target.setTeam( source.getTeam() );
        target.setNickName( source.getNickName() );

        target.setStatus( source.getStatus() != null ? source.getStatus() : target.getStatus() );
    }

    @Override
    public List<PlayerDTO> toDTOList(List<PlayerEntity> players) {
        if ( players == null ) {
            return null;
        }

        List<PlayerDTO> list = new ArrayList<PlayerDTO>( players.size() );
        for ( PlayerEntity playerEntity : players ) {
            list.add( toDTO( playerEntity ) );
        }

        return list;
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-04T13:04:23+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchMapperImpl implements MatchMapper {

    @Override
    public MatchDTO toDTO(MatchEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchDTO matchDTO = new MatchDTO();

        matchDTO.setId( entity.getId() );
        matchDTO.setDateTime( entity.getDateTime() );
        matchDTO.setLocation( entity.getLocation() );
        matchDTO.setDescription( entity.getDescription() );
        matchDTO.setMaxPlayers( entity.getMaxPlayers() );
        matchDTO.setPrice( entity.getPrice() );

        return matchDTO;
    }

    @Override
    public MatchEntity toEntity(MatchDTO dto) {
        if ( dto == null ) {
            return null;
        }

        MatchEntity matchEntity = new MatchEntity();

        matchEntity.setId( dto.getId() );
        matchEntity.setDateTime( dto.getDateTime() );
        matchEntity.setLocation( dto.getLocation() );
        matchEntity.setDescription( dto.getDescription() );
        matchEntity.setMaxPlayers( dto.getMaxPlayers() );
        matchEntity.setPrice( dto.getPrice() );

        return matchEntity;
    }

    @Override
    public void updateEntity(MatchDTO dto, MatchEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setDateTime( dto.getDateTime() );
        entity.setLocation( dto.getLocation() );
        entity.setDescription( dto.getDescription() );
        entity.setMaxPlayers( dto.getMaxPlayers() );
        entity.setPrice( dto.getPrice() );
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchRegistrationMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.JerseyColor;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-04T13:04:22+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchRegistrationMapperImpl implements MatchRegistrationMapper {

    @Override
    public MatchRegistrationEntity toEntity(MatchEntity match, PlayerEntity player, PlayerMatchStatus status, ExcuseReason excuseReason, String note, JerseyColor jerseyColor, String adminNote, String createdBy) {
        if ( match == null && player == null && status == null && excuseReason == null && note == null && jerseyColor == null && adminNote == null && createdBy == null ) {
            return null;
        }

        MatchRegistrationEntity matchRegistrationEntity = new MatchRegistrationEntity();

        matchRegistrationEntity.setMatch( match );
        matchRegistrationEntity.setPlayer( player );
        matchRegistrationEntity.setStatus( status );
        matchRegistrationEntity.setExcuseReason( excuseReason );
        matchRegistrationEntity.setExcuseNote( note );
        matchRegistrationEntity.setJerseyColor( jerseyColor );
        matchRegistrationEntity.setAdminNote( adminNote );
        matchRegistrationEntity.setCreatedBy( createdBy );
        matchRegistrationEntity.setTimestamp( java.time.LocalDateTime.now() );

        return matchRegistrationEntity;
    }

    @Override
    public MatchRegistrationDTO toDTO(MatchRegistrationEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchRegistrationDTO matchRegistrationDTO = new MatchRegistrationDTO();

        matchRegistrationDTO.setMatchId( entityMatchId( entity ) );
        matchRegistrationDTO.setPlayerId( entityPlayerId( entity ) );
        matchRegistrationDTO.setId( entity.getId() );
        matchRegistrationDTO.setStatus( entity.getStatus() );
        matchRegistrationDTO.setExcuseReason( entity.getExcuseReason() );
        matchRegistrationDTO.setExcuseNote( entity.getExcuseNote() );
        matchRegistrationDTO.setAdminNote( entity.getAdminNote() );
        matchRegistrationDTO.setJerseyColor( entity.getJerseyColor() );
        matchRegistrationDTO.setCreatedBy( entity.getCreatedBy() );

        return matchRegistrationDTO;
    }

    private Long entityMatchId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        MatchEntity match = matchRegistrationEntity.getMatch();
        if ( match == null ) {
            return null;
        }
        Long id = match.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }

    private Long entityPlayerId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        PlayerEntity player = matchRegistrationEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerInactivityPeriodMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-04T13:04:23+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerInactivityPeriodMapperImpl implements PlayerInactivityPeriodMapper {

    @Override
    public PlayerInactivityPeriodDTO toDTO(PlayerInactivityPeriodEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerInactivityPeriodDTO playerInactivityPeriodDTO = new PlayerInactivityPeriodDTO();

        playerInactivityPeriodDTO.setPlayerId( entityPlayerId( entity ) );
        playerInactivityPeriodDTO.setId( entity.getId() );
        playerInactivityPeriodDTO.setInactiveFrom( entity.getInactiveFrom() );
        playerInactivityPeriodDTO.setInactiveTo( entity.getInactiveTo() );

        return playerInactivityPeriodDTO;
    }

    @Override
    public PlayerInactivityPeriodEntity toEntity(PlayerInactivityPeriodDTO dto, PlayerEntity player) {
        if ( dto == null ) {
            return null;
        }

        PlayerInactivityPeriodEntity playerInactivityPeriodEntity = createEntity( dto, player );

        playerInactivityPeriodEntity.setInactiveFrom( dto.getInactiveFrom() );
        playerInactivityPeriodEntity.setInactiveTo( dto.getInactiveTo() );

        return playerInactivityPeriodEntity;
    }

    @Override
    public void updateEntityFromDto(PlayerInactivityPeriodDTO dto, PlayerInactivityPeriodEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setInactiveFrom( dto.getInactiveFrom() );
        entity.setInactiveTo( dto.getInactiveTo() );
    }

    private Long entityPlayerId(PlayerInactivityPeriodEntity playerInactivityPeriodEntity) {
        if ( playerInactivityPeriodEntity == null ) {
            return null;
        }
        PlayerEntity player = playerInactivityPeriodEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}


# Soubor: C:\Projekty PrĂˇce\StaraGarda\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-04T13:04:23+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerMapperImpl implements PlayerMapper {

    @Override
    public PlayerDTO toDTO(PlayerEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerDTO playerDTO = new PlayerDTO();

        playerDTO.setId( entity.getId() );
        playerDTO.setName( entity.getName() );
        playerDTO.setSurname( entity.getSurname() );
        playerDTO.setType( entity.getType() );
        playerDTO.setJerseyColor( entity.getJerseyColor() );

        return playerDTO;
    }

    @Override
    public PlayerEntity toEntity(PlayerDTO dto) {
        if ( dto == null ) {
            return null;
        }

        PlayerEntity playerEntity = new PlayerEntity();

        playerEntity.setId( dto.getId() );
        playerEntity.setName( dto.getName() );
        playerEntity.setSurname( dto.getSurname() );
        playerEntity.setType( dto.getType() );
        playerEntity.setJerseyColor( dto.getJerseyColor() );

        return playerEntity;
    }

    @Override
    public void updatePlayerDTO(PlayerDTO source, PlayerDTO target) {
        if ( source == null ) {
            return;
        }

        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setType( source.getType() );
        target.setJerseyColor( source.getJerseyColor() );
    }

    @Override
    public void updatePlayerEntity(PlayerDTO source, PlayerEntity target) {
        if ( source == null ) {
            return;
        }

        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setType( source.getType() );
        target.setJerseyColor( source.getJerseyColor() );
    }
}


----------------------
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import Home from "./pages/Home";
import LoginPage from './pages/LoginPage';
import Navbar from './components/Navbar';
import SharedLayout from "./pages/SharedLayout"
import ScrollToTop from "./components/ScrollToTop";
import RegisterPage from "./pages/RegisterPage";
import RequireAuth from "./RequireAuth";
import Matches from "./pages/Matches";
import Players from "./pages/Players";
import { CurrentPlayerProvider } from "./hooks/useCurrentPlayer";


const App = () => (
  <BrowserRouter>
    <ScrollToTop resetPrefixes={["/"]} />

    <Routes>
      {/*VeĹ™ejnĂ© strĂˇnky â€“ BEZ SharedLayout */}
      <Route path="/login" element={<LoginPage />} />
      <Route path="/register" element={<RegisterPage />} />

      {/* ChrĂˇnÄ›nĂˇ ÄŤĂˇst aplikace â€“ se SharedLayout + Navbar*/}
      <Route
        path="/"
        element={
          <RequireAuth>
            <CurrentPlayerProvider>
              <SharedLayout />
            </CurrentPlayerProvider>
          </RequireAuth>
        }
      >
        {/* index = "/" */}
        {/* sem mĹŻĹľeĹˇ pĹ™idĂˇvat dalĹˇĂ­ chrĂˇnÄ›nĂ© strĂˇnky, napĹ™.: */}
        <Route index element={<Home />} />
        <Route path="/matches" element={<Matches />} />
        <Route path="/players" element={<Players />} />



      </Route>

      {/* fallback â€“ cokoliv jinĂ©ho â†’ login */}

      <Route path="*" element={<Navigate to="/login" replace />} />
    </Routes>
  </BrowserRouter>
);

export default App;
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html,
body {
  margin: 0;
  padding: 0;
  width: 100%;
  overflow-x: hidden;
  /* odstranĂ­ horizontĂˇlnĂ­ scroll */
}

.layout {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  /* aby footer byl vĹľdy dole */
}

.content {
  flex: 1;
  /* zabere volnĂ© mĂ­sto mezi headerem a footerem */
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
}

.container {
  max-width: 1600px;
  width: 100%;
  margin: 0 auto;
  padding: 10px 16px;
}

footer {
  background: #222;
  color: #0a0101;
  padding: 20px 16px;
  text-align: center;
}

.inner {
  width: 100%;
  max-width: 1600px;
  margin: 0 auto;
  padding: 0 20px;

}

ul {
  list-style-position: inside;
  /* odrĂˇĹľka uvnitĹ™ */
  padding-left: 1.2em;
  /* prostor mezi okrajem a textem */
  margin: 0.5em 0;
  /* mezera nad a pod seznamem */
  text-align: left;
  /* aby text nebyl na stĹ™edu */
}

li {
  margin-bottom: 0.5em;
  /* mezera mezi poloĹľkami */
  line-height: 1.5em;
  /* vĂ­ce vzduchu mezi Ĺ™Ăˇdky textu */
}

.slider {
  height: 50vh;
  /*border: 2px solid #0a0101;*/
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;

}
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./index.css";
import "bootstrap/dist/css/bootstrap.min.css";
import App from "./App.jsx";

// Import AuthProvider a BrowserRouter ze sprĂˇvnĂ˝ch cest
import { AuthProvider } from "./hooks/useAuth.jsx";
import { BrowserRouter } from "react-router-dom";

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <AuthProvider>


        <App />


    </AuthProvider>
  </StrictMode>
);
// chrĂˇnÄ›nĂˇ routa s vyuĹľitĂ­m useAuth()
//ZabezpeÄŤenĂ­: nerenderuje UI dokud nevĂ­me stav. Akce auth je pouze v hooku, ne v komponentÄ›.

import { Navigate } from "react-router-dom";
import { useAuth } from "./hooks/useAuth";

const RequireAuth = ({ children }) => {
    const { user, loading } = useAuth();

    if (loading) return <p>OvÄ›Ĺ™uji pĹ™ihlĂˇĹˇenĂ­â€¦</p>;

    return user ? children : <Navigate to="/login" replace />;
};

export default RequireAuth;

import api from "./axios";

/**
 * PĹ™ihlĂˇĹˇenĂ­ uĹľivatele
 */
export const loginUser = (email, password) =>
    api.post("/login", { email, password });

/**
 * OdhlĂˇĹˇenĂ­
 */
export const logoutUser = () =>
    api.post("/logout");

/**
 * NaÄŤtenĂ­ aktuĂˇlnĂ­ho uĹľivatele
 */
export const fetchCurrentUser = () =>
    api.get("/auth/me");

/**
 * RychlĂˇ kontrola pĹ™ihlĂˇĹˇenĂ­
 */
export const checkAuthentication = async () => {
    try {
        await fetchCurrentUser();
        return true;
    } catch {
        return false;
    }
};

/**
 * Registrace novĂ©ho uĹľivatele
 */
export const registerUser = (data) =>
    api.post("/auth/register", data);
import axios from "axios";

axios.defaults.withCredentials = true;

const api = axios.create({
    baseURL: import.meta.env.VITE_API_URL + "/api", // backend
    withCredentials: true,
});

export default api;
import api from "./axios";

export const getMyPlayers = () =>
    api.get("/players/me");

export const setCurrentPlayer = (playerId) =>
    api.post(`/current-player/${playerId}`);

export const getCurrentPlayer = () =>
    api.get(`/current-player`);
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
.footer {
    width: 100%;
    /* zabere celou ĹˇĂ­Ĺ™ku */
    text-align: center;
    /* vodorovnÄ› na stĹ™ed */
    padding: 20px 0;
    /* prostor nahoĹ™e a dole */
    background-color: #DEEFE7;
    /* nebo jinĂˇ barva */
}

footer p {
    text-align: center;
    font-size: 18px;
}
import React from 'react'
import "./Footer.css"

const Footer = () => {
  return (
      <div>Â© 2025 Petr Hlista. VĹˇechna prĂˇva vyhrazena.</div>
  )
}

export default Footer
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

.header-top {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    /* poloĹľky vlevo, uprostĹ™ed, vpravo */
    align-items: center;
    padding: 5px 20px;
    background-color: #b0d4e6;
    font-size: 16px;
    font-weight: bold;
}


/* PoloĹľky v headeru */
.header-item {
    margin: 0 10px;
}

/* ResponsivnÄ› na mobilu */
@media (max-width: 700px) {
    .header-top {
        flex-direction: column;
        align-items: center;
        font-size: 12px;
    }

    .header-item {
        margin: 2px 0;
    }

    /* Skryj aktuality */
    .header-item:first-child {
        display: none;
    }
}

.header-top {
    background-color: #b0d4e6;
}

.header-top .inner {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0px 10px;
}
import React from 'react'
import "./HeaderTop.css"


const HeaderTop = () => {
  return (
      <div className="header-top">
          <div className="inner">
              <div className="header-item">Aktuality: Aplikace v testovĂˇnĂ­</div>
              <div className="header-item">đź“ž +420 776 609 956</div>
              <div className="header-item">âś‰ info@phsoft.cz</div>
          </div>
      </div>
  );
};

export default HeaderTop
//jedna komponenta pro vĂ­ce pouĹľitĂ­ (DRY).

import { Link } from "react-router-dom";
import { format } from "date-fns";

const MatchCard = ({ match, showPricePerPlayer = false }) => {
    const dateStr = format(new Date(match.dateTime), "dd.MM.yyyy HH:mm");

    return (
        <div className="card h-100 mb-3">
            <h5>{match.location}</h5>
            <p>{dateStr}</p>
            <p>{match.description}</p>
            {showPricePerPlayer && (
                <p><strong>Cena hrĂˇÄŤe:</strong> {match.pricePerRegisterdPlayer} KÄŤ</p>
            )}
            <Link to={`/match/${match.id}`} className="btn btn-primary">
                Detail
            </Link>
        </div>
    );
};

export default MatchCard;
import React from "react";
import { Link } from "react-router-dom";
import { format } from 'date-fns';


const MatchOverview = ({ match }) => {
    if (!match) return null;

    const formattedDateTime = format(match.dateTime, 'dd.MM.yyyy HH:mm');

    return (
        <section className="mb-3">
            <div className="card h-100">
                <div className="card-body">
                    <h5 className="card-title">
                        Hokej #{match.id} â€“ {match.location}
                    </h5>

                    <h6 className="card-subtitle mb-2 text-muted">
                        {formattedDateTime.toLocaleString()}

                    </h6>

                    {match.description && (
                        <p className="card-text">{match.description}</p>
                    )}

                    <p className="card-text">
                        <strong>MaximĂˇl hrĂˇÄŤi:</strong> {match.maxPlayers}
                    </p>

                    <p className="card-text">
                        <strong>Cena:</strong> {match.price} KÄŤ
                    </p>
                    <p className="card-text">
                        <strong>Cena za hrĂˇÄŤe:</strong> {match.pricePerRegisterdPlayer} KÄŤ
                    </p>


                    <Link
                        to={`/match/${match.id}`}
                        className="btn btn-primary mt-2"
                    >
                        Detail ÄŤehokoliv
                    </Link>
                </div>
            </div>
        </section>
    );
};


export default MatchOverview;
/* zĂˇklad */
.site-nav {
    width: 100%;
    background-color: #DEEFE7;
}

/* hlavnĂ­ kontejner - desktop: logo vlevo, menu napravo */
.navigation {
    display: flex;
    align-items: center;
    justify-content: space-between;
    /* logo vlevo, ostatnĂ­ doprava */
    padding: 0 20px;
    height: 70px;
    box-sizing: border-box;
}

/* logo */
.nav-header {
    display: flex;
    align-items: center;
}

.nav-logo {
    width: 150px;
    display: block;

}

/* toggle (hamburger) - default hide (desktop) */
.nav-toggle {
    display: none;
}

/* menu (desktop) */
.nav-list {
    display: flex;
    align-items: center;
    gap: 20px;
}

.nav-list ul {
    display: flex;
    list-style: none;
    margin: 0;
    padding: 0;
    gap: 20px;
}

.nav-list li {
    margin: 0;
}

.nav-list a {
    text-decoration: none;
    color: #222;
    padding: 8px 4px;
}

/* aktivnĂ­ odkaz (pĹ™izpĹŻsob si barvy) */
.activeLink {
    font-weight: 600;
    border-bottom: 2px solid #1B5E20;
}

.nonactiveLink {
    color: #222;
}

/* --- RESPONSIVE (mobile) --- */
@media (max-width: 700px) {

    .nav-toggle {
        display: block;
    }

    .hamburger-btn {
        background: none;
        border: none;
        padding: 8px;
        cursor: pointer;
    }

    .hamburger-icon {
        font-size: 26px;
    }

    /* OPRAVENĂ‰ MENU */
    .nav-list {
        position: fixed;
        top: 0;
        left: 0;

        height: 100vh;

        width: 80%;
        /* mĂ­sto 120px */
        max-width: 240px;
        /* max ĹˇĂ­Ĺ™ka */

        background-color: #DEEFE7;
        display: flex;
        flex-direction: column;
        padding-top: 80px;
        padding-left: 10px;
        /* OK dĂ­ky box-sizing */
        box-sizing: border-box;

        transform: translateX(-100%);
        transition: transform 0.28s ease;

        z-index: 1500;
        box-shadow: 2px 0 8px rgba(0, 0, 0, 0.06);
    }

    .nav-list.show {
        transform: translateX(0);
    }

    .nav-list.hide {
        transform: translateX(-100%);
    }

    .nav-list ul {
        flex-direction: column;
        gap: 16px;
        margin: 0;
        padding: 0;
    }

    .nav-list a {
        font-size: 18px;
    }

    .nav-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.45);
        z-index: 1200;
    }
}
// UI navbar bez API logiky, UI ÄŤistĂ©, logika logout v API vrstvÄ›.

import { useState } from "react";
import { NavLink, useNavigate } from "react-router-dom";
import { GiHamburgerMenu } from "react-icons/gi";
import { AiOutlineClose } from "react-icons/ai";
import { logoutUser } from "../api/authApi";
import { useAuth } from "../hooks/useAuth";
import { PlayerIcon } from "../icons";
import { UserIcon } from "../icons";
import { useCurrentPlayer } from "../hooks/useCurrentPlayer";

import "./Navbar.css";

const Navbar = () => {
    const [showMenu, setShowMenu] = useState(false);
    const { user, logout } = useAuth();
    const { currentPlayer } = useCurrentPlayer()
    const navigate = useNavigate();

    const closeMenu = () => {
        if (window.innerWidth < 700) {
            setShowMenu(false);
        }
    };

    const handleLogout = async () => {
        await logout();
        navigate("/login");
    };

    return (
        <nav className="navbar navbar-light bg-light">
            <div className="container">
                <span className="navbar-brand">Hokej App</span>

                <button
                    className="nav-toggle"
                    onClick={() => setShowMenu(!showMenu)}
                    aria-label="Toggle menu"
                >
                    {showMenu ? <AiOutlineClose /> : <GiHamburgerMenu />}
                </button>

                <div className={`nav-list ${showMenu ? "show" : "hide"}`}>
                    <ul>
                        <li>
                            <NavLink to="/players" className={({ isActive }) =>
                                isActive ? "activeLink" : "nonactiveLink"
                            } onClick={closeMenu}>
                                HrĂˇÄŤi
                            </NavLink>
                        </li>

                        <li>
                            <NavLink to="/Matches" className={({ isActive }) =>
                                isActive ? "activeLink" : "nonactiveLink"
                            } onClick={closeMenu}>
                                ZĂˇpasy
                            </NavLink>
                        </li>

                        <li>
                            <NavLink to="/Registrace" className={({ isActive }) =>
                                isActive ? "activeLink" : "nonactiveLink"
                            } onClick={closeMenu}>
                                Registrace
                            </NavLink>
                        </li>

                        <li>
                            <NavLink to="/contact" className={({ isActive }) =>
                                isActive ? "activeLink" : "nonactiveLink"
                            } onClick={closeMenu}>
                                NastavenĂ­
                            </NavLink>

                        </li>
                    </ul>
                </div>
                <div className="d-flex gap-3">
                    {user && (
                        <>
                            <span>
                                <UserIcon />{" "}
                                {user.name} {user.surname}
                                <div><PlayerIcon />{" "}  {currentPlayer
                                    ? `${currentPlayer.name} ${currentPlayer.surname}`
                                    : "NenĂ­ vybrĂˇn hrĂˇÄŤ"}</div>
                            </span>

                            <button className="btn btn-outline-danger" onClick={handleLogout}>
                                OdhlĂˇsit
                            </button>
                        </>
                    )}
                </div>
            </div>
        </nav>
    );
};

export default Navbar;
/* Kontejner pro vĹˇechny karty hrĂˇÄŤĹŻ */
.player-card {
    flex: 0 1 300px;
    max-width: 360px;
    width: 100%;
    padding: 20px 20px;

    background-color: #fff;
    border: 1px solid #e0e0e0;
    border-radius: 12px;

    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
    cursor: pointer;

    transition:
        transform 0.25s cubic-bezier(0.4, 0, 0.2, 1),
            box-shadow 0.25s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Hover efekt */
.player-card:hover {
transform: translateY(-4px) scale(1.02);
}

/* AktivnĂ­ klik (volitelnÄ› â€“ hezkĂ˝ detail) */
.player-card:active {
    transform: scale(1.01);
}

.player-card:focus-visible {
    outline: none;
    box-shadow: 0 0 0 3px rgba(13, 110, 253, 0.4);
}


.player-list {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    /* aby se karty zalamovaly na dalĹˇĂ­ Ĺ™Ăˇdek */
    gap: 16px;
    /* mezera mezi kartami */
    justify-content: flex-start;
}

/* Jedna karta hrĂˇÄŤe */
.player-card {
    flex: 0 1 300px;
    /* zĂˇkladnĂ­ ĹˇĂ­Ĺ™ka cca 260px, ale pruĹľnĂˇ */
    max-width: 360px;
    /* nepĹ™esĂˇhne 320px na velkĂ˝ch displejĂ­ch */
    display: flex;
}

.player-item {
    flex: 0 1 300px;
    max-width: 360px;
}

.player-card {
    width: 100%;
}

/* Link pĹ™es celou kartu */
.player-card-link {
    display: block;
    width: 100%;
    height: 100%;
}

/* Na velmi malĂ˝ch obrazovkĂˇch: karta pĹ™es celou ĹˇĂ­Ĺ™ku */
@media (max-width: 576px) {
    .player-card {
        flex: 1 1 100%;
        max-width: 100%;
    }
}

//UI komponenta povÄ›Ĺ™enĂˇ jen zobrazenĂ­m
import { usePlayers } from "../hooks/usePlayers";
import PlayerCard from "./PlayerCard";
import { setCurrentPlayer } from "../api/playerApi";
import { useNavigate } from "react-router-dom";
import { useCurrentPlayer } from "../hooks/useCurrentPlayer";

import "./Player.css";


const Player = () => {
    const { players, loading, error } = usePlayers();
    const navigate = useNavigate();
    const { refreshCurrentPlayer } = useCurrentPlayer();

    const handleSelectPlayer = async (playerId) => {
        try {
            await setCurrentPlayer(playerId);
            await refreshCurrentPlayer();  // zavolĂˇ POST /players/{id}
            navigate("/matches");               // po ĂşspÄ›chu pĹ™echod na zĂˇpasy
        } catch (err) {
            console.error("Nelze nastavit aktuĂˇlnĂ­ho hrĂˇÄŤe", err);
            alert("NepodaĹ™ilo se vybrat hrĂˇÄŤe.");
        }
    };

    if (loading) return <p>NaÄŤĂ­tĂˇm hrĂˇÄŤeâ€¦</p>;
    if (error) return <p className="text-danger">{error}</p>;

    return (
        <div className="player-list">
            {players.map((p) => (
                <div className="player-item" key={p.id}>
                    <PlayerCard
                        player={p}
                        onSelect={() => handleSelectPlayer(p.id)}
                    />
                </div>
            ))}
        </div>
    );
};

export default Player;
// src/components/PlayerCard.jsx
import RoleGuard from "./RoleGuard";
import { PhoneIcon } from "../icons";


const PlayerCard = ({ player, onSelect }) => {
    return (
        <div
            className="player-card"
            role="button"
            tabIndex={0}
            onClick={onSelect}
            onKeyDown={(e) => e.key === "Enter" && onSelect()}
        >
            <div className="card-body">
                <h5 className="card-title">{player.fullName}</h5>

                <p className="card-text">
                    <strong>TĂ˝m:</strong> {player.team}
                </p>

                <RoleGuard roles={["ROLE_ADMIN"]}>
                    <p className="card-text">
                        <strong>Typ:</strong> {player.type}
                    </p>
                    <p className="card-text">
                        <strong>Status:</strong> {player.status}
                    </p>
                </RoleGuard>

                    <p className="card-text mb-0">
                        <PhoneIcon /> {player.phoneNumber}
                    </p>
            </div>

        </div>
    );
};

export default PlayerCard;
import { useAuth } from "../hooks/useAuth";

const RoleGuard = ({ roles, children }) => {
    const { user } = useAuth();

    if (!user) return null;
    if (!roles.includes(user.role)) return null;

    return children;
};

export default RoleGuard;
import { useEffect } from "react";
import { useLocation } from "react-router-dom";

const ScrollToTop = ({ resetPrefixes = [] }) => {
    const { pathname } = useLocation();

    useEffect(() => {
        // Pokud aktuĂˇlnĂ­ path zaÄŤĂ­nĂˇ nÄ›kterĂ˝m prefixem â†’ scroll na zaÄŤĂˇtek
        if (resetPrefixes.some(prefix => pathname.startsWith(prefix))) {
            window.scrollTo(0, 0);
        }
        // Jinak nech scroll tam, kde byl
    }, [pathname, resetPrefixes]);

    return null;
};

export default ScrollToTop;
import React, { useEffect, useState } from "react";


const App = () => {
  const [message, setMessage] = useState("");

  useEffect(() => {
    fetch("http://localhost:8080/api/test")
      .then((res) => res.text())
      .then((data) => setMessage(data))
      .catch((err) => setMessage("Chyba: " + err));
  }, []);

  return (
    <div>
      <h1>Test pĹ™ipojenĂ­ k backendu</h1>
      <p>{message}</p>
    </div>
  );
};

export default App;
// src/hooks/useAuth.jsx

import { createContext, useContext, useEffect, useState } from "react";
import { fetchCurrentUser, logoutUser } from "../api/authApi";

const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
    const [user, setUser] = useState(null);
    const [loading, setLoading] = useState(true);

    const loadUser = async () => {
        setLoading(true);
        try {
            const res = await fetchCurrentUser();
            setUser(res.data);
        } catch {
            setUser(null);
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        loadUser();
    }, []);

    const updateUser = async () => {
        await loadUser();
    };

    const logout = async () => {
        try {
            await logoutUser();
        } catch (err) {
            console.error("Logout error:", err);
        } finally {
            setUser(null);
        }
    };

    return (
        <AuthContext.Provider value={{ user, loading, updateUser, logout }}>
            {children}
        </AuthContext.Provider>
    );
};

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error("useAuth must be used inside AuthProvider");
    }
    return context;
};
// src/hooks/useCurrentPlayer.js
import { createContext, useContext, useEffect, useState } from "react";
import { getCurrentPlayer } from "../api/playerApi";

const CurrentPlayerContext = createContext(null);

export const CurrentPlayerProvider = ({ children }) => {
    const [currentPlayer, setCurrentPlayer] = useState(null);
    const [loading, setLoading] = useState(true);

    const refreshCurrentPlayer = async () => {
        try {
            const res = await getCurrentPlayer();
            setCurrentPlayer(res.data);   // oÄŤekĂˇvĂˇme PlayerDTO z backendu
        } catch (err) {
            console.error("NepodaĹ™ilo se naÄŤĂ­st aktuĂˇlnĂ­ho hrĂˇÄŤe", err);
            setCurrentPlayer(null);
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        // pĹ™i prvnĂ­m naÄŤtenĂ­ chrĂˇnÄ›nĂ© ÄŤĂˇsti webu se zkusĂ­ naÄŤĂ­st aktuĂˇlnĂ­ hrĂˇÄŤ
        refreshCurrentPlayer();
    }, []);

    return (
        <CurrentPlayerContext.Provider
            value={{ currentPlayer, setCurrentPlayer, refreshCurrentPlayer, loading }}
        >
            {children}
        </CurrentPlayerContext.Provider>
    );
};

export const useCurrentPlayer = () => useContext(CurrentPlayerContext);
//custom hook pro naÄŤtenĂ­ zĂˇpasĹŻ
//VĂ˝hoda: UI komponenta jen vypisuje, hook Ĺ™eĹˇĂ­ data fetching.

import { useState, useEffect } from "react";
import api from "../api/axios";

export const useMatches = () => {
    const [matches, setMatches] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        api.get("/matches/me/upcoming-overview")
            .then(res => setMatches(res.data))
            .catch(console.error)
            .finally(() => setLoading(false));
    }, []);

    return { matches, loading };
};
//logika oddÄ›lena od komponenty UI.
import { useState, useEffect } from "react";
import { getMyPlayers } from "../api/playerApi";

export const usePlayers = () => {
    const [players, setPlayers] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        getMyPlayers()
            .then(res => setPlayers(res.data))
            .catch(err => setError(err.message))
            .finally(() => setLoading(false));
    }, []);

    return { players, loading, error };
};
export * from "./PlayerIcons";
export * from "./NavigationIcons";
import { GiHamburgerMenu } from "react-icons/gi";
import { AiOutlineClose } from "react-icons/ai";

export const HamburgerIcon = () => <GiHamburgerMenu />;
export const CloseIcon = () => <AiOutlineClose />;
import { FaPhone, FaUser, FaShieldAlt } from "react-icons/fa";
import { GiHockey } from "react-icons/gi";

export const PhoneIcon = () => <FaPhone />;
export const UserIcon = () => <FaUser />;
export const AdminIcon = () => <FaShieldAlt />;
export const PlayerIcon = () => <GiHockey />;
import MatchCard from "../components/MatchCard";
import Player from "../components/Player";
import { useMatches } from "../hooks/useMatches";
import { useAuth } from "../hooks/useAuth";

const Home = () => {
    const { matches, loading } = useMatches();
    const { user } = useAuth();

    if (loading) return <p>NaÄŤĂ­tĂˇm dataâ€¦</p>;

    return (
        <div>
           <Player />
            <h3>NadchĂˇzejĂ­cĂ­ zĂˇpasy</h3>
            {matches.map(match => (
                <MatchCard key={match.id} match={match} showPricePerPlayer />
            ))}
        </div>
    );
};

export default Home;
import React, { useState, useEffect } from "react";
import { useAuth } from "../hooks/useAuth";
import { loginUser } from "../api/authApi";
import { useNavigate } from "react-router-dom";

const LoginPage = () => {
    const navigate = useNavigate();
    const { updateUser } = useAuth();
    const [email, setEmail] = useState("");
    const [password, setPassword] = useState("");
    const [error, setError] = useState(null);
    const [loading, setLoading] = useState(false);

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError(null);
        setLoading(true);

        try {
            await loginUser(email, password);
            await updateUser();               // naÄŤte usera do kontextu
            navigate("/");                    // pĹ™esmÄ›ruj na domovskou
        } catch (err) {
            setError(err?.response?.data?.message || "NeplatnĂ© pĹ™ihlĂˇĹˇenĂ­");
        } finally {
            setLoading(false);
        }
    };

    return (
        <div className="container mt-5">
            <div className="row justify-content-center">
                <div className="col-12 d-flex justify-content-center">
                    <div
                        className="card shadow p-4 mx-auto"
                        style={{ maxWidth: "420px" }}
                    >
                        <h3 className="text-center mb-2">PĹ™ihlĂˇĹˇenĂ­</h3>
                        <h5 className="text-center mb-4 text-muted">HokejApp</h5>

                        {error && (
                            <div className="alert alert-danger">
                                {error}
                            </div>
                        )}

                        <form onSubmit={handleSubmit}>
                            <div className="mb-3">
                                <label className="form-label">E-mail</label>
                                <input
                                    type="text"
                                    className="form-control"
                                    value={email}
                                    onChange={(e) => setEmail(e.target.value)}
                                    required
                                />
                            </div>

                            <div className="mb-4">
                                <label className="form-label">Heslo</label>
                                <input
                                    type="password"
                                    className="form-control"
                                    value={password}
                                    onChange={(e) => setPassword(e.target.value)}
                                    required
                                />
                            </div>

                            <button
                                type="submit"
                                className="btn btn-primary w-100 mb-2"
                                disabled={loading}
                            >
                                {loading ? "PĹ™ihlaĹˇujiâ€¦" : "PĹ™ihlĂˇsit se"}
                            </button>


                            {/*NOVĂ‰ TLAÄŚĂŤTKO PRO REGISTRACI */}
                            <button
                                type="button"
                                className="btn btn-outline-secondary w-100 mt-3"
                                onClick={() => navigate("/register")}
                            >
                                Registrovat se
                            </button>
                        </form>
                    </div>
                </div>
            </div>
        </div>
    );
};

export default LoginPage;
import React from 'react'

const matches = () => {


  return (
    <div>matches</div>
  )
}

export default matches
import React from 'react'
import Player from "../components/Player"

const Players = () => {

  return (
    <div>Player</div>


  )
}

export default Players
import { useState } from "react";
import { useNavigate } from "react-router-dom";
import { registerUser } from "../api/authApi";

const RegisterPage = () => {
  const navigate = useNavigate();

  const [form, setForm] = useState({
    name: "",
    surname: "",
    email: "",
    password: "",
    passwordConfirm: ""
  });

  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);
  const [success, setSuccess] = useState(false); // đź‘ NOVĂť STAV

  const handleChange = (e) => {
    setForm({
      ...form,
      [e.target.name]: e.target.value
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError(null);
    setLoading(true);
    setSuccess(false);

    if (form.password !== form.passwordConfirm) {
      setError("Hesla se neshodujĂ­.");
      setLoading(false);
      return;
    }

    try {
      await registerUser(form);

      // MĂŤSTO NAVIGATE ZOBRAZĂŤME HLĂĹ KU
      setSuccess(true);

    } catch (err) {
      setError(err.message || "Registrace se nezdaĹ™ila.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="container mt-4">
      <div className="row justify-content-center">
        <div className="col-md-6 col-lg-5">
          <div className="card shadow p-4">
            <h3 className="text-center mb-4">Registrace</h3>

            {error && (
              <div className="alert alert-danger">
                {error}
              </div>
            )}

            {success && (
              <div className="alert alert-success">
                <strong>Registrace probÄ›hla ĂşspÄ›ĹˇnÄ›.</strong>
                <br />
                Byl VĂˇm zaslĂˇn e-mail s odkazem pro aktivaci ĂşÄŤtu.
                ProsĂ­m zkontrolujte svou schrĂˇnku (i sloĹľku Spam).
              </div>
            )}

            {/* đź”ą FORMULĂĹ SE SKRYJE PO ĂšSPÄšCHU */}
            {!success && (
              <form onSubmit={handleSubmit}>
                <div className="mb-3">
                  <label className="form-label">KĹ™estnĂ­ jmĂ©no</label>
                  <input
                    type="text"
                    className="form-control"
                    name="name"
                    value={form.name}
                    onChange={handleChange}
                    required
                  />
                </div>

                <div className="mb-3">
                  <label className="form-label">PĹ™Ă­jmenĂ­</label>
                  <input
                    type="text"
                    className="form-control"
                    name="surname"
                    value={form.surname}
                    onChange={handleChange}
                    required
                  />
                </div>

                <div className="mb-3">
                  <label className="form-label">E-mail</label>
                  <input
                    type="email"
                    className="form-control"
                    name="email"
                    value={form.email}
                    onChange={handleChange}
                    required
                  />
                </div>

                <div className="mb-3">
                  <label className="form-label">Heslo</label>
                  <input
                    type="password"
                    className="form-control"
                    name="password"
                    value={form.password}
                    onChange={handleChange}
                    required
                  />
                </div>

                <div className="mb-3">
                  <label className="form-label">PotvrzenĂ­ hesla</label>
                  <input
                    type="password"
                    className="form-control"
                    name="passwordConfirm"
                    value={form.passwordConfirm}
                    onChange={handleChange}
                    required
                  />
                </div>

                <button
                  type="submit"
                  className="btn btn-primary w-100 mb-2"
                  disabled={loading}
                >
                  {loading ? "Registrujiâ€¦" : "Registrovat"}
                </button>
              </form>
            )}

            {/* đź”ą TLAÄŚĂŤTKO ZPÄšT NA LOGIN â€“ vĹľdy viditelnĂ© */}
            <button
              type="button"
              className="btn btn-outline-secondary w-100 mt-2"
              onClick={() => navigate("/login")}
            >
              ZpÄ›t na pĹ™ihlĂˇĹˇenĂ­
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default RegisterPage;
import { Outlet } from "react-router-dom"
import Navbar from "../components/Navbar"
import Footer from "../components/Footer"
import HeaderTop from "../components/HeaderTop"

const SharedLayout = () => {
    return (
        <div className="layout">
            <HeaderTop />
            <Navbar />
            <main className="content">
                <div className="container">
                    <Outlet />
                </div>
            </main>
            <Footer />
        </div>
    )
}

export default SharedLayout
