# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\AppConfig.java


package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class AppConfig {

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\AuditAspect.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

@Component
@Aspect
public class AuditAspect {

    private static final Logger logger = LoggerFactory.getLogger("AUDIT_LOGGER");

    // Pointcut pro v≈°echny metody ve slu≈æb√°ch
    @Pointcut("within(cz.phsoft.hokej.models.services..*)")
    public void serviceMethods() {}

    // Spust√≠ se p≈ôed metodou
    @Before("serviceMethods()")
    public void logBefore(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().toShortString();
        String args = java.util.Arrays.toString(joinPoint.getArgs());
        logger.info("START {} at {} with args {}", methodName, LocalDateTime.now(), args);
    }

    // Spust√≠ se po √∫spƒõ≈°n√©m dokonƒçen√≠ metody
    @AfterReturning(pointcut = "serviceMethods()", returning = "result")
    public void logAfterReturning(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();

        Long userId = null;
        Long playerId = null;

        for (Object arg : args) {
            if (arg instanceof PlayerEntity player) {
                playerId = player.getId();
            } else if (arg instanceof MatchRegistrationEntity registration) {
                playerId = registration.getPlayer().getId();
            } else if (arg instanceof Long id) {
                // pokud m√° metoda Long parametry, m≈Ø≈æe≈° urƒçit podle po≈ôad√≠
                // t≈ôeba prvn√≠ Long = matchId, druh√Ω = playerId
            }
        }

        // logov√°n√≠
        logger.info("END {} - userId={} playerId={} returned [{}] at {}",
                methodName, userId, playerId, result, LocalDateTime.now());
    }
}



# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\CustomJsonLoginFilter.java


package cz.phsoft.hokej.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.context.HttpSessionSecurityContextRepository;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

// filtr pro REST login
public class CustomJsonLoginFilter extends UsernamePasswordAuthenticationFilter {

    private final ObjectMapper objectMapper = new ObjectMapper();

    public CustomJsonLoginFilter(String loginUrl, AuthenticationManager authManager) {
        setFilterProcessesUrl(loginUrl);
        setAuthenticationManager(authManager);
    }

    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        try {
            // Podporujeme x-www-form-urlencoded i JSON
            String email = null;
            String password = null;

// Podporujeme x-www-form-urlencoded
            if ("application/x-www-form-urlencoded".equals(request.getContentType())) {
                email = request.getParameter("username");
                password = request.getParameter("password");
            }

// Podporujeme JSON
            if ((email == null || password == null) &&
                    request.getContentType() != null &&
                    request.getContentType().contains("application/json")) {
                Map<String, String> json = objectMapper.readValue(request.getInputStream(), Map.class);
                email = json.get("email");
                password = json.get("password");
            }


            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(email, password);
            setDetails(request, authRequest);

            return this.getAuthenticationManager().authenticate(authRequest);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }


    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
                                            FilterChain chain, Authentication authResult)
            throws IOException, ServletException {

        // Ulo≈æen√≠ do SecurityContextHolder
        SecurityContextHolder.getContext().setAuthentication(authResult);

        // Vytvo≈ôen√≠ session a ulo≈æen√≠ SPRING_SECURITY_CONTEXT
        request.getSession(true).setAttribute(
                HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY,
                SecurityContextHolder.getContext()
        );

        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");

        Map<String, Object> result = new HashMap<>();
        result.put("status", "ok");
        result.put("user", authResult.getName());

        objectMapper.writeValue(response.getWriter(), result);
    }

    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException {
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");

        Map<String, Object> result = new HashMap<>();
        result.put("status", "error");
        result.put("message", "Neplatn√© p≈ôihla≈°ovac√≠ √∫daje");

        objectMapper.writeValue(response.getWriter(), result);
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\CustomUserDetailsService.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.Set;
import java.util.stream.Collectors;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final AppUserRepository appUserRepository;

    public CustomUserDetailsService(AppUserRepository appUserRepository) {
        this.appUserRepository = appUserRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        AppUserEntity user = appUserRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        return org.springframework.security.core.userdetails.User.builder()
                .username(user.getEmail())
                .password(user.getPassword())
                .roles(user.getRole().name().replace("ROLE_", "")) // "ADMIN", "PLAYER", ...
                .build();
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\DataInitializer.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import jakarta.annotation.PostConstruct;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Component;
import org.springframework.jdbc.core.JdbcTemplate;


import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Component
public class DataInitializer {

    private final PlayerRepository playerRepository;
    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository matchRegistrationRepository;
    private final AppUserRepository appUserRepository;
    private final JdbcTemplate jdbcTemplate;

    public DataInitializer(PlayerRepository playerRepository,
                           MatchRepository matchRepository,
                           MatchRegistrationRepository matchRegistrationRepository,
                           AppUserRepository appUserRepository,
                           JdbcTemplate jdbcTemplate) {
        this.playerRepository = playerRepository;
        this.matchRepository = matchRepository;
        this.matchRegistrationRepository = matchRegistrationRepository;
        this.appUserRepository = appUserRepository;
        this.jdbcTemplate = jdbcTemplate;
    }

    @PostConstruct
    public void init() {
        // Pokud existuje alespo≈à 1 hr√°ƒç, DB u≈æ byla inicializovan√°
        if (playerRepository.count() > 0) {
            System.out.println("Data already initialized ‚Äì skipping DataInitializer.");
            return;
        }
        System.out.println("Initializing default data...");

        // --- Seznam hr√°ƒç≈Ø ---
        List<PlayerEntity> players = new ArrayList<>(List.of(
                new PlayerEntity("Hr√°ƒç_1", "Jedna", "", PlayerType.VIP, "+420776609956", Team.DARK),
                new PlayerEntity("Hr√°ƒç_2", "Dva", "", PlayerType.VIP, "+420776609956", Team.LIGHT),
                new PlayerEntity("Hr√°ƒç_3", "T≈ôi", "", PlayerType.VIP, "+420776609956", Team.LIGHT),
                new PlayerEntity("Hr√°ƒç_4", "ƒåty≈ôi", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT),
                new PlayerEntity("Hr√°ƒç_5", "Pƒõt", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT),
                new PlayerEntity("Hr√°ƒç_6", "≈†est", "", PlayerType.STANDARD, "+420776609956", Team.DARK),
                new PlayerEntity("Hr√°ƒç_7", "Sedm", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT),
                new PlayerEntity("Hr√°ƒç_8", "Osum", "", PlayerType.BASIC, "+420776609956", Team.DARK),
                new PlayerEntity("Hr√°ƒç_9", "Devƒõt", "", PlayerType.BASIC, "+420776609956", Team.DARK),
                new PlayerEntity("Hr√°ƒç_10", "Deset", "", PlayerType.BASIC, "+420776609956", Team.DARK)
                // ... p≈ô√≠padnƒõ dal≈°√≠ hr√°ƒçi
        ));

        // --- Vytvo≈ôen√≠ u≈æivatel≈Ø ke ka≈æd√©mu hr√°ƒçi ---

        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();

        // --- Default admin ---
        if (appUserRepository.findByEmail("admin@example.com").isEmpty()) {
            AppUserEntity admin = new AppUserEntity();
            admin.setEmail("admin@example.com");
            admin.setPassword(encoder.encode("Administrator123"));
            admin.setRole(Role.ROLE_ADMIN);
            appUserRepository.save(admin);
            System.out.println("Default admin user created.");
        } else {
            System.out.println("Admin user already exists ‚Äì skipping.");
        }

        System.out.println("Data initialization completed.");

        int playerCounter = 1;
        for (PlayerEntity player : players) {
            // vytvo≈ôen√≠ u≈æivatele
            String email = "player" + playerCounter + "@example.com";
            String password = "Player123";

            AppUserEntity user = new AppUserEntity();
            user.setEmail(email);
            user.setPassword(encoder.encode(password));
            user.setRole(Role.ROLE_PLAYER);

            // p≈ôi≈ôadit hr√°ƒçe k u≈æivateli
            player.setUser(user);

            // ulo≈æit u≈æivatele (cascade ulo≈æ√≠ i hr√°ƒçe, pokud je spr√°vnƒõ nastaven)
            appUserRepository.save(user);

            playerCounter++;
        }

        // --- Ulo≈æit hr√°ƒçe (u≈æ ulo≈æen p≈ôi cascade, ale pro jistotu) ---
        playerRepository.saveAll(players);

        // --- Vytvo≈ôen√≠ z√°pas≈Ø ---
        LocalDateTime startDate = LocalDateTime.of(2025, 11, 21, 18, 45);
        for (int i = 0; i < 10; i++) {
            MatchEntity match = new MatchEntity();
            match.setDateTime(startDate.plusWeeks(i));
            match.setLocation("Ostravice");
            match.setDescription("");
            match.setMaxPlayers(12);
            match.setPrice(2200);
            matchRepository.save(match);
        }

        // --- Registrace hr√°ƒç≈Ø na z√°pas id 3 ---
        MatchEntity match3 = matchRepository.findById(3L)
                .orElseThrow(() -> new RuntimeException("Match with id 3 not found"));

        for (long playerId = 1; playerId <= 6; playerId++) {
            final long pid = playerId;
            PlayerEntity player = playerRepository.findById(playerId)
                    .orElseThrow(() -> new RuntimeException("Player with id " + pid + " not found"));

            MatchRegistrationEntity reg = new MatchRegistrationEntity();
            reg.setMatch(match3);
            reg.setPlayer(player);
            reg.setStatus(PlayerMatchStatus.REGISTERED);
            reg.setTimestamp(LocalDateTime.now());
            reg.setCreatedBy("user");
            matchRegistrationRepository.save(reg);
        }

        // --- Default admin ---
        if (appUserRepository.findByEmail("admin@example.com").isEmpty()) {
            AppUserEntity admin = new AppUserEntity();
            admin.setEmail("admin@example.com");
            admin.setPassword(encoder.encode("Administrator123"));
            admin.setRole(Role.ROLE_ADMIN);
            appUserRepository.save(admin);
            System.out.println("Default admin user created.");
        } else {
            System.out.println("Admin user already exists ‚Äì skipping.");
        }

        // --- vytvo≈ôen√≠ triggeru ---
        try {
            jdbcTemplate.execute("""
                           CREATE TRIGGER trg_match_reg_insert
                           AFTER INSERT ON match_registrations
                           FOR EACH ROW
                           BEGIN
                               INSERT INTO match_registration_history
                               (match_registration_id, match_id, player_id, status, excuse_reason,
                                excuse_note, admin_note, jersey_color, original_timestamp, created_by,
                                action, changed_at)
                               VALUES
                               (NEW.id, NEW.match_id, NEW.player_id, NEW.status, NEW.excuse_reason,
                                NEW.excuse_note, NEW.admin_note, NEW.jersey_color, NEW.timestamp, NEW.created_by,
                                'INSERT', NOW());
                           END
                    """);
            System.out.println("Trigger created successfully.");
        } catch (Exception e) {
            System.out.println("Trigger already exists or error: " + e.getMessage());
        }

        try {
            jdbcTemplate.execute("""
                    CREATE TRIGGER trg_match_reg_update
                    AFTER UPDATE ON match_registrations
                    FOR EACH ROW
                    BEGIN
                        INSERT INTO match_registration_history
                        (match_registration_id, match_id, player_id, status, excuse_reason,
                         excuse_note, admin_note, jersey_color, original_timestamp, created_by,
                         action, changed_at)
                        VALUES
                        (NEW.id, NEW.match_id, NEW.player_id, NEW.status, NEW.excuse_reason,
                         NEW.excuse_note, NEW.admin_note, NEW.jersey_color, NEW.timestamp, NEW.created_by,
                         'UPDATE', NOW());
                    END
                    """);
            System.out.println("Trigger created successfully.");
        } catch (Exception e) {
            System.out.println("Trigger already exists or error: " + e.getMessage());
        }

        try {
            jdbcTemplate.execute("""
        CREATE TRIGGER trg_match_reg_delete
        AFTER DELETE ON match_registrations
        FOR EACH ROW
                BEGIN
        INSERT INTO match_registration_history
                (match_registration_id, match_id, player_id, status, excuse_reason,
                        excuse_note, admin_note, jersey_color, original_timestamp, created_by,
                        action, changed_at)
        VALUES
                (OLD.id, OLD.match_id, OLD.player_id, OLD.status, OLD.excuse_reason,
                        OLD.excuse_note, OLD.admin_note, OLD.jersey_color, OLD.timestamp, OLD.created_by,
                        'DELETE', NOW());
        END
        """);
            System.out.println("Trigger created successfully.");
                } catch (Exception e) {
                    System.out.println("Trigger already exists or error: " + e.getMessage());
                }
        
        System.out.println("Data initialization completed.");
    

    }
}





# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\GlobalExceptionHandler.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.exceptions.ApiError;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import jakarta.servlet.http.HttpServletRequest;

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ApiError> handleAccessDenied(AccessDeniedException ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.FORBIDDEN.value(),
                "Forbidden",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // ‚Üê IP klienta);
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(error);
    }

    // --- Nenalezen√© zdroje (404) ---
    @ExceptionHandler({
            MatchNotFoundException.class,
            PlayerNotFoundException.class,
            RegistrationNotFoundException.class
    })
    public ResponseEntity<ApiError> handleNotFound(RuntimeException ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.NOT_FOUND.value(),
                "Not Found",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // ‚Üê IP klienta
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    // --- Konflikty (409) ---
    @ExceptionHandler(DuplicateRegistrationException.class)
    public ResponseEntity<ApiError> handleConflict(DuplicateRegistrationException ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.CONFLICT.value(),
                "Conflict",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // ‚Üê IP klienta);
        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
    }

    // --- Obecn√© chyby (500) ---
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiError> handleAll(Exception ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // ‚Üê IP klienta);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\SecurityConfig.java


package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;



import java.util.List;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;

    @Value("${app.test-mode:false}")
    private boolean isTestMode;

    public SecurityConfig(CustomUserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    // Password encoder
    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    // Authentication provider
    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    // AuthenticationManager
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    // Security filter chain
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http, AuthenticationManager authManager) throws Exception {

        http.csrf(csrf -> csrf.disable())
                .cors(cors -> {});

        if (isTestMode) {
            // üîπ Test mode - v≈°echno povoleno a HTTP Basic pro Postman
            http.authorizeHttpRequests(auth -> auth.anyRequest().permitAll())
                    .httpBasic();
        } else {
            // üîπ Produkce - REST login p≈ôes CustomJsonLoginFilter
            http.authorizeHttpRequests(auth -> auth
                            .requestMatchers("/api/matches").hasAnyRole("ADMIN","MANAGER")
                            .requestMatchers("/api/matches/upcoming", "/api/matches/past").hasAnyRole("ADMIN","MANAGER")
                            .requestMatchers("/api/matches/**").authenticated()
                            .requestMatchers("/api/players").hasAnyRole("ADMIN","MANAGER")
                            .requestMatchers("/api/players/**").authenticated()
                            .requestMatchers("/api/registrations/all",
                                    "/api/registrations/for-match/**",
                                    "/api/registrations/no-response/**").hasAnyRole("ADMIN","MANAGER")
                            .requestMatchers("/api/registrations/**").authenticated()
                            .requestMatchers("/api/inactivity/All",
                                    "/api/inactivity/**").hasAnyRole("ADMIN","MANAGER")
                            .requestMatchers("/api/inactivity/player/**").authenticated()
                            .anyRequest().authenticated()
                    )
                    //  TADY P≈òESNƒö
                    .sessionManagement(sm ->
                            sm.sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
                    )
                    //  a TEPRVE PAK login filter
                    .addFilterAt(
                            new CustomJsonLoginFilter("/api/login", authManager),
                            UsernamePasswordAuthenticationFilter.class
                    )
                    .logout(logout -> logout
                            .logoutUrl("/logout")
                            .deleteCookies("JSESSIONID")
                            .logoutSuccessHandler((request, response, auth) -> {
                                response.setContentType("application/json");
                                response.setCharacterEncoding("UTF-8");
                                response.getWriter().write("{\"status\":\"ok\",\"message\":\"Odhl√°≈°eno\"}");
                            })
                    );
        }

        return http.build();
    }

    // CORS pro React dev server a cookies
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(List.of("http://localhost:5173"));
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\DebugController.java


package cz.phsoft.hokej.controllers;

import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class DebugController {

    @GetMapping("/api/debug/me")
    public Object me(Authentication auth) {
        return auth;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\MatchController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;
import cz.phsoft.hokej.models.dto.MatchOverviewDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.services.MatchService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;


@RestController
@RequestMapping("/api/matches")
@CrossOrigin(origins = "*")
public class MatchController {

    private final MatchService matchService;


    public MatchController(MatchService matchService) {
        this.matchService = matchService;

    }

    // Detail z√°pasu
    @GetMapping("/matchDetail/{id}")
    public MatchDetailDTO getMatchDetail(@PathVariable Long id) {
        return matchService.getMatchDetail(id);
    }

    // V≈°echny z√°pasy
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getAllMatches() {
        return matchService.getAllMatches();
    }

    // Nadch√°zej√≠c√≠ z√°pas
    @PreAuthorize("isAuthenticated()")
    @GetMapping("/next")
    public MatchDTO getNextMatch() {
        return matchService.getNextMatch();
    }

    // V≈°echny nadch√°zej√≠c√≠ z√°pasy
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #playerId)")
    @GetMapping("/upcoming")
    public List<MatchDTO> getUpcomingMatches() {
        return matchService.getUpcomingMatches();
    }

    // Nadch√°zej√≠c√≠ z√°pasy pro p≈ôihl√°≈°en√©ho hr√°ƒçe
    @GetMapping("/me/upcoming")
    @PreAuthorize("isAuthenticated()")
    public List<MatchDTO> getUpcomingMatchesForMe(Authentication authentication) {
        // z UserDetails z√≠sk√°me username
        String email = authentication.getName();
        // najdeme hr√°ƒçe podle emailu
        Long playerId = matchService.getPlayerIdByEmail(email);
        return matchService.getUpcomingMatchesForPlayer(playerId);
    }

    @GetMapping("/me/upcoming-overview")
    @PreAuthorize("isAuthenticated()")
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForMe(Authentication authentication) {
        String email = authentication.getName();
        Long playerId = matchService.getPlayerIdByEmail(email);
        return matchService.getUpcomingMatchesOverviewForPlayer(playerId);
    }

    // Nadch√°zej√≠c√≠ z√°pasy pro konkr√©tn√≠ho hr√°ƒçe
    @GetMapping("/player/{playerId}/upcoming")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #playerId)")
    public List<MatchDTO> getUpcomingMatchesForPlayer(@PathVariable Long playerId) {
        return matchService.getUpcomingMatchesForPlayer(playerId);
    }

    // U≈æ uskuteƒçnƒõn√© z√°pasy
    @GetMapping("/past")
    public List<MatchDTO> getPastMatches() {
        return matchService.getPastMatches();
    }

    // Vytvo≈ôen√≠ z√°pasu
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public MatchDTO createMatch(@Valid @RequestBody MatchDTO matchDTO) {
        return matchService.createMatch(matchDTO);
    }

    // Z√≠sk√°n√≠ z√°pasu podle ID
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO getMatch(@PathVariable Long id) {
        return matchService.getMatchById(id);
    }

    // Editace z√°pasu
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO updateMatch(@PathVariable Long id, @Valid @RequestBody MatchDTO dto) {
        return matchService.updateMatch(id, dto);
    }

    // Smaz√°n√≠ z√°pasu
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SuccessResponseDTO> deleteMatch(@PathVariable Long id) {
        SuccessResponseDTO response = matchService.deleteMatch(id);
        return ResponseEntity.ok(response);
    }

    // Dostupn√© z√°pasy pro hr√°ƒçe
    @GetMapping("/available-for-player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #playerId)")
    public List<MatchDTO> getAvailableMatchesForPlayer(@PathVariable Long playerId) {
        return matchService.getAvailableMatchesForPlayer(playerId);
    }

}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\MatchRegistrationController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import cz.phsoft.hokej.security.PlayerSecurity;
import org.springframework.web.bind.annotation.*;
import org.springframework.security.access.prepost.PreAuthorize;

import java.util.List;

@RestController
@RequestMapping("/api/registrations")
@CrossOrigin(origins = "*")
public class MatchRegistrationController {

    private final MatchRegistrationService service;
    private final PlayerSecurity playerSecurity;

    public MatchRegistrationController(MatchRegistrationService service,
                                       PlayerSecurity playerSecurity) {
        this.service = service;
        this.playerSecurity = playerSecurity;
    }

    // -----------------------------------------------------
    // üî• JEDIN√ù UNIVERZ√ÅLN√ç ENDPOINT PRO REGISTRACE
    // -----------------------------------------------------
    @PostMapping("/upsert")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #request.playerId)")
    public MatchRegistrationDTO upsert(@RequestBody MatchRegistrationRequest request) {
        return service.upsertRegistration(
                request.getMatchId(),
                request.getPlayerId(),
                request.getJerseyColor(),
                request.getAdminNote(),
                request.getExcuseReason(),
                request.getExcuseNote(),
                request.isUnregister()
        );
    }

    // -----------------------------------------------------
    // GET ENDPOINTY
    // -----------------------------------------------------

    @GetMapping("/all")
    public List<MatchRegistrationDTO> getAllRegistrations() {
        return service.getAllRegistrations();
    }

    @GetMapping("/for-player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #playerId)")
    public List<MatchRegistrationDTO> forPlayer(@PathVariable Long playerId) {
        return service.getRegistrationsForPlayer(playerId);
    }

    @GetMapping("/for-match/{matchId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> forMatch(@PathVariable Long matchId) {
        return service.getRegistrationsForMatch(matchId);
    }

    @GetMapping("/no-response/{matchId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getNoResponse(@PathVariable Long matchId) {
        return service.getNoResponsePlayers(matchId);
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.PlayerService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/players")
@CrossOrigin(origins = "*")
public class PlayerController {

    private final PlayerService playerService;

    public PlayerController(PlayerService playerService) {
        this.playerService = playerService;
    }

    // v≈°ichni hr√°ƒçi
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getAllPlayers() {
        return playerService.getAllPlayers();
    }

    // hr√°ƒç dle id

    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #id)")
    public PlayerDTO getPlayerById(@PathVariable Long id) {
        return playerService.getPlayerById(id);
    }

    // vytvo≈ôen√≠ hr√°ƒçe
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    @PostMapping
    public PlayerDTO createPlayer(@RequestBody PlayerDTO playerDTO) {
        return playerService.createPlayer(playerDTO);

    }

    // aktualizace hr√°ƒçe dle id hr√°ƒçe
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    @PutMapping("/{id}")
    public PlayerDTO updatePlayer(@PathVariable Long id, @RequestBody PlayerDTO dto) {
        return playerService.updatePlayer(id, dto);
    }

    // odstran√≠ hr√°ƒçe
    @PreAuthorize("hasRole('ADMIN')")
    @DeleteMapping("/{id}")
    public ResponseEntity<SuccessResponseDTO> deletePlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.deletePlayer(id);
        return ResponseEntity.ok(response);
    }


}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerInactivityPeriodController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import cz.phsoft.hokej.models.services.PlayerInactivityPeriodService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/inactivity")
@CrossOrigin(origins = "*")
public class PlayerInactivityPeriodController {

    private final PlayerInactivityPeriodService service;

    public PlayerInactivityPeriodController(PlayerInactivityPeriodService service) {
        this.service = service;
    }

    // v≈°echny z√°znamy o neaktivitƒõ hr√°ƒç≈Ø
    @GetMapping("/all")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getAll() {
        return service.getAll();
    }

    // neaktivita hr√°ƒç≈Ø dle id neaktivity
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<PlayerInactivityPeriodDTO> getById(@PathVariable Long id) {
        PlayerInactivityPeriodDTO dto = service.getById(id);
        return ResponseEntity.ok(dto);
    }

    // z√≠sk√° z√°znamy o periodƒõ neaktivity dle id hr√°ƒçe
    @GetMapping("/player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getByPlayer(@PathVariable Long playerId) {
        return service.getByPlayer(playerId);
    }

    // vytvo≈ô√≠ z√°znam o neaktivitƒõ hr√°ƒçe
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<PlayerInactivityPeriodDTO> create(@RequestBody PlayerInactivityPeriodDTO dto) {
        PlayerInactivityPeriodDTO created = service.create(dto);
        return ResponseEntity.ok(created);
    }

    // zmƒõn√≠ z√°znam o neaktivitƒõ hr√°ƒçe dle id
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<PlayerInactivityPeriodDTO> update(
            @PathVariable Long id,
            @RequestBody PlayerInactivityPeriodDTO dto) {

        PlayerInactivityPeriodDTO updated = service.update(id, dto);
        return ResponseEntity.ok(updated);
    }

    // vyma≈æe z√°znam o neaktivitƒõ hr√°ƒçe dle id z√°znamu
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        service.delete(id);
        return ResponseEntity.noContent().build();
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestController.java


package cz.phsoft.hokej.controllers;

import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/test")
@CrossOrigin(origins = "*")
public class TestController {

    @GetMapping
    public String hello() {
        return "Backend je online!";
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestSmsController.java


/*
package cz.phsoft.hokej.controllers;


import cz.phsoft.hokej.models.services.sms.SmsTextBeeService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TestSmsController {

    private final SmsTextBeeService smsTextBeeService;

    public TestSmsController(SmsTextBeeService smsTextBeeService) {
        this.smsTextBeeService = smsTextBeeService;
    }

    /**
     * Testovac√≠ endpoint pro odesl√°n√≠ SMS na testovac√≠ ƒç√≠slo.
     * Zavolej: GET /api/test-sms
     */
/*
    @GetMapping("/api/test-sms")
    public String sendTestSms() {
        smsTextBeeService.sendSms("+420776609956", "testovac√≠ sms app-sg");
        return "SMS byla odesl√°na na testovac√≠ ƒç√≠slo +420776609956";
    }
}

        */


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\AppUserEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.Role;
import jakarta.persistence.*;

import java.util.Set;

@Entity
@Table(name = "app_users")
public class AppUserEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role;

    // One-to-Many: jeden u≈æivatel ‚Üí v√≠ce hr√°ƒç≈Ø
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<PlayerEntity> players;

    // gettery/settery


    public Long getId() {return id;    }
    public void setId(Long id) {        this.id = id;    }

    public String getEmail() {        return email;    }
    public void setEmail(String email) {        this.email = email;    }

    public String getPassword() {        return password;    }
    public void setPassword(String password) {        this.password = password;    }

    public Role getRole() {        return role;    }
    public void setRole(Role role) {        this.role = role;    }

    public Set<PlayerEntity> getPlayers() {        return players;    }
    public void setPlayers(Set<PlayerEntity> players) {        this.players = players;    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchEntity.java


package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;
import java.time.LocalDateTime;

/**
 * t≈ô√≠da pro vkl√°d√°n√≠ Entity z√°pasu do db
 */
@Entity
@Table(name = "matches")
public class MatchEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private LocalDateTime dateTime;

    @Column(nullable = false)
    private String location;

    private String description;

    // maxim√°ln√≠ poƒçet hr√°ƒç≈Ø - vyu≈æ√≠v√° se pro ovƒõ≈ôen√≠ kapacity p≈ôi p≈ôihl√°≈°en√≠
    @Column(nullable = false)
    private Integer maxPlayers;

    @Column(nullable = false)
    private Integer price;

    public MatchEntity() {}

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }

    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() { return price; }

    public void setPrice(Integer price) { this.price = price; }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * t≈ô√≠da reprezentuje registracei hr√°ƒçe k z√°pasu
 */
@Entity
@Table(name = "match_registrations")
public class MatchRegistrationEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "match_id", nullable = false)
    private MatchEntity match;

    @ManyToOne
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerMatchStatus status;

    @Enumerated(EnumType.STRING)
    private ExcuseReason excuseReason;

    private String excuseNote;

    // admin m≈Ø≈æe vlo≈æit pozn√°mku, nap≈ô. kdy≈æ se nƒõkdo zaregistruje a pot√© nep≈ô√≠jde
    private String adminNote;

    @Enumerated(EnumType.STRING)
    @Column(name = "jersey_color")
    private Team jerseyColor;

    // datƒças vytvo≈ôen√≠ registrace - mus√≠ se mƒõnit aby nebyl hr√°ƒç i po zru≈°en√≠ registrace
    // v po≈ôad√≠ p≈ôed hr√°ƒçi kte≈ô√≠ se registrovali po zru≈°en√≠ registrace
    @Column(nullable = false, updatable = true)
    private LocalDateTime timestamp = LocalDateTime.now();

    // syst√©m automaticky vytv√°≈ô√≠ reserved/registered dle kapacity - maxPlayers
    @Column(nullable = false, updatable = true)
    private String createdBy; // "user" nebo "system"

    public MatchRegistrationEntity() {
    }

    // Gettery a Settery


    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public MatchEntity getMatch() {
        return match;
    }

    public void setMatch(MatchEntity match) {
        this.match = match;
    }

    public PlayerEntity getPlayer() {
        return player;
    }

    public void setPlayer(PlayerEntity player) {
        this.player = player;
    }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }

    public ExcuseReason getExcuseReason() {
        return excuseReason;
    }

    public void setExcuseReason(ExcuseReason excuseReason) {
        this.excuseReason = excuseReason;
    }

    public String getExcuseNote() {
        return excuseNote;
    }

    public void setExcuseNote(String excuseNote) {
        this.excuseNote = excuseNote;
    }

    public String getAdminNote() {
        return adminNote;
    }

    public void setAdminNote(String adminNote) {
        this.adminNote = adminNote;
    }

    public Team getJerseyColor() {
        return jerseyColor;
    }

    public void setJerseyColor(Team jerseyColor) {
        this.jerseyColor = jerseyColor;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }
}





# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationHistoryEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.persistence.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "match_registration_history")
public class MatchRegistrationHistoryEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // ID z p≈Øvodn√≠ hlavn√≠ tabulky
    @Column(name = "match_registration_id", nullable = false)
    private Long matchRegistrationId;

    @Column(name = "match_id", nullable = false)
    private Long matchId;

    @Column(name = "player_id", nullable = false)
    private Long playerId;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerMatchStatus status;

    @Enumerated(EnumType.STRING)
    @Column(name = "excuse_reason")
    private ExcuseReason excuseReason;

    @Column(name = "excuse_note")
    private String excuseNote;

    @Column(name = "admin_note")
    private String adminNote;

    @Enumerated(EnumType.STRING)
    @Column(name = "jersey_color")
    private Team jerseyColor;

    // p≈Øvodn√≠ timestamp
    @Column(name = "original_timestamp", nullable = false)
    private LocalDateTime originalTimestamp;

    @Column(name = "created_by", nullable = false)
    private String createdBy;

    @Column(nullable = false)
    private String action; // INSERT / UPDATE / DELETE

    @Column(name = "changed_at", nullable = false)
    private LocalDateTime changedAt;

    public MatchRegistrationHistoryEntity() {
    }

    // Gettery a settery


    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getMatchRegistrationId() {
        return matchRegistrationId;
    }

    public void setMatchRegistrationId(Long matchRegistrationId) {
        this.matchRegistrationId = matchRegistrationId;
    }

    public Long getMatchId() {
        return matchId;
    }

    public void setMatchId(Long matchId) {
        this.matchId = matchId;
    }

    public Long getPlayerId() {
        return playerId;
    }

    public void setPlayerId(Long playerId) {
        this.playerId = playerId;
    }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }

    public ExcuseReason getExcuseReason() {
        return excuseReason;
    }

    public void setExcuseReason(ExcuseReason excuseReason) {
        this.excuseReason = excuseReason;
    }

    public String getExcuseNote() {
        return excuseNote;
    }

    public void setExcuseNote(String excuseNote) {
        this.excuseNote = excuseNote;
    }

    public String getAdminNote() {
        return adminNote;
    }

    public void setAdminNote(String adminNote) {
        this.adminNote = adminNote;
    }

    public Team getJerseyColor() {
        return jerseyColor;
    }

    public void setJerseyColor(Team jerseyColor) {
        this.jerseyColor = jerseyColor;
    }

    public LocalDateTime getOriginalTimestamp() {
        return originalTimestamp;
    }

    public void setOriginalTimestamp(LocalDateTime originalTimestamp) {
        this.originalTimestamp = originalTimestamp;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }

    public String getAction() {
        return action;
    }

    public void setAction(String action) {
        this.action = action;
    }

    public LocalDateTime getChangedAt() {
        return changedAt;
    }

    public void setChangedAt(LocalDateTime changedAt) {
        this.changedAt = changedAt;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerType;
import jakarta.persistence.*;

@Entity
@Table(name = "player_entity")
public class PlayerEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String surname;

    private String nickName;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerType type; // VIP, STANDARD, BASIC

    private String fullName;
    private String phoneNumber;

    @Enumerated(EnumType.STRING)
    private Team team;

    // Many-to-One: ka≈æd√Ω hr√°ƒç pat≈ô√≠ jednomu u≈æivateli
    @ManyToOne
    @JoinColumn(name = "user_id")
    private AppUserEntity user;

    // ----------------- Konstruktor -----------------
    public PlayerEntity() {
        this.type = PlayerType.BASIC;
    }

    public PlayerEntity(String name, String surname, String nickName, PlayerType type, String phoneNumber, Team team) {
        this.name = name;
        this.surname = surname;
        this.nickName = nickName;
        this.type = type;
        this.fullName = name + " " + surname;
        this.phoneNumber = phoneNumber;
        this.team = team;
    }

    // ----------------- Gettery a Settery -----------------
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
        updateFullName();
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
        updateFullName();
    }

    public String getNickname() { return nickName;}
    public void setNickname(String nickName) { this.nickName = nickName; }

    public String getFullName() {
        return fullName;
    }

    public PlayerType getType() {
        return type;
    }
    public void setType(PlayerType type) {
        this.type = type;
    }

    private void updateFullName() {
        this.fullName = name + " " + surname;
    }

    public String getPhoneNumber() {
        return phoneNumber;
    }
    public void setPhoneNumber(String phoneNumber) {
        this.phoneNumber = phoneNumber;
    }

    public Team getTeam() {
        return team;
    }
    public void setTeam(Team team) {
        this.team = team;
    }

    public AppUserEntity getUser() {
        return user;
    }
    public void setUser(AppUserEntity user) {
        this.user = user;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerInactivityPeriodEntity.java


package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "player_inactivity_period")
public class PlayerInactivityPeriodEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    // neaktivn√≠ od
    @Column(name = "inactive_from", nullable = false)
    private LocalDateTime inactiveFrom;

    // neaktivn√≠ do
    @Column(name = "inactive_to", nullable = false)
    private LocalDateTime inactiveTo;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public PlayerEntity getPlayer() {
        return player;
    }

    public void setPlayer(PlayerEntity player) {
        this.player = player;
    }

    public LocalDateTime getInactiveFrom() {
        return inactiveFrom;
    }

    public void setInactiveFrom(LocalDateTime inactiveFrom) {
        this.inactiveFrom = inactiveFrom;
    }

    public LocalDateTime getInactiveTo() {
        return inactiveTo;
    }

    public void setInactiveTo(LocalDateTime inactiveTo) {
        this.inactiveTo = inactiveTo;
    }

}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\ExcuseReason.java


package cz.phsoft.hokej.data.enums;

public enum ExcuseReason {
    NEMOC,
    PRACE,
    NECHE_SE_MI,
    JINE
}



# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\PlayerMatchStatus.java


package cz.phsoft.hokej.data.enums;

public enum PlayerMatchStatus {
    REGISTERED,
    UNREGISTERED,
    EXCUSED,  // omluven
    RESERVED, // n√°hradn√≠k

}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\PlayerType.java


package cz.phsoft.hokej.data.enums;

public enum PlayerType {
    VIP,
    STANDARD,
    BASIC
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\Role.java


package cz.phsoft.hokej.data.enums;

public enum Role {
    ROLE_PLAYER,
    ROLE_MANAGER,
    ROLE_ADMIN
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\Team.java


package cz.phsoft.hokej.data.enums;

public enum Team {
    DARK,
    LIGHT

}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\AppUserRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface AppUserRepository extends JpaRepository<AppUserEntity, Long> {
    Optional<AppUserEntity> findByEmail(String email);
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRegistrationHistoryRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchRegistrationHistoryEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface MatchRegistrationHistoryRepository extends JpaRepository<MatchRegistrationHistoryEntity, Long> {

    // v≈°echny registrace na z√°pas
    List<MatchRegistrationHistoryEntity> findByMatchRegistrationIdOrderByChangedAtDesc(Long matchRegistrationId);

    // Historie pro konkr√©tn√≠ z√°pas
    List<MatchRegistrationHistoryEntity> findByMatchIdOrderByChangedAtDesc(Long matchId);

    // Historie zmƒõn hr√°ƒçe
    List<MatchRegistrationHistoryEntity> findByPlayerIdOrderByChangedAtDesc(Long playerId);

}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRegistrationRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

    @Repository
    public interface MatchRegistrationRepository extends JpaRepository<MatchRegistrationEntity, Long> {

        // Vr√°t√≠ posledn√≠ status pro dan√©ho hr√°ƒçe a z√°pas
        Boolean existsByPlayerIdAndMatchId(Long playerId, Long matchId);

        // Volitelnƒõ: v≈°echny registrace pro urƒçit√Ω z√°pas
        List<MatchRegistrationEntity> findByMatchId(Long matchId);

        // Volitelnƒõ: v≈°echny registrace pro urƒçit√©ho hr√°ƒçe
        List<MatchRegistrationEntity> findByPlayerId(Long playerId);

        // --- Nov√° metoda pro hled√°n√≠ konkr√©tn√≠ registrace ---
        Optional<MatchRegistrationEntity> findByPlayerIdAndMatchId(Long playerId, Long matchId);

        long countByMatchIdAndStatus(Long matchId, PlayerMatchStatus status);
    }


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import java.time.LocalDateTime;
import java.util.List;

public interface MatchRepository extends JpaRepository<MatchEntity, Long> {
    List<MatchEntity> findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime dateTime);
    List<MatchEntity> findByDateTimeBeforeOrderByDateTimeDesc(LocalDateTime dateTime);
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\PlayerInactivityPeriodRepository.java



package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface PlayerInactivityPeriodRepository extends JpaRepository<PlayerInactivityPeriodEntity, Long> {

    // zjist√≠, zda hr√°ƒç je aktu√°lnƒõ neaktivn√≠
    boolean existsByPlayerAndInactiveFromLessThanEqualAndInactiveToGreaterThanEqual(
            PlayerEntity player, LocalDateTime from, LocalDateTime to);

    // z√≠sk√° v≈°echny neaktivn√≠ obdob√≠ hr√°ƒçe, kter√© spadaj√≠ do intervalu
    List<PlayerInactivityPeriodEntity> findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
            PlayerEntity player, LocalDateTime from, LocalDateTime to);

    List<PlayerInactivityPeriodEntity> findByPlayerOrderByInactiveFromAsc(PlayerEntity player);
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\PlayerRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface PlayerRepository extends JpaRepository<PlayerEntity, Long> {
    Optional<PlayerEntity> findById(Long id);

    List<PlayerEntity> findByIdNotIn(List<Long> ids);
    boolean existsByNameAndSurname(String name, String surname);

    Optional<PlayerEntity> findByNameAndSurname(String name, String surname);
    Optional<PlayerEntity> findByUserEmail(String email);

}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\ApiError.java


package cz.phsoft.hokej.exceptions;

import com.fasterxml.jackson.annotation.JsonFormat;
import java.time.LocalDateTime;

public class ApiError {

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime timestamp;
    private int status;
    private String error;
    private String message;
    private String path;
    private String clientIp; // ‚Üê novƒõ

    public ApiError(int status, String error, String message, String path, String clientIp) {
        this.timestamp = LocalDateTime.now();
        this.status = status;
        this.error = error;
        this.message = message;
        this.path = path;
        this.clientIp = clientIp;
    }

    public LocalDateTime getTimestamp() { return timestamp; }
    public int getStatus() { return status; }
    public String getError() { return error; }
    public String getMessage() { return message; }
    public String getPath() { return path; }
    public String getClientIp() { return clientIp; }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\DuplicateRegistrationException.java


package cz.phsoft.hokej.exceptions;

public class DuplicateRegistrationException extends RuntimeException {
    public DuplicateRegistrationException(Long matchId, Long playerId) {
        super("Hr√°ƒç " + playerId + " ji≈æ m√° aktivn√≠ registraci na z√°pas " + matchId);
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\MatchNotFoundException.java


package cz.phsoft.hokej.exceptions;

public class MatchNotFoundException extends RuntimeException {
    public MatchNotFoundException(Long matchId) {
        super("Z√°pas s ID " + matchId + " nenalezen.");;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\PlayerNotFoundException.java


package cz.phsoft.hokej.exceptions;

public class PlayerNotFoundException extends RuntimeException {
    public PlayerNotFoundException(Long playerId) {
        super("Hr√°ƒç s ID " + playerId + " nenalezen.");}
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\RegistrationNotFoundException.java


package cz.phsoft.hokej.exceptions;

public class RegistrationNotFoundException extends RuntimeException {
    public RegistrationNotFoundException(Long matchId, Long playerId) {
        super("Hr√°ƒç " + playerId + " nem√° registraci na z√°pas " + matchId);
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\AppUserMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.PlayerSummaryDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

import java.util.List;

@Mapper(componentModel = "spring")
public interface AppUserMapper {
    @Mapping(target = "players", source = "players")
    AppUserDTO toDto(AppUserEntity entity);

    List<AppUserDTO> toDtoList(List<AppUserEntity> entities);

    PlayerSummaryDTO toPlayerSummary(PlayerEntity entity);
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\MatchMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;

@Mapper(componentModel = "spring")
public interface MatchMapper {

    MatchDTO toDTO(MatchEntity entity);

    MatchEntity toEntity(MatchDTO dto);

    void updateEntity(MatchDTO dto, @MappingTarget MatchEntity entity);
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\MatchRegistrationMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

import java.util.List;

@Mapper(componentModel = "spring")
public interface MatchRegistrationMapper {

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "match", source = "match")
    @Mapping(target = "player", source = "player")
    @Mapping(target = "status", source = "status")
    @Mapping(target = "excuseReason", source = "excuseReason")
    @Mapping(target = "excuseNote", source = "note")
    @Mapping(target = "jerseyColor", source = "jerseyColor")
    @Mapping(target = "adminNote", source = "adminNote")
    @Mapping(target = "createdBy", source = "createdBy")
    @Mapping(target = "timestamp", expression = "java(java.time.LocalDateTime.now())")
    MatchRegistrationEntity toEntity(
            MatchEntity match,
            PlayerEntity player,
            PlayerMatchStatus status,
            ExcuseReason excuseReason,
            String note,
            Team jerseyColor,
            String adminNote,
            String createdBy
    );

    // entity ‚Üí DTO (voliteln√©)
    @Mapping(target = "matchId", source = "match.id")
    @Mapping(target = "playerId", source = "player.id")
    MatchRegistrationDTO toDTO(MatchRegistrationEntity entity);

    List<MatchRegistrationDTO> toDTOList(List<MatchRegistrationEntity> entities);
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\PlayerInactivityPeriodMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import org.mapstruct.*;

@Mapper(componentModel = "spring")
public interface PlayerInactivityPeriodMapper {

    // Entity -> DTO (OK)
    @Mapping(target = "playerId", source = "player.id")
    PlayerInactivityPeriodDTO toDTO(PlayerInactivityPeriodEntity entity);

    // DTO -> Entity (player ≈ôe≈°√≠ @ObjectFactory)
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "player", ignore = true)
    PlayerInactivityPeriodEntity toEntity(PlayerInactivityPeriodDTO dto, @Context PlayerEntity player);

    // UPDATE DTO -> existuj√≠c√≠ entity (bez zmƒõny player)
    @Mapping(target = "player", ignore = true)
    void updateEntityFromDto(PlayerInactivityPeriodDTO dto, @MappingTarget PlayerInactivityPeriodEntity entity);

    // FACTORY ‚Äì jedin√Ω spr√°vn√Ω zp≈Øsob, jak nastavit player z @Context
    @ObjectFactory
    default PlayerInactivityPeriodEntity createEntity(PlayerInactivityPeriodDTO dto, @Context PlayerEntity player) {
        PlayerInactivityPeriodEntity entity = new PlayerInactivityPeriodEntity();
        entity.setPlayer(player);
        return entity;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\PlayerMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

import java.util.List;

@Mapper(componentModel = "spring")
public interface PlayerMapper {

        // Entity ‚Üí DTO (heslo se nepos√≠l√°)
        @Mapping(target = "fullName", ignore = true) // generuje se v DTO
        PlayerDTO toDTO(PlayerEntity entity);

        // DTO ‚Üí Entity (heslo se mapuje, pokud existuje)
        PlayerEntity toEntity(PlayerDTO dto);

        // Aktualizace existuj√≠c√≠ho DTO (ignorujeme fullName)
        @Mapping(target = "fullName", ignore = true)
        void updatePlayerDTO(PlayerDTO source, @MappingTarget PlayerDTO target);

        // Aktualizace existuj√≠c√≠ Entity (heslo se mapuje, fullName nen√≠ pole v Entity)
        void updatePlayerEntity(PlayerDTO source, @MappingTarget PlayerEntity target);

    List<PlayerDTO> toDTOList(List<PlayerEntity> players);


}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\requests\MatchRegistrationRequest.java


package cz.phsoft.hokej.models.dto.requests;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.validation.constraints.*;


public class MatchRegistrationRequest {
    @NotNull
    @Positive
    private Long matchId;

    @NotNull
    @Positive
    private Long playerId;

    private Team jerseyColor;
    private ExcuseReason excuseReason;
    private String excuseNote;
    private String adminNote;
    private boolean unregister;

    public Long getMatchId() { return matchId; }
    public Long getPlayerId() { return playerId; }
    public Team getJerseyColor() { return jerseyColor; }
    public ExcuseReason getExcuseReason() { return excuseReason; }
    public String getExcuseNote() { return excuseNote; }
    public String getAdminNote() { return adminNote; }
    public boolean isUnregister() { return unregister; }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\AppUserDTO.java


package cz.phsoft.hokej.models.dto;

import java.util.Set;

public class AppUserDTO {
    private Long id;
    private String email;
    private String role;
    private Set<PlayerSummaryDTO> players; // jednostrann√©

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getRole() {
        return role;
    }

    public void setRole(String role) {
        this.role = role;
    }

    public Set<PlayerSummaryDTO> getPlayers() {
        return players;
    }

    public void setPlayers(Set<PlayerSummaryDTO> players) {
        this.players = players;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchDetailDTO.java


package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;

import java.time.LocalDateTime;
import java.util.List;

public class MatchDetailDTO {
    private Long id;
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime dateTime;
    private int maxPlayers;
    private int inGamePlayers;
    private int outGamePlayers;
    private int waitingPlayers;
    private int noActionPlayers;
    private double pricePerRegisteredPlayer;
    private int remainingSlots;

    List<PlayerDTO> registeredPlayers;
    List<PlayerDTO> reservedPlayers;
    List<PlayerDTO> unregisteredPlayers;
    List<PlayerDTO> excusedPlayers;
    List<PlayerDTO> noResponsePlayers;

    // Gettery a settery

    public Long getId() {       return id;    }
    public void setId(Long id) {
        this.id = id;
    }
    public LocalDateTime getDateTime() {
        return dateTime;
    }

    public void setDateTime(LocalDateTime dateTime) {
        this.dateTime = dateTime;
    }

    public int getMaxPlayers() {
        return maxPlayers;
    }
    public void setMaxPlayers(int maxPlayers) {
        this.maxPlayers = maxPlayers;
    }

    public int getInGamePlayers() {
        return inGamePlayers;
    }
    public void setInGamePlayers(int inGamePlayers) {
        this.inGamePlayers = inGamePlayers;
    }

    public void setOutGamePlayers(int outGamePlayers) {
        this.outGamePlayers = outGamePlayers;
    }

    public int getWaitingPlayers() {
        return waitingPlayers;
    }
    public void setWaitingPlayers(int waitingPlayers) {
        this.waitingPlayers = waitingPlayers;
    }

    public int getNoActionPlayers() {
        return noActionPlayers;
    }
    public void setNoActionPlayers(int noActionPlayers) {
        this.noActionPlayers = noActionPlayers;
    }

    public double getPricePerRegisteredPlayer() {
        return pricePerRegisteredPlayer;
    }
    public void setPricePerRegisteredPlayer(double pricePerRegisteredPlayer) {
        this.pricePerRegisteredPlayer = pricePerRegisteredPlayer;
    }

    public int getRemainingSlots() {
        return remainingSlots;
    }
    public void setRemainingSlots(int remainingSlots) {
        this.remainingSlots = remainingSlots;
    }

    public List<PlayerDTO> getRegisteredPlayers() {
        return registeredPlayers;
    }
    public void setRegisteredPlayers(List<PlayerDTO> registeredPlayers) {
        this.registeredPlayers = registeredPlayers;
    }

    public List<PlayerDTO> getReservedPlayers() {
        return reservedPlayers;
    }
    public void setReservedPlayers(List<PlayerDTO> reservedPlayers) {
        this.reservedPlayers = reservedPlayers;
    }

    public List<PlayerDTO> getUnregisteredPlayers() {
        return unregisteredPlayers;
    }

    public void setUnregisteredPlayers(List<PlayerDTO> unregisteredPlayers) {
        this.unregisteredPlayers = unregisteredPlayers;
    }
    public List<PlayerDTO> getExcusedPlayers() {
        return excusedPlayers;
    }
    public void setExcusedPlayers(List<PlayerDTO> excusedPlayers) {
        this.excusedPlayers = excusedPlayers;
    }

    public List<PlayerDTO> getNoResponsePlayers() {
        return noResponsePlayers;
    }
    public void setNoResponsePlayers(List<PlayerDTO> noResponsePlayers) {
        this.noResponsePlayers = noResponsePlayers;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchDTO.java


package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import jakarta.validation.constraints.FutureOrPresent;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

import java.time.LocalDateTime;

public class MatchDTO {

    private Long id;
    @NotNull(message = "Datum a ƒças z√°pasu je povinn√©.")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime dateTime;

    @NotBlank(message = "M√≠sto z√°pasu je povinn√©.")
    @Size(min = 3, max = 100)
    private String location;

    @Size(max = 255, message = "Popis m≈Ø≈æe m√≠t max 255 znak≈Ø.")
    private String description;

    @NotNull(message = "Maxim√°ln√≠ poƒçet hr√°ƒç≈Ø je povinn√Ω")
    private Integer maxPlayers;

    @NotNull(message = "Cena je povinn√°")
    private Integer price;

    // gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }
    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() {
        return price;
    }

    public void setPrice(Integer price) {
        this.price = price;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchOverviewDTO.java


package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import java.time.LocalDateTime;

public class MatchOverviewDTO {

    private Long id;

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime dateTime;

    private String location;
    private String description;
    private Integer price;
    private int maxPlayers;
    private int inGamePlayers;
    private double pricePerRegisteredPlayer;

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getPrice() { return price; }
    public void setPrice(Integer price) { this.price = price; }

    public int getMaxPlayers() { return maxPlayers; }
    public void setMaxPlayers(int maxPlayers) { this.maxPlayers = maxPlayers; }

    public int getInGamePlayers() { return inGamePlayers; }
    public void setInGamePlayers(int inGamePlayers) { this.inGamePlayers = inGamePlayers; }

    public double getPricePerRegisteredPlayer() { return pricePerRegisteredPlayer; }
    public void setPricePerRegisteredPlayer(double pricePerRegisteredPlayer) { this.pricePerRegisteredPlayer = pricePerRegisteredPlayer; }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchRegistrationDTO.java


package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;

public class MatchRegistrationDTO {
    private Long id; // voliteln√©, p≈ôi GET

    @NotNull(message = "ID z√°pasu je povinn√©.")
    @Positive(message = "ID z√°pasu mus√≠ b√Ωt kladn√©.")
    private Long matchId;

    @NotNull(message = "ID hr√°ƒçe je povinn√©.")
    @Positive(message = "ID hr√°ƒçe mus√≠ b√Ωt kladn√©.")
    private Long playerId;

    private PlayerMatchStatus status;
    private ExcuseReason excuseReason; // pouze pokud status = EXCUSED
    private String excuseNote;
    private String adminNote;
    private Team jerseyColor;

    @NotNull
    private String createdBy; // "user" nebo "system"

    private PlayerDTO playerDTO;

    public MatchRegistrationDTO() {}

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public Long getMatchId() { return matchId; }
    public void setMatchId(Long matchId) { this.matchId = matchId; }

    public Long getPlayerId() { return playerId; }
    public void setPlayerId(Long playerId) { this.playerId = playerId; }

    public PlayerMatchStatus getStatus() { return status; }
    public void setStatus(PlayerMatchStatus status) { this.status = status; }

    public ExcuseReason getExcuseReason() { return excuseReason; }
    public void setExcuseReason(ExcuseReason excuseReason) { this.excuseReason = excuseReason; }

    public String getExcuseNote() { return excuseNote; }
    public void setExcuseNote(String excuseNote) { this.excuseNote = excuseNote; }

    public String getAdminNote() { return adminNote; }
    public void setAdminNote(String adminNote) { this.adminNote = adminNote; }

    public Team getJerseyColor() { return jerseyColor; }
    public void setJerseyColor(Team jerseyColor) { this.jerseyColor = jerseyColor; }

    public String getCreatedBy() { return createdBy; }
    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }
}



# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerDTO.java


package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerType;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class PlayerDTO {


    private Long id; // autogenerated, nullable p≈ôi create

    @NotBlank(message = "K≈ôestn√≠ jm√©no je povinn√©.")
    @Size(min = 2, max = 50)
    private String name; // not null

    @NotBlank(message = "P≈ô√≠jmen√≠ je povinn√©.")
    @Size(min = 2, max = 50)
    private String surname; // not null
    private String nickName;
    private String fullName; // derived
    private String phoneNumber;
    private PlayerType type; // not null, default BASIC
    private Team team;


    public PlayerDTO() {
        this.type = PlayerType.BASIC;
   }

    public PlayerDTO(Long id, String name, String surname, String nickName, PlayerType type, Team team) {
        this.id = id;
        this.name = name;
        this.surname = surname;
        this.nickName = nickName;
        this.type = type != null ? type : PlayerType.BASIC;
        this.updateFullName();
        this.team = team;
    }

    // --- Gettery a Settery ---

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; updateFullName(); }

    public String getSurname() { return surname; }
    public void setSurname(String surname) { this.surname = surname; updateFullName(); }

    public String getNickName() { return nickName; }

    public void setNickName(String nickName) { this.nickName = nickName; }

    public String getFullName() { return fullName; }

    public PlayerType getType() { return type; }
    public void setType(PlayerType type) { this.type = type != null ? type : PlayerType.BASIC; }

    private void updateFullName() { this.fullName = name + " " + surname; }

    public Team getTeam() { return team; }
    public void setTeam(Team team) { this.team = team; }

    public String getPhoneNumber() { return phoneNumber; }
    public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerInactivityPeriodDTO.java


package cz.phsoft.hokej.models.dto;

import java.time.LocalDateTime;

public class PlayerInactivityPeriodDTO {

    private Long id;
    private Long playerId;
    private LocalDateTime inactiveFrom;
    private LocalDateTime inactiveTo;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getPlayerId() {
        return playerId;
    }

    public void setPlayerId(Long playerId) {
        this.playerId = playerId;
    }

    public LocalDateTime getInactiveFrom() {
        return inactiveFrom;
    }

    public void setInactiveFrom(LocalDateTime inactiveFrom) {
        this.inactiveFrom = inactiveFrom;
    }

    public LocalDateTime getInactiveTo() {
        return inactiveTo;
    }

    public void setInactiveTo(LocalDateTime inactiveTo) {
        this.inactiveTo = inactiveTo;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerSummaryDTO.java


package cz.phsoft.hokej.models.dto;

public class PlayerSummaryDTO {
    private Long id;
    private String name;
    private String jerseyColor;
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\SuccessResponseDTO.java


package cz.phsoft.hokej.models.dto;

public class SuccessResponseDTO {
    private  String message;
    private Long id;
    private String timestamp;

    public SuccessResponseDTO(String message, Long id, String timestamp) {
        this.message = message;
        this.id = id;
        this.timestamp = timestamp;
    }

    public String getMessage() { return message; }
    public Long getId() { return id; }
    public String getTimestamp() { return timestamp; }

}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsMessageBuilder.java


package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import org.springframework.stereotype.Component;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;

import java.time.format.DateTimeFormatter;

@Component
public class SmsMessageBuilder {

    private final MatchRegistrationRepository matchRegistrationRepository;
    private final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");

    public SmsMessageBuilder(MatchRegistrationRepository matchRegistrationRepository) {
        this.matchRegistrationRepository = matchRegistrationRepository;
    }

    // --------------------------
    // zpr√°va po registraci/odhl√°≈°en√≠/omluven√≠
    // --------------------------
    public String buildMessageRegistration(MatchRegistrationEntity registration) {
        PlayerMatchStatus status = registration.getStatus();
        String statusText = switch (status) {
            case REGISTERED -> "p≈ôihl√°sil se k z√°pasu";
            case UNREGISTERED -> "odhl√°sil se ze z√°pasu";
            case EXCUSED -> "omluven";
            default -> "nezn√°m√Ω stav";
        };

        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(registration.getMatch().getId(), PlayerMatchStatus.REGISTERED);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - datum: ")
                .append(registration.getMatch().getDateTime().toLocalDate());

        if (status != PlayerMatchStatus.EXCUSED) {
            sb.append(", ").append(registeredCount)
                    .append("/").append(registration.getMatch().getMaxPlayers());
        }

        sb.append(", hr√°ƒç: ").append(registration.getPlayer().getFullName())
                .append(", status: ").append(statusText);

        return sb.toString();
    }

    // --------------------------
    // zpr√°va pro hr√°ƒçe, kte≈ô√≠ je≈°tƒõ nereagovali
    // --------------------------
    public String buildMessageNoResponse(PlayerDTO player, MatchEntity match) {
        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - upozornƒõn√≠: z√°pas ")
                .append(match.getDateTime().format(dateFormatter))
                .append(" - voln√° m√≠sta: ")
                .append(match.getMaxPlayers() - registeredCount)
                .append(". Je≈°tƒõ jste nereagoval.");

        return sb.toString();
    }

    // --------------------------
    // fin√°ln√≠ p≈ôipom√≠nka pro p≈ôihl√°≈°en√© hr√°ƒçe v den z√°pasu
    // --------------------------
    public String buildMessageFinal(MatchRegistrationEntity registration) {
        MatchEntity match = registration.getMatch();
        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);

        double pricePerPlayer = match.getPrice() / Math.max(registeredCount, 1);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - p≈ôipom√≠nka z√°pasu ")
                .append(match.getDateTime().format(dateFormatter))
                .append(", p≈ôihl√°≈°eno: ").append(registeredCount).append("/").append(match.getMaxPlayers())
                .append(", cena na hr√°ƒçe: ").append(String.format("%.2f Kƒç", pricePerPlayer));

        return sb.toString();
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsSchedulerService.java


package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import jakarta.transaction.Transactional;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.List;

@Service
public class SmsSchedulerService {

    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository registrationRepository;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;
    private final MatchRegistrationService matchRegistrationService;

    public SmsSchedulerService(
            MatchRepository matchRepository,
            MatchRegistrationRepository registrationRepository,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder,
            MatchRegistrationService matchRegistrationService) {

        this.matchRepository = matchRepository;
        this.registrationRepository = registrationRepository;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
        this.matchRegistrationService = matchRegistrationService;
    }

    // Posl√°n√≠ SMS v den z√°pasu
    // Spust√≠ se ka≈æd√Ω den v 12:30
    @Scheduled(cron = "0 30 12 * * *")
    @Transactional
    public void sendFinalSmsForTodayMatches() {

        LocalDate today = LocalDate.now();

        // najdeme v≈°echny dne≈°n√≠ z√°pasy
        List<MatchEntity> todaysMatches = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().toLocalDate().isEqual(today))
                .toList();

        for (MatchEntity match : todaysMatches) {

            // naƒçteme v≈°echny registrace k dan√©mu z√°pasu (BEZ zmƒõn entit)
            List<MatchRegistrationEntity> registrations =
                    registrationRepository.findByMatchId(match.getId());

            for (MatchRegistrationEntity reg : registrations) {

                // pou≈æije≈° sv≈Øj p≈Øvodn√≠ builder
                String smsMsg = smsMessageBuilder.buildMessageFinal(reg);

                try {
                    smsService.sendSms(reg.getPlayer().getPhoneNumber(), smsMsg);
                    System.out.println("Fin√°ln√≠ SMS posl√°na hr√°ƒçi "
                            + reg.getPlayer().getFullName() + ": " + smsMsg);

                } catch (Exception e) {
                    System.err.println("Chyba SMS pro hr√°ƒçe "
                            + reg.getPlayer().getFullName() + ": " + e.getMessage());
                }
            }
        }
    }

    // posl√°n√≠ SMS 3 dny p≈ôed z√°pasem - noresponse player
    @Scheduled(cron = "0 40 14 * * *") // ka≈æd√Ω den ve 12:30
    @Transactional
    public void sendNoResponseSmsForMatchesIn3Days() {

        LocalDate targetDate = LocalDate.now().plusDays(3);

        // v≈°echny z√°pasy, kter√© jsou za 3 dny
        List<MatchEntity> matchesInThreeDays = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().toLocalDate().isEqual(targetDate))
                .toList();

        for (MatchEntity match : matchesInThreeDays) {

            // pou≈æijeme tv≈Øj existuj√≠c√≠ helper
            List<PlayerDTO> noResponsePlayers =
                    matchRegistrationService.getNoResponsePlayers(match.getId());

            for (PlayerDTO player : noResponsePlayers) {

                String smsMsg = smsMessageBuilder.buildMessageNoResponse(player, match);

                try {
                    smsService.sendSms(player.getPhoneNumber(), smsMsg);
                    System.out.println("NORESPONSE SMS posl√°na hr√°ƒçi "
                            + player.getFullName() + ": " + smsMsg);
                } catch (Exception e) {
                    System.err.println("Chyba NORESPONSE SMS pro hr√°ƒçe "
                            + player.getFullName() + ": " + e.getMessage());
                }
            }
        }
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsService.java


package cz.phsoft.hokej.models.services.sms;

public interface SmsService {
    void sendSms(String phoneNumber, String message);
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsServiceImpl.java


/* package cz.phsoft.hokej.models.services.sms;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;

@Service
public class SmsServiceImpl {

   // private final RestTemplate restTemplate = new RestTemplate();

    @Value("${textbee.api-url}")
    private String apiUrl;

    @Value("${textbee.api-key}")
    private String apiKey;

    // testovac√≠ ƒç√≠slo
    //private final String testNumber = "+420776609956";

    /**
     * Ode≈°le SMS na testovac√≠ ƒç√≠slo.
     * @param message text zpr√°vy
     */

/*
    public void sendSms(String phoneNumber, String message) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("x-api-key", apiKey);

        Map<String, Object> body = Map.of(
                "recipients", List.of(phoneNumber),
                "message", message
        );

        HttpEntity<Map<String,Object>> request = new HttpEntity<>(body, headers);

        try {
            ResponseEntity<String> response = restTemplate.postForEntity(apiUrl, request, String.class);
            System.out.println("SMS posl√°na na testovac√≠ ƒç√≠slo  xxx   : " + response.getBody());
        } catch (Exception e) {
            System.err.println("Chyba p≈ôi odes√≠l√°n√≠ SMS: " + e.getMessage());
        }
    }

*/


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsTextBeeService.java


package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.models.services.sms.SmsService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;

// textbee - free s omezen√≠m na 50 sms / den
@Service
public class SmsTextBeeService implements SmsService {

    @Value("${sms.enabled:true}")
    private boolean smsEnabled;

    @Value("${textbee.api-url}")
    private String apiUrl;

    @Value("${textbee.api-key}")
    private String apiKey;

    private final RestTemplate restTemplate = new RestTemplate();

    @Override
    public void sendSms(String phoneNumber, String message) {
        if (!smsEnabled) {
            System.out.println("SMS disabled, message not sent: " + message);
            return;
        }

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("x-api-key", apiKey);

        Map<String, Object> body = Map.of(
                "recipients", List.of(phoneNumber),
                "message", message
        );

        HttpEntity<Map<String,Object>> request = new HttpEntity<>(body, headers);

        try {
            ResponseEntity<String> response = restTemplate.postForEntity(apiUrl, request, String.class);
            System.out.println("SMS odesl√°na hr√°ƒçi: " + phoneNumber + ", response: " + response.getBody());
        } catch (Exception e) {
            System.err.println("Chyba p≈ôi odes√≠l√°n√≠ SMS: " + e.getMessage());
        }
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;

import java.util.List;

public interface MatchRegistrationService {

    // üî• Vrac√≠ DTO m√≠sto entity
    MatchRegistrationDTO upsertRegistration(
            Long matchId,
            Long playerId,
            Team jerseyColor,
            String adminNote,
            ExcuseReason excuseReason,
            String excuseNote,
            boolean unregister
    );

    List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId);

    List<MatchRegistrationDTO> getAllRegistrations();

    List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId);

    List<PlayerDTO> getNoResponsePlayers(Long matchId);

    void recalcStatusesForMatch(Long matchId);
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.DuplicateRegistrationException;
import cz.phsoft.hokej.exceptions.MatchNotFoundException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.exceptions.RegistrationNotFoundException;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.mappers.MatchRegistrationMapper;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.sms.SmsMessageBuilder;
import cz.phsoft.hokej.models.services.sms.SmsService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
public class MatchRegistrationServiceImpl implements MatchRegistrationService {

    Logger logger = LoggerFactory.getLogger(MatchServiceImpl.class);
    private final MatchRegistrationRepository registrationRepository;
    private final MatchRepository matchRepository;
    private final PlayerRepository playerRepository;
    private final MatchRegistrationMapper matchRegistrationMapper;
    private final PlayerMapper playerMapper;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;

    public MatchRegistrationServiceImpl(
            MatchRegistrationRepository registrationRepository,
            MatchRepository matchRepository,
            PlayerRepository playerRepository,
            MatchRegistrationMapper matchRegistrationMapper,
            PlayerMapper playerMapper,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder) {
        this.registrationRepository = registrationRepository;
        this.matchRepository = matchRepository;
        this.playerRepository = playerRepository;
        this.matchRegistrationMapper = matchRegistrationMapper;
        this.playerMapper = playerMapper;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
    }
    private MatchEntity getMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }
    private PlayerEntity getPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }
    private boolean isSlotAvailable(MatchEntity match) {
        long registeredCount = registrationRepository.countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);
        return registeredCount < match.getMaxPlayers();
    }
    private void sendSms(MatchRegistrationEntity registration, String message) {
        if (registration == null || registration.getPlayer() == null) return;
        try {
            smsService.sendSms(registration.getPlayer().getPhoneNumber(), message);
        } catch (Exception e) {
            System.err.println("Chyba SMS: " + e.getMessage());
        }
    }
    private MatchRegistrationEntity updateRegistrationStatus(
            MatchRegistrationEntity registration, PlayerMatchStatus status, String updatedBy, boolean updateTimestamp) {

        registration.setStatus(PlayerMatchStatus.valueOf(status.name()));
        registration.setCreatedBy(updatedBy);
        if (updateTimestamp) {
            registration.setTimestamp(LocalDateTime.now());
        }
        return registrationRepository.saveAndFlush(registration);
    }
    // -------------------- REGISTRATION --------------------
    @Transactional
    @Override
    public MatchRegistrationDTO upsertRegistration(
            Long matchId,
            Long playerId,
            Team jerseyColor,
            String adminNote,
            ExcuseReason excuseReason,
            String excuseNote,
            boolean unregister) {

        // TEST: po≈°li ERROR zpr√°vu pro otestov√°n√≠ emailu
        logger.error("Test ERROR zpr√°va pro email");

        MatchEntity match = getMatchOrThrow(matchId);
        PlayerEntity player = getPlayerOrThrow(playerId);

        MatchRegistrationEntity registration = registrationRepository
                .findByPlayerIdAndMatchId(playerId, matchId)
                .orElse(null);

        PlayerMatchStatus newStatus;

        // UNREGISTER: lze pouze kdy≈æ hr√°ƒç m√° aktu√°lnƒõ REGISTERED
        if (unregister) {
            if (registration == null || registration.getStatus() != PlayerMatchStatus.REGISTERED) {
                throw new RegistrationNotFoundException(matchId, playerId);
            }
            registration.setExcuseReason(null);
            newStatus = PlayerMatchStatus.UNREGISTERED;

            // EXCUSE: lze vytvo≈ôit pouze pokud hr√°ƒç NEM√Å status REGISTERED
        } else if (excuseReason != null) {
            if (registration != null && registration.getStatus() == PlayerMatchStatus.REGISTERED) {
                throw new DuplicateRegistrationException(matchId, playerId);
            }
            // pokud neexistuje, vytvo≈ô√≠me pozici; pokud existuje a nen√≠ REGISTERED, povol√≠me EXCUSED
            if (registration == null) {
                registration = new MatchRegistrationEntity();
                registration.setMatch(match);
                registration.setPlayer(player);
            }
            registration.setExcuseReason(excuseReason);
            newStatus = PlayerMatchStatus.EXCUSED;

            // REGISTER / RESERVE: lze vytvo≈ôit pokud hr√°ƒç NEM√Å status REGISTERED (tedy i kdy≈æ m√° EXCUSED)
        } else {
            // pokud u≈æ je registrov√°n, nepovol√≠me duplicitu
            if (registration != null && registration.getStatus() == PlayerMatchStatus.REGISTERED) {
                throw new DuplicateRegistrationException(matchId, playerId);
            }

            newStatus = isSlotAvailable(match) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;

            if (registration == null) {
                registration = new MatchRegistrationEntity();
                registration.setMatch(match);
                registration.setPlayer(player);
            } else {
                // p≈ôi p≈ôechodu na register/reserve zru≈°√≠me p≈ô√≠padnou v√Ωmluvu
                registration.setExcuseReason(null);
            }
        }

        registration.setStatus(newStatus);
        registration.setTimestamp(LocalDateTime.now());
        registration.setCreatedBy("user");

        if (jerseyColor != null) registration.setJerseyColor(jerseyColor);
        if (adminNote != null) registration.setAdminNote(adminNote);
        // excuseReason u≈æ jsme nastavili v√Ω≈°e (pokud to byl EXCUSED p≈ô√≠pad)
        if (excuseReason != null) registration.setExcuseReason(excuseReason);

        registration = registrationRepository.save(registration);

        if (unregister) recalcStatusesForMatch(matchId);

        sendSms(registration, smsMessageBuilder.buildMessageRegistration(registration));

        return matchRegistrationMapper.toDTO(registration);
    }
    // -------------------- FETCH --------------------
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId) {
        return matchRegistrationMapper.toDTOList(registrationRepository.findByMatchId(matchId));
    }

    @Override
    public List<MatchRegistrationDTO> getAllRegistrations() {
        return matchRegistrationMapper.toDTOList(registrationRepository.findAll());
    }

    @Override
    public List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId) {
        return matchRegistrationMapper.toDTOList(registrationRepository.findByPlayerId(playerId));
    }

    @Override
    public List<PlayerDTO> getNoResponsePlayers(Long matchId) {
        List<Long> responded = registrationRepository.findByMatchId(matchId).stream()
                .map(r -> r.getPlayer().getId())
                .toList();

        List<PlayerEntity> noResponsePlayers = playerRepository.findAll().stream()
                .filter(p -> !responded.contains(p.getId()))
                .toList();

        return noResponsePlayers.stream()
                .map(playerMapper::toDTO)
                .toList();
    }
    // -------------------- RECALC --------------------
    @Override
    @Transactional
    public void recalcStatusesForMatch(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);
        int maxPlayers = match.getMaxPlayers();

        List<MatchRegistrationEntity> regs = registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED
                        || r.getStatus() == PlayerMatchStatus.RESERVED)
                .sorted((a, b) -> a.getTimestamp().compareTo(b.getTimestamp()))
                .toList();

        for (int i = 0; i < regs.size(); i++) {
            MatchRegistrationEntity reg = regs.get(i);
            PlayerMatchStatus newStatus = (i < maxPlayers) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;
            if (reg.getStatus() != newStatus) updateRegistrationStatus(reg, newStatus, "system", false);
        }
    }

    // -------------------- SMS --------------------
    @Transactional
    public void sendSmsToRegisteredPlayers(Long matchId) {
        registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .forEach(r -> sendSms(r, smsMessageBuilder.buildMessageFinal(r)));
    }

    public void sendNoResponseSmsForMatch(Long matchId) {
        var match = getMatchOrThrow(matchId);

        getNoResponsePlayers(matchId).forEach(player -> {
            String smsMsg = smsMessageBuilder.buildMessageNoResponse(player, match);

            try {
                smsService.sendSms(player.getPhoneNumber(), smsMsg);
            } catch (Exception e) {
                System.err.println("Chyba SMS pro hr√°ƒçe "
                        + player.getFullName() + ": " + e.getMessage());
                logger.error("Chyba p≈ôi odesl√°n√≠ SMS hr√°ƒçi {}: {}", player.getFullName(), e.getMessage());
            }
        });
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;
import cz.phsoft.hokej.models.dto.MatchOverviewDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;

import java.util.List;

public interface MatchService {
    List<MatchDTO> getAllMatches();
    List<MatchDTO> getUpcomingMatches();
    List<MatchDTO> getPastMatches();
    MatchDTO getNextMatch();
    MatchDTO getMatchById(Long id);
    MatchDTO createMatch(MatchDTO dto);
    MatchDTO updateMatch(Long id, MatchDTO dto);
    SuccessResponseDTO deleteMatch(Long id);
    MatchDetailDTO getMatchDetail(Long id);
    List<MatchDTO> getAvailableMatchesForPlayer(Long playerId);
    List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId);
    Long getPlayerIdByEmail(String email);
    List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId);


}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.MatchNotFoundException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.models.dto.*;
import cz.phsoft.hokej.models.dto.mappers.MatchMapper;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class MatchServiceImpl implements MatchService {

    private final MatchRepository matchRepository;
    private final MatchMapper matchMapper;
    private final MatchRegistrationService registrationService;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodService playerInactivityPeriodService;
    private final PlayerMapper playerMapper;
    private static final String ROLE_ADMIN = "ROLE_ADMIN";
    private static final String ROLE_MANAGER = "ROLE_MANAGER";

    public MatchServiceImpl(MatchRepository matchRepository,
                            MatchMapper matchMapper,
                            MatchRegistrationService registrationService,
                            PlayerRepository playerRepository,
                            PlayerInactivityPeriodService playerInactivityPeriodService,
                            PlayerMapper playerMapper) {
        this.matchRepository = matchRepository;
        this.matchMapper = matchMapper;
        this.registrationService = registrationService;
        this.playerRepository = playerRepository;
        this.playerInactivityPeriodService = playerInactivityPeriodService;
        this.playerMapper = playerMapper;
    }
    // metoda pro z√≠sk√°n√≠ v≈°ech z√°pas≈Ø
    @Override
    public List<MatchDTO> getAllMatches() {
        return matchRepository.findAll().stream()
                .map(matchMapper::toDTO)
                .toList();
    }
    // metoda pro z√≠sk√°n√≠ v≈°ech nadch√°zej√≠c√≠ch z√°pas≈Ø
    @Override
    public List<MatchDTO> getUpcomingMatches() {
        return matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now())
                .stream()
                .map(matchMapper::toDTO)
                .toList();
    }
    // metoda pro z√≠sk√°n√≠ uplynul√Ωch z√°pas≈Ø
    public List<MatchDTO> getPastMatches() {
        return matchRepository.findByDateTimeBeforeOrderByDateTimeDesc(LocalDateTime.now())
                .stream()
                .map(matchMapper::toDTO)
                .toList();
    }
    // metoda pro z√≠sk√°n√≠ prvn√≠ho nadch√°zej√≠c√≠ho z√°pasu
    @Override
    public MatchDTO getNextMatch() {
        return matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now())
                .stream()
                .findFirst()
                .map(matchMapper::toDTO)
                .orElse(null);
    }
    // metoda pro z√°pas dle ID
    @Override
    public MatchDTO getMatchById(Long id) {
        return matchMapper.toDTO(findMatchOrThrow(id));
    }

    // metoda pro vytvo≈ôen√≠ z√°pasu
    @Override
    public MatchDTO createMatch(MatchDTO dto) {
        MatchEntity entity = matchMapper.toEntity(dto);
        return matchMapper.toDTO(matchRepository.save(entity));
    }

    // metoda pro √∫pravu z√°pasu
    @Override
    public MatchDTO updateMatch(Long id, MatchDTO dto) {
        MatchEntity match = findMatchOrThrow(id);

        int oldMaxPlayers = match.getMaxPlayers();
        matchMapper.updateEntity(dto, match);
        MatchEntity saved = matchRepository.save(match);

        // P≈ôepoƒçet registrac√≠ pokud do≈°lo ke zmƒõnƒõ maxPlayers
        if (saved.getMaxPlayers() != oldMaxPlayers) {
            registrationService.recalcStatusesForMatch(saved.getId());
        }

        return matchMapper.toDTO(saved);
    }

    // metoda pro odstranƒõn√≠ z√°pasu
    @Override
    public SuccessResponseDTO deleteMatch(Long id) {
        MatchEntity match = findMatchOrThrow(id);

        // 2) Pokud existuje, sma≈æeme ho
        matchRepository.delete(match);

        return new SuccessResponseDTO(
                "Z√°pas " + match.getId() + match.getDateTime() + " byl √∫spƒõ≈°nƒõ smaz√°n",
                id,
                LocalDateTime.now().toString()
        );
    }

    // metoda pro detail z√°pasu - omezen v√Ωpis pro ADMIN, MANAGER, PLAYER
    @Override
    public MatchDetailDTO getMatchDetail(Long id) {
        MatchEntity match = findMatchOrThrow(id);
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();

        boolean isAdminOrManager = auth != null && auth.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals(ROLE_ADMIN) || a.getAuthority().equals(ROLE_MANAGER));

        // oddƒõlena logika p≈ô√≠stupu hr√°ƒçe do priv√°tn√≠ metody
        checkAccessForPlayer(match, auth);

        // sbƒõr statistik hr√°ƒç≈Ø p≈ôes priv√°tn√≠ metodu
        return collectPlayerStatus(match, isAdminOrManager);
    }

    // priv√°tn√≠ metoda pro kontrolu p≈ô√≠stupu hr√°ƒçe - jen pokud byl registrov√°n na z√°pas
    private void checkAccessForPlayer(MatchEntity match, Authentication auth) {
        if (auth == null || !auth.isAuthenticated()) return;

        boolean isAdminOrManager = auth.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals(ROLE_ADMIN) || a.getAuthority().equals(ROLE_MANAGER));

        if (isAdminOrManager) return;

        Object principal = auth.getPrincipal();
        if (!(principal instanceof org.springframework.security.core.userdetails.UserDetails userDetails)) return;

        List<PlayerEntity> ownedPlayers = playerRepository.findAll().stream()
                .filter(p -> p.getUser() != null && p.getUser().getEmail().equals(userDetails.getUsername()))
                .toList();

        boolean hasRestrictedPlayer = ownedPlayers.stream()
                .anyMatch(p -> {
                    List<MatchRegistrationDTO> registrations = registrationService.getRegistrationsForMatch(match.getId());

                    boolean noResponse = registrations.stream()
                            .noneMatch(r -> r.getPlayerId().equals(p.getId()));

                    boolean inactiveForMatch = !playerInactivityPeriodService.isActive(p, match.getDateTime());

                    return noResponse || inactiveForMatch;
                });

        if (hasRestrictedPlayer) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "Nem√°te p≈ô√≠stup k detailu tohoto z√°pasu."
            );
        }
    }

    // priv√°tn√≠ metoda pro sbƒõr statistik hr√°ƒç≈Ø
    private MatchDetailDTO collectPlayerStatus(MatchEntity match, boolean isAdminOrManager) {
        List<MatchRegistrationDTO> registrations = registrationService.getRegistrationsForMatch(match.getId());

        // P≈ôevod v≈°ech registrac√≠ na Map<PlayerMatchStatus, List<PlayerDTO>>
        var statusToPlayersMap = registrations.stream()
                .map(r -> playerRepository.findById(r.getPlayerId())
                        .map(playerMapper::toDTO)
                        .map(dto -> new java.util.AbstractMap.SimpleEntry<>(r.getStatus(), dto))
                )
                .filter(java.util.Optional::isPresent) // odstran√≠me chybƒõj√≠c√≠ hr√°ƒçe
                .map(java.util.Optional::get)
                .collect(Collectors.groupingBy(
                        java.util.Map.Entry::getKey,
                        Collectors.mapping(java.util.Map.Entry::getValue, Collectors.toList())
                ));

        List<PlayerEntity> allPlayers = playerRepository.findAll();
        Set<Long> respondedIds = registrations.stream()
                .map(MatchRegistrationDTO::getPlayerId)
                .collect(Collectors.toSet());

        List<PlayerDTO> noResponsePlayers = allPlayers.stream()
                .filter(p -> !respondedIds.contains(p.getId()))
                .map(playerMapper::toDTO)
                .toList();

        // Poƒçty hr√°ƒç≈Ø podle statusu
        int inGamePlayers = statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()).size();
        int outGamePlayers = statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()).size()
                + statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()).size();
        int waitingPlayers = statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()).size();
        int noActionPlayers = noResponsePlayers.size();
        int remainingSlots = match.getMaxPlayers() - inGamePlayers;
        double pricePerRegistered = inGamePlayers > 0 ? match.getPrice() / (double) inGamePlayers : 0;

        MatchDetailDTO dto = new MatchDetailDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setMaxPlayers(match.getMaxPlayers());
        dto.setInGamePlayers(inGamePlayers);
        dto.setOutGamePlayers(outGamePlayers);
        dto.setWaitingPlayers(waitingPlayers);
        dto.setNoActionPlayers(noActionPlayers);
        dto.setPricePerRegisteredPlayer(pricePerRegistered);
        dto.setRemainingSlots(remainingSlots);

        // Nastaven√≠ hr√°ƒç≈Ø podle statusu z mapy
        dto.setRegisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()));
        dto.setReservedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()));
        dto.setUnregisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()));
        dto.setExcusedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()));

        // pouze admin/manager uvid√≠ no-response hr√°ƒçe
        dto.setNoResponsePlayers(isAdminOrManager ? noResponsePlayers : null);

        return dto;
    }


    // dostupn√© z√°pasy pro hr√°ƒçe - byl nebo je aktivn√≠
    @Override
    public List<MatchDTO> getAvailableMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        // Filtrace p≈ôes stream bez meziv√Ωsledk≈Ø
        return matchRepository.findAll().stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .map(matchMapper::toDTO)
                .toList();
    }

    // z√≠sk√°n√≠ hr√°ƒçe dle emailu
    public Long getPlayerIdByEmail(String email) {
        return playerRepository.findByUserEmail(email)
                .map(PlayerEntity::getId)
                .orElseThrow(() -> new RuntimeException("Hr√°ƒç s emailem " + email + " nenalezen"));
    }

    // n√°hled nadch√°zej√≠c√≠ch z√°pasu pro hr√°ƒçe - dle PlayerType
    @Override
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        // 1) Nejbli≈æ≈°√≠ nadch√°zej√≠c√≠ z√°pasy podle data
        List<MatchEntity> upcomingAll = matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now());

        // 2) Omezen√≠ podle typu hr√°ƒçe
        List<MatchEntity> limited = switch (type) {
            case VIP -> upcomingAll;
            case STANDARD -> upcomingAll.stream().limit(2).toList();
            case BASIC -> upcomingAll.isEmpty() ? List.of() : List.of(upcomingAll.get(0));
        };

        // 3) Filtrov√°n√≠ podle aktivity hr√°ƒçe a mapov√°n√≠ na MatchOverviewDTO
        return limited.stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .map(this::toOverviewDTO)   // mapujeme p≈ô√≠mo ve slu≈æbƒõ
                .toList();
    }
    // nadch√°zej√≠c√≠ z√°pasy pro hr√°ƒçe
    @Override
    public List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        // 1) Nejbli≈æ≈°√≠ nadch√°zej√≠c√≠ z√°pasy podle data
        List<MatchEntity> upcomingAll = matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now());

        List<MatchEntity> limited = switch (type) {
            case VIP -> upcomingAll;
            case STANDARD -> upcomingAll.stream().limit(2).toList();
            case BASIC -> upcomingAll.isEmpty() ? List.of() : List.of(upcomingAll.get(0));
        };

        // 2) Filtrov√°n√≠ podle aktivity hr√°ƒçe
        return limited.stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .map(matchMapper::toDTO)
                .toList();
    }

    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    private MatchEntity findMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }

    private MatchOverviewDTO toOverviewDTO(MatchEntity match) {
        MatchOverviewDTO dto = new MatchOverviewDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setLocation(match.getLocation());
        dto.setDescription(match.getDescription());
        dto.setPrice(match.getPrice());
        dto.setMaxPlayers(match.getMaxPlayers());

        // poƒçet registrovan√Ωch hr√°ƒç≈Ø
        int inGamePlayers = registrationService.getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .mapToInt(r -> 1)
                .sum();
        dto.setInGamePlayers(inGamePlayers);

        // cena na registrovan√©ho hr√°ƒçe
        double pricePerPlayer = inGamePlayers > 0 && match.getPrice() != null
                ? match.getPrice() / (double) inGamePlayers : 0;
        dto.setPricePerRegisteredPlayer(pricePerPlayer);

        return dto;
    }


}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;

import java.time.LocalDateTime;
import java.util.List;

public interface PlayerInactivityPeriodService {

    List<PlayerInactivityPeriodDTO> getAll();

    PlayerInactivityPeriodDTO getById(Long id);

    List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId);

    PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto);

    PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto);

    void delete(Long id);

    public boolean isActive(PlayerEntity player, LocalDateTime dateTime);
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.data.repositories.PlayerInactivityPeriodRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.dto.mappers.PlayerInactivityPeriodMapper;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import java.util.List;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

@Service
public class PlayerInactivityPeriodServiceImpl implements PlayerInactivityPeriodService {

    private final PlayerInactivityPeriodRepository inactivityRepository;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodMapper mapper;

    public PlayerInactivityPeriodServiceImpl(PlayerInactivityPeriodRepository inactivityRepository,
                                             PlayerRepository playerRepository,
                                             PlayerInactivityPeriodMapper mapper) {
        this.inactivityRepository = inactivityRepository;
        this.playerRepository = playerRepository;
        this.mapper = mapper;
    }

    @Override
    public List<PlayerInactivityPeriodDTO> getAll() {
        return inactivityRepository.findAll().stream()
                .map(mapper::toDTO)
                .toList();
    }

    @Override
    public PlayerInactivityPeriodDTO getById(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException(
                        "Obdob√≠ neaktivity s ID " + id + " neexistuje."
                ));
        return mapper.toDTO(entity);
    }

    @Override
    public List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId) {
        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new RuntimeException("Player not found"));

        return inactivityRepository.findByPlayerOrderByInactiveFromAsc(player)
                .stream()
                .map(mapper::toDTO)
                .toList();
    }

    // --- TRANSACTIONAL pro z√°pis dat ---
    @Override
    @Transactional
    public PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto) {
        PlayerEntity player = playerRepository.findById(dto.getPlayerId())
                .orElseThrow(() -> new IllegalArgumentException("Hr√°ƒç s ID " + dto.getPlayerId() + " neexistuje."));

        validateDates(dto);

        // kontrola p≈ôekryvu existuj√≠c√≠ch obdob√≠
        boolean overlaps = !inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        player, dto.getInactiveFrom(), dto.getInactiveTo()
                ).isEmpty();

        if (overlaps) {
            throw new IllegalStateException("Nov√© obdob√≠ se p≈ôekr√Ωv√° s existuj√≠c√≠m obdob√≠m neaktivity hr√°ƒçe.");
        }

        PlayerInactivityPeriodEntity entity = mapper.toEntity(dto, player);
        return mapper.toDTO(inactivityRepository.save(entity));
    }

    @Override
    @Transactional
    public PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Obdob√≠ neaktivity s ID " + id + " neexistuje."));

        validateDates(dto);

        // kontrola p≈ôekryvu, ignoruje aktu√°ln√≠ z√°znam
        boolean overlaps = inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        entity.getPlayer(), dto.getInactiveFrom(), dto.getInactiveTo()
                ).stream()
                .anyMatch(p -> !p.getId().equals(id));

        if (overlaps) {
            throw new IllegalStateException("Upraven√© obdob√≠ se p≈ôekr√Ωv√° s jin√Ωm obdob√≠m neaktivity hr√°ƒçe.");
        }

        mapper.updateEntityFromDto(dto, entity);
        return mapper.toDTO(inactivityRepository.save(entity));
    }

    @Override
    @Transactional
    public void delete(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Obdob√≠ neaktivity s ID " + id + " neexistuje."));
        inactivityRepository.delete(entity);
    }

    // --- true = aktivn√≠, false = neaktivn√≠ ---
    public boolean isActive(PlayerEntity player, LocalDateTime dateTime) {
        return !inactivityRepository.existsByPlayerAndInactiveFromLessThanEqualAndInactiveToGreaterThanEqual(
                player, dateTime, dateTime);
    }

    // --- priv√°tn√≠ metoda pro validaci dat ---
    private void validateDates(PlayerInactivityPeriodDTO dto) {
        if (dto.getInactiveFrom() == null || dto.getInactiveTo() == null) {
            throw new IllegalArgumentException("Datum od a do nesm√≠ b√Ωt null.");
        }
        if (!dto.getInactiveFrom().isBefore(dto.getInactiveTo())) {
            throw new IllegalArgumentException("inactiveFrom mus√≠ b√Ωt p≈ôed inactiveTo.");
        }
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;

import java.util.List;


public interface PlayerService {
    List<PlayerDTO> getAllPlayers();
    PlayerDTO getPlayerById(Long id);
    PlayerDTO createPlayer(PlayerDTO player);
    PlayerDTO updatePlayer(Long id, PlayerDTO player);
    SuccessResponseDTO deletePlayer(Long id);
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;
import cz.phsoft.hokej.models.dto.PlayerDTO;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
public class PlayerServiceImpl implements PlayerService {

    private final PlayerRepository playerRepository;
    private final PlayerMapper playerMapper;

    public PlayerServiceImpl(PlayerRepository playerRepository, PlayerMapper playerMapper) {
        this.playerRepository = playerRepository;
        this.playerMapper = playerMapper;
    }

    @Override
    public List<PlayerDTO> getAllPlayers() {
        return playerRepository.findAll().stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    @Override
    public PlayerDTO getPlayerById(Long id) {
        PlayerEntity player = playerRepository.findById(id)
                .orElseThrow(() -> new PlayerNotFoundException(id)); // m√≠sto RuntimeException
        return playerMapper.toDTO(player);
    }

    // --- TRANSACTIONAL pro z√°pis dat ---
    @Override
    @Transactional
    public PlayerDTO createPlayer(PlayerDTO dto) {
        checkDuplicateNameSurname(dto.getName(), dto.getSurname(), null);

        PlayerEntity entity = playerMapper.toEntity(dto);
        PlayerEntity saved = playerRepository.save(entity);
        return playerMapper.toDTO(saved);
    }

    @Override
    @Transactional
    public PlayerDTO updatePlayer(Long id, PlayerDTO dto) {
        PlayerEntity existing = findPlayerOrThrow(id);

        // pokud se jm√©no/p≈ô√≠jmen√≠ mƒõn√≠, ovƒõ≈ô duplicitu
        if (!existing.getName().equals(dto.getName()) || !existing.getSurname().equals(dto.getSurname())) {
            checkDuplicateNameSurname(dto.getName(), dto.getSurname(), id);
        }

        existing.setName(dto.getName());
        existing.setSurname(dto.getSurname());
        existing.setType(dto.getType());
        existing.setTeam(dto.getTeam());

        PlayerEntity saved = playerRepository.save(existing);
        return playerMapper.toDTO(saved);
    }

    @Override
    @Transactional
    public SuccessResponseDTO deletePlayer(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);
        playerRepository.delete(player);

        return new SuccessResponseDTO(
                "Hr√°ƒç " + player.getFullName() + " byl √∫spƒõ≈°nƒõ smaz√°n",
                id,
                LocalDateTime.now().toString()
        );
    }

    // --- priv√°tn√≠ metoda pro kontrolu duplicity jm√©na a p≈ô√≠jmen√≠ ---
    private void checkDuplicateNameSurname(String name, String surname, Long ignoreId) {
        Optional<PlayerEntity> duplicateOpt = playerRepository.findByNameAndSurname(name, surname);

        if (duplicateOpt.isPresent()) {
            if (ignoreId == null || !duplicateOpt.get().getId().equals(ignoreId)) {
                throw new RuntimeException("Hr√°ƒç se jm√©nem " + name + " " + surname + " ji≈æ existuje.");
            }
        }
    }

    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\PlayerSecurity.java


package cz.phsoft.hokej.security;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

@Component("playerSecurity") // n√°zev pro pou≈æit√≠ v SpEL (@PreAuthorize)
public class PlayerSecurity {

    private static final Logger logger = LoggerFactory.getLogger(PlayerSecurity.class);

    private final PlayerRepository playerRepository;

    public PlayerSecurity(PlayerRepository playerRepository) {
        this.playerRepository = playerRepository;
    }

    /**
     * Zjist√≠, zda je aktu√°lnƒõ p≈ôihl√°≈°en√Ω u≈æivatel vlastn√≠kem hr√°ƒçe
     *
     * @param authentication aktu√°ln√≠ authentication objekt
     * @param playerId       ID hr√°ƒçe
     * @return true pokud je vlastn√≠kem, jinak false
     */
    public boolean isOwner(Authentication authentication, Long playerId) {
        try {
            if (authentication == null || !authentication.isAuthenticated()) {
                logger.warn("Neautorizovan√Ω p≈ô√≠stup: ≈æ√°dn√° autentizace pro playerId {}", playerId);
                return false;
            }

            Object principal = authentication.getPrincipal();
            if (!(principal instanceof UserDetails userDetails)) {
                logger.warn("Neautorizovan√Ω p≈ô√≠stup: principal nen√≠ UserDetails pro playerId {}", playerId);
                return false;
            }

            boolean isOwner = playerRepository.findById(playerId)
                    .map(player -> player.getUser() != null &&
                            player.getUser().getEmail().equals(userDetails.getUsername()))
                    .orElse(false);

            if (!isOwner) {
                logger.warn("Neautorizovan√Ω p≈ô√≠stup: u≈æivatel {} nen√≠ vlastn√≠kem hr√°ƒçe {}", userDetails.getUsername(), playerId);
            }

            return isOwner;

        } catch (Exception e) {
            logger.error("Chyba p≈ôi kontrole vlastn√≠ka hr√°ƒçe {}: {}", playerId, e.getMessage(), e);
            // nikdy nepropustit v√Ωjimku do SpEL
            return false;
        }
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\StaraGardaApplication.java


package cz.phsoft.hokej;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableJpaRepositories // JPA v na≈°em Spring Boot projektu
@EnableScheduling
public class StaraGardaApplication {
    public static void main(String[] args) {
        SpringApplication.run(StaraGardaApplication.class, args);


        }
    }


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\test\java\cz\phsoft\hokej\controllers\MatchControllerTest.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.StaraGardaApplication;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.security.test.context.support.WithAnonymousUser;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest(
        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
        classes = StaraGardaApplication.class
)
@AutoConfigureMockMvc
public class MatchControllerTest {

    @Autowired
    private MockMvc mockMvc;

    // ---------------------------------------------------------
    // GET /api/matches ‚Äì pouze MANAGER + ADMIN
    // ---------------------------------------------------------

    @Test
    @WithMockUser(roles = {"ADMIN"})
    void getAllMatches_asAdmin_shouldReturn200() throws Exception {
        mockMvc.perform(get("/api/matches"))
                .andExpect(status().isOk());
    }

    @Test
    @WithMockUser(roles = {"MANAGER"})
    void getAllMatches_asManager_shouldReturn200() throws Exception {
        mockMvc.perform(get("/api/matches"))
                .andExpect(status().isOk());
    }

    @Test
    @WithMockUser(roles = {"PLAYER"})
    void getAllMatches_asPlayer_shouldReturn403() throws Exception {
        mockMvc.perform(get("/api/matches"))
                .andExpect(status().isForbidden());
    }

    @Test
    @WithAnonymousUser
    void getAllMatches_unauthenticated_shouldReturn401() throws Exception {
        mockMvc.perform(get("/api/matches"))
                .andExpect(status().isUnauthorized());
    }

    // ---------------------------------------------------------
    // GET /api/matches/next ‚Äì mus√≠ b√Ωt p≈ôihl√°≈°en√Ω kdokoliv
    // ---------------------------------------------------------

    @Test
    @WithMockUser
    void getNextMatch_authenticated_shouldReturn200() throws Exception {
        mockMvc.perform(get("/api/matches/next"))
                .andExpect(status().isOk());
    }

    @Test
    @WithAnonymousUser
    void getNextMatch_unauthenticated_shouldReturn401() throws Exception {
        mockMvc.perform(get("/api/matches/next"))
                .andExpect(status().isUnauthorized());
    }

    // ---------------------------------------------------------
    // POST /api/matches ‚Äì ADMIN
    // ---------------------------------------------------------

    @Test
    @WithMockUser(roles = {"ADMIN"})
    void createMatch_asAdmin_shouldReturn200() throws Exception {

        String json = """
                {
                    "dateTime": "2030-01-01T18:00:00",
                    "location": "Brno",
                    "description": "Testovac√≠ z√°pas",
                    "maxPlayers": 20,
                    "price": 150
                }
                """;

        mockMvc.perform(post("/api/matches")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(json))
                .andExpect(status().isOk());
    }

    @Test
    @WithMockUser(roles = {"MANAGER"})
    void createMatch_asManager_shouldReturn403() throws Exception {

        String json = """
                {
                    "dateTime": "2030-01-01T18:00:00",
                    "location": "Brno",
                    "description": "Testovac√≠ z√°pas",
                    "maxPlayers": 20,
                    "price": 150
                }
                """;

        mockMvc.perform(post("/api/matches")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(json))
                .andExpect(status().isForbidden());
    }

    @Test
    @WithAnonymousUser
    void createMatch_unauthenticated_shouldReturn401() throws Exception {
        mockMvc.perform(post("/api/matches")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{}"))
                .andExpect(status().isUnauthorized());
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\AppUserMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.PlayerSummaryDTO;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-15T14:57:09+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class AppUserMapperImpl implements AppUserMapper {

    @Override
    public AppUserDTO toDto(AppUserEntity entity) {
        if ( entity == null ) {
            return null;
        }

        AppUserDTO appUserDTO = new AppUserDTO();

        appUserDTO.setPlayers( playerEntitySetToPlayerSummaryDTOSet( entity.getPlayers() ) );
        appUserDTO.setId( entity.getId() );
        appUserDTO.setEmail( entity.getEmail() );
        if ( entity.getRole() != null ) {
            appUserDTO.setRole( entity.getRole().name() );
        }

        return appUserDTO;
    }

    @Override
    public List<AppUserDTO> toDtoList(List<AppUserEntity> entities) {
        if ( entities == null ) {
            return null;
        }

        List<AppUserDTO> list = new ArrayList<AppUserDTO>( entities.size() );
        for ( AppUserEntity appUserEntity : entities ) {
            list.add( toDto( appUserEntity ) );
        }

        return list;
    }

    @Override
    public PlayerSummaryDTO toPlayerSummary(PlayerEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerSummaryDTO playerSummaryDTO = new PlayerSummaryDTO();

        return playerSummaryDTO;
    }

    protected Set<PlayerSummaryDTO> playerEntitySetToPlayerSummaryDTOSet(Set<PlayerEntity> set) {
        if ( set == null ) {
            return null;
        }

        Set<PlayerSummaryDTO> set1 = new LinkedHashSet<PlayerSummaryDTO>( Math.max( (int) ( set.size() / .75f ) + 1, 16 ) );
        for ( PlayerEntity playerEntity : set ) {
            set1.add( toPlayerSummary( playerEntity ) );
        }

        return set1;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-15T14:57:10+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchMapperImpl implements MatchMapper {

    @Override
    public MatchDTO toDTO(MatchEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchDTO matchDTO = new MatchDTO();

        matchDTO.setId( entity.getId() );
        matchDTO.setDateTime( entity.getDateTime() );
        matchDTO.setLocation( entity.getLocation() );
        matchDTO.setDescription( entity.getDescription() );
        matchDTO.setMaxPlayers( entity.getMaxPlayers() );
        matchDTO.setPrice( entity.getPrice() );

        return matchDTO;
    }

    @Override
    public MatchEntity toEntity(MatchDTO dto) {
        if ( dto == null ) {
            return null;
        }

        MatchEntity matchEntity = new MatchEntity();

        matchEntity.setId( dto.getId() );
        matchEntity.setDateTime( dto.getDateTime() );
        matchEntity.setLocation( dto.getLocation() );
        matchEntity.setDescription( dto.getDescription() );
        matchEntity.setMaxPlayers( dto.getMaxPlayers() );
        matchEntity.setPrice( dto.getPrice() );

        return matchEntity;
    }

    @Override
    public void updateEntity(MatchDTO dto, MatchEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setDateTime( dto.getDateTime() );
        entity.setLocation( dto.getLocation() );
        entity.setDescription( dto.getDescription() );
        entity.setMaxPlayers( dto.getMaxPlayers() );
        entity.setPrice( dto.getPrice() );
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchRegistrationMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-15T14:57:09+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchRegistrationMapperImpl implements MatchRegistrationMapper {

    @Override
    public MatchRegistrationEntity toEntity(MatchEntity match, PlayerEntity player, PlayerMatchStatus status, ExcuseReason excuseReason, String note, Team jerseyColor, String adminNote, String createdBy) {
        if ( match == null && player == null && status == null && excuseReason == null && note == null && jerseyColor == null && adminNote == null && createdBy == null ) {
            return null;
        }

        MatchRegistrationEntity matchRegistrationEntity = new MatchRegistrationEntity();

        matchRegistrationEntity.setMatch( match );
        matchRegistrationEntity.setPlayer( player );
        matchRegistrationEntity.setStatus( status );
        matchRegistrationEntity.setExcuseReason( excuseReason );
        matchRegistrationEntity.setExcuseNote( note );
        matchRegistrationEntity.setJerseyColor( jerseyColor );
        matchRegistrationEntity.setAdminNote( adminNote );
        matchRegistrationEntity.setCreatedBy( createdBy );
        matchRegistrationEntity.setTimestamp( java.time.LocalDateTime.now() );

        return matchRegistrationEntity;
    }

    @Override
    public MatchRegistrationDTO toDTO(MatchRegistrationEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchRegistrationDTO matchRegistrationDTO = new MatchRegistrationDTO();

        matchRegistrationDTO.setMatchId( entityMatchId( entity ) );
        matchRegistrationDTO.setPlayerId( entityPlayerId( entity ) );
        matchRegistrationDTO.setId( entity.getId() );
        matchRegistrationDTO.setStatus( entity.getStatus() );
        matchRegistrationDTO.setExcuseReason( entity.getExcuseReason() );
        matchRegistrationDTO.setExcuseNote( entity.getExcuseNote() );
        matchRegistrationDTO.setAdminNote( entity.getAdminNote() );
        matchRegistrationDTO.setJerseyColor( entity.getJerseyColor() );
        matchRegistrationDTO.setCreatedBy( entity.getCreatedBy() );

        return matchRegistrationDTO;
    }

    @Override
    public List<MatchRegistrationDTO> toDTOList(List<MatchRegistrationEntity> entities) {
        if ( entities == null ) {
            return null;
        }

        List<MatchRegistrationDTO> list = new ArrayList<MatchRegistrationDTO>( entities.size() );
        for ( MatchRegistrationEntity matchRegistrationEntity : entities ) {
            list.add( toDTO( matchRegistrationEntity ) );
        }

        return list;
    }

    private Long entityMatchId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        MatchEntity match = matchRegistrationEntity.getMatch();
        if ( match == null ) {
            return null;
        }
        Long id = match.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }

    private Long entityPlayerId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        PlayerEntity player = matchRegistrationEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerInactivityPeriodMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-15T14:57:09+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerInactivityPeriodMapperImpl implements PlayerInactivityPeriodMapper {

    @Override
    public PlayerInactivityPeriodDTO toDTO(PlayerInactivityPeriodEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerInactivityPeriodDTO playerInactivityPeriodDTO = new PlayerInactivityPeriodDTO();

        playerInactivityPeriodDTO.setPlayerId( entityPlayerId( entity ) );
        playerInactivityPeriodDTO.setId( entity.getId() );
        playerInactivityPeriodDTO.setInactiveFrom( entity.getInactiveFrom() );
        playerInactivityPeriodDTO.setInactiveTo( entity.getInactiveTo() );

        return playerInactivityPeriodDTO;
    }

    @Override
    public PlayerInactivityPeriodEntity toEntity(PlayerInactivityPeriodDTO dto, PlayerEntity player) {
        if ( dto == null ) {
            return null;
        }

        PlayerInactivityPeriodEntity playerInactivityPeriodEntity = createEntity( dto, player );

        playerInactivityPeriodEntity.setInactiveFrom( dto.getInactiveFrom() );
        playerInactivityPeriodEntity.setInactiveTo( dto.getInactiveTo() );

        return playerInactivityPeriodEntity;
    }

    @Override
    public void updateEntityFromDto(PlayerInactivityPeriodDTO dto, PlayerInactivityPeriodEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setInactiveFrom( dto.getInactiveFrom() );
        entity.setInactiveTo( dto.getInactiveTo() );
    }

    private Long entityPlayerId(PlayerInactivityPeriodEntity playerInactivityPeriodEntity) {
        if ( playerInactivityPeriodEntity == null ) {
            return null;
        }
        PlayerEntity player = playerInactivityPeriodEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-15T14:57:09+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerMapperImpl implements PlayerMapper {

    @Override
    public PlayerDTO toDTO(PlayerEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerDTO playerDTO = new PlayerDTO();

        playerDTO.setId( entity.getId() );
        playerDTO.setName( entity.getName() );
        playerDTO.setSurname( entity.getSurname() );
        playerDTO.setType( entity.getType() );
        playerDTO.setTeam( entity.getTeam() );
        playerDTO.setPhoneNumber( entity.getPhoneNumber() );

        return playerDTO;
    }

    @Override
    public PlayerEntity toEntity(PlayerDTO dto) {
        if ( dto == null ) {
            return null;
        }

        PlayerEntity playerEntity = new PlayerEntity();

        playerEntity.setId( dto.getId() );
        playerEntity.setName( dto.getName() );
        playerEntity.setSurname( dto.getSurname() );
        playerEntity.setType( dto.getType() );
        playerEntity.setPhoneNumber( dto.getPhoneNumber() );
        playerEntity.setTeam( dto.getTeam() );

        return playerEntity;
    }

    @Override
    public void updatePlayerDTO(PlayerDTO source, PlayerDTO target) {
        if ( source == null ) {
            return;
        }

        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setNickName( source.getNickName() );
        target.setType( source.getType() );
        target.setTeam( source.getTeam() );
        target.setPhoneNumber( source.getPhoneNumber() );
    }

    @Override
    public void updatePlayerEntity(PlayerDTO source, PlayerEntity target) {
        if ( source == null ) {
            return;
        }

        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setType( source.getType() );
        target.setPhoneNumber( source.getPhoneNumber() );
        target.setTeam( source.getTeam() );
    }

    @Override
    public List<PlayerDTO> toDTOList(List<PlayerEntity> players) {
        if ( players == null ) {
            return null;
        }

        List<PlayerDTO> list = new ArrayList<PlayerDTO>( players.size() );
        for ( PlayerEntity playerEntity : players ) {
            list.add( toDTO( playerEntity ) );
        }

        return list;
    }
}
