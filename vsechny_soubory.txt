

# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\config\DataInitializer.java


package cz.phsoft.hokej.config;


import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.JerseyColor;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import jakarta.annotation.PostConstruct;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.util.List;

@Component
public class DataInitializer {


    private final PlayerRepository playerRepository;
    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository matchRegistrationRepository;

    public DataInitializer(PlayerRepository playerRepository,
                           MatchRepository matchRepository,
                           MatchRegistrationRepository matchRegistrationRepository) {
        this.playerRepository = playerRepository;
        this.matchRepository = matchRepository;
        this.matchRegistrationRepository = matchRegistrationRepository;
    }

    @PostConstruct
    public void init() {
        // --- 10 hrĂˇÄŤĹŻ ---
        List<PlayerEntity> players = List.of(
                new PlayerEntity("Petr", "Hlista", PlayerType.VIP, JerseyColor.DARK),
                new PlayerEntity("LaÄŹa", "BraĹľina", PlayerType.VIP, JerseyColor.LIGHT),
                new PlayerEntity("David", "PodsednĂ­k", PlayerType.VIP, JerseyColor.LIGHT),
                new PlayerEntity("VlastĂ­k", "PstruĹľĂ­", PlayerType.VIP, JerseyColor.LIGHT),
                new PlayerEntity("Otakar", "ZĂˇĹˇkodnĂ˝", PlayerType.VIP, JerseyColor.LIGHT),
                new PlayerEntity("Jarda", "MenĹˇĂ­k", PlayerType.STANDARD, JerseyColor.DARK),
                new PlayerEntity("LuboĹˇ", "NovĂˇk", PlayerType.STANDARD, JerseyColor.LIGHT),
                new PlayerEntity("LukĂˇĹˇ", "NovĂˇk", PlayerType.STANDARD, JerseyColor.DARK),
                new PlayerEntity("Martin", "ÄŚermĂˇk", PlayerType.STANDARD, JerseyColor.DARK),
                new PlayerEntity("Pavel", "EliĂˇĹˇ", PlayerType.STANDARD, JerseyColor.DARK),
                new PlayerEntity("StaĹa", "Jurok", PlayerType.BASIC, JerseyColor.DARK),
                new PlayerEntity("Michal", "Pyszko", PlayerType.BASIC, JerseyColor.DARK),
                new PlayerEntity("Jenda", "KaluĹľa", PlayerType.STANDARD, JerseyColor.LIGHT),
                new PlayerEntity("TomĂˇĹˇ", "Faldyna", PlayerType.STANDARD, JerseyColor.DARK),
                new PlayerEntity("Martin", "Faldyna", PlayerType.STANDARD, JerseyColor.DARK),
                new PlayerEntity("Lola", "Dorda", PlayerType.STANDARD, JerseyColor.DARK),
                new PlayerEntity("LukĂˇĹˇ", "Dorda", PlayerType.STANDARD, JerseyColor.DARK),
                new PlayerEntity("Martin", "Dorda", PlayerType.STANDARD, JerseyColor.DARK),
                new PlayerEntity("Radim", "MaliĹˇ", PlayerType.STANDARD, JerseyColor.DARK),
                new PlayerEntity("LaÄŹa", "Pavlica", PlayerType.STANDARD, JerseyColor.DARK)

        );
        playerRepository.saveAll(players);

        // --- 5 zĂˇpasĹŻ, kaĹľdĂ˝ pĂˇtek od 21.11.2025 ---
        LocalDateTime startDate = LocalDateTime.of(2025, 11, 21, 18, 45);
        for (int i = 0; i < 5; i++) {
            MatchEntity match = new MatchEntity();
            match.setDateTime(startDate.plusWeeks(i));
            match.setLocation("Ostravice");
            match.setDescription("");
            match.setMaxPlayers(12);
            match.setPrice(2200);
            matchRepository.save(match);
        }
      // --- VytvoĹ™enĂ­ registracĂ­ 6 hrĂˇÄŤĹŻ (id 1-6) na zĂˇpas id 3 ---
        MatchEntity match3 = matchRepository.findById(3L)
                .orElseThrow(() -> new RuntimeException("Match with id 3 not found"));

        for (long playerId = 1; playerId <= 6; playerId++) {
            final long pid = playerId;
            PlayerEntity player = playerRepository.findById(playerId)
                    .orElseThrow(() -> new RuntimeException("Player with id " + pid + " not found"));

            MatchRegistrationEntity reg = new MatchRegistrationEntity();
            reg.setMatch(match3);
            reg.setPlayer(player);
            reg.setStatus(PlayerMatchStatus.REGISTERED);
            reg.setTimestamp(LocalDateTime.now());
            reg.setCreatedBy("user");

            matchRegistrationRepository.save(reg);
        }
    }

}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\config\SecurityConfig.java


package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

/* - POVOLENO VĹ E PRO TESTOVĂNĂŤ V POSTMAN */

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable()) // vypnout CSRF pro testovĂˇnĂ­
                .authorizeHttpRequests(auth -> auth.anyRequest().permitAll()); // vĹˇechno volnÄ›
        return http.build();
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\controllers\MatchController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;
import cz.phsoft.hokej.models.dto.mappers.MatchMapper;
import cz.phsoft.hokej.models.services.MatchService;
import jakarta.validation.Valid;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/matches")
@CrossOrigin(origins = "*")
public class MatchController {

    private final MatchService matchService;

    public MatchController(MatchService matchService) {
        this.matchService = matchService;
    }

    // detail zĂˇpasu
    @GetMapping("/matchDetail/{id}")
    public MatchDetailDTO getMatchDetail(@PathVariable Long id) {
        return matchService.getMatchDetail(id);
    }

    // vĹˇechny zĂˇpasy
    @GetMapping
    public List<MatchDTO> getAllMatches() {
        return matchService.getAllMatches();
    }

    // prvnĂ­ aktuĂˇlnĂ­ zĂˇpas
    @GetMapping("/next")
    public MatchDTO getNextMatch() {
        return matchService.getNextMatch();
    }

    // aktuĂˇlnĂ­ zĂˇpasy (bez proĹˇlĂ˝ch dat)
    @GetMapping("/upcoming")
    public List<MatchDTO> getUpcomingMatches() {
        return matchService.getUpcomingMatches();
    }

    // proĹˇlĂ© zĂˇpasy
    @GetMapping("/past")
    public List<MatchDTO> getPastMatches() {
        return matchService.getPastMatches();
    }


    // POST pĹ™idat zĂˇpas
    @PostMapping
    public MatchDTO createMatch(@Valid @RequestBody MatchDTO dto) {
        return matchService.createMatch(dto);
    }

    // GET podle ID
    @GetMapping("/{id}")
    public MatchDTO getMatch(@PathVariable Long id) {
        return matchService.getMatchById(id);
    }


    // PUT editovat zĂˇpas
    @PutMapping("/{id}")
    public MatchDTO updateMatch(@PathVariable Long id, @Valid @RequestBody MatchDTO dto) {
        return matchService.updateMatch(id, dto);
    }

    // DELETE smazat zĂˇpas
    @DeleteMapping("/{id}")
    public void deleteMatch(@PathVariable Long id) {
        matchService.deleteMatch(id);
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\controllers\MatchRegistrationController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.JerseyColor;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/registrations")
@CrossOrigin(origins = "*")
public class MatchRegistrationController {

    private final MatchRegistrationService service;

    public MatchRegistrationController(MatchRegistrationService service) {
        this.service = service;
    }

    @PostMapping("/register")
    public MatchRegistrationEntity register(@RequestParam Long matchId, @RequestParam Long playerId,
                                            @RequestParam JerseyColor jerseyColor, @RequestParam String adminNote) {
        return service.registerPlayer(matchId, playerId, jerseyColor,adminNote);
    }

    @PostMapping("/unregister")
    public MatchRegistrationEntity unregister(@RequestParam Long matchId, @RequestParam Long playerId,  @RequestParam String reason,
                                              @RequestParam(required = false) String note) {
        return service.unregisterPlayer(matchId, playerId, note, reason);
    }

    @PostMapping("/excuse")
    public MatchRegistrationEntity excuse(@RequestParam Long matchId, @RequestParam Long playerId,
                                          @RequestParam String reason,
                                          @RequestParam(required = false) String note) {
        return service.excusePlayer(matchId, playerId, note, reason);
    }
    @GetMapping("/all")
    public List<MatchRegistrationEntity> getAllRegistrations() {
        return service.getAllRegistrations();
    }

    @GetMapping("/for-player")
    public List<MatchRegistrationEntity> forPlayer(@RequestParam Long playerId) {
        return service.getRegistrationsForPlayer(playerId);
    }

    @GetMapping("/last-status")
    public MatchRegistrationEntity lastStatus(@RequestParam Long matchId, @RequestParam Long playerId) {
        return service.getLastStatus(matchId, playerId);
    }

    @GetMapping("/for-match")
    public List<MatchRegistrationEntity> forMatch(@RequestParam Long matchId) {
        return service.getRegistrationsForMatch(matchId);
    }

    @GetMapping("/no-response/{matchId}")
    public List<PlayerEntity> getNoResponse(@PathVariable Long matchId) {
        return service.getNoResponsePlayers(matchId);
    }

    @GetMapping("/last-statuses/{matchId}")
    public List<MatchRegistrationEntity> lastStatusesForMatch(@PathVariable Long matchId) {
        return service.getLastStatusesForMatch(matchId);
    }



}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\controllers\PlayerController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.PlayerService;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/players")
@CrossOrigin(origins = "*")
public class PlayerController {

    private final PlayerService playerService;
    private final PlayerMapper playerMapper;

    public PlayerController(PlayerService playerService, PlayerMapper playerMapper) {
        this.playerService = playerService;
        this.playerMapper = playerMapper;
    }

    // GET all players
    @GetMapping
    public List<PlayerDTO> getAllPlayers() {
        return playerService.getAllPlayers()
                .stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    // GET by ID
    @GetMapping("/{id}")
    public PlayerDTO getPlayer(@PathVariable Long id) {
        return playerMapper.toDTO(playerService.getPlayerById(id));
    }

    // CREATE new player
    @PostMapping
    public PlayerDTO createPlayer(@RequestBody PlayerDTO dto) {
        return playerMapper.toDTO(
                playerService.createPlayer(playerMapper.toEntity(dto))
        );
    }

    // UPDATE player
    @PutMapping("/{id}")
    public PlayerDTO updatePlayer(@PathVariable Long id, @RequestBody PlayerDTO dto) {

        // Map DTO â†’ Entity (bez hesla)
        var newEntity = playerMapper.toEntity(dto);

        // Update uloĹľenĂ©ho hrĂˇÄŤe
        var updated = playerService.updatePlayer(id, newEntity);

        return playerMapper.toDTO(updated);
    }

    // DELETE player
    @DeleteMapping("/{id}")
    public void deletePlayer(@PathVariable Long id) {
        playerService.deletePlayer(id);
    }

    

}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\data\entities\MatchEntity.java


package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "matches")
public class MatchEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private LocalDateTime dateTime;

    @Column(nullable = false)
    private String location;

    private String description;

    @Column(nullable = false)
    private Integer maxPlayers;

    @Column(nullable = false)
    private Integer price;

    public MatchEntity() {}

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }

    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() {
        return price;
    }

    public void setPrice(Integer price) {
        this.price = price;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.JerseyColor;
import jakarta.persistence.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "match_registrations")
public class MatchRegistrationEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "match_id", nullable = false)
    private MatchEntity match;

    @ManyToOne
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerMatchStatus status;

    @Enumerated(EnumType.STRING)
    private ExcuseReason excuseReason;

    private String excuseNote;

    private String adminNote;

    @Enumerated(EnumType.STRING)
    @Column(name = "jersey_color")
    private JerseyColor jerseyColor;

    @Column(nullable = false, updatable = false)
    private LocalDateTime timestamp = LocalDateTime.now();

    @Column(nullable = false, updatable = false)
    private String createdBy; // "user" nebo "system"

    public MatchRegistrationEntity() {
    }

    // Gettery a Settery
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public MatchEntity getMatch() {
        return match;
    }

    public void setMatch(MatchEntity match) {
        this.match = match;
    }

    public PlayerEntity getPlayer() {
        return player;
    }

    public void setPlayer(PlayerEntity player) {
        this.player = player;
    }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }

    public ExcuseReason getExcuseReason() {
        return excuseReason;
    }

    public void setExcuseReason(ExcuseReason excuseReason) {
        this.excuseReason = excuseReason;
    }

    public String getExcuseNote() {
        return excuseNote;
    }

    public void setExcuseNote(String excuseNote) {
        this.excuseNote = excuseNote;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }

    public String getAdminNote() {
        return adminNote;
    }

    public void setAdminNote(String adminNote) {
        this.adminNote = adminNote;
    }

    public JerseyColor getJerseyColor() {
        return jerseyColor;
    }

    public void setJerseyColor(JerseyColor jerseyColor) {
        this.jerseyColor = jerseyColor;
    }
}





# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationHistoryEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.JerseyColor;
import jakarta.persistence.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "match_registration_history")
public class MatchRegistrationHistoryEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // ID z pĹŻvodnĂ­ hlavnĂ­ tabulky
    @Column(name = "match_registration_id", nullable = false)
    private Long matchRegistrationId;

    @Column(name = "match_id", nullable = false)
    private Long matchId;

    @Column(name = "player_id", nullable = false)
    private Long playerId;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerMatchStatus status;

    @Enumerated(EnumType.STRING)
    @Column(name = "excuse_reason")
    private ExcuseReason excuseReason;

    @Column(name = "excuse_note")
    private String excuseNote;

    @Column(name = "admin_note")
    private String adminNote;

    @Enumerated(EnumType.STRING)
    @Column(name = "jersey_color")
    private JerseyColor jerseyColor;

    @Column(name = "original_timestamp", nullable = false)
    private LocalDateTime originalTimestamp;

    @Column(name = "created_by", nullable = false)
    private String createdBy;

    @Column(nullable = false)
    private String action; // INSERT / UPDATE / DELETE

    @Column(name = "changed_at", nullable = false)
    private LocalDateTime changedAt;

    public MatchRegistrationHistoryEntity() {
    }

    // Gettery a settery

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getMatchRegistrationId() {
        return matchRegistrationId;
    }

    public void setMatchRegistrationId(Long matchRegistrationId) {
        this.matchRegistrationId = matchRegistrationId;
    }

    public Long getMatchId() {
        return matchId;
    }

    public void setMatchId(Long matchId) {
        this.matchId = matchId;
    }

    public Long getPlayerId() {
        return playerId;
    }

    public void setPlayerId(Long playerId) {
        this.playerId = playerId;
    }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }

    public ExcuseReason getExcuseReason() {
        return excuseReason;
    }

    public void setExcuseReason(ExcuseReason excuseReason) {
        this.excuseReason = excuseReason;
    }

    public String getExcuseNote() {
        return excuseNote;
    }

    public void setExcuseNote(String excuseNote) {
        this.excuseNote = excuseNote;
    }

    public String getAdminNote() {
        return adminNote;
    }

    public void setAdminNote(String adminNote) {
        this.adminNote = adminNote;
    }

    public JerseyColor getJerseyColor() {
        return jerseyColor;
    }

    public void setJerseyColor(JerseyColor jerseyColor) {
        this.jerseyColor = jerseyColor;
    }

    public LocalDateTime getOriginalTimestamp() {
        return originalTimestamp;
    }

    public void setOriginalTimestamp(LocalDateTime originalTimestamp) {
        this.originalTimestamp = originalTimestamp;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }

    public String getAction() {
        return action;
    }

    public void setAction(String action) {
        this.action = action;
    }

    public LocalDateTime getChangedAt() {
        return changedAt;
    }

    public void setChangedAt(LocalDateTime changedAt) {
        this.changedAt = changedAt;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\data\entities\PlayerEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.JerseyColor;
import cz.phsoft.hokej.data.enums.PlayerType;
import jakarta.persistence.*;

@Entity
@Table(name = "player_entity")
public class PlayerEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String surname;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerType type; // VIP, STANDARD, BASIC

    private String fullName;

    @Enumerated(EnumType.STRING)
    private JerseyColor jerseyColor;

    public PlayerEntity() {
        this.type = PlayerType.BASIC;
    }

    public PlayerEntity(String name, String surname, PlayerType type, JerseyColor jerseyColor) {
        this.name = name;
        this.surname = surname;
        this.type = type;
        this.fullName = name + " " + surname;
        this.jerseyColor = jerseyColor;

    }

    // Gettery a Settery + updateFullName
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; updateFullName(); }

    public String getSurname() { return surname; }
    public void setSurname(String surname) { this.surname = surname; updateFullName(); }

    public String getFullName() { return fullName; }

    public PlayerType getType() { return type; }
    public void setType(PlayerType type) { this.type = type; }

    private void updateFullName() { this.fullName = name + " " + surname; }

    public JerseyColor getJerseyColor() { return jerseyColor; }

    public void setJerseyColor(JerseyColor jerseyColor) { this.jerseyColor = jerseyColor; }
}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\data\enums\ExcuseReason.java


package cz.phsoft.hokej.data.enums;

public enum ExcuseReason {
    NEMOC,
    PRACE,
    JINE
}



# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\data\enums\JerseyColor.java


package cz.phsoft.hokej.data.enums;

public enum JerseyColor {
    DARK,
    LIGHT

}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\data\enums\PlayerMatchStatus.java


package cz.phsoft.hokej.data.enums;

public enum PlayerMatchStatus {
    REGISTERED,
    UNREGISTERED,
    EXCUSED,  // omluven
    RESERVED // nĂˇhradnĂ­k
}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\data\enums\PlayerType.java


package cz.phsoft.hokej.data.enums;

public enum PlayerType {
    VIP,
    STANDARD,
    BASIC
}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\data\enums\Role.java


package cz.phsoft.hokej.data.enums;

public enum Role {
    ROLE_PLAYER,
    ROLE_MANAGER,
    ROLE_ADMIN
}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\data\repositories\MatchRegistrationHistoryRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchRegistrationHistoryEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface MatchRegistrationHistoryRepository extends JpaRepository<MatchRegistrationHistoryEntity, Long> {

    // ZĂ­skat kompletnĂ­ historii registrace podle ID pĹŻvodnĂ­ho zĂˇznamu
    List<MatchRegistrationHistoryEntity> findByMatchRegistrationIdOrderByChangedAtDesc(Long matchRegistrationId);

    // Historie pro konkrĂ©tnĂ­ zĂˇpas
    List<MatchRegistrationHistoryEntity> findByMatchIdOrderByChangedAtDesc(Long matchId);

    // Historie zmÄ›n hrĂˇÄŤe
    List<MatchRegistrationHistoryEntity> findByPlayerIdOrderByChangedAtDesc(Long playerId);

}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\data\repositories\MatchRegistrationRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

    @Repository
    public interface MatchRegistrationRepository extends JpaRepository<MatchRegistrationEntity, Long> {

        // VrĂˇtĂ­ poslednĂ­ status pro danĂ©ho hrĂˇÄŤe a zĂˇpas
        Optional<MatchRegistrationEntity> findTopByPlayerIdAndMatchIdOrderByTimestampDesc(Long playerId, Long matchId);

        // VolitelnÄ›: vĹˇechny registrace pro urÄŤitĂ˝ zĂˇpas
        List<MatchRegistrationEntity> findByMatchId(Long matchId);

        // VolitelnÄ›: vĹˇechny registrace pro urÄŤitĂ©ho hrĂˇÄŤe
        List<MatchRegistrationEntity> findByPlayer(PlayerEntity player);

        // --- NovĂˇ metoda pro hledĂˇnĂ­ konkrĂ©tnĂ­ registrace ---
        Optional<MatchRegistrationEntity> findByPlayerIdAndMatchId(Long playerId, Long matchId);

    }


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\data\repositories\MatchRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import java.time.LocalDateTime;
import java.util.List;

public interface MatchRepository extends JpaRepository<MatchEntity, Long> {
    List<MatchEntity> findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime dateTime);
    List<MatchEntity> findByDateTimeBeforeOrderByDateTimeDesc(LocalDateTime dateTime);
}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\data\repositories\PlayerRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface PlayerRepository extends JpaRepository<PlayerEntity, Long> {
    Optional<PlayerEntity> findById(Long id);

    List<PlayerEntity> findByIdNotIn(List<Long> ids);
}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\exceptions\ApiError.java


package cz.phsoft.hokej.exceptions;

import com.fasterxml.jackson.annotation.JsonFormat;
import java.time.LocalDateTime;

public class ApiError {

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime timestamp;
    private int status;
    private String error;
    private String message;
    private String path;

    public ApiError(int status, String error, String message, String path) {
        this.timestamp = LocalDateTime.now();
        this.status = status;
        this.error = error;
        this.message = message;
        this.path = path;
    }

    public LocalDateTime getTimestamp() { return timestamp; }
    public int getStatus() { return status; }
    public String getError() { return error; }
    public String getMessage() { return message; }
    public String getPath() { return path; }
}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\exceptions\DuplicateRegistrationException.java


package cz.phsoft.hokej.exceptions;

public class DuplicateRegistrationException extends RuntimeException {

    public DuplicateRegistrationException(String message) {
        super(message);
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\exceptions\GlobalExceptionHandler.java


package cz.phsoft.hokej.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;


import jakarta.servlet.http.HttpServletRequest;

@RestControllerAdvice
public class GlobalExceptionHandler {

    private ResponseEntity<cz.phsoft.hokej.exceptions.ApiError> buildError(HttpStatus status, String message, String path) {
        cz.phsoft.hokej.exceptions.ApiError error = new cz.phsoft.hokej.exceptions.ApiError(
                status.value(),
                status.getReasonPhrase(),
                message,
                path
        );
        return ResponseEntity.status(status).body(error);
    }

    // 1) DuplicateRegistrationException â†’ 400
    @ExceptionHandler(DuplicateRegistrationException.class)
    public ResponseEntity<cz.phsoft.hokej.exceptions.ApiError> handleDuplicateRegistration(
            DuplicateRegistrationException ex,
            HttpServletRequest request) {

        return buildError(HttpStatus.BAD_REQUEST, ex.getMessage(), request.getRequestURI());
    }

    // 2) Validace DTO â†’ 400
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<cz.phsoft.hokej.exceptions.ApiError> handleValidation(MethodArgumentNotValidException ex,
                                                                                HttpServletRequest request) {

        String msg = ex.getBindingResult().getFieldErrors().stream()
                .map(err -> err.getField() + ": " + err.getDefaultMessage())
                .findFirst()
                .orElse("Validation failed");

        return buildError(HttpStatus.BAD_REQUEST, msg, request.getRequestURI());
    }

    // 3) LibovolnĂˇ jinĂˇ neoÄŤekĂˇvanĂˇ vyjĂ­mka â†’ 500
    @ExceptionHandler(Exception.class)
    public ResponseEntity<cz.phsoft.hokej.exceptions.ApiError> handleAll(Exception ex, HttpServletRequest request) {

        ex.printStackTrace(); // nebo logger

        return buildError(
                HttpStatus.INTERNAL_SERVER_ERROR,
                ex.getMessage(),
                request.getRequestURI()
        );
    }


}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\models\dto\mappers\MatchMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;

@Mapper(componentModel = "spring")
public interface MatchMapper {

    MatchDTO toDTO(MatchEntity entity);

    MatchEntity toEntity(MatchDTO dto);

    void updateEntity(MatchDTO dto, @MappingTarget MatchEntity entity);
}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\models\dto\mappers\MatchRegistrationMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

public interface MatchRegistrationMapper {
    // DTO â†’ Entity
    @Mapping(source = "matchId", target = "match.matchId")
    @Mapping(source = "playerId", target = "player.playerId")
    MatchRegistrationEntity toEntity(MatchRegistrationDTO dto, MatchEntity match, PlayerEntity player);

    // Entity â†’ DTO
    @Mapping(source = "match.matchId", target = "matchId")
    @Mapping(source = "player.playerId", target = "playerId")
    MatchRegistrationDTO toDTO(MatchRegistrationEntity entity);

    // Aktualizace Entity
    void updateEntity(MatchRegistrationDTO dto, @MappingTarget MatchRegistrationEntity entity);
}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\models\dto\mappers\PlayerMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

@Mapper(componentModel = "spring")
public interface PlayerMapper {

        // Entity â†’ DTO (heslo se neposĂ­lĂˇ)
        @Mapping(target = "fullName", ignore = true) // generuje se v DTO
        PlayerDTO toDTO(PlayerEntity entity);

        // DTO â†’ Entity (heslo se mapuje, pokud existuje)
        PlayerEntity toEntity(PlayerDTO dto);

        // Aktualizace existujĂ­cĂ­ho DTO (ignorujeme fullName)
        @Mapping(target = "fullName", ignore = true)
        void updatePlayerDTO(PlayerDTO source, @MappingTarget PlayerDTO target);

        // Aktualizace existujĂ­cĂ­ Entity (heslo se mapuje, fullName nenĂ­ pole v Entity)
        void updatePlayerEntity(PlayerDTO source, @MappingTarget PlayerEntity target);
}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\models\dto\MatchDetailDTO.java


package cz.phsoft.hokej.models.dto;

import java.time.LocalDateTime;
import java.util.List;

public class MatchDetailDTO {
    private Long id;
    private LocalDateTime dateTime;
    private int maxPlayers;
    private int inGamePlayers;
    private int outGamePlayers;
    private int waitingPlayers;
    private int noActionPlayers;
    private double pricePerRegisteredPlayer;
    private int remainingSlots;

    private List<String> registeredPlayers;
    private List<String> reservedPlayers;
    private List<String> unregisteredPlayers;
    private List<String> excusedPlayers;
    private List<String> noResponsePlayers;

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public int getMaxPlayers() { return maxPlayers; }
    public void setMaxPlayers(int maxPlayers) { this.maxPlayers = maxPlayers; }

    public double getPricePerRegisteredPlayer() { return pricePerRegisteredPlayer; }
    public void setPricePerRegisteredPlayer(double pricePerRegisteredPlayer) { this.pricePerRegisteredPlayer = pricePerRegisteredPlayer; }

    public int getRemainingSlots() { return remainingSlots; }
    public void setRemainingSlots(int remainingSlots) { this.remainingSlots = remainingSlots; }

    public List<String> getRegisteredPlayers() { return registeredPlayers; }
    public void setRegisteredPlayers(List<String> registeredPlayers) { this.registeredPlayers = registeredPlayers; }

    public List<String> getReservedPlayers() { return reservedPlayers; }
    public void setReservedPlayers(List<String> reservedPlayers) { this.reservedPlayers = reservedPlayers; }

    public List<String> getUnregisteredPlayers() { return unregisteredPlayers; }
    public void setUnregisteredPlayers(List<String> unregisteredPlayers) { this.unregisteredPlayers = unregisteredPlayers; }

    public List<String> getExcusedPlayers() { return excusedPlayers; }
    public void setExcusedPlayers(List<String> excusedPlayers) { this.excusedPlayers = excusedPlayers; }

    public int getInGamePlayers() { return inGamePlayers;  }
    public void setInGamePlayers(int inGamePlayers) { this.inGamePlayers = inGamePlayers; }

    public int getOutGamePlayers() { return outGamePlayers; }
    public void setOutGamePlayers(int outGamePlayers) { this.outGamePlayers = outGamePlayers; }

    public int getNoActionPlayers() { return noActionPlayers; }
    public void setNoActionPlayers(int noActionPlayers) { this.noActionPlayers = noActionPlayers; }

    public int getWaitingPlayers() { return waitingPlayers; }
    public void setWaitingPlayers(int waitingPlayers) { this.waitingPlayers = waitingPlayers; }

    public List<String> getNoResponsePlayers() { return noResponsePlayers; }

    public void setNoResponsePlayers(List<String> noResponsePlayers) { this.noResponsePlayers = noResponsePlayers; }
}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\models\dto\MatchDTO.java


package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import jakarta.validation.constraints.FutureOrPresent;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

import java.time.LocalDateTime;

public class MatchDTO {

    private Long id;
    @NotNull(message = "Datum a ÄŤas zĂˇpasu je povinnĂ©.")
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    private LocalDateTime dateTime;

    @NotBlank(message = "MĂ­sto zĂˇpasu je povinnĂ©.")
    @Size(min = 3, max = 100)
    private String location;

    @Size(max = 255, message = "Popis mĹŻĹľe mĂ­t max 255 znakĹŻ.")
    private String description;

    @NotNull(message = "MaximĂˇlnĂ­ poÄŤet hrĂˇÄŤĹŻ je povinnĂ˝")
    private Integer maxPlayers;

    @NotNull(message = "Cena je povinnĂˇ")
    private Integer price;

    // gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }
    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() {
        return price;
    }

    public void setPrice(Integer price) {
        this.price = price;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\models\dto\MatchRegistrationDTO.java


package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.JerseyColor;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;

import java.time.chrono.JapaneseChronology;

public class MatchRegistrationDTO {
    private Long id; // volitelnĂ©, pĹ™i GET

    @NotNull(message = "ID zĂˇpasu je povinnĂ©.")
    @Positive(message = "ID zĂˇpasu musĂ­ bĂ˝t kladnĂ©.")
    private Long matchId;

    @NotNull(message = "ID hrĂˇÄŤe je povinnĂ©.")
    @Positive(message = "ID hrĂˇÄŤe musĂ­ bĂ˝t kladnĂ©.")
    private Long playerId;

    private PlayerMatchStatus status;
    private ExcuseReason excuseReason; // pouze pokud status = EXCUSED
    private String excuseNote;
    private String adminNote;
    private JerseyColor jerseyColor;

    @NotNull
    private String createdBy; // "user" nebo "system"

    public MatchRegistrationDTO() {}

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public Long getMatchId() { return matchId; }
    public void setMatchId(Long matchId) { this.matchId = matchId; }

    public Long getPlayerId() { return playerId; }
    public void setPlayerId(Long playerId) { this.playerId = playerId; }

    public PlayerMatchStatus getStatus() { return status; }
    public void setStatus(PlayerMatchStatus status) { this.status = status; }

    public ExcuseReason getExcuseReason() { return excuseReason; }
    public void setExcuseReason(ExcuseReason excuseReason) { this.excuseReason = excuseReason; }

    public String getExcuseNote() { return excuseNote; }
    public void setExcuseNote(String excuseNote) { this.excuseNote = excuseNote; }

    public String getAdminNote() { return adminNote; }
    public void setAdminNote(String adminNote) { this.adminNote = adminNote; }

    public JerseyColor getJerseyColor() { return jerseyColor; }
    public void setJerseyColor(JerseyColor jerseyColor) { this.jerseyColor = jerseyColor; }

    public String getCreatedBy() { return createdBy; }
    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }
}



# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\models\dto\MatchRegistrationHistoryDTO.java


package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.JerseyColor;

import java.time.LocalDateTime;

public class MatchRegistrationHistoryDTO {

    private Long id;
    private Long matchRegistrationId;
    private Long matchId;
    private Long playerId;

    private PlayerMatchStatus status;
    private ExcuseReason excuseReason;
    private String excuseNote;
    private String adminNote;
    private JerseyColor jerseyColor;

    private LocalDateTime originalTimestamp;
    private String createdBy;

    private String action;       // INSERT / UPDATE / DELETE
    private LocalDateTime changedAt;

    public MatchRegistrationHistoryDTO() {
    }

    // Gettery a settery

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getMatchRegistrationId() {
        return matchRegistrationId;
    }

    public void setMatchRegistrationId(Long matchRegistrationId) {
        this.matchRegistrationId = matchRegistrationId;
    }

    public Long getMatchId() {
        return matchId;
    }

    public void setMatchId(Long matchId) {
        this.matchId = matchId;
    }

    public Long getPlayerId() {
        return playerId;
    }

    public void setPlayerId(Long playerId) {
        this.playerId = playerId;
    }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }

    public ExcuseReason getExcuseReason() {
        return excuseReason;
    }

    public void setExcuseReason(ExcuseReason excuseReason) {
        this.excuseReason = excuseReason;
    }

    public String getExcuseNote() {
        return excuseNote;
    }

    public void setExcuseNote(String excuseNote) {
        this.excuseNote = excuseNote;
    }

    public String getAdminNote() {
        return adminNote;
    }

    public void setAdminNote(String adminNote) {
        this.adminNote = adminNote;
    }

    public JerseyColor getJerseyColor() {
        return jerseyColor;
    }

    public void setJerseyColor(JerseyColor jerseyColor) {
        this.jerseyColor = jerseyColor;
    }

    public LocalDateTime getOriginalTimestamp() {
        return originalTimestamp;
    }

    public void setOriginalTimestamp(LocalDateTime originalTimestamp) {
        this.originalTimestamp = originalTimestamp;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }

    public String getAction() {
        return action;
    }

    public void setAction(String action) {
        this.action = action;
    }

    public LocalDateTime getChangedAt() {
        return changedAt;
    }

    public void setChangedAt(LocalDateTime changedAt) {
        this.changedAt = changedAt;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\models\dto\PlayerDTO.java


package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.JerseyColor;
import cz.phsoft.hokej.data.enums.PlayerType;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class PlayerDTO {


    private Long id; // autogenerated, nullable pĹ™i create

    @NotBlank(message = "KĹ™estnĂ­ jmĂ©no je povinnĂ©.")
    @Size(min = 2, max = 50)
    private String name; // not null

    @NotBlank(message = "PĹ™Ă­jmenĂ­ je povinnĂ©.")
    @Size(min = 2, max = 50)
    private String surname; // not null

    private String fullName; // derived
    private PlayerType type; // not null, default BASIC
    private JerseyColor jerseyColor;


    public PlayerDTO() {
        this.type = PlayerType.BASIC;
   }

    public PlayerDTO(Long id, String name, String surname, PlayerType type, JerseyColor jerseyColor) {
        this.id = id;
        this.name = name;
        this.surname = surname;
        this.type = type != null ? type : PlayerType.BASIC;
        this.updateFullName();
        this.jerseyColor = jerseyColor;
    }

    // --- Gettery a Settery ---

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; updateFullName(); }

    public String getSurname() { return surname; }
    public void setSurname(String surname) { this.surname = surname; updateFullName(); }

    public String getFullName() { return fullName; }

    public PlayerType getType() { return type; }
    public void setType(PlayerType type) { this.type = type != null ? type : PlayerType.BASIC; }

    private void updateFullName() { this.fullName = name + " " + surname; }

    public JerseyColor getJerseyColor() { return jerseyColor; }

    public void setJerseyColor(JerseyColor jerseyColor) { this.jerseyColor = jerseyColor; }
}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationHistoryService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.MatchRegistrationHistoryDTO;

import java.util.List;

public interface MatchRegistrationHistoryService {
    MatchRegistrationHistoryDTO save(MatchRegistrationHistoryDTO dto);

    List<MatchRegistrationHistoryDTO> getHistoryForRegistration(Long registrationId);

    void delete(Long id);

}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationHistoryServiceImpl.java


package cz.phsoft.hokej.models.services.impl;

import cz.phsoft.hokej.data.entities.MatchRegistrationHistoryEntity;
import cz.phsoft.hokej.data.repositories.MatchRegistrationHistoryRepository;
import cz.phsoft.hokej.models.dto.MatchRegistrationHistoryDTO;
import cz.phsoft.hokej.models.services.MatchRegistrationHistoryService;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class MatchRegistrationHistoryServiceImpl implements MatchRegistrationHistoryService {

    private final MatchRegistrationHistoryRepository repository;

    public MatchRegistrationHistoryServiceImpl(MatchRegistrationHistoryRepository repository) {
        this.repository = repository;
    }

    @Override
    @Transactional
    public MatchRegistrationHistoryDTO save(MatchRegistrationHistoryDTO dto) {

        // PĹ™evod DTO â†’ Entity manuĂˇlnÄ›
        MatchRegistrationHistoryEntity entity = new MatchRegistrationHistoryEntity();
        entity.setMatchRegistrationId(dto.getMatchRegistrationId());
        entity.setMatchId(dto.getMatchId());
        entity.setPlayerId(dto.getPlayerId());
        entity.setStatus(dto.getStatus());
        entity.setExcuseReason(dto.getExcuseReason());
        entity.setExcuseNote(dto.getExcuseNote());
        entity.setAdminNote(dto.getAdminNote());
        entity.setJerseyColor(dto.getJerseyColor());
        entity.setOriginalTimestamp(dto.getOriginalTimestamp() != null ? dto.getOriginalTimestamp() : LocalDateTime.now());
        entity.setCreatedBy(dto.getCreatedBy() != null ? dto.getCreatedBy() : "system");
        entity.setAction(dto.getAction() != null ? dto.getAction() : "INSERT");
        entity.setChangedAt(LocalDateTime.now());

        MatchRegistrationHistoryEntity saved = repository.save(entity);

        // PĹ™evod Entity â†’ DTO manuĂˇlnÄ›
        MatchRegistrationHistoryDTO result = new MatchRegistrationHistoryDTO();
        result.setId(saved.getId());
        result.setMatchRegistrationId(saved.getMatchRegistrationId());
        result.setMatchId(saved.getMatchId());
        result.setPlayerId(saved.getPlayerId());
        result.setStatus(saved.getStatus());
        result.setExcuseReason(saved.getExcuseReason());
        result.setExcuseNote(saved.getExcuseNote());
        result.setAdminNote(saved.getAdminNote());
        result.setJerseyColor(saved.getJerseyColor());
        result.setOriginalTimestamp(saved.getOriginalTimestamp());
        result.setCreatedBy(saved.getCreatedBy());
        result.setAction(saved.getAction());
        result.setChangedAt(saved.getChangedAt());

        return result;
    }

    @Override
    public List<MatchRegistrationHistoryDTO> getHistoryForRegistration(Long registrationId) {
        return repository.findByMatchRegistrationIdOrderByChangedAtDesc(registrationId)
                .stream()
                .map(e -> {
                    MatchRegistrationHistoryDTO dto = new MatchRegistrationHistoryDTO();
                    dto.setId(e.getId());
                    dto.setMatchRegistrationId(e.getMatchRegistrationId());
                    dto.setMatchId(e.getMatchId());
                    dto.setPlayerId(e.getPlayerId());
                    dto.setStatus(e.getStatus());
                    dto.setExcuseReason(e.getExcuseReason());
                    dto.setExcuseNote(e.getExcuseNote());
                    dto.setAdminNote(e.getAdminNote());
                    dto.setJerseyColor(e.getJerseyColor());
                    dto.setOriginalTimestamp(e.getOriginalTimestamp());
                    dto.setCreatedBy(e.getCreatedBy());
                    dto.setAction(e.getAction());
                    dto.setChangedAt(e.getChangedAt());
                    return dto;
                })
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public void delete(Long id) {
        repository.deleteById(id);
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.JerseyColor;


import java.util.List;

    public interface MatchRegistrationService {


        // PĹ™ihlĂˇsit hrĂˇÄŤe s volitelnou barvou dresu a poznĂˇmkou admina
        MatchRegistrationEntity registerPlayer(Long matchId, Long playerId, JerseyColor jerseyColor, String adminNote);

        // OdhlĂˇsit hrĂˇÄŤe
        MatchRegistrationEntity unregisterPlayer(Long matchId, Long playerId, String note, String reason);

        // Omluvit hrĂˇÄŤe s dĹŻvodem
        MatchRegistrationEntity excusePlayer(Long matchId, Long playerId, String note, String reason);

        // ZĂ­skat poslednĂ­ status hrĂˇÄŤe u zĂˇpasu
        MatchRegistrationEntity getLastStatus(Long matchId, Long playerId);

        // ZĂ­skat poslednĂ­ statusy vĹˇech hrĂˇÄŤĹŻ u zĂˇpasu
        List<MatchRegistrationEntity> getLastStatusesForMatch(Long matchId);

        // Seznam vĹˇech registracĂ­ pro zĂˇpas
        List<MatchRegistrationEntity> getRegistrationsForMatch(Long matchId);

        // Seznam vĹˇech registracĂ­
        List<MatchRegistrationEntity> getAllRegistrations();

        // Seznam registracĂ­ pro konkrĂ©tnĂ­ho hrĂˇÄŤe
        List<MatchRegistrationEntity> getRegistrationsForPlayer(Long playerId);

        // ZĂ­skat hrĂˇÄŤe, kteĹ™Ă­ se vĹŻbec nevyjĂˇdĹ™ili k zĂˇpasu
        List<PlayerEntity> getNoResponsePlayers(Long matchId);

        // PĹ™epoÄŤet statusĹŻ REGISTERED / RESERVED podle kapacity
        void recalcStatusesForMatch(Long matchId);


    }







# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.JerseyColor;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.DuplicateRegistrationException;
import cz.phsoft.hokej.models.dto.mappers.MatchRegistrationMapper;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class MatchRegistrationServiceImpl implements MatchRegistrationService {

    private final MatchRegistrationRepository registrationRepository;
    private final MatchRepository matchRepository;
    private final PlayerRepository playerRepository;
    private final MatchRegistrationMapper matchRegistrationMapper;

    public MatchRegistrationServiceImpl(
            MatchRegistrationRepository registrationRepository,
            MatchRepository matchRepository,
            PlayerRepository playerRepository,
            MatchRegistrationMapper matchRegistrationMapper) {

        this.registrationRepository = registrationRepository;
        this.matchRepository = matchRepository;
        this.playerRepository = playerRepository;
        this.matchRegistrationMapper = matchRegistrationMapper;
    }

    // ---------------------------------------------------------------------
    // REGISTRACE
    // ---------------------------------------------------------------------
    @Override
    @Transactional
    public MatchRegistrationEntity registerPlayer(Long matchId, Long playerId, JerseyColor jerseyColor, String adminNote) {

        MatchRegistrationEntity current = registrationRepository
                .findTopByPlayerIdAndMatchIdOrderByTimestampDesc(playerId, matchId)
                .orElse(null);

        if (current != null) {
            throw new DuplicateRegistrationException("HrĂˇÄŤ jiĹľ mĂˇ registraci k zĂˇpasu");
        }

        return saveStatus(matchId, playerId, null, null,
                PlayerMatchStatus.REGISTERED, jerseyColor, adminNote, "user");
    }

    @Override
    @Transactional
    public MatchRegistrationEntity unregisterPlayer(Long matchId, Long playerId, String note, String reason) {
        MatchRegistrationEntity current = registrationRepository
                .findTopByPlayerIdAndMatchIdOrderByTimestampDesc(playerId, matchId)
                .orElseThrow(() -> new RuntimeException("HrĂˇÄŤ nemĂˇ registraci k zĂˇpasu"));

        current.setStatus(PlayerMatchStatus.UNREGISTERED);
        current.setExcuseNote(note);
        current.setExcuseReason(ExcuseReason.valueOf(reason.toUpperCase()));
        current.setTimestamp(LocalDateTime.now());
        current.setCreatedBy("user");

        return registrationRepository.save(current);
    }

    @Override
    @Transactional
    public MatchRegistrationEntity excusePlayer(Long matchId, Long playerId, String note, String reason) {

        MatchRegistrationEntity current = registrationRepository
                .findTopByPlayerIdAndMatchIdOrderByTimestampDesc(playerId, matchId)
                .orElse(null);

        if (current != null) {
            throw new DuplicateRegistrationException("HrĂˇÄŤ jiĹľ mĂˇ registraci, nelze omluvit");
        }

        return saveStatus(matchId, playerId,
                ExcuseReason.valueOf(reason.toUpperCase()), note,
                PlayerMatchStatus.EXCUSED, null, null, "user");
    }

    // ---------------------------------------------------------------------
    // ZĂŤSKĂVĂNĂŤ REGISTRACĂŤ
    // ---------------------------------------------------------------------
    @Override
    public MatchRegistrationEntity getLastStatus(Long matchId, Long playerId) {
        return registrationRepository
                .findTopByPlayerIdAndMatchIdOrderByTimestampDesc(playerId, matchId)
                .orElse(null);
    }

    @Override
    public List<MatchRegistrationEntity> getLastStatusesForMatch(Long matchId) {
        return playerRepository.findAll().stream()
                .map(p -> getLastStatus(matchId, p.getId()))
                .filter(r -> r != null)
                .collect(Collectors.toList());
    }

    @Override
    public List<MatchRegistrationEntity> getRegistrationsForMatch(Long matchId) {
        return registrationRepository.findByMatchId(matchId);
    }

    @Override
    public List<MatchRegistrationEntity> getAllRegistrations() {
        return registrationRepository.findAll();
    }

    @Override
    public List<MatchRegistrationEntity> getRegistrationsForPlayer(Long playerId) {
        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new RuntimeException("Player not found"));
        return registrationRepository.findByPlayer(player);
    }

    @Override
    public List<PlayerEntity> getNoResponsePlayers(Long matchId) {
        List<PlayerEntity> allPlayers = playerRepository.findAll();
        Set<Long> respondedIds = registrationRepository.findByMatchId(matchId)
                .stream()
                .map(r -> r.getPlayer().getId())
                .collect(Collectors.toSet());

        return allPlayers.stream()
                .filter(p -> !respondedIds.contains(p.getId()))
                .collect(Collectors.toList());
    }

    // ---------------------------------------------------------------------
    // CORE SAVE â€“ pĹ™es mapper
    // ---------------------------------------------------------------------
    @Transactional
    private MatchRegistrationEntity saveStatus(Long matchId,
                                               Long playerId,
                                               ExcuseReason excuseReason,
                                               String note,
                                               PlayerMatchStatus status,
                                               JerseyColor jerseyColor,
                                               String adminNote,
                                               String createdBy) {

        MatchEntity match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new RuntimeException("Player not found"));

        PlayerMatchStatus finalStatus = (status != null)
                ? status
                : determineStatus(matchId, match);

        MatchRegistrationEntity reg =
                matchRegistrationMapper.toEntity(
                        match,
                        player,
                        finalStatus,
                        excuseReason,
                        note,
                        jerseyColor,
                        adminNote,
                        createdBy
                );

        return registrationRepository.save(reg);
    }

    // ---------------------------------------------------------------------
    // Status REGISTERED / RESERVED
    // ---------------------------------------------------------------------
    private PlayerMatchStatus determineStatus(Long matchId, MatchEntity match) {
        long registeredCount = registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .count();

        return registeredCount < match.getMaxPlayers()
                ? PlayerMatchStatus.REGISTERED
                : PlayerMatchStatus.RESERVED;
    }

    // ---------------------------------------------------------------------
    // Recalculate statuses
    // ---------------------------------------------------------------------
    @Transactional
    public void recalcStatusesForMatch(Long matchId) {
        MatchEntity match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        int maxPlayers = match.getMaxPlayers();

        var latest = registrationRepository.findByMatchId(matchId).stream()
                .collect(Collectors.groupingBy(
                        r -> r.getPlayer().getId(),
                        Collectors.collectingAndThen(
                                Collectors.maxBy((a, b) -> a.getTimestamp().compareTo(b.getTimestamp())),
                                opt -> opt.orElse(null)
                        )));

        List<MatchRegistrationEntity> active = latest.values().stream()
                .filter(r -> r != null)
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED
                        || r.getStatus() == PlayerMatchStatus.RESERVED)
                .sorted((a, b) -> a.getTimestamp().compareTo(b.getTimestamp()))
                .toList();

        for (int i = 0; i < active.size(); i++) {
            PlayerMatchStatus newStatus = (i < maxPlayers)
                    ? PlayerMatchStatus.REGISTERED
                    : PlayerMatchStatus.RESERVED;

            MatchRegistrationEntity old = active.get(i);

            if (old.getStatus() != newStatus) {
                old.setStatus(newStatus);
                old.setTimestamp(LocalDateTime.now());
                old.setCreatedBy("system");
                registrationRepository.save(old);
            }
        }
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\models\services\MatchService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;

import java.util.List;

public interface MatchService {
    List<MatchDTO> getAllMatches();
    List<MatchDTO> getUpcomingMatches();
    List<MatchDTO> getPastMatches();
    MatchDTO getNextMatch();
    MatchDTO getMatchById(Long id);
    MatchDTO createMatch(MatchDTO dto);
    MatchDTO updateMatch(Long id, MatchDTO dto);
    void deleteMatch(Long id);
    MatchDetailDTO getMatchDetail(Long id);

}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\models\services\MatchServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;
import cz.phsoft.hokej.models.dto.mappers.MatchMapper;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class MatchServiceImpl implements MatchService {

    private final MatchRepository matchRepository;
    private final MatchMapper matchMapper;
    private final MatchRegistrationService registrationService;
    private final PlayerRepository playerRepository;   // â† DOPLNÄšNO !!!

    public MatchServiceImpl(MatchRepository matchRepository,
                            MatchMapper matchMapper,
                            MatchRegistrationService registrationService,
                            PlayerRepository playerRepository) { // â† DOPLNÄšNO !!!
        this.matchRepository = matchRepository;
        this.matchMapper = matchMapper;
        this.registrationService = registrationService;
        this.playerRepository = playerRepository;       // â† DOPLNÄšNO !!!
    }

    @Override
    public List<MatchDTO> getAllMatches() {
        return matchRepository.findAll()
                .stream()
                .map(matchMapper::toDTO)
                .collect(Collectors.toList());
    }

    @Override
    public List<MatchDTO> getUpcomingMatches() {
        return matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now())
                .stream()
                .map(matchMapper::toDTO)
                .collect(Collectors.toList());
    }

    public List<MatchDTO> getPastMatches() {
        return matchRepository.findByDateTimeBeforeOrderByDateTimeDesc(LocalDateTime.now())
                .stream()
                .map(matchMapper::toDTO)
                .collect(Collectors.toList());
    }

    @Override
    public MatchDTO getNextMatch() {
        return matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now())
                .stream()
                .findFirst()
                .map(matchMapper::toDTO)
                .orElse(null);
    }

    @Override
    public MatchDTO getMatchById(Long id) {
        return matchMapper.toDTO(matchRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Match not found: " + id)));
    }

    @Override
    public MatchDTO createMatch(MatchDTO dto) {
        MatchEntity entity = matchMapper.toEntity(dto);
        return matchMapper.toDTO(matchRepository.save(entity));
    }

    @Override
    public MatchDTO updateMatch(Long id, MatchDTO dto) {
        MatchEntity entity = matchRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Match not found: " + id));

        int oldMaxPlayers = entity.getMaxPlayers();
        matchMapper.updateEntity(dto, entity);
        MatchEntity saved = matchRepository.save(entity);

        if (saved.getMaxPlayers() != oldMaxPlayers) {
            registrationService.recalcStatusesForMatch(saved.getId());
        }

        return matchMapper.toDTO(saved);
    }

    @Override
    public void deleteMatch(Long id) {
        matchRepository.deleteById(id);
    }

    // -------------------------------------------------------------------------
    // --------------------------- MATCH DETAIL --------------------------------
    // -------------------------------------------------------------------------

    @Override
    public MatchDetailDTO getMatchDetail(Long id) {

        MatchEntity match = matchRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("ZĂˇpas nenalezen"));

        List<MatchRegistrationEntity> registrations = registrationService.getRegistrationsForMatch(id);

        // --- 1) ROZDÄšLENĂŤ PODLE STATUSĹ® ---
        List<MatchRegistrationEntity> registered = registrations.stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .toList();

        List<MatchRegistrationEntity> reserved = registrations.stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.RESERVED)
                .toList();

        List<MatchRegistrationEntity> unregistered = registrations.stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.UNREGISTERED)
                .toList();

        List<MatchRegistrationEntity> excused = registrations.stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.EXCUSED)
                .toList();

        // --- 2) NO-RESPONSE HRĂÄŚI PĹĂŤMO ZDE ---
        List<PlayerEntity> allPlayers = playerRepository.findAll();

        Set<Long> respondedIds = registrations.stream()
                .map(r -> r.getPlayer().getId())
                .collect(Collectors.toSet());

        List<PlayerEntity> noResponsePlayers = allPlayers.stream()
                .filter(p -> !respondedIds.contains(p.getId()))
                .toList();

        // --- 3) POÄŚTY ---
        int inGamePlayers = registered.size();
        int outGamePlayers = unregistered.size() + excused.size();
        int waitingPlayers = reserved.size();
        int noActionPlayers = noResponsePlayers.size();

        int remainingSlots = match.getMaxPlayers() - inGamePlayers;

        double pricePerRegistered = inGamePlayers > 0
                ? match.getPrice() / (double) inGamePlayers
                : 0;

        // --- 4) DTO ---
        MatchDetailDTO dto = new MatchDetailDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setMaxPlayers(match.getMaxPlayers());

        dto.setInGamePlayers(inGamePlayers);
        dto.setOutGamePlayers(outGamePlayers);
        dto.setWaitingPlayers(waitingPlayers);
        dto.setNoActionPlayers(noActionPlayers);

        dto.setPricePerRegisteredPlayer(pricePerRegistered);
        dto.setRemainingSlots(remainingSlots);

        dto.setRegisteredPlayers(
                registered.stream()
                        .map(r -> r.getPlayer().getName() + " " + r.getPlayer().getSurname())
                        .toList()
        );

        dto.setReservedPlayers(
                reserved.stream()
                        .map(r -> r.getPlayer().getName() + " " + r.getPlayer().getSurname())
                        .toList()
        );

        dto.setUnregisteredPlayers(
                unregistered.stream()
                        .map(r -> r.getPlayer().getName() + " " + r.getPlayer().getSurname())
                        .toList()
        );

        dto.setExcusedPlayers(
                excused.stream()
                        .map(r -> r.getPlayer().getName() + " " + r.getPlayer().getSurname())
                        .toList()
        );

        dto.setNoResponsePlayers(
                noResponsePlayers.stream()
                        .map(p -> p.getName() + " " + p.getSurname())
                        .toList()
        );

        return dto;
    }

}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\models\services\PlayerService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import java.util.List;


public interface PlayerService {
    List<PlayerEntity> getAllPlayers();
    PlayerEntity getPlayerById(Long id);
    PlayerEntity createPlayer(PlayerEntity player);
    PlayerEntity updatePlayer(Long id, PlayerEntity player);
    void deletePlayer(Long id);
}


# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\models\services\PlayerServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class PlayerServiceImpl implements PlayerService {

    private final PlayerRepository playerRepository;

    public PlayerServiceImpl(PlayerRepository playerRepository) {
        this.playerRepository = playerRepository;
    }

    @Override
    public List<PlayerEntity> getAllPlayers() {
        return playerRepository.findAll();
    }

    @Override
    public PlayerEntity getPlayerById(Long id) {
        return playerRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Player not found: " + id));
    }

    @Override
    public PlayerEntity createPlayer(PlayerEntity player) {
        return playerRepository.save(player);
    }

    @Override
    public PlayerEntity updatePlayer(Long id, PlayerEntity newData) {
        PlayerEntity existing = getPlayerById(id);

        existing.setName(newData.getName());
        existing.setSurname(newData.getSurname());
        existing.setType(newData.getType());
        existing.setJerseyColor((newData.getJerseyColor()));
        return playerRepository.save(existing);
    }

    @Override
    public void deletePlayer(Long id) {
        playerRepository.deleteById(id);
    }
}



# Soubor: C:\Projekty Práce\StaraGarda\src\main\java\cz\phsoft\hokej\StaraGardaApplication.java


package cz.phsoft.hokej;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

@SpringBootApplication
@EnableJpaRepositories // <-- PĹ™idĂˇnĂ­m tohoto Ĺ™Ăˇdku "aktivujeme" JPA v naĹˇem Spring Boot projektu
public class StaraGardaApplication {
    public static void main(String[] args) {
        SpringApplication.run(StaraGardaApplication.class, args);


        }
    }


# Soubor: C:\Projekty Práce\StaraGarda\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-03T11:03:07+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchMapperImpl implements MatchMapper {

    @Override
    public MatchDTO toDTO(MatchEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchDTO matchDTO = new MatchDTO();

        matchDTO.setId( entity.getId() );
        matchDTO.setDateTime( entity.getDateTime() );
        matchDTO.setLocation( entity.getLocation() );
        matchDTO.setDescription( entity.getDescription() );
        matchDTO.setMaxPlayers( entity.getMaxPlayers() );
        matchDTO.setPrice( entity.getPrice() );

        return matchDTO;
    }

    @Override
    public MatchEntity toEntity(MatchDTO dto) {
        if ( dto == null ) {
            return null;
        }

        MatchEntity matchEntity = new MatchEntity();

        matchEntity.setId( dto.getId() );
        matchEntity.setDateTime( dto.getDateTime() );
        matchEntity.setLocation( dto.getLocation() );
        matchEntity.setDescription( dto.getDescription() );
        matchEntity.setMaxPlayers( dto.getMaxPlayers() );
        matchEntity.setPrice( dto.getPrice() );

        return matchEntity;
    }

    @Override
    public void updateEntity(MatchDTO dto, MatchEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setDateTime( dto.getDateTime() );
        entity.setLocation( dto.getLocation() );
        entity.setDescription( dto.getDescription() );
        entity.setMaxPlayers( dto.getMaxPlayers() );
        entity.setPrice( dto.getPrice() );
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-03T11:03:07+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerMapperImpl implements PlayerMapper {

    @Override
    public PlayerDTO toDTO(PlayerEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerDTO playerDTO = new PlayerDTO();

        playerDTO.setId( entity.getId() );
        playerDTO.setName( entity.getName() );
        playerDTO.setSurname( entity.getSurname() );
        playerDTO.setType( entity.getType() );
        playerDTO.setJerseyColor( entity.getJerseyColor() );

        return playerDTO;
    }

    @Override
    public PlayerEntity toEntity(PlayerDTO dto) {
        if ( dto == null ) {
            return null;
        }

        PlayerEntity playerEntity = new PlayerEntity();

        playerEntity.setId( dto.getId() );
        playerEntity.setName( dto.getName() );
        playerEntity.setSurname( dto.getSurname() );
        playerEntity.setType( dto.getType() );
        playerEntity.setJerseyColor( dto.getJerseyColor() );

        return playerEntity;
    }

    @Override
    public void updatePlayerDTO(PlayerDTO source, PlayerDTO target) {
        if ( source == null ) {
            return;
        }

        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setType( source.getType() );
        target.setJerseyColor( source.getJerseyColor() );
    }

    @Override
    public void updatePlayerEntity(PlayerDTO source, PlayerEntity target) {
        if ( source == null ) {
            return;
        }

        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setType( source.getType() );
        target.setJerseyColor( source.getJerseyColor() );
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\AppConfig.java


package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class AppConfig {

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\AuditAspect.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

@Component
@Aspect
public class AuditAspect {

    private static final Logger logger = LoggerFactory.getLogger("AUDIT_LOGGER");

    // Pointcut pro vĹˇechny metody ve sluĹľbĂˇch
    @Pointcut("within(cz.phsoft.hokej.models.services..*)")
    public void serviceMethods() {}

    // SpustĂ­ se pĹ™ed metodou
    @Before("serviceMethods()")
    public void logBefore(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().toShortString();
        String args = java.util.Arrays.toString(joinPoint.getArgs());
        logger.info("START {} at {} with args {}", methodName, LocalDateTime.now(), args);
    }

    // SpustĂ­ se po ĂşspÄ›ĹˇnĂ©m dokonÄŤenĂ­ metody
    @AfterReturning(pointcut = "serviceMethods()", returning = "result")
    public void logAfterReturning(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();

        Long userId = null;
        Long playerId = null;

        for (Object arg : args) {
            if (arg instanceof PlayerEntity player) {
                playerId = player.getId();
            } else if (arg instanceof MatchRegistrationEntity registration) {
                playerId = registration.getPlayer().getId();
            } else if (arg instanceof Long id) {
                // pokud mĂˇ metoda Long parametry, mĹŻĹľeĹˇ urÄŤit podle poĹ™adĂ­
                // tĹ™eba prvnĂ­ Long = matchId, druhĂ˝ = playerId
            }
        }

        // logovĂˇnĂ­
        logger.info("END {} - userId={} playerId={} returned [{}] at {}",
                methodName, userId, playerId, result, LocalDateTime.now());
    }
}



# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\CustomUserDetailsService.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.Set;
import java.util.stream.Collectors;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final AppUserRepository appUserRepository;

    public CustomUserDetailsService(AppUserRepository appUserRepository) {
        this.appUserRepository = appUserRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        AppUserEntity user = appUserRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        return org.springframework.security.core.userdetails.User.builder()
                .username(user.getEmail())
                .password(user.getPassword())
                .roles(user.getRole().name().replace("ROLE_", "")) // "ADMIN", "PLAYER", ...
                .build();
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\DataInitializer.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.JerseyColor;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import jakarta.annotation.PostConstruct;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Component
public class DataInitializer {

    private final PlayerRepository playerRepository;
    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository matchRegistrationRepository;
    private final AppUserRepository appUserRepository;

    public DataInitializer(PlayerRepository playerRepository,
                           MatchRepository matchRepository,
                           MatchRegistrationRepository matchRegistrationRepository,
                           AppUserRepository appUserRepository) {
        this.playerRepository = playerRepository;
        this.matchRepository = matchRepository;
        this.matchRegistrationRepository = matchRegistrationRepository;
        this.appUserRepository = appUserRepository;
    }

    @PostConstruct
    public void init() {
        // Pokud existuje alespoĹ 1 hrĂˇÄŤ, DB uĹľ byla inicializovanĂˇ
        if (playerRepository.count() > 0) {
            System.out.println("Data already initialized â€“ skipping DataInitializer.");
            return;
        }
        System.out.println("Initializing default data...");

        // --- Seznam hrĂˇÄŤĹŻ ---
        List<PlayerEntity> players = new ArrayList<>(List.of(
                new PlayerEntity("Petr", "Hlista", PlayerType.VIP, "+420776609956", JerseyColor.DARK),
                new PlayerEntity("LaÄŹa", "BraĹľina", PlayerType.VIP, "+420776609956", JerseyColor.LIGHT),
                new PlayerEntity("David", "PodsednĂ­k", PlayerType.VIP, "+420776609956", JerseyColor.LIGHT),
                new PlayerEntity("VlastĂ­k", "PstruĹľĂ­", PlayerType.VIP, "+420776609956", JerseyColor.LIGHT),
                new PlayerEntity("Otakar", "ZĂˇĹˇkodnĂ˝", PlayerType.VIP, "+420776609956", JerseyColor.LIGHT),
                new PlayerEntity("Jarda", "MenĹˇĂ­k", PlayerType.STANDARD, "+420776609956", JerseyColor.DARK),
                new PlayerEntity("LuboĹˇ", "NovĂˇk", PlayerType.STANDARD, "+420776609956", JerseyColor.LIGHT),
                new PlayerEntity("LukĂˇĹˇ", "NovĂˇk", PlayerType.STANDARD, "+420776609956", JerseyColor.DARK),
                new PlayerEntity("Martin", "ÄŚermĂˇk", PlayerType.STANDARD, "+420776609956", JerseyColor.DARK),
                new PlayerEntity("Pavel", "EliĂˇĹˇ", PlayerType.STANDARD, "+420776609956", JerseyColor.DARK)
                // ... pĹ™Ă­padnÄ› dalĹˇĂ­ hrĂˇÄŤi
        ));

        // --- VytvoĹ™enĂ­ uĹľivatelĹŻ ke kaĹľdĂ©mu hrĂˇÄŤi ---

        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();

        // --- Default admin ---
        if (appUserRepository.findByEmail("admin@example.com").isEmpty()) {
            AppUserEntity admin = new AppUserEntity();
            admin.setEmail("admin@example.com");
            admin.setPassword(encoder.encode("Administrator123"));
            admin.setRole(Role.ROLE_ADMIN);
            appUserRepository.save(admin);
            System.out.println("Default admin user created.");
        } else {
            System.out.println("Admin user already exists â€“ skipping.");
        }

        System.out.println("Data initialization completed.");

        int playerCounter = 1;
        for (PlayerEntity player : players) {
            // vytvoĹ™enĂ­ uĹľivatele
            String email = "player" + playerCounter + "@example.com";
            String password = "Player123";

            AppUserEntity user = new AppUserEntity();
            user.setEmail(email);
            user.setPassword(encoder.encode(password));
            user.setRole(Role.ROLE_PLAYER);

            // pĹ™iĹ™adit hrĂˇÄŤe k uĹľivateli
            player.setUser(user);

            // uloĹľit uĹľivatele (cascade uloĹľĂ­ i hrĂˇÄŤe, pokud je sprĂˇvnÄ› nastaven)
            appUserRepository.save(user);

            playerCounter++;
        }

        // --- UloĹľit hrĂˇÄŤe (uĹľ uloĹľen pĹ™i cascade, ale pro jistotu) ---
        playerRepository.saveAll(players);

        // --- VytvoĹ™enĂ­ zĂˇpasĹŻ ---
        LocalDateTime startDate = LocalDateTime.of(2025, 11, 21, 18, 45);
        for (int i = 0; i < 10; i++) {
            MatchEntity match = new MatchEntity();
            match.setDateTime(startDate.plusWeeks(i));
            match.setLocation("Ostravice");
            match.setDescription("");
            match.setMaxPlayers(12);
            match.setPrice(2200);
            matchRepository.save(match);
        }

        // --- Registrace hrĂˇÄŤĹŻ na zĂˇpas id 3 ---
        MatchEntity match3 = matchRepository.findById(3L)
                .orElseThrow(() -> new RuntimeException("Match with id 3 not found"));

        for (long playerId = 1; playerId <= 6; playerId++) {
            final long pid = playerId;
            PlayerEntity player = playerRepository.findById(playerId)
                    .orElseThrow(() -> new RuntimeException("Player with id " + pid + " not found"));

            MatchRegistrationEntity reg = new MatchRegistrationEntity();
            reg.setMatch(match3);
            reg.setPlayer(player);
            reg.setStatus(PlayerMatchStatus.REGISTERED);
            reg.setTimestamp(LocalDateTime.now());
            reg.setCreatedBy("user");
            matchRegistrationRepository.save(reg);
        }

        // --- Default admin ---
        if (appUserRepository.findByEmail("admin@example.com").isEmpty()) {
            AppUserEntity admin = new AppUserEntity();
            admin.setEmail("admin@example.com");
            admin.setPassword(encoder.encode("Administrator123"));
            admin.setRole(Role.ROLE_ADMIN);
            appUserRepository.save(admin);
            System.out.println("Default admin user created.");
        } else {
            System.out.println("Admin user already exists â€“ skipping.");
        }

        System.out.println("Data initialization completed.");
    }
}





# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\GlobalExceptionHandler.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.exceptions.ApiError;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import jakarta.persistence.EntityNotFoundException;
import jakarta.servlet.http.HttpServletRequest;

@ControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {

    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ApiError> handleAccessDenied(AccessDeniedException ex, HttpServletRequest request) {
        ApiError error = new ApiError(
                HttpStatus.FORBIDDEN.value(),
                "Forbidden",
                ex.getMessage(),
                request.getRequestURI()
        );
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(error);
    }

    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<ApiError> handleNotFound(EntityNotFoundException ex, HttpServletRequest request) {
        ApiError error = new ApiError(
                HttpStatus.NOT_FOUND.value(),
                "Not Found",
                ex.getMessage(),
                request.getRequestURI()
        );
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiError> handleAll(Exception ex, HttpServletRequest request) {
        ApiError error = new ApiError(
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error",
                ex.getMessage(),
                request.getRequestURI()
        );
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\SecurityConfig.java


package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.beans.factory.annotation.Value;

@Configuration
@EnableMethodSecurity // aktivuje @PreAuthorize
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;

    @Value("${app.test-mode:false}")
    private boolean isTestMode;

    public SecurityConfig(CustomUserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;

    }

    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        if (isTestMode) {
            // --- TestovacĂ­ reĹľim: vĹˇechno volnÄ› pro Postman ---
            http
                    .csrf(csrf -> csrf.disable())
                    .authorizeHttpRequests(auth -> auth.anyRequest().permitAll());
        } else {
            // --- ProdukÄŤnĂ­ reĹľim: autentizace + role + Basic Auth + FormLogin ---
            http
                    .csrf(csrf -> csrf.disable())
                    .authorizeHttpRequests(auth -> auth
                            // MATCH
                            .requestMatchers("/api/matches").hasAnyRole("ADMIN","MANAGER")
                            .requestMatchers("/api/matches/upcoming", "/api/matches/past").hasAnyRole("ADMIN","MANAGER")
                            .requestMatchers("/api/matches/**").authenticated()

                            // PLAYER
                            .requestMatchers("/api/players").hasAnyRole("ADMIN","MANAGER")
                            .requestMatchers("/api/players/**").authenticated()

                            // REGISTRATIONS
                            .requestMatchers("/api/registrations/all",
                                    "/api/registrations/for-match/**",
                                    "/api/registrations/no-response/**")
                            .hasAnyRole("ADMIN","MANAGER")
                            .requestMatchers("/api/registrations/**").authenticated()

                            // INACTIVITY
                            .requestMatchers("/api/inactivity/All",
                                    "/api/inactivity/**")
                            .hasAnyRole("ADMIN","MANAGER")
                            .requestMatchers("/api/inactivity/player/**").authenticated()

                            .anyRequest().authenticated()
                    )
                    .formLogin(form -> form
                            .loginPage("/login")
                            .permitAll()
                    )
                    .httpBasic(httpBasic -> {}); // đź”Ą JSON 403
        }

        return http.build();
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\MatchController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;
import cz.phsoft.hokej.models.services.MatchService;
import jakarta.validation.Valid;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;


@RestController
@RequestMapping("/api/matches")
@CrossOrigin(origins = "*")
public class MatchController {

    private final MatchService matchService;


    public MatchController(MatchService matchService) {
        this.matchService = matchService;

    }

    // Detail zĂˇpasu
    @GetMapping("/matchDetail/{id}")
    public MatchDetailDTO getMatchDetail(@PathVariable Long id) {
        return matchService.getMatchDetail(id);
    }

    // VĹˇechny zĂˇpasy
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getAllMatches() {
        return matchService.getAllMatches();
    }

    // NadchĂˇzejĂ­cĂ­ zĂˇpas
    @PreAuthorize("isAuthenticated()")
    @GetMapping("/next")
    public MatchDTO getNextMatch() {
        return matchService.getNextMatch();
    }

    // VĹˇechny nadchĂˇzejĂ­cĂ­ zĂˇpasy
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #playerId)")
    @GetMapping("/upcoming")
    public List<MatchDTO> getUpcomingMatches() {
        return matchService.getUpcomingMatches();
    }

    // NadchĂˇzejĂ­cĂ­ zĂˇpasy pro konkrĂ©tnĂ­ho hrĂˇÄŤe
    @GetMapping("/player/{playerId}/upcoming")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #playerId)")
    public List<MatchDTO> getUpcomingMatchesForPlayer(@PathVariable Long playerId) {
        return matchService.getUpcomingMatchesForPlayer(playerId);

    }

    // UĹľ uskuteÄŤnÄ›nĂ© zĂˇpasy
    @GetMapping("/past")
    public List<MatchDTO> getPastMatches() {
        return matchService.getPastMatches();
    }

    // VytvoĹ™enĂ­ zĂˇpasu
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public MatchDTO createMatch(@Valid @RequestBody MatchDTO matchDTO) {
        return matchService.createMatch(matchDTO);
    }

    // ZĂ­skĂˇnĂ­ zĂˇpasu podle ID
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO getMatch(@PathVariable Long id) {
        return matchService.getMatchById(id);
    }

    // Editace zĂˇpasu
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO updateMatch(@PathVariable Long id, @Valid @RequestBody MatchDTO dto) {
        return matchService.updateMatch(id, dto);
    }

    // SmazĂˇnĂ­ zĂˇpasu
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public void deleteMatch(@PathVariable Long id) {
        matchService.deleteMatch(id);
    }

    // DostupnĂ© zĂˇpasy pro hrĂˇÄŤe
    @GetMapping("/available-for-player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #playerId)")
    public List<MatchDTO> getAvailableMatchesForPlayer(@PathVariable Long playerId) {
        return matchService.getAvailableMatchesForPlayer(playerId);
    }

}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\MatchRegistrationController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import cz.phsoft.hokej.security.PlayerSecurity;
import org.springframework.web.bind.annotation.*;
import org.springframework.security.access.prepost.PreAuthorize;

import java.util.List;

@RestController
@RequestMapping("/api/registrations")
@CrossOrigin(origins = "*")
public class MatchRegistrationController {

    private final MatchRegistrationService service;
    private final PlayerSecurity playerSecurity;

    public MatchRegistrationController(MatchRegistrationService service,
                                       PlayerSecurity playerSecurity) {
        this.service = service;
        this.playerSecurity = playerSecurity;
    }

    // -----------------------------------------------------
    // đź”Ą JEDINĂť UNIVERZĂLNĂŤ ENDPOINT PRO REGISTRACE
    // -----------------------------------------------------
    @PostMapping("/upsert")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #request.playerId)")
    public MatchRegistrationDTO upsert(@RequestBody MatchRegistrationRequest request) {
        return service.upsertRegistration(
                request.getMatchId(),
                request.getPlayerId(),
                request.getJerseyColor(),
                request.getAdminNote(),
                request.getExcuseReason(),
                request.getExcuseNote(),
                request.isUnregister()
        );
    }

    // -----------------------------------------------------
    // GET ENDPOINTY
    // -----------------------------------------------------

    @GetMapping("/all")
    public List<MatchRegistrationDTO> getAllRegistrations() {
        return service.getAllRegistrations();
    }

    @GetMapping("/for-player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #playerId)")
    public List<MatchRegistrationDTO> forPlayer(@PathVariable Long playerId) {
        return service.getRegistrationsForPlayer(playerId);
    }

    @GetMapping("/for-match/{matchId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> forMatch(@PathVariable Long matchId) {
        return service.getRegistrationsForMatch(matchId);
    }

    @GetMapping("/no-response/{matchId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getNoResponse(@PathVariable Long matchId) {
        return service.getNoResponsePlayers(matchId);
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.PlayerService;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/players")
@CrossOrigin(origins = "*")
public class PlayerController {

    private final PlayerService playerService;

    public PlayerController(PlayerService playerService) {
        this.playerService = playerService;
    }

    // vĹˇichni hrĂˇÄŤi
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getAllPlayers() {
        return playerService.getAllPlayers();
    }

    // hrĂˇÄŤ dle id

    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(principal, #id)")
    public PlayerDTO getPlayerById(@PathVariable Long id) {
        return playerService.getPlayerById(id);
    }

    // vytvoĹ™enĂ­ hrĂˇÄŤe
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    @PostMapping
    public PlayerDTO createPlayer(@RequestBody PlayerDTO playerDTO) {
        return playerService.createPlayer(playerDTO);

    }

    // aktualizace hrĂˇÄŤe dle id hrĂˇÄŤe
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    @PutMapping("/{id}")
    public PlayerDTO updatePlayer(@PathVariable Long id, @RequestBody PlayerDTO dto) {
        return playerService.updatePlayer(id, dto);
    }

    // odstranĂ­ hrĂˇÄŤe
    @PreAuthorize("hasRole('ADMIN')")
    @DeleteMapping("/{id}")
    public void deletePlayer(@PathVariable Long id) {
        playerService.deletePlayer(id);
    }


}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerInactivityPeriodController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import cz.phsoft.hokej.models.services.PlayerInactivityPeriodService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/inactivity")
@CrossOrigin(origins = "*")
public class PlayerInactivityPeriodController {

    private final PlayerInactivityPeriodService service;

    public PlayerInactivityPeriodController(PlayerInactivityPeriodService service) {
        this.service = service;
    }

    // vĹˇechny zĂˇznamy o neaktivitÄ› hrĂˇÄŤĹŻ
    @GetMapping("/all")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getAll() {
        return service.getAll();
    }

    // neaktivita hrĂˇÄŤĹŻ dle id neaktivity
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<PlayerInactivityPeriodDTO> getById(@PathVariable Long id) {
        PlayerInactivityPeriodDTO dto = service.getById(id);
        return ResponseEntity.ok(dto);
    }

    // zĂ­skĂˇ zĂˇznamy o periodÄ› neaktivity dle id hrĂˇÄŤe
    @GetMapping("/player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getByPlayer(@PathVariable Long playerId) {
        return service.getByPlayer(playerId);
    }

    // vytvoĹ™Ă­ zĂˇznam o neaktivitÄ› hrĂˇÄŤe
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<PlayerInactivityPeriodDTO> create(@RequestBody PlayerInactivityPeriodDTO dto) {
        PlayerInactivityPeriodDTO created = service.create(dto);
        return ResponseEntity.ok(created);
    }

    // zmÄ›nĂ­ zĂˇznam o neaktivitÄ› hrĂˇÄŤe dle id
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<PlayerInactivityPeriodDTO> update(
            @PathVariable Long id,
            @RequestBody PlayerInactivityPeriodDTO dto) {

        PlayerInactivityPeriodDTO updated = service.update(id, dto);
        return ResponseEntity.ok(updated);
    }

    // vymaĹľe zĂˇznam o neaktivitÄ› hrĂˇÄŤe dle id zĂˇznamu
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        service.delete(id);
        return ResponseEntity.noContent().build();
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestController.java


package cz.phsoft.hokej.controllers;

import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/test")
@CrossOrigin(origins = "*")
public class TestController {

    @GetMapping
    public String hello() {
        return "Backend je online!";
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestSmsController.java


/*
package cz.phsoft.hokej.controllers;


import cz.phsoft.hokej.models.services.sms.SmsTextBeeService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TestSmsController {

    private final SmsTextBeeService smsTextBeeService;

    public TestSmsController(SmsTextBeeService smsTextBeeService) {
        this.smsTextBeeService = smsTextBeeService;
    }

    /**
     * TestovacĂ­ endpoint pro odeslĂˇnĂ­ SMS na testovacĂ­ ÄŤĂ­slo.
     * Zavolej: GET /api/test-sms
     */
/*
    @GetMapping("/api/test-sms")
    public String sendTestSms() {
        smsTextBeeService.sendSms("+420776609956", "testovacĂ­ sms app-sg");
        return "SMS byla odeslĂˇna na testovacĂ­ ÄŤĂ­slo +420776609956";
    }
}

        */


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\AppUserEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.Role;
import jakarta.persistence.*;

import java.util.Set;

@Entity
@Table(name = "app_users")
public class AppUserEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role;

    // One-to-Many: jeden uĹľivatel â†’ vĂ­ce hrĂˇÄŤĹŻ
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<PlayerEntity> players;

    // gettery/settery


    public Long getId() {return id;    }
    public void setId(Long id) {        this.id = id;    }

    public String getEmail() {        return email;    }
    public void setEmail(String email) {        this.email = email;    }

    public String getPassword() {        return password;    }
    public void setPassword(String password) {        this.password = password;    }

    public Role getRole() {        return role;    }
    public void setRole(Role role) {        this.role = role;    }

    public Set<PlayerEntity> getPlayers() {        return players;    }
    public void setPlayers(Set<PlayerEntity> players) {        this.players = players;    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchEntity.java


package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;
import java.time.LocalDateTime;

/**
 * tĹ™Ă­da pro vklĂˇdĂˇnĂ­ Entity zĂˇpasu do db
 */
@Entity
@Table(name = "matches")
public class MatchEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private LocalDateTime dateTime;

    @Column(nullable = false)
    private String location;

    private String description;

    // maximĂˇlnĂ­ poÄŤet hrĂˇÄŤĹŻ - vyuĹľĂ­vĂˇ se pro ovÄ›Ĺ™enĂ­ kapacity pĹ™i pĹ™ihlĂˇĹˇenĂ­
    @Column(nullable = false)
    private Integer maxPlayers;

    @Column(nullable = false)
    private Integer price;

    public MatchEntity() {}

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }

    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() { return price; }

    public void setPrice(Integer price) { this.price = price; }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.JerseyColor;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * tĹ™Ă­da reprezentuje registracei hrĂˇÄŤe k zĂˇpasu
 */
@Entity
@Table(name = "match_registrations")
public class MatchRegistrationEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "match_id", nullable = false)
    private MatchEntity match;

    @ManyToOne
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerMatchStatus status;

    @Enumerated(EnumType.STRING)
    private ExcuseReason excuseReason;

    private String excuseNote;

    // admin mĹŻĹľe vloĹľit poznĂˇmku, napĹ™. kdyĹľ se nÄ›kdo zaregistruje a potĂ© nepĹ™Ă­jde
    private String adminNote;

    @Enumerated(EnumType.STRING)
    @Column(name = "jersey_color")
    private JerseyColor jerseyColor;

    // datÄŤas vytvoĹ™enĂ­ registrace - musĂ­ se mÄ›nit aby nebyl hrĂˇÄŤ i po zruĹˇenĂ­ registrace
    // v poĹ™adĂ­ pĹ™ed hrĂˇÄŤi kteĹ™Ă­ se registrovali po zruĹˇenĂ­ registrace
    @Column(nullable = false, updatable = true)
    private LocalDateTime timestamp = LocalDateTime.now();

    // systĂ©m automaticky vytvĂˇĹ™Ă­ reserved/registered dle kapacity - maxPlayers
    @Column(nullable = false, updatable = true)
    private String createdBy; // "user" nebo "system"

    public MatchRegistrationEntity() {
    }

    // Gettery a Settery


    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public MatchEntity getMatch() {
        return match;
    }

    public void setMatch(MatchEntity match) {
        this.match = match;
    }

    public PlayerEntity getPlayer() {
        return player;
    }

    public void setPlayer(PlayerEntity player) {
        this.player = player;
    }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }

    public ExcuseReason getExcuseReason() {
        return excuseReason;
    }

    public void setExcuseReason(ExcuseReason excuseReason) {
        this.excuseReason = excuseReason;
    }

    public String getExcuseNote() {
        return excuseNote;
    }

    public void setExcuseNote(String excuseNote) {
        this.excuseNote = excuseNote;
    }

    public String getAdminNote() {
        return adminNote;
    }

    public void setAdminNote(String adminNote) {
        this.adminNote = adminNote;
    }

    public JerseyColor getJerseyColor() {
        return jerseyColor;
    }

    public void setJerseyColor(JerseyColor jerseyColor) {
        this.jerseyColor = jerseyColor;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }
}





# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationHistoryEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.JerseyColor;
import jakarta.persistence.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "match_registration_history")
public class MatchRegistrationHistoryEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // ID z pĹŻvodnĂ­ hlavnĂ­ tabulky
    @Column(name = "match_registration_id", nullable = false)
    private Long matchRegistrationId;

    @Column(name = "match_id", nullable = false)
    private Long matchId;

    @Column(name = "player_id", nullable = false)
    private Long playerId;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerMatchStatus status;

    @Enumerated(EnumType.STRING)
    @Column(name = "excuse_reason")
    private ExcuseReason excuseReason;

    @Column(name = "excuse_note")
    private String excuseNote;

    @Column(name = "admin_note")
    private String adminNote;

    @Enumerated(EnumType.STRING)
    @Column(name = "jersey_color")
    private JerseyColor jerseyColor;

    // pĹŻvodnĂ­ timestamp
    @Column(name = "original_timestamp", nullable = false)
    private LocalDateTime originalTimestamp;

    @Column(name = "created_by", nullable = false)
    private String createdBy;

    @Column(nullable = false)
    private String action; // INSERT / UPDATE / DELETE

    @Column(name = "changed_at", nullable = false)
    private LocalDateTime changedAt;

    public MatchRegistrationHistoryEntity() {
    }

    // Gettery a settery


    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getMatchRegistrationId() {
        return matchRegistrationId;
    }

    public void setMatchRegistrationId(Long matchRegistrationId) {
        this.matchRegistrationId = matchRegistrationId;
    }

    public Long getMatchId() {
        return matchId;
    }

    public void setMatchId(Long matchId) {
        this.matchId = matchId;
    }

    public Long getPlayerId() {
        return playerId;
    }

    public void setPlayerId(Long playerId) {
        this.playerId = playerId;
    }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }

    public ExcuseReason getExcuseReason() {
        return excuseReason;
    }

    public void setExcuseReason(ExcuseReason excuseReason) {
        this.excuseReason = excuseReason;
    }

    public String getExcuseNote() {
        return excuseNote;
    }

    public void setExcuseNote(String excuseNote) {
        this.excuseNote = excuseNote;
    }

    public String getAdminNote() {
        return adminNote;
    }

    public void setAdminNote(String adminNote) {
        this.adminNote = adminNote;
    }

    public JerseyColor getJerseyColor() {
        return jerseyColor;
    }

    public void setJerseyColor(JerseyColor jerseyColor) {
        this.jerseyColor = jerseyColor;
    }

    public LocalDateTime getOriginalTimestamp() {
        return originalTimestamp;
    }

    public void setOriginalTimestamp(LocalDateTime originalTimestamp) {
        this.originalTimestamp = originalTimestamp;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }

    public String getAction() {
        return action;
    }

    public void setAction(String action) {
        this.action = action;
    }

    public LocalDateTime getChangedAt() {
        return changedAt;
    }

    public void setChangedAt(LocalDateTime changedAt) {
        this.changedAt = changedAt;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.JerseyColor;
import cz.phsoft.hokej.data.enums.PlayerType;
import jakarta.persistence.*;

@Entity
@Table(name = "player_entity")
public class PlayerEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String surname;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerType type; // VIP, STANDARD, BASIC

    private String fullName;
    private String phoneNumber;

    @Enumerated(EnumType.STRING)
    private JerseyColor jerseyColor;

    // Many-to-One: kaĹľdĂ˝ hrĂˇÄŤ patĹ™Ă­ jednomu uĹľivateli
    @ManyToOne
    @JoinColumn(name = "user_id")
    private AppUserEntity user;

    // ----------------- Konstruktor -----------------
    public PlayerEntity() {
        this.type = PlayerType.BASIC;
    }

    public PlayerEntity(String name, String surname, PlayerType type, String phoneNumber, JerseyColor jerseyColor) {
        this.name = name;
        this.surname = surname;
        this.type = type;
        this.fullName = name + " " + surname;
        this.phoneNumber = phoneNumber;
        this.jerseyColor = jerseyColor;
    }

    // ----------------- Gettery a Settery -----------------
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
        updateFullName();
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
        updateFullName();
    }

    public String getFullName() {
        return fullName;
    }

    public PlayerType getType() {
        return type;
    }

    public void setType(PlayerType type) {
        this.type = type;
    }

    private void updateFullName() {
        this.fullName = name + " " + surname;
    }

    public String getPhoneNumber() {
        return phoneNumber;
    }

    public void setPhoneNumber(String phoneNumber) {
        this.phoneNumber = phoneNumber;
    }

    public JerseyColor getJerseyColor() {
        return jerseyColor;
    }

    public void setJerseyColor(JerseyColor jerseyColor) {
        this.jerseyColor = jerseyColor;
    }

    public AppUserEntity getUser() {
        return user;
    }

    public void setUser(AppUserEntity user) {
        this.user = user;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerInactivityPeriodEntity.java


package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "player_inactivity_period")
public class PlayerInactivityPeriodEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    // neaktivnĂ­ od
    @Column(name = "inactive_from", nullable = false)
    private LocalDateTime inactiveFrom;

    // neaktivnĂ­ do
    @Column(name = "inactive_to", nullable = false)
    private LocalDateTime inactiveTo;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public PlayerEntity getPlayer() {
        return player;
    }

    public void setPlayer(PlayerEntity player) {
        this.player = player;
    }

    public LocalDateTime getInactiveFrom() {
        return inactiveFrom;
    }

    public void setInactiveFrom(LocalDateTime inactiveFrom) {
        this.inactiveFrom = inactiveFrom;
    }

    public LocalDateTime getInactiveTo() {
        return inactiveTo;
    }

    public void setInactiveTo(LocalDateTime inactiveTo) {
        this.inactiveTo = inactiveTo;
    }

}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\ExcuseReason.java


package cz.phsoft.hokej.data.enums;

public enum ExcuseReason {
    NEMOC,
    PRACE,
    NECHE_SE_MI,
    JINE
}



# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\JerseyColor.java


package cz.phsoft.hokej.data.enums;

public enum JerseyColor {
    DARK,
    LIGHT

}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\PlayerMatchStatus.java


package cz.phsoft.hokej.data.enums;

public enum PlayerMatchStatus {
    REGISTERED,
    UNREGISTERED,
    EXCUSED,  // omluven
    RESERVED, // nĂˇhradnĂ­k

}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\PlayerType.java


package cz.phsoft.hokej.data.enums;

public enum PlayerType {
    VIP,
    STANDARD,
    BASIC
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\Role.java


package cz.phsoft.hokej.data.enums;

public enum Role {
    ROLE_PLAYER,
    ROLE_MANAGER,
    ROLE_ADMIN
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\AppUserRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface AppUserRepository extends JpaRepository<AppUserEntity, Long> {
    Optional<AppUserEntity> findByEmail(String email);
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRegistrationHistoryRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchRegistrationHistoryEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface MatchRegistrationHistoryRepository extends JpaRepository<MatchRegistrationHistoryEntity, Long> {

    // vĹˇechny registrace na zĂˇpas
    List<MatchRegistrationHistoryEntity> findByMatchRegistrationIdOrderByChangedAtDesc(Long matchRegistrationId);

    // Historie pro konkrĂ©tnĂ­ zĂˇpas
    List<MatchRegistrationHistoryEntity> findByMatchIdOrderByChangedAtDesc(Long matchId);

    // Historie zmÄ›n hrĂˇÄŤe
    List<MatchRegistrationHistoryEntity> findByPlayerIdOrderByChangedAtDesc(Long playerId);

}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRegistrationRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

    @Repository
    public interface MatchRegistrationRepository extends JpaRepository<MatchRegistrationEntity, Long> {

        // VrĂˇtĂ­ poslednĂ­ status pro danĂ©ho hrĂˇÄŤe a zĂˇpas
        Boolean existsByPlayerIdAndMatchId(Long playerId, Long matchId);

        // VolitelnÄ›: vĹˇechny registrace pro urÄŤitĂ˝ zĂˇpas
        List<MatchRegistrationEntity> findByMatchId(Long matchId);

        // VolitelnÄ›: vĹˇechny registrace pro urÄŤitĂ©ho hrĂˇÄŤe
        List<MatchRegistrationEntity> findByPlayerId(Long playerId);

        // --- NovĂˇ metoda pro hledĂˇnĂ­ konkrĂ©tnĂ­ registrace ---
        Optional<MatchRegistrationEntity> findByPlayerIdAndMatchId(Long playerId, Long matchId);

        long countByMatchAndStatus(MatchEntity match, PlayerMatchStatus status);

    }


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import java.time.LocalDateTime;
import java.util.List;

public interface MatchRepository extends JpaRepository<MatchEntity, Long> {
    List<MatchEntity> findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime dateTime);
    List<MatchEntity> findByDateTimeBeforeOrderByDateTimeDesc(LocalDateTime dateTime);
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\PlayerInactivityPeriodRepository.java



package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface PlayerInactivityPeriodRepository extends JpaRepository<PlayerInactivityPeriodEntity, Long> {

    // zjistĂ­, zda hrĂˇÄŤ je aktuĂˇlnÄ› neaktivnĂ­
    boolean existsByPlayerAndInactiveFromLessThanEqualAndInactiveToGreaterThanEqual(
            PlayerEntity player, LocalDateTime from, LocalDateTime to);

    // zĂ­skĂˇ vĹˇechny neaktivnĂ­ obdobĂ­ hrĂˇÄŤe, kterĂ© spadajĂ­ do intervalu
    List<PlayerInactivityPeriodEntity> findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
            PlayerEntity player, LocalDateTime from, LocalDateTime to);

    List<PlayerInactivityPeriodEntity> findByPlayerOrderByInactiveFromAsc(PlayerEntity player);
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\PlayerRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface PlayerRepository extends JpaRepository<PlayerEntity, Long> {
    Optional<PlayerEntity> findById(Long id);

    List<PlayerEntity> findByIdNotIn(List<Long> ids);
    boolean existsByNameAndSurname(String name, String surname);
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\ApiError.java


package cz.phsoft.hokej.exceptions;

import com.fasterxml.jackson.annotation.JsonFormat;
import java.time.LocalDateTime;

public class ApiError {

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime timestamp;
    private int status;
    private String error;
    private String message;
    private String path;

    public ApiError(int status, String error, String message, String path) {
        this.timestamp = LocalDateTime.now();
        this.status = status;
        this.error = error;
        this.message = message;
        this.path = path;
    }

    public LocalDateTime getTimestamp() { return timestamp; }
    public int getStatus() { return status; }
    public String getError() { return error; }
    public String getMessage() { return message; }
    public String getPath() { return path; }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\DuplicateRegistrationException.java


package cz.phsoft.hokej.exceptions;

public class DuplicateRegistrationException extends RuntimeException {
    public DuplicateRegistrationException(Long matchId, Long playerId) {
        super("HrĂˇÄŤ " + playerId + " jiĹľ mĂˇ aktivnĂ­ registraci na zĂˇpas " + matchId);
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\MatchNotFoundException.java


package cz.phsoft.hokej.exceptions;

public class MatchNotFoundException extends RuntimeException {
    public MatchNotFoundException(Long matchId) {
        super("ZĂˇpas s ID " + matchId + " nenalezen.");;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\PlayerNotFoundException.java


package cz.phsoft.hokej.exceptions;

public class PlayerNotFoundException extends RuntimeException {
    public PlayerNotFoundException(Long playerId) {
        super("HrĂˇÄŤ s ID " + playerId + " nenalezen.");}
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\RegistrationNotFoundException.java


package cz.phsoft.hokej.exceptions;

public class RegistrationNotFoundException extends RuntimeException {
    public RegistrationNotFoundException(Long matchId, Long playerId) {
        super("HrĂˇÄŤ " + playerId + " nemĂˇ registraci na zĂˇpas " + matchId);
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\AppUserMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.PlayerSummaryDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

import java.util.List;

@Mapper(componentModel = "spring")
public interface AppUserMapper {
    @Mapping(target = "players", source = "players")
    AppUserDTO toDto(AppUserEntity entity);

    List<AppUserDTO> toDtoList(List<AppUserEntity> entities);

    PlayerSummaryDTO toPlayerSummary(PlayerEntity entity);
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\MatchMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;

@Mapper(componentModel = "spring")
public interface MatchMapper {

    MatchDTO toDTO(MatchEntity entity);

    MatchEntity toEntity(MatchDTO dto);

    void updateEntity(MatchDTO dto, @MappingTarget MatchEntity entity);
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\MatchRegistrationMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.JerseyColor;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

import java.util.List;

@Mapper(componentModel = "spring")
public interface MatchRegistrationMapper {

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "match", source = "match")
    @Mapping(target = "player", source = "player")
    @Mapping(target = "status", source = "status")
    @Mapping(target = "excuseReason", source = "excuseReason")
    @Mapping(target = "excuseNote", source = "note")
    @Mapping(target = "jerseyColor", source = "jerseyColor")
    @Mapping(target = "adminNote", source = "adminNote")
    @Mapping(target = "createdBy", source = "createdBy")
    @Mapping(target = "timestamp", expression = "java(java.time.LocalDateTime.now())")
    MatchRegistrationEntity toEntity(
            MatchEntity match,
            PlayerEntity player,
            PlayerMatchStatus status,
            ExcuseReason excuseReason,
            String note,
            JerseyColor jerseyColor,
            String adminNote,
            String createdBy
    );

    // entity â†’ DTO (volitelnĂ©)
    @Mapping(target = "matchId", source = "match.id")
    @Mapping(target = "playerId", source = "player.id")
    MatchRegistrationDTO toDTO(MatchRegistrationEntity entity);

    List<MatchRegistrationDTO> toDTOList(List<MatchRegistrationEntity> entities);
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\PlayerInactivityPeriodMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import org.mapstruct.*;

@Mapper(componentModel = "spring")
public interface PlayerInactivityPeriodMapper {

    // Entity -> DTO (OK)
    @Mapping(target = "playerId", source = "player.id")
    PlayerInactivityPeriodDTO toDTO(PlayerInactivityPeriodEntity entity);

    // DTO -> Entity (player Ĺ™eĹˇĂ­ @ObjectFactory)
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "player", ignore = true)
    PlayerInactivityPeriodEntity toEntity(PlayerInactivityPeriodDTO dto, @Context PlayerEntity player);

    // UPDATE DTO -> existujĂ­cĂ­ entity (bez zmÄ›ny player)
    @Mapping(target = "player", ignore = true)
    void updateEntityFromDto(PlayerInactivityPeriodDTO dto, @MappingTarget PlayerInactivityPeriodEntity entity);

    // FACTORY â€“ jedinĂ˝ sprĂˇvnĂ˝ zpĹŻsob, jak nastavit player z @Context
    @ObjectFactory
    default PlayerInactivityPeriodEntity createEntity(PlayerInactivityPeriodDTO dto, @Context PlayerEntity player) {
        PlayerInactivityPeriodEntity entity = new PlayerInactivityPeriodEntity();
        entity.setPlayer(player);
        return entity;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\PlayerMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

import java.util.List;

@Mapper(componentModel = "spring")
public interface PlayerMapper {

        // Entity â†’ DTO (heslo se neposĂ­lĂˇ)
        @Mapping(target = "fullName", ignore = true) // generuje se v DTO
        PlayerDTO toDTO(PlayerEntity entity);

        // DTO â†’ Entity (heslo se mapuje, pokud existuje)
        PlayerEntity toEntity(PlayerDTO dto);

        // Aktualizace existujĂ­cĂ­ho DTO (ignorujeme fullName)
        @Mapping(target = "fullName", ignore = true)
        void updatePlayerDTO(PlayerDTO source, @MappingTarget PlayerDTO target);

        // Aktualizace existujĂ­cĂ­ Entity (heslo se mapuje, fullName nenĂ­ pole v Entity)
        void updatePlayerEntity(PlayerDTO source, @MappingTarget PlayerEntity target);

    List<PlayerDTO> toDTOList(List<PlayerEntity> players);


}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\requests\MatchRegistrationRequest.java


package cz.phsoft.hokej.models.dto.requests;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.JerseyColor;
import jakarta.validation.constraints.*;


public class MatchRegistrationRequest {
    @NotNull
    @Positive
    private Long matchId;

    @NotNull
    @Positive
    private Long playerId;

    private JerseyColor jerseyColor;
    private ExcuseReason excuseReason;
    private String excuseNote;
    private String adminNote;
    private boolean unregister;

    public Long getMatchId() { return matchId; }
    public Long getPlayerId() { return playerId; }
    public JerseyColor getJerseyColor() { return jerseyColor; }
    public ExcuseReason getExcuseReason() { return excuseReason; }
    public String getExcuseNote() { return excuseNote; }
    public String getAdminNote() { return adminNote; }
    public boolean isUnregister() { return unregister; }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\AppUserDTO.java


package cz.phsoft.hokej.models.dto;

import java.util.Set;

public class AppUserDTO {
    private Long id;
    private String email;
    private String role;
    private Set<PlayerSummaryDTO> players; // jednostrannĂ©

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getRole() {
        return role;
    }

    public void setRole(String role) {
        this.role = role;
    }

    public Set<PlayerSummaryDTO> getPlayers() {
        return players;
    }

    public void setPlayers(Set<PlayerSummaryDTO> players) {
        this.players = players;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchDetailDTO.java


package cz.phsoft.hokej.models.dto;

import java.time.LocalDateTime;
import java.util.List;

public class MatchDetailDTO {
    private Long id;
    private LocalDateTime dateTime;
    private int maxPlayers;
    private int inGamePlayers;
    private int outGamePlayers;
    private int waitingPlayers;
    private int noActionPlayers;
    private double pricePerRegisteredPlayer;
    private int remainingSlots;

    List<PlayerDTO> registeredPlayers;
    List<PlayerDTO> reservedPlayers;
    List<PlayerDTO> unregisteredPlayers;
    List<PlayerDTO> excusedPlayers;
    List<PlayerDTO> noResponsePlayers;

    // Gettery a settery

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public LocalDateTime getDateTime() {
        return dateTime;
    }

    public void setDateTime(LocalDateTime dateTime) {
        this.dateTime = dateTime;
    }

    public int getMaxPlayers() {
        return maxPlayers;
    }

    public void setMaxPlayers(int maxPlayers) {
        this.maxPlayers = maxPlayers;
    }

    public int getInGamePlayers() {
        return inGamePlayers;
    }

    public void setInGamePlayers(int inGamePlayers) {
        this.inGamePlayers = inGamePlayers;
    }

    public int getOutGamePlayers() {
        return outGamePlayers;
    }

    public void setOutGamePlayers(int outGamePlayers) {
        this.outGamePlayers = outGamePlayers;
    }

    public int getWaitingPlayers() {
        return waitingPlayers;
    }

    public void setWaitingPlayers(int waitingPlayers) {
        this.waitingPlayers = waitingPlayers;
    }

    public int getNoActionPlayers() {
        return noActionPlayers;
    }

    public void setNoActionPlayers(int noActionPlayers) {
        this.noActionPlayers = noActionPlayers;
    }

    public double getPricePerRegisteredPlayer() {
        return pricePerRegisteredPlayer;
    }

    public void setPricePerRegisteredPlayer(double pricePerRegisteredPlayer) {
        this.pricePerRegisteredPlayer = pricePerRegisteredPlayer;
    }

    public int getRemainingSlots() {
        return remainingSlots;
    }

    public void setRemainingSlots(int remainingSlots) {
        this.remainingSlots = remainingSlots;
    }

    public List<PlayerDTO> getRegisteredPlayers() {
        return registeredPlayers;
    }

    public void setRegisteredPlayers(List<PlayerDTO> registeredPlayers) {
        this.registeredPlayers = registeredPlayers;
    }

    public List<PlayerDTO> getReservedPlayers() {
        return reservedPlayers;
    }

    public void setReservedPlayers(List<PlayerDTO> reservedPlayers) {
        this.reservedPlayers = reservedPlayers;
    }

    public List<PlayerDTO> getUnregisteredPlayers() {
        return unregisteredPlayers;
    }

    public void setUnregisteredPlayers(List<PlayerDTO> unregisteredPlayers) {
        this.unregisteredPlayers = unregisteredPlayers;
    }

    public List<PlayerDTO> getExcusedPlayers() {
        return excusedPlayers;
    }

    public void setExcusedPlayers(List<PlayerDTO> excusedPlayers) {
        this.excusedPlayers = excusedPlayers;
    }

    public List<PlayerDTO> getNoResponsePlayers() {
        return noResponsePlayers;
    }

    public void setNoResponsePlayers(List<PlayerDTO> noResponsePlayers) {
        this.noResponsePlayers = noResponsePlayers;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchDTO.java


package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import jakarta.validation.constraints.FutureOrPresent;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

import java.time.LocalDateTime;

public class MatchDTO {

    private Long id;
    @NotNull(message = "Datum a ÄŤas zĂˇpasu je povinnĂ©.")
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    private LocalDateTime dateTime;

    @NotBlank(message = "MĂ­sto zĂˇpasu je povinnĂ©.")
    @Size(min = 3, max = 100)
    private String location;

    @Size(max = 255, message = "Popis mĹŻĹľe mĂ­t max 255 znakĹŻ.")
    private String description;

    @NotNull(message = "MaximĂˇlnĂ­ poÄŤet hrĂˇÄŤĹŻ je povinnĂ˝")
    private Integer maxPlayers;

    @NotNull(message = "Cena je povinnĂˇ")
    private Integer price;

    // gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }
    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() {
        return price;
    }

    public void setPrice(Integer price) {
        this.price = price;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchRegistrationDTO.java


package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.JerseyColor;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;

public class MatchRegistrationDTO {
    private Long id; // volitelnĂ©, pĹ™i GET

    @NotNull(message = "ID zĂˇpasu je povinnĂ©.")
    @Positive(message = "ID zĂˇpasu musĂ­ bĂ˝t kladnĂ©.")
    private Long matchId;

    @NotNull(message = "ID hrĂˇÄŤe je povinnĂ©.")
    @Positive(message = "ID hrĂˇÄŤe musĂ­ bĂ˝t kladnĂ©.")
    private Long playerId;

    private PlayerMatchStatus status;
    private ExcuseReason excuseReason; // pouze pokud status = EXCUSED
    private String excuseNote;
    private String adminNote;
    private JerseyColor jerseyColor;

    @NotNull
    private String createdBy; // "user" nebo "system"

    private PlayerDTO playerDTO;

    public MatchRegistrationDTO() {}

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public Long getMatchId() { return matchId; }
    public void setMatchId(Long matchId) { this.matchId = matchId; }

    public Long getPlayerId() { return playerId; }
    public void setPlayerId(Long playerId) { this.playerId = playerId; }

    public PlayerMatchStatus getStatus() { return status; }
    public void setStatus(PlayerMatchStatus status) { this.status = status; }

    public ExcuseReason getExcuseReason() { return excuseReason; }
    public void setExcuseReason(ExcuseReason excuseReason) { this.excuseReason = excuseReason; }

    public String getExcuseNote() { return excuseNote; }
    public void setExcuseNote(String excuseNote) { this.excuseNote = excuseNote; }

    public String getAdminNote() { return adminNote; }
    public void setAdminNote(String adminNote) { this.adminNote = adminNote; }

    public JerseyColor getJerseyColor() { return jerseyColor; }
    public void setJerseyColor(JerseyColor jerseyColor) { this.jerseyColor = jerseyColor; }

    public String getCreatedBy() { return createdBy; }
    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }
}



# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerDTO.java


package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.JerseyColor;
import cz.phsoft.hokej.data.enums.PlayerType;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class PlayerDTO {


    private Long id; // autogenerated, nullable pĹ™i create

    @NotBlank(message = "KĹ™estnĂ­ jmĂ©no je povinnĂ©.")
    @Size(min = 2, max = 50)
    private String name; // not null

    @NotBlank(message = "PĹ™Ă­jmenĂ­ je povinnĂ©.")
    @Size(min = 2, max = 50)
    private String surname; // not null

    private String fullName; // derived
    private String phoneNumber;
    private PlayerType type; // not null, default BASIC
    private JerseyColor jerseyColor;


    public PlayerDTO() {
        this.type = PlayerType.BASIC;
   }

    public PlayerDTO(Long id, String name, String surname, PlayerType type, JerseyColor jerseyColor) {
        this.id = id;
        this.name = name;
        this.surname = surname;
        this.type = type != null ? type : PlayerType.BASIC;
        this.updateFullName();
        this.jerseyColor = jerseyColor;
    }

    // --- Gettery a Settery ---

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; updateFullName(); }

    public String getSurname() { return surname; }
    public void setSurname(String surname) { this.surname = surname; updateFullName(); }

    public String getFullName() { return fullName; }

    public PlayerType getType() { return type; }
    public void setType(PlayerType type) { this.type = type != null ? type : PlayerType.BASIC; }

    private void updateFullName() { this.fullName = name + " " + surname; }

    public JerseyColor getJerseyColor() { return jerseyColor; }
    public void setJerseyColor(JerseyColor jerseyColor) { this.jerseyColor = jerseyColor; }

    public String getPhoneNumber() { return phoneNumber; }
    public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerInactivityPeriodDTO.java


package cz.phsoft.hokej.models.dto;

import java.time.LocalDateTime;

public class PlayerInactivityPeriodDTO {

    private Long id;
    private Long playerId;
    private LocalDateTime inactiveFrom;
    private LocalDateTime inactiveTo;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getPlayerId() {
        return playerId;
    }

    public void setPlayerId(Long playerId) {
        this.playerId = playerId;
    }

    public LocalDateTime getInactiveFrom() {
        return inactiveFrom;
    }

    public void setInactiveFrom(LocalDateTime inactiveFrom) {
        this.inactiveFrom = inactiveFrom;
    }

    public LocalDateTime getInactiveTo() {
        return inactiveTo;
    }

    public void setInactiveTo(LocalDateTime inactiveTo) {
        this.inactiveTo = inactiveTo;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerSummaryDTO.java


package cz.phsoft.hokej.models.dto;

public class PlayerSummaryDTO {
    private Long id;
    private String name;
    private String jerseyColor;
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsMessageBuilder.java


package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import org.springframework.stereotype.Component;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;

import java.time.format.DateTimeFormatter;

@Component
public class SmsMessageBuilder {

    private final MatchRegistrationRepository matchRegistrationRepository;
    private final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");

    public SmsMessageBuilder(MatchRegistrationRepository matchRegistrationRepository) {
        this.matchRegistrationRepository = matchRegistrationRepository;
    }

    // --------------------------
    // zprĂˇva po registraci/odhlĂˇĹˇenĂ­/omluvenĂ­
    // --------------------------
    public String buildMessageRegistration(MatchRegistrationEntity registration) {
        PlayerMatchStatus status = registration.getStatus();
        String statusText = switch (status) {
            case REGISTERED -> "pĹ™ihlĂˇsil se k zĂˇpasu";
            case UNREGISTERED -> "odhlĂˇsil se ze zĂˇpasu";
            case EXCUSED -> "omluven";
            default -> "neznĂˇmĂ˝ stav";
        };

        Long registeredCount = matchRegistrationRepository
                .countByMatchAndStatus(registration.getMatch(), PlayerMatchStatus.REGISTERED);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - datum: ")
                .append(registration.getMatch().getDateTime().toLocalDate());

        if (status != PlayerMatchStatus.EXCUSED) {
            sb.append(", ").append(registeredCount)
                    .append("/").append(registration.getMatch().getMaxPlayers());
        }

        sb.append(", hrĂˇÄŤ: ").append(registration.getPlayer().getFullName())
                .append(", status: ").append(statusText);

        return sb.toString();
    }

    // --------------------------
    // zprĂˇva pro hrĂˇÄŤe, kteĹ™Ă­ jeĹˇtÄ› nereagovali
    // --------------------------
    public String buildMessageNoResponse(PlayerDTO player, MatchEntity match) {
        Long registeredCount = matchRegistrationRepository
                .countByMatchAndStatus(match, PlayerMatchStatus.REGISTERED);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - upozornÄ›nĂ­: zĂˇpas ")
                .append(match.getDateTime().format(dateFormatter))
                .append(" - volnĂˇ mĂ­sta: ")
                .append(match.getMaxPlayers() - registeredCount)
                .append(". JeĹˇtÄ› jste nereagoval.");

        return sb.toString();
    }

    // --------------------------
    // finĂˇlnĂ­ pĹ™ipomĂ­nka pro pĹ™ihlĂˇĹˇenĂ© hrĂˇÄŤe v den zĂˇpasu
    // --------------------------
    public String buildMessageFinal(MatchRegistrationEntity registration) {
        MatchEntity match = registration.getMatch();
        Long registeredCount = matchRegistrationRepository
                .countByMatchAndStatus(match, PlayerMatchStatus.REGISTERED);

        double pricePerPlayer = match.getPrice() / Math.max(registeredCount, 1);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - pĹ™ipomĂ­nka zĂˇpasu ")
                .append(match.getDateTime().format(dateFormatter))
                .append(", pĹ™ihlĂˇĹˇeno: ").append(registeredCount).append("/").append(match.getMaxPlayers())
                .append(", cena na hrĂˇÄŤe: ").append(String.format("%.2f KÄŤ", pricePerPlayer));

        return sb.toString();
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsSchedulerService.java


package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import jakarta.transaction.Transactional;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.List;

@Service
public class SmsSchedulerService {

    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository registrationRepository;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;
    private final MatchRegistrationService matchRegistrationService;

    public SmsSchedulerService(
            MatchRepository matchRepository,
            MatchRegistrationRepository registrationRepository,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder,
            MatchRegistrationService matchRegistrationService) {

        this.matchRepository = matchRepository;
        this.registrationRepository = registrationRepository;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
        this.matchRegistrationService = matchRegistrationService;
    }

    // PoslĂˇnĂ­ SMS v den zĂˇpasu
    // SpustĂ­ se kaĹľdĂ˝ den v 12:30
    @Scheduled(cron = "0 30 12 * * *")
    @Transactional
    public void sendFinalSmsForTodayMatches() {

        LocalDate today = LocalDate.now();

        // najdeme vĹˇechny dneĹˇnĂ­ zĂˇpasy
        List<MatchEntity> todaysMatches = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().toLocalDate().isEqual(today))
                .toList();

        for (MatchEntity match : todaysMatches) {

            // naÄŤteme vĹˇechny registrace k danĂ©mu zĂˇpasu (BEZ zmÄ›n entit)
            List<MatchRegistrationEntity> registrations =
                    registrationRepository.findByMatchId(match.getId());

            for (MatchRegistrationEntity reg : registrations) {

                // pouĹľijeĹˇ svĹŻj pĹŻvodnĂ­ builder
                String smsMsg = smsMessageBuilder.buildMessageFinal(reg);

                try {
                    smsService.sendSms(reg.getPlayer().getPhoneNumber(), smsMsg);
                    System.out.println("FinĂˇlnĂ­ SMS poslĂˇna hrĂˇÄŤi "
                            + reg.getPlayer().getFullName() + ": " + smsMsg);

                } catch (Exception e) {
                    System.err.println("Chyba SMS pro hrĂˇÄŤe "
                            + reg.getPlayer().getFullName() + ": " + e.getMessage());
                }
            }
        }
    }

    // poslĂˇnĂ­ SMS 3 dny pĹ™ed zĂˇpasem - noresponse player
    @Scheduled(cron = "0 40 14 * * *") // kaĹľdĂ˝ den ve 12:30
    @Transactional
    public void sendNoResponseSmsForMatchesIn3Days() {

        LocalDate targetDate = LocalDate.now().plusDays(3);

        // vĹˇechny zĂˇpasy, kterĂ© jsou za 3 dny
        List<MatchEntity> matchesInThreeDays = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().toLocalDate().isEqual(targetDate))
                .toList();

        for (MatchEntity match : matchesInThreeDays) {

            // pouĹľijeme tvĹŻj existujĂ­cĂ­ helper
            List<PlayerDTO> noResponsePlayers =
                    matchRegistrationService.getNoResponsePlayers(match.getId());

            for (PlayerDTO player : noResponsePlayers) {

                String smsMsg = smsMessageBuilder.buildMessageNoResponse(player, match);

                try {
                    smsService.sendSms(player.getPhoneNumber(), smsMsg);
                    System.out.println("NORESPONSE SMS poslĂˇna hrĂˇÄŤi "
                            + player.getFullName() + ": " + smsMsg);
                } catch (Exception e) {
                    System.err.println("Chyba NORESPONSE SMS pro hrĂˇÄŤe "
                            + player.getFullName() + ": " + e.getMessage());
                }
            }
        }
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsService.java


package cz.phsoft.hokej.models.services.sms;

public interface SmsService {
    void sendSms(String phoneNumber, String message);
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsServiceImpl.java


/* package cz.phsoft.hokej.models.services.sms;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;

@Service
public class SmsServiceImpl {

   // private final RestTemplate restTemplate = new RestTemplate();

    @Value("${textbee.api-url}")
    private String apiUrl;

    @Value("${textbee.api-key}")
    private String apiKey;

    // testovacĂ­ ÄŤĂ­slo
    //private final String testNumber = "+420776609956";

    /**
     * OdeĹˇle SMS na testovacĂ­ ÄŤĂ­slo.
     * @param message text zprĂˇvy
     */

/*
    public void sendSms(String phoneNumber, String message) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("x-api-key", apiKey);

        Map<String, Object> body = Map.of(
                "recipients", List.of(phoneNumber),
                "message", message
        );

        HttpEntity<Map<String,Object>> request = new HttpEntity<>(body, headers);

        try {
            ResponseEntity<String> response = restTemplate.postForEntity(apiUrl, request, String.class);
            System.out.println("SMS poslĂˇna na testovacĂ­ ÄŤĂ­slo  xxx   : " + response.getBody());
        } catch (Exception e) {
            System.err.println("Chyba pĹ™i odesĂ­lĂˇnĂ­ SMS: " + e.getMessage());
        }
    }

*/


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsTextBeeService.java


package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.models.services.sms.SmsService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;

// textbee - free s omezenĂ­m na 50 sms / den
@Service
public class SmsTextBeeService implements SmsService {

    @Value("${sms.enabled:true}")
    private boolean smsEnabled;

    @Value("${textbee.api-url}")
    private String apiUrl;

    @Value("${textbee.api-key}")
    private String apiKey;

    private final RestTemplate restTemplate = new RestTemplate();

    @Override
    public void sendSms(String phoneNumber, String message) {
        if (!smsEnabled) {
            System.out.println("SMS disabled, message not sent: " + message);
            return;
        }

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("x-api-key", apiKey);

        Map<String, Object> body = Map.of(
                "recipients", List.of(phoneNumber),
                "message", message
        );

        HttpEntity<Map<String,Object>> request = new HttpEntity<>(body, headers);

        try {
            ResponseEntity<String> response = restTemplate.postForEntity(apiUrl, request, String.class);
            System.out.println("SMS odeslĂˇna hrĂˇÄŤi: " + phoneNumber + ", response: " + response.getBody());
        } catch (Exception e) {
            System.err.println("Chyba pĹ™i odesĂ­lĂˇnĂ­ SMS: " + e.getMessage());
        }
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.JerseyColor;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;

import java.util.List;

public interface MatchRegistrationService {

    // đź”Ą VracĂ­ DTO mĂ­sto entity
    MatchRegistrationDTO upsertRegistration(
            Long matchId,
            Long playerId,
            JerseyColor jerseyColor,
            String adminNote,
            ExcuseReason excuseReason,
            String excuseNote,
            boolean unregister
    );

    List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId);

    List<MatchRegistrationDTO> getAllRegistrations();

    List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId);

    List<PlayerDTO> getNoResponsePlayers(Long matchId);

    void recalcStatusesForMatch(Long matchId);
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.JerseyColor;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.DuplicateRegistrationException;
import cz.phsoft.hokej.exceptions.MatchNotFoundException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.exceptions.RegistrationNotFoundException;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.mappers.MatchRegistrationMapper;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.sms.SmsMessageBuilder;
import cz.phsoft.hokej.models.services.sms.SmsService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
public class MatchRegistrationServiceImpl implements MatchRegistrationService {

    Logger logger = LoggerFactory.getLogger(MatchServiceImpl.class);
    private final MatchRegistrationRepository registrationRepository;
    private final MatchRepository matchRepository;
    private final PlayerRepository playerRepository;
    private final MatchRegistrationMapper matchRegistrationMapper;
    private final PlayerMapper playerMapper;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;

    public MatchRegistrationServiceImpl(
            MatchRegistrationRepository registrationRepository,
            MatchRepository matchRepository,
            PlayerRepository playerRepository,
            MatchRegistrationMapper matchRegistrationMapper,
            PlayerMapper playerMapper,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder) {
        this.registrationRepository = registrationRepository;
        this.matchRepository = matchRepository;
        this.playerRepository = playerRepository;
        this.matchRegistrationMapper = matchRegistrationMapper;
        this.playerMapper = playerMapper;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
    }

    private MatchEntity getMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }

    private PlayerEntity getPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    private boolean isSlotAvailable(Long matchId) {
        long registeredCount = registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .count();
        return registeredCount < getMatchOrThrow(matchId).getMaxPlayers();
    }

    private void sendSms(MatchRegistrationEntity registration, String message) {
        if (registration == null || registration.getPlayer() == null) return;
        try {
            smsService.sendSms(registration.getPlayer().getPhoneNumber(), message);
        } catch (Exception e) {
            System.err.println("Chyba SMS: " + e.getMessage());
        }
    }

    private MatchRegistrationEntity updateRegistrationStatus(
            MatchRegistrationEntity registration, PlayerMatchStatus status, String updatedBy, boolean updateTimestamp) {

        registration.setStatus(PlayerMatchStatus.valueOf(status.name()));
        registration.setCreatedBy(updatedBy);
        if (updateTimestamp) {
            registration.setTimestamp(LocalDateTime.now());
        }
        return registrationRepository.saveAndFlush(registration);
    }

    // -------------------- REGISTRATION --------------------

    @Transactional
    @Override
    public MatchRegistrationDTO upsertRegistration(
            Long matchId,
            Long playerId,
            JerseyColor jerseyColor,
            String adminNote,
            ExcuseReason excuseReason,
            String excuseNote,
            boolean unregister) {

        // TEST: poĹˇli ERROR zprĂˇvu pro otestovĂˇnĂ­ emailu
        logger.error("Test ERROR zprĂˇva pro email");

        MatchEntity match = getMatchOrThrow(matchId);
        PlayerEntity player = getPlayerOrThrow(playerId);

        MatchRegistrationEntity registration = registrationRepository
                .findByPlayerIdAndMatchId(playerId, matchId)
                .orElse(null);

        PlayerMatchStatus newStatus;

        if (unregister) {
            if (registration == null) throw new RegistrationNotFoundException(matchId, playerId);
            registration.setExcuseReason(null);
            newStatus = PlayerMatchStatus.UNREGISTERED;
        } else if (excuseReason != null) {
            if (registration != null && registration.getStatus() != PlayerMatchStatus.UNREGISTERED) {
                throw new DuplicateRegistrationException(matchId, playerId);
            }
            registration.setExcuseReason(excuseReason);
            newStatus = PlayerMatchStatus.EXCUSED;
        } else {
            newStatus = isSlotAvailable(matchId) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;
            if (registration != null) registration.setExcuseReason(null);
        }

        if (registration == null) {
            registration = new MatchRegistrationEntity();
            registration.setMatch(match);
            registration.setPlayer(player);
        }

        registration.setStatus(newStatus);
        registration.setTimestamp(LocalDateTime.now());
        registration.setCreatedBy("user");

        if (jerseyColor != null) registration.setJerseyColor(jerseyColor);
        if (adminNote != null) registration.setAdminNote(adminNote);
        if (excuseReason != null) registration.setExcuseReason(excuseReason);

        registration = registrationRepository.save(registration);

        if (unregister) recalcStatusesForMatch(matchId);

        sendSms(registration, smsMessageBuilder.buildMessageRegistration(registration));



        return matchRegistrationMapper.toDTO(registration);
    }

    // -------------------- FETCH --------------------
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId) {
        return matchRegistrationMapper.toDTOList(registrationRepository.findByMatchId(matchId));
    }

    @Override
    public List<MatchRegistrationDTO> getAllRegistrations() {
        return matchRegistrationMapper.toDTOList(registrationRepository.findAll());
    }

    @Override
    public List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId) {
        return matchRegistrationMapper.toDTOList(registrationRepository.findByPlayerId(playerId));
    }

    @Override
    public List<PlayerDTO> getNoResponsePlayers(Long matchId) {
        List<Long> responded = registrationRepository.findByMatchId(matchId).stream()
                .map(r -> r.getPlayer().getId())
                .toList();

        List<PlayerEntity> noResponsePlayers = playerRepository.findAll().stream()
                .filter(p -> !responded.contains(p.getId()))
                .toList();

        return noResponsePlayers.stream()
                .map(playerMapper::toDTO)
                .toList();
    }



    // -------------------- RECALC --------------------
    @Override
    @Transactional
    public void recalcStatusesForMatch(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);
        int maxPlayers = match.getMaxPlayers();

        List<MatchRegistrationEntity> regs = registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED
                        || r.getStatus() == PlayerMatchStatus.RESERVED)
                .sorted((a, b) -> a.getTimestamp().compareTo(b.getTimestamp()))
                .toList();

        for (int i = 0; i < regs.size(); i++) {
            MatchRegistrationEntity reg = regs.get(i);
            PlayerMatchStatus newStatus = (i < maxPlayers) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;
            if (reg.getStatus() != newStatus) updateRegistrationStatus(reg, newStatus, "system", false);
        }
    }

    // -------------------- SMS --------------------
    @Transactional
    public void sendSmsToRegisteredPlayers(Long matchId) {
        registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .forEach(r -> sendSms(r, smsMessageBuilder.buildMessageFinal(r)));
    }

    public void sendNoResponseSmsForMatch(Long matchId) {
        var match = getMatchOrThrow(matchId);

        getNoResponsePlayers(matchId).forEach(player -> {
            String smsMsg = smsMessageBuilder.buildMessageNoResponse(player, match);

            try {
                smsService.sendSms(player.getPhoneNumber(), smsMsg);
            } catch (Exception e) {
                System.err.println("Chyba SMS pro hrĂˇÄŤe "
                        + player.getFullName() + ": " + e.getMessage());
            }
        });
    }

}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;

import java.util.List;

public interface MatchService {
    List<MatchDTO> getAllMatches();
    List<MatchDTO> getUpcomingMatches();
    List<MatchDTO> getPastMatches();
    MatchDTO getNextMatch();
    MatchDTO getMatchById(Long id);
    MatchDTO createMatch(MatchDTO dto);
    MatchDTO updateMatch(Long id, MatchDTO dto);
    void deleteMatch(Long id);
    MatchDetailDTO getMatchDetail(Long id);
    List<MatchDTO> getAvailableMatchesForPlayer(Long playerId);
    List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId);
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.mappers.MatchMapper;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class MatchServiceImpl implements MatchService {

    private final MatchRepository matchRepository;
    private final MatchMapper matchMapper;
    private final MatchRegistrationService registrationService;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodService playerInactivityPeriodService;
    private final PlayerMapper playerMapper; // novÄ› injektovĂˇn

    public MatchServiceImpl(MatchRepository matchRepository,
                            MatchMapper matchMapper,
                            MatchRegistrationService registrationService,
                            PlayerRepository playerRepository,
                            PlayerInactivityPeriodService playerInactivityPeriodService,
                            PlayerMapper playerMapper) {
        this.matchRepository = matchRepository;
        this.matchMapper = matchMapper;
        this.registrationService = registrationService;
        this.playerRepository = playerRepository;
        this.playerInactivityPeriodService = playerInactivityPeriodService;
        this.playerMapper = playerMapper;
    }

    @Override
    public List<MatchDTO> getAllMatches() {
        return matchRepository.findAll()
                .stream()
                .map(matchMapper::toDTO)
                .collect(Collectors.toList());
    }

    @Override
    public List<MatchDTO> getUpcomingMatches() {
        return matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now())
                .stream()
                .map(matchMapper::toDTO)
                .collect(Collectors.toList());
    }

    public List<MatchDTO> getPastMatches() {
        return matchRepository.findByDateTimeBeforeOrderByDateTimeDesc(LocalDateTime.now())
                .stream()
                .map(matchMapper::toDTO)
                .collect(Collectors.toList());
    }

    @Override
    public MatchDTO getNextMatch() {
        return matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now())
                .stream()
                .findFirst()
                .map(matchMapper::toDTO)
                .orElse(null);
    }

    @Override
    public MatchDTO getMatchById(Long id) {
        MatchEntity match = findMatchOrThrow(id);
        return matchMapper.toDTO(match);
    }

    @Override
    public MatchDTO createMatch(MatchDTO dto) {
        MatchEntity entity = matchMapper.toEntity(dto);
        return matchMapper.toDTO(matchRepository.save(entity));
    }

    @Override
    public MatchDTO updateMatch(Long id, MatchDTO dto) {
        MatchEntity match = findMatchOrThrow(id);

        int oldMaxPlayers = match.getMaxPlayers();
        matchMapper.updateEntity(dto, match);
        MatchEntity saved = matchRepository.save(match);

        if (saved.getMaxPlayers() != oldMaxPlayers) {
            registrationService.recalcStatusesForMatch(saved.getId());
        }

        return matchMapper.toDTO(saved);
    }

    @Override
    public void deleteMatch(Long id) {
        matchRepository.deleteById(id);
    }

    @Override
    public MatchDetailDTO getMatchDetail(Long id) {

        MatchEntity match = findMatchOrThrow(id);

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        boolean isAdminOrManager = auth != null && auth.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals("ROLE_ADMIN") ||
                        a.getAuthority().equals("ROLE_MANAGER"));

        // pokud nenĂ­ admin/manager, zjisti vlastnÄ›nĂ© hrĂˇÄŤe a jejich statusy
        if (!isAdminOrManager && auth != null && auth.isAuthenticated()) {
            Object principal = auth.getPrincipal();
            if (principal instanceof org.springframework.security.core.userdetails.UserDetails userDetails) {

                // zĂ­skat ID hrĂˇÄŤĹŻ patĹ™Ă­cĂ­ch aktuĂˇlnĂ­mu pĹ™ihlĂˇĹˇenĂ©mu uĹľivateli
                List<PlayerEntity> ownedPlayers = playerRepository.findAll().stream()
                        .filter(p -> p.getUser() != null && p.getUser().getEmail().equals(userDetails.getUsername()))
                        .toList();

                // zjisti registrace tÄ›chto hrĂˇÄŤĹŻ u zĂˇpasu
                List<MatchRegistrationDTO> registrations = registrationService.getRegistrationsForMatch(id);

                boolean hasRestrictedPlayer = ownedPlayers.stream()
                        .anyMatch(p -> {
                            // 1) NO_RESPONSE = hrĂˇÄŤ nenĂ­ registrovĂˇn na zĂˇpas
                            boolean noResponse = registrations.stream()
                                    .noneMatch(r -> r.getPlayerId().equals(p.getId()));

                            // 2) INACTIVITY = hrĂˇÄŤ je v obdobĂ­ neaktivity
                            boolean inactiveForMatch = !playerInactivityPeriodService.isActive(p, match.getDateTime());

                            return noResponse || inactiveForMatch;
                        });

                if (hasRestrictedPlayer) {
                    throw new org.springframework.security.access.AccessDeniedException(
                            "NemĂˇte pĹ™Ă­stup k detailu tohoto zĂˇpasu."
                    );
                }
            }
        }

        // --- pĹŻvodnĂ­ logika pro registrace ---
        List<MatchRegistrationDTO> registrations = registrationService.getRegistrationsForMatch(id);

        List<MatchRegistrationDTO> registered = registrations.stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .toList();

        List<MatchRegistrationDTO> reserved = registrations.stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.RESERVED)
                .toList();

        List<MatchRegistrationDTO> unregistered = registrations.stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.UNREGISTERED)
                .toList();

        List<MatchRegistrationDTO> excused = registrations.stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.EXCUSED)
                .toList();

        List<PlayerEntity> allPlayers = playerRepository.findAll();

        Set<Long> respondedIds = registrations.stream()
                .map(MatchRegistrationDTO::getPlayerId)
                .collect(Collectors.toSet());

        List<PlayerEntity> noResponsePlayers = allPlayers.stream()
                .filter(p -> !respondedIds.contains(p.getId()))
                .toList();

        int inGamePlayers = registered.size();
        int outGamePlayers = unregistered.size() + excused.size();
        int waitingPlayers = reserved.size();
        int noActionPlayers = noResponsePlayers.size();

        int remainingSlots = match.getMaxPlayers() - inGamePlayers;
        double pricePerRegistered = inGamePlayers > 0 ? match.getPrice() / (double) inGamePlayers : 0;

        MatchDetailDTO dto = new MatchDetailDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setMaxPlayers(match.getMaxPlayers());

        dto.setInGamePlayers(inGamePlayers);
        dto.setOutGamePlayers(outGamePlayers);
        dto.setWaitingPlayers(waitingPlayers);
        dto.setNoActionPlayers(noActionPlayers);

        dto.setPricePerRegisteredPlayer(pricePerRegistered);
        dto.setRemainingSlots(remainingSlots);

        List<PlayerDTO> registeredPlayers = registered.stream()
                .map(r -> playerRepository.findById(r.getPlayerId()))
                .filter(java.util.Optional::isPresent)
                .map(opt -> playerMapper.toDTO(opt.get()))
                .toList();

        List<PlayerDTO> reservedPlayers = reserved.stream()
                .map(r -> playerRepository.findById(r.getPlayerId()))
                .filter(java.util.Optional::isPresent)
                .map(opt -> playerMapper.toDTO(opt.get()))
                .toList();

        List<PlayerDTO> unregisteredPlayers = unregistered.stream()
                .map(r -> playerRepository.findById(r.getPlayerId()))
                .filter(java.util.Optional::isPresent)
                .map(opt -> playerMapper.toDTO(opt.get()))
                .toList();

        List<PlayerDTO> excusedPlayers = excused.stream()
                .map(r -> playerRepository.findById(r.getPlayerId()))
                .filter(java.util.Optional::isPresent)
                .map(opt -> playerMapper.toDTO(opt.get()))
                .toList();

        List<PlayerDTO> noResponsePlayerDTOs = noResponsePlayers.stream()
                .map(playerMapper::toDTO)
                .toList();

        dto.setRegisteredPlayers(registeredPlayers);
        dto.setReservedPlayers(reservedPlayers);
        dto.setUnregisteredPlayers(unregisteredPlayers);
        dto.setExcusedPlayers(excusedPlayers);

        // pouze admin/manager uvidĂ­ no-response hrĂˇÄŤe
        dto.setNoResponsePlayers(isAdminOrManager ? noResponsePlayerDTOs : null);

        return dto;
    }


    @Override
    public List<MatchDTO> getAvailableMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        return matchRepository.findAll().stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .map(matchMapper::toDTO)
                .toList();
    }

    @Override
    public List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId) {

        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        // 1) NejbliĹľĹˇĂ­ nadchĂˇzejĂ­cĂ­ zĂˇpasy podle data
        List<MatchEntity> upcomingAll =
                matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now());

        List<MatchEntity> limited = switch (type) {
            case VIP -> upcomingAll; // VIP vidĂ­ vĹˇe

            case STANDARD -> upcomingAll.stream()
                    .limit(2) // pouze 2 nejbliĹľĹˇĂ­ termĂ­ny
                    .toList();

            case BASIC -> upcomingAll.isEmpty()
                    ? List.of()
                    : List.of(upcomingAll.get(0)); // BASIC vidĂ­ jen 1 nejbliĹľĹˇĂ­ termĂ­n
        };

        // 2) AĹľ nynĂ­ filtrujeme podle aktivity hrĂˇÄŤe (inactivity period)
        List<MatchEntity> activeOnly = limited.stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .toList();

        // 3) PĹ™evedenĂ­ na DTO
        return activeOnly.stream()
                .map(matchMapper::toDTO)
                .toList();
    }

    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new RuntimeException("Player not found: " + playerId));
    }

    private MatchEntity findMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found: " + matchId));
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;

import java.time.LocalDateTime;
import java.util.List;

public interface PlayerInactivityPeriodService {

    List<PlayerInactivityPeriodDTO> getAll();

    PlayerInactivityPeriodDTO getById(Long id);

    List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId);

    PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto);

    PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto);

    void delete(Long id);

    public boolean isActive(PlayerEntity player, LocalDateTime dateTime);
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodServiceImpl.java


import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.data.repositories.PlayerInactivityPeriodRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.dto.mappers.PlayerInactivityPeriodMapper;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import cz.phsoft.hokej.models.services.PlayerInactivityPeriodService;

import java.util.List;
import java.util.stream.Collectors;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;


@Service
public class PlayerInactivityPeriodServiceImpl implements PlayerInactivityPeriodService {

    private final PlayerInactivityPeriodRepository inactivityRepository;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodMapper mapper;

    public PlayerInactivityPeriodServiceImpl(PlayerInactivityPeriodRepository inactivityRepository,
                                             PlayerRepository playerRepository,
                                             PlayerInactivityPeriodMapper mapper) {
        this.inactivityRepository = inactivityRepository;
        this.playerRepository = playerRepository;
        this.mapper = mapper;
    }

    @Override
    public List<PlayerInactivityPeriodDTO> getAll() {
        return inactivityRepository.findAll()
                .stream()
                .map(mapper::toDTO)
                .collect(Collectors.toList());
    }

    @Override
    public PlayerInactivityPeriodDTO getById(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException(
                        "ObdobĂ­ neaktivity s ID " + id + " neexistuje."
                ));
        return mapper.toDTO(entity);
    }

    @Override
    public List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId) {
        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new RuntimeException("Player not found"));

        return inactivityRepository.findByPlayerOrderByInactiveFromAsc(player)
                .stream()
                .map(mapper::toDTO)
                .toList();
    }

    @Override
    public PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto) {
        PlayerEntity player = playerRepository.findById(dto.getPlayerId())
                .orElseThrow(() -> new IllegalArgumentException("HrĂˇÄŤ s ID " + dto.getPlayerId() + " neexistuje."));

        if (dto.getInactiveFrom() == null || dto.getInactiveTo() == null) {
            throw new IllegalArgumentException("Datum od a do nesmĂ­ bĂ˝t null.");
        }
        if (!dto.getInactiveFrom().isBefore(dto.getInactiveTo())) {
            throw new IllegalArgumentException("inactiveFrom musĂ­ bĂ˝t pĹ™ed inactiveTo.");
        }

        // kontrola pĹ™ekryvu
        boolean overlaps = !inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        player, dto.getInactiveFrom(), dto.getInactiveTo()
                ).isEmpty();

        if (overlaps) {
            throw new IllegalStateException("NovĂ© obdobĂ­ se pĹ™ekrĂ˝vĂˇ s existujĂ­cĂ­m obdobĂ­m neaktivity hrĂˇÄŤe.");
        }

        PlayerInactivityPeriodEntity entity = mapper.toEntity(dto, player);
        return mapper.toDTO(inactivityRepository.save(entity));
    }

    @Override
    public PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("ObdobĂ­ neaktivity s ID " + id + " neexistuje."));

        if (dto.getInactiveFrom() == null || dto.getInactiveTo() == null) {
            throw new IllegalArgumentException("Datum od a do nesmĂ­ bĂ˝t null.");
        }
        if (!dto.getInactiveFrom().isBefore(dto.getInactiveTo())) {
            throw new IllegalArgumentException("inactiveFrom musĂ­ bĂ˝t pĹ™ed inactiveTo.");
        }

        // kontrola pĹ™ekryvu, ignoruje aktuĂˇlnĂ­ zĂˇznam
        boolean overlaps = inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        entity.getPlayer(), dto.getInactiveFrom(), dto.getInactiveTo()
                ).stream()
                .anyMatch(p -> !p.getId().equals(id));

        if (overlaps) {
            throw new IllegalStateException("UpravenĂ© obdobĂ­ se pĹ™ekrĂ˝vĂˇ s jinĂ˝m obdobĂ­m neaktivity hrĂˇÄŤe.");
        }

        mapper.updateEntityFromDto(dto, entity);
        return mapper.toDTO(inactivityRepository.save(entity));
    }

    @Override
    public void delete(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("ObdobĂ­ neaktivity s ID " + id + " neexistuje."));
        inactivityRepository.delete(entity);
    }

    // true = aktivnĂ­, false = neaktivnĂ­
    public boolean isActive(PlayerEntity player, LocalDateTime dateTime) {
        return !inactivityRepository.existsByPlayerAndInactiveFromLessThanEqualAndInactiveToGreaterThanEqual(
                player, dateTime, dateTime);
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;

import java.util.List;


public interface PlayerService {
    List<PlayerDTO> getAllPlayers();
    PlayerDTO getPlayerById(Long id);
    PlayerDTO createPlayer(PlayerDTO player);
    PlayerDTO updatePlayer(Long id, PlayerDTO player);
    void deletePlayer(Long id);
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import org.springframework.stereotype.Service;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class PlayerServiceImpl implements PlayerService {

    private final PlayerRepository playerRepository;
    private final PlayerMapper playerMapper;


    public PlayerServiceImpl(PlayerRepository playerRepository, PlayerMapper playerMapper) {
        this.playerRepository = playerRepository;
        this.playerMapper = playerMapper;
    }

    @Override
    public List<PlayerDTO> getAllPlayers() {
        return playerRepository.findAll()
                .stream()
                .map(playerMapper::toDTO)
                .collect(Collectors.toList());

    }

    @Override
    public PlayerDTO getPlayerById(Long id) {
            PlayerEntity player = findPlayerOrThrow(id);
            return playerMapper.toDTO(player);

    }

    @Override
    public PlayerDTO createPlayer(PlayerDTO dto) {
        // kontrola duplicity
        if (playerRepository.existsByNameAndSurname(dto.getName(), dto.getSurname())) {
            throw new RuntimeException("HrĂˇÄŤ se jmĂ©nem " + dto.getName() + " " + dto.getSurname() + " jiĹľ existuje.");
        }

        PlayerEntity entity = playerMapper.toEntity(dto);
        PlayerEntity saved = playerRepository.save(entity);
        return playerMapper.toDTO(saved);
    }

    @Override
    public PlayerDTO updatePlayer(Long id, PlayerDTO dto) {

        PlayerEntity existing = findPlayerOrThrow(id);

        // pokud se jmĂ©no/pĹ™Ă­jmenĂ­ mÄ›nĂ­, ovÄ›Ĺ™ duplicitu
        if ((!existing.getName().equals(dto.getName())
                || !existing.getSurname().equals(dto.getSurname()))
                && playerRepository.existsByNameAndSurname(dto.getName(), dto.getSurname())) {

            throw new RuntimeException("HrĂˇÄŤ se jmĂ©nem " + dto.getName() + " " + dto.getSurname() + " jiĹľ existuje.");
        }

        // aktualizace dat
        existing.setName(dto.getName());
        existing.setSurname(dto.getSurname());
        existing.setType(dto.getType());
        existing.setJerseyColor(dto.getJerseyColor());

        PlayerEntity saved = playerRepository.save(existing);
        return playerMapper.toDTO(saved);
    }

    @Override
    public void deletePlayer(Long id) {
        playerRepository.deleteById(id);
    }

    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new RuntimeException("Player not found: " + playerId));
    }

}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\PlayerSecurity.java


package cz.phsoft.hokej.security;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

@Component("playerSecurity") // nĂˇzev pro pouĹľitĂ­ v SpEL (@PreAuthorize)
public class PlayerSecurity {

    private final PlayerRepository playerRepository;

    public PlayerSecurity(PlayerRepository playerRepository) {
        this.playerRepository = playerRepository;
    }

    public boolean isOwner(org.springframework.security.core.Authentication authentication, Long playerId) {
        try {
            if (authentication == null || !authentication.isAuthenticated()) {
                return false;
            }

            Object principal = authentication.getPrincipal();
            if (!(principal instanceof org.springframework.security.core.userdetails.UserDetails userDetails)) {
                return false;
            }

            return playerRepository.findById(playerId)
                    .map(player -> player.getUser() != null &&
                            player.getUser().getEmail().equals(userDetails.getUsername()))
                    .orElse(false);

        } catch (Exception e) {
            // nikdy nepropustit vĂ˝jimku do SpEL
            return false;
        }
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\StaraGardaApplication.java


package cz.phsoft.hokej;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableJpaRepositories // JPA v naĹˇem Spring Boot projektu
@EnableScheduling
public class StaraGardaApplication {
    public static void main(String[] args) {
        SpringApplication.run(StaraGardaApplication.class, args);


        }
    }


# Soubor: C:\Projekty Práce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\AppUserMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.PlayerSummaryDTO;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-11T16:02:38+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class AppUserMapperImpl implements AppUserMapper {

    @Override
    public AppUserDTO toDto(AppUserEntity entity) {
        if ( entity == null ) {
            return null;
        }

        AppUserDTO appUserDTO = new AppUserDTO();

        appUserDTO.setPlayers( playerEntitySetToPlayerSummaryDTOSet( entity.getPlayers() ) );
        appUserDTO.setId( entity.getId() );
        appUserDTO.setEmail( entity.getEmail() );
        if ( entity.getRole() != null ) {
            appUserDTO.setRole( entity.getRole().name() );
        }

        return appUserDTO;
    }

    @Override
    public List<AppUserDTO> toDtoList(List<AppUserEntity> entities) {
        if ( entities == null ) {
            return null;
        }

        List<AppUserDTO> list = new ArrayList<AppUserDTO>( entities.size() );
        for ( AppUserEntity appUserEntity : entities ) {
            list.add( toDto( appUserEntity ) );
        }

        return list;
    }

    @Override
    public PlayerSummaryDTO toPlayerSummary(PlayerEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerSummaryDTO playerSummaryDTO = new PlayerSummaryDTO();

        return playerSummaryDTO;
    }

    protected Set<PlayerSummaryDTO> playerEntitySetToPlayerSummaryDTOSet(Set<PlayerEntity> set) {
        if ( set == null ) {
            return null;
        }

        Set<PlayerSummaryDTO> set1 = new LinkedHashSet<PlayerSummaryDTO>( Math.max( (int) ( set.size() / .75f ) + 1, 16 ) );
        for ( PlayerEntity playerEntity : set ) {
            set1.add( toPlayerSummary( playerEntity ) );
        }

        return set1;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-11T16:02:39+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchMapperImpl implements MatchMapper {

    @Override
    public MatchDTO toDTO(MatchEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchDTO matchDTO = new MatchDTO();

        matchDTO.setId( entity.getId() );
        matchDTO.setDateTime( entity.getDateTime() );
        matchDTO.setLocation( entity.getLocation() );
        matchDTO.setDescription( entity.getDescription() );
        matchDTO.setMaxPlayers( entity.getMaxPlayers() );
        matchDTO.setPrice( entity.getPrice() );

        return matchDTO;
    }

    @Override
    public MatchEntity toEntity(MatchDTO dto) {
        if ( dto == null ) {
            return null;
        }

        MatchEntity matchEntity = new MatchEntity();

        matchEntity.setId( dto.getId() );
        matchEntity.setDateTime( dto.getDateTime() );
        matchEntity.setLocation( dto.getLocation() );
        matchEntity.setDescription( dto.getDescription() );
        matchEntity.setMaxPlayers( dto.getMaxPlayers() );
        matchEntity.setPrice( dto.getPrice() );

        return matchEntity;
    }

    @Override
    public void updateEntity(MatchDTO dto, MatchEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setDateTime( dto.getDateTime() );
        entity.setLocation( dto.getLocation() );
        entity.setDescription( dto.getDescription() );
        entity.setMaxPlayers( dto.getMaxPlayers() );
        entity.setPrice( dto.getPrice() );
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchRegistrationMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.JerseyColor;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-11T16:02:39+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchRegistrationMapperImpl implements MatchRegistrationMapper {

    @Override
    public MatchRegistrationEntity toEntity(MatchEntity match, PlayerEntity player, PlayerMatchStatus status, ExcuseReason excuseReason, String note, JerseyColor jerseyColor, String adminNote, String createdBy) {
        if ( match == null && player == null && status == null && excuseReason == null && note == null && jerseyColor == null && adminNote == null && createdBy == null ) {
            return null;
        }

        MatchRegistrationEntity matchRegistrationEntity = new MatchRegistrationEntity();

        matchRegistrationEntity.setMatch( match );
        matchRegistrationEntity.setPlayer( player );
        matchRegistrationEntity.setStatus( status );
        matchRegistrationEntity.setExcuseReason( excuseReason );
        matchRegistrationEntity.setExcuseNote( note );
        matchRegistrationEntity.setJerseyColor( jerseyColor );
        matchRegistrationEntity.setAdminNote( adminNote );
        matchRegistrationEntity.setCreatedBy( createdBy );
        matchRegistrationEntity.setTimestamp( java.time.LocalDateTime.now() );

        return matchRegistrationEntity;
    }

    @Override
    public MatchRegistrationDTO toDTO(MatchRegistrationEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchRegistrationDTO matchRegistrationDTO = new MatchRegistrationDTO();

        matchRegistrationDTO.setMatchId( entityMatchId( entity ) );
        matchRegistrationDTO.setPlayerId( entityPlayerId( entity ) );
        matchRegistrationDTO.setId( entity.getId() );
        matchRegistrationDTO.setStatus( entity.getStatus() );
        matchRegistrationDTO.setExcuseReason( entity.getExcuseReason() );
        matchRegistrationDTO.setExcuseNote( entity.getExcuseNote() );
        matchRegistrationDTO.setAdminNote( entity.getAdminNote() );
        matchRegistrationDTO.setJerseyColor( entity.getJerseyColor() );
        matchRegistrationDTO.setCreatedBy( entity.getCreatedBy() );

        return matchRegistrationDTO;
    }

    @Override
    public List<MatchRegistrationDTO> toDTOList(List<MatchRegistrationEntity> entities) {
        if ( entities == null ) {
            return null;
        }

        List<MatchRegistrationDTO> list = new ArrayList<MatchRegistrationDTO>( entities.size() );
        for ( MatchRegistrationEntity matchRegistrationEntity : entities ) {
            list.add( toDTO( matchRegistrationEntity ) );
        }

        return list;
    }

    private Long entityMatchId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        MatchEntity match = matchRegistrationEntity.getMatch();
        if ( match == null ) {
            return null;
        }
        Long id = match.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }

    private Long entityPlayerId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        PlayerEntity player = matchRegistrationEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerInactivityPeriodMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-11T16:02:39+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerInactivityPeriodMapperImpl implements PlayerInactivityPeriodMapper {

    @Override
    public PlayerInactivityPeriodDTO toDTO(PlayerInactivityPeriodEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerInactivityPeriodDTO playerInactivityPeriodDTO = new PlayerInactivityPeriodDTO();

        playerInactivityPeriodDTO.setPlayerId( entityPlayerId( entity ) );
        playerInactivityPeriodDTO.setId( entity.getId() );
        playerInactivityPeriodDTO.setInactiveFrom( entity.getInactiveFrom() );
        playerInactivityPeriodDTO.setInactiveTo( entity.getInactiveTo() );

        return playerInactivityPeriodDTO;
    }

    @Override
    public PlayerInactivityPeriodEntity toEntity(PlayerInactivityPeriodDTO dto, PlayerEntity player) {
        if ( dto == null ) {
            return null;
        }

        PlayerInactivityPeriodEntity playerInactivityPeriodEntity = createEntity( dto, player );

        playerInactivityPeriodEntity.setInactiveFrom( dto.getInactiveFrom() );
        playerInactivityPeriodEntity.setInactiveTo( dto.getInactiveTo() );

        return playerInactivityPeriodEntity;
    }

    @Override
    public void updateEntityFromDto(PlayerInactivityPeriodDTO dto, PlayerInactivityPeriodEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setInactiveFrom( dto.getInactiveFrom() );
        entity.setInactiveTo( dto.getInactiveTo() );
    }

    private Long entityPlayerId(PlayerInactivityPeriodEntity playerInactivityPeriodEntity) {
        if ( playerInactivityPeriodEntity == null ) {
            return null;
        }
        PlayerEntity player = playerInactivityPeriodEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-11T16:02:38+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerMapperImpl implements PlayerMapper {

    @Override
    public PlayerDTO toDTO(PlayerEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerDTO playerDTO = new PlayerDTO();

        playerDTO.setId( entity.getId() );
        playerDTO.setName( entity.getName() );
        playerDTO.setSurname( entity.getSurname() );
        playerDTO.setType( entity.getType() );
        playerDTO.setJerseyColor( entity.getJerseyColor() );
        playerDTO.setPhoneNumber( entity.getPhoneNumber() );

        return playerDTO;
    }

    @Override
    public PlayerEntity toEntity(PlayerDTO dto) {
        if ( dto == null ) {
            return null;
        }

        PlayerEntity playerEntity = new PlayerEntity();

        playerEntity.setId( dto.getId() );
        playerEntity.setName( dto.getName() );
        playerEntity.setSurname( dto.getSurname() );
        playerEntity.setType( dto.getType() );
        playerEntity.setPhoneNumber( dto.getPhoneNumber() );
        playerEntity.setJerseyColor( dto.getJerseyColor() );

        return playerEntity;
    }

    @Override
    public void updatePlayerDTO(PlayerDTO source, PlayerDTO target) {
        if ( source == null ) {
            return;
        }

        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setType( source.getType() );
        target.setJerseyColor( source.getJerseyColor() );
        target.setPhoneNumber( source.getPhoneNumber() );
    }

    @Override
    public void updatePlayerEntity(PlayerDTO source, PlayerEntity target) {
        if ( source == null ) {
            return;
        }

        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setType( source.getType() );
        target.setPhoneNumber( source.getPhoneNumber() );
        target.setJerseyColor( source.getJerseyColor() );
    }

    @Override
    public List<PlayerDTO> toDTOList(List<PlayerEntity> players) {
        if ( players == null ) {
            return null;
        }

        List<PlayerDTO> list = new ArrayList<PlayerDTO>( players.size() );
        for ( PlayerEntity playerEntity : players ) {
            list.add( toDTO( playerEntity ) );
        }

        return list;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-04T13:04:23+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchMapperImpl implements MatchMapper {

    @Override
    public MatchDTO toDTO(MatchEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchDTO matchDTO = new MatchDTO();

        matchDTO.setId( entity.getId() );
        matchDTO.setDateTime( entity.getDateTime() );
        matchDTO.setLocation( entity.getLocation() );
        matchDTO.setDescription( entity.getDescription() );
        matchDTO.setMaxPlayers( entity.getMaxPlayers() );
        matchDTO.setPrice( entity.getPrice() );

        return matchDTO;
    }

    @Override
    public MatchEntity toEntity(MatchDTO dto) {
        if ( dto == null ) {
            return null;
        }

        MatchEntity matchEntity = new MatchEntity();

        matchEntity.setId( dto.getId() );
        matchEntity.setDateTime( dto.getDateTime() );
        matchEntity.setLocation( dto.getLocation() );
        matchEntity.setDescription( dto.getDescription() );
        matchEntity.setMaxPlayers( dto.getMaxPlayers() );
        matchEntity.setPrice( dto.getPrice() );

        return matchEntity;
    }

    @Override
    public void updateEntity(MatchDTO dto, MatchEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setDateTime( dto.getDateTime() );
        entity.setLocation( dto.getLocation() );
        entity.setDescription( dto.getDescription() );
        entity.setMaxPlayers( dto.getMaxPlayers() );
        entity.setPrice( dto.getPrice() );
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchRegistrationMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.JerseyColor;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-04T13:04:22+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchRegistrationMapperImpl implements MatchRegistrationMapper {

    @Override
    public MatchRegistrationEntity toEntity(MatchEntity match, PlayerEntity player, PlayerMatchStatus status, ExcuseReason excuseReason, String note, JerseyColor jerseyColor, String adminNote, String createdBy) {
        if ( match == null && player == null && status == null && excuseReason == null && note == null && jerseyColor == null && adminNote == null && createdBy == null ) {
            return null;
        }

        MatchRegistrationEntity matchRegistrationEntity = new MatchRegistrationEntity();

        matchRegistrationEntity.setMatch( match );
        matchRegistrationEntity.setPlayer( player );
        matchRegistrationEntity.setStatus( status );
        matchRegistrationEntity.setExcuseReason( excuseReason );
        matchRegistrationEntity.setExcuseNote( note );
        matchRegistrationEntity.setJerseyColor( jerseyColor );
        matchRegistrationEntity.setAdminNote( adminNote );
        matchRegistrationEntity.setCreatedBy( createdBy );
        matchRegistrationEntity.setTimestamp( java.time.LocalDateTime.now() );

        return matchRegistrationEntity;
    }

    @Override
    public MatchRegistrationDTO toDTO(MatchRegistrationEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchRegistrationDTO matchRegistrationDTO = new MatchRegistrationDTO();

        matchRegistrationDTO.setMatchId( entityMatchId( entity ) );
        matchRegistrationDTO.setPlayerId( entityPlayerId( entity ) );
        matchRegistrationDTO.setId( entity.getId() );
        matchRegistrationDTO.setStatus( entity.getStatus() );
        matchRegistrationDTO.setExcuseReason( entity.getExcuseReason() );
        matchRegistrationDTO.setExcuseNote( entity.getExcuseNote() );
        matchRegistrationDTO.setAdminNote( entity.getAdminNote() );
        matchRegistrationDTO.setJerseyColor( entity.getJerseyColor() );
        matchRegistrationDTO.setCreatedBy( entity.getCreatedBy() );

        return matchRegistrationDTO;
    }

    private Long entityMatchId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        MatchEntity match = matchRegistrationEntity.getMatch();
        if ( match == null ) {
            return null;
        }
        Long id = match.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }

    private Long entityPlayerId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        PlayerEntity player = matchRegistrationEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerInactivityPeriodMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-04T13:04:23+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerInactivityPeriodMapperImpl implements PlayerInactivityPeriodMapper {

    @Override
    public PlayerInactivityPeriodDTO toDTO(PlayerInactivityPeriodEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerInactivityPeriodDTO playerInactivityPeriodDTO = new PlayerInactivityPeriodDTO();

        playerInactivityPeriodDTO.setPlayerId( entityPlayerId( entity ) );
        playerInactivityPeriodDTO.setId( entity.getId() );
        playerInactivityPeriodDTO.setInactiveFrom( entity.getInactiveFrom() );
        playerInactivityPeriodDTO.setInactiveTo( entity.getInactiveTo() );

        return playerInactivityPeriodDTO;
    }

    @Override
    public PlayerInactivityPeriodEntity toEntity(PlayerInactivityPeriodDTO dto, PlayerEntity player) {
        if ( dto == null ) {
            return null;
        }

        PlayerInactivityPeriodEntity playerInactivityPeriodEntity = createEntity( dto, player );

        playerInactivityPeriodEntity.setInactiveFrom( dto.getInactiveFrom() );
        playerInactivityPeriodEntity.setInactiveTo( dto.getInactiveTo() );

        return playerInactivityPeriodEntity;
    }

    @Override
    public void updateEntityFromDto(PlayerInactivityPeriodDTO dto, PlayerInactivityPeriodEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setInactiveFrom( dto.getInactiveFrom() );
        entity.setInactiveTo( dto.getInactiveTo() );
    }

    private Long entityPlayerId(PlayerInactivityPeriodEntity playerInactivityPeriodEntity) {
        if ( playerInactivityPeriodEntity == null ) {
            return null;
        }
        PlayerEntity player = playerInactivityPeriodEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}


# Soubor: C:\Projekty Práce\StaraGarda\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-04T13:04:23+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerMapperImpl implements PlayerMapper {

    @Override
    public PlayerDTO toDTO(PlayerEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerDTO playerDTO = new PlayerDTO();

        playerDTO.setId( entity.getId() );
        playerDTO.setName( entity.getName() );
        playerDTO.setSurname( entity.getSurname() );
        playerDTO.setType( entity.getType() );
        playerDTO.setJerseyColor( entity.getJerseyColor() );

        return playerDTO;
    }

    @Override
    public PlayerEntity toEntity(PlayerDTO dto) {
        if ( dto == null ) {
            return null;
        }

        PlayerEntity playerEntity = new PlayerEntity();

        playerEntity.setId( dto.getId() );
        playerEntity.setName( dto.getName() );
        playerEntity.setSurname( dto.getSurname() );
        playerEntity.setType( dto.getType() );
        playerEntity.setJerseyColor( dto.getJerseyColor() );

        return playerEntity;
    }

    @Override
    public void updatePlayerDTO(PlayerDTO source, PlayerDTO target) {
        if ( source == null ) {
            return;
        }

        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setType( source.getType() );
        target.setJerseyColor( source.getJerseyColor() );
    }

    @Override
    public void updatePlayerEntity(PlayerDTO source, PlayerEntity target) {
        if ( source == null ) {
            return;
        }

        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setType( source.getType() );
        target.setJerseyColor( source.getJerseyColor() );
    }
}
