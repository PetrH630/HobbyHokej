# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\AppConfig.java


package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class AppConfig {

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\AuditAspect.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

@Component
@Aspect
public class AuditAspect {

    private static final Logger logger = LoggerFactory.getLogger("AUDIT_LOGGER");

    // Pointcut pro v≈°echny metody ve slu≈æb√°ch
    @Pointcut("within(cz.phsoft.hokej.models.services..*)")
    public void serviceMethods() {}

    // Spust√≠ se p≈ôed metodou
    @Before("serviceMethods()")
    public void logBefore(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().toShortString();
        String args = java.util.Arrays.toString(joinPoint.getArgs());
        logger.info("START {} at {} with args {}", methodName, LocalDateTime.now(), args);
    }

    // Spust√≠ se po √∫spƒõ≈°n√©m dokonƒçen√≠ metody
    @AfterReturning(pointcut = "serviceMethods()", returning = "result")
    public void logAfterReturning(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();

        Long userId = null;
        Long playerId = null;

        for (Object arg : args) {
            if (arg instanceof PlayerEntity player) {
                playerId = player.getId();
            } else if (arg instanceof MatchRegistrationEntity registration) {
                playerId = registration.getPlayer().getId();
            } else if (arg instanceof Long id) {
                // pokud m√° metoda Long parametry, m≈Ø≈æe≈° urƒçit podle po≈ôad√≠
                // t≈ôeba prvn√≠ Long = matchId, druh√Ω = playerId
            }
        }

        // logov√°n√≠
        logger.info("END {} - userId={} playerId={} returned [{}] at {}",
                methodName, userId, playerId, result, LocalDateTime.now());
    }
}



# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\CustomJsonLoginFilter.java


package cz.phsoft.hokej.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.context.HttpSessionSecurityContextRepository;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

// filtr pro REST login
public class CustomJsonLoginFilter extends UsernamePasswordAuthenticationFilter {

    private final ObjectMapper objectMapper = new ObjectMapper();

    public CustomJsonLoginFilter(String loginUrl, AuthenticationManager authManager) {
        setFilterProcessesUrl(loginUrl);
        setAuthenticationManager(authManager);
    }

    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        try {
            // Podporujeme x-www-form-urlencoded i JSON
            String email = null;
            String password = null;

// Podporujeme x-www-form-urlencoded
            if ("application/x-www-form-urlencoded".equals(request.getContentType())) {
                email = request.getParameter("username");
                password = request.getParameter("password");
            }

// Podporujeme JSON
            if ((email == null || password == null) &&
                    request.getContentType() != null &&
                    request.getContentType().contains("application/json")) {
                Map<String, String> json = objectMapper.readValue(request.getInputStream(), Map.class);
                email = json.get("email");
                password = json.get("password");
            }


            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(email, password);
            setDetails(request, authRequest);

            return this.getAuthenticationManager().authenticate(authRequest);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }


    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
                                            FilterChain chain, Authentication authResult)
            throws IOException, ServletException {

        // Ulo≈æen√≠ do SecurityContextHolder
        SecurityContextHolder.getContext().setAuthentication(authResult);

        // Vytvo≈ôen√≠ session a ulo≈æen√≠ SPRING_SECURITY_CONTEXT
        request.getSession(true).setAttribute(
                HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY,
                SecurityContextHolder.getContext()
        );

        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");

        Map<String, Object> result = new HashMap<>();
        result.put("status", "ok");
        result.put("user", authResult.getName());

        objectMapper.writeValue(response.getWriter(), result);
    }

    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException {
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");

        Map<String, Object> result = new HashMap<>();
        result.put("status", "error");
        result.put("message", "Neplatn√© p≈ôihla≈°ovac√≠ √∫daje");

        objectMapper.writeValue(response.getWriter(), result);
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\CustomUserDetailsService.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.Set;
import java.util.stream.Collectors;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final AppUserRepository appUserRepository;

    public CustomUserDetailsService(AppUserRepository appUserRepository) {
        this.appUserRepository = appUserRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        AppUserEntity user = appUserRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        return org.springframework.security.core.userdetails.User.builder()
                .username(user.getEmail())
                .password(user.getPassword())
                .roles(user.getRole().name().replace("ROLE_", "")) // "ADMIN", "PLAYER", ...
                .build();
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\DataInitializer.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import jakarta.annotation.PostConstruct;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Component;
import org.springframework.jdbc.core.JdbcTemplate;


import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Component
public class DataInitializer {

    private final PlayerRepository playerRepository;
    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository matchRegistrationRepository;
    private final AppUserRepository appUserRepository;
    private final JdbcTemplate jdbcTemplate;

    public DataInitializer(PlayerRepository playerRepository,
                           MatchRepository matchRepository,
                           MatchRegistrationRepository matchRegistrationRepository,
                           AppUserRepository appUserRepository,
                           JdbcTemplate jdbcTemplate) {
        this.playerRepository = playerRepository;
        this.matchRepository = matchRepository;
        this.matchRegistrationRepository = matchRegistrationRepository;
        this.appUserRepository = appUserRepository;
        this.jdbcTemplate = jdbcTemplate;
    }

    @PostConstruct
    public void init() {
        // Pokud existuje alespo≈à 1 hr√°ƒç, DB u≈æ byla inicializovan√°
        if (playerRepository.count() > 0) {
            System.out.println("Data already initialized ‚Äì skipping DataInitializer.");
            return;
        }
        System.out.println("Initializing default data...");

        // --- Seznam hr√°ƒç≈Ø ---
        List<PlayerEntity> players = new ArrayList<>(List.of(
                new PlayerEntity("Hr√°ƒç_1", "Jedna", "", PlayerType.VIP, "+420776609956", Team.DARK),
                new PlayerEntity("Hr√°ƒç_2", "Dva", "", PlayerType.VIP, "+420776609956", Team.LIGHT),
                new PlayerEntity("Hr√°ƒç_3", "T≈ôi", "", PlayerType.VIP, "+420776609956", Team.LIGHT),
                new PlayerEntity("Hr√°ƒç_4", "ƒåty≈ôi", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT),
                new PlayerEntity("Hr√°ƒç_5", "Pƒõt", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT),
                new PlayerEntity("Hr√°ƒç_6", "≈†est", "", PlayerType.STANDARD, "+420776609956", Team.DARK),
                new PlayerEntity("Hr√°ƒç_7", "Sedm", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT),
                new PlayerEntity("Hr√°ƒç_8", "Osum", "", PlayerType.BASIC, "+420776609956", Team.DARK),
                new PlayerEntity("Hr√°ƒç_9", "Devƒõt", "", PlayerType.BASIC, "+420776609956", Team.DARK),
                new PlayerEntity("Hr√°ƒç_10", "Deset", "", PlayerType.BASIC, "+420776609956", Team.DARK)
                // ... p≈ô√≠padnƒõ dal≈°√≠ hr√°ƒçi
        ));

        // --- Vytvo≈ôen√≠ u≈æivatel≈Ø ke ka≈æd√©mu hr√°ƒçi ---

        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();

        // --- Default admin ---
        if (appUserRepository.findByEmail("admin@example.com").isEmpty()) {
            AppUserEntity admin = new AppUserEntity();
            admin.setEmail("admin@example.com");
            admin.setPassword(encoder.encode("Administrator123"));
            admin.setRole(Role.ROLE_ADMIN);
            appUserRepository.save(admin);
            System.out.println("Default admin user created.");
        } else {
            System.out.println("Admin user already exists ‚Äì skipping.");
        }

        System.out.println("Data initialization completed.");

        int playerCounter = 1;
        for (PlayerEntity player : players) {
            // vytvo≈ôen√≠ u≈æivatele
            String email = "player" + playerCounter + "@example.com";
            String password = "Player123";

            AppUserEntity user = new AppUserEntity();
            user.setEmail(email);
            user.setPassword(encoder.encode(password));
            user.setRole(Role.ROLE_PLAYER);

            // p≈ôi≈ôadit hr√°ƒçe k u≈æivateli
            player.setUser(user);

            // ulo≈æit u≈æivatele (cascade ulo≈æ√≠ i hr√°ƒçe, pokud je spr√°vnƒõ nastaven)
            appUserRepository.save(user);

            playerCounter++;
        }

        // --- Ulo≈æit hr√°ƒçe (u≈æ ulo≈æen p≈ôi cascade, ale pro jistotu) ---
        playerRepository.saveAll(players);

        // --- Vytvo≈ôen√≠ z√°pas≈Ø ---
        LocalDateTime startDate = LocalDateTime.of(2025, 11, 21, 18, 45);
        for (int i = 0; i < 10; i++) {
            MatchEntity match = new MatchEntity();
            match.setDateTime(startDate.plusWeeks(i));
            match.setLocation("Ostravice");
            match.setDescription("");
            match.setMaxPlayers(12);
            match.setPrice(2200);
            matchRepository.save(match);
        }

        // --- Registrace hr√°ƒç≈Ø na z√°pas id 3 ---
        MatchEntity match3 = matchRepository.findById(3L)
                .orElseThrow(() -> new RuntimeException("Match with id 3 not found"));

        for (long playerId = 1; playerId <= 6; playerId++) {
            final long pid = playerId;
            PlayerEntity player = playerRepository.findById(playerId)
                    .orElseThrow(() -> new RuntimeException("Player with id " + pid + " not found"));

            MatchRegistrationEntity reg = new MatchRegistrationEntity();
            reg.setMatch(match3);
            reg.setPlayer(player);
            reg.setStatus(PlayerMatchStatus.REGISTERED);
            reg.setTimestamp(LocalDateTime.now());
            reg.setCreatedBy("user");
            matchRegistrationRepository.save(reg);
        }

        // --- Default admin ---
        if (appUserRepository.findByEmail("admin@example.com").isEmpty()) {
            AppUserEntity admin = new AppUserEntity();
            admin.setEmail("admin@example.com");
            admin.setPassword(encoder.encode("Administrator123"));
            admin.setRole(Role.ROLE_ADMIN);
            appUserRepository.save(admin);
            System.out.println("Default admin user created.");
        } else {
            System.out.println("Admin user already exists ‚Äì skipping.");
        }

        // --- vytvo≈ôen√≠ triggeru ---
        try {
            jdbcTemplate.execute("""
                           CREATE TRIGGER trg_match_reg_insert
                           AFTER INSERT ON match_registrations
                           FOR EACH ROW
                           BEGIN
                               INSERT INTO match_registration_history
                               (match_registration_id, match_id, player_id, status, excuse_reason,
                                excuse_note, admin_note, jersey_color, original_timestamp, created_by,
                                action, changed_at)
                               VALUES
                               (NEW.id, NEW.match_id, NEW.player_id, NEW.status, NEW.excuse_reason,
                                NEW.excuse_note, NEW.admin_note, NEW.jersey_color, NEW.timestamp, NEW.created_by,
                                'INSERT', NOW());
                           END
                    """);
            System.out.println("Trigger created successfully.");
        } catch (Exception e) {
            System.out.println("Trigger already exists or error: " + e.getMessage());
        }

        try {
            jdbcTemplate.execute("""
                    CREATE TRIGGER trg_match_reg_update
                    AFTER UPDATE ON match_registrations
                    FOR EACH ROW
                    BEGIN
                        INSERT INTO match_registration_history
                        (match_registration_id, match_id, player_id, status, excuse_reason,
                         excuse_note, admin_note, jersey_color, original_timestamp, created_by,
                         action, changed_at)
                        VALUES
                        (NEW.id, NEW.match_id, NEW.player_id, NEW.status, NEW.excuse_reason,
                         NEW.excuse_note, NEW.admin_note, NEW.jersey_color, NEW.timestamp, NEW.created_by,
                         'UPDATE', NOW());
                    END
                    """);
            System.out.println("Trigger created successfully.");
        } catch (Exception e) {
            System.out.println("Trigger already exists or error: " + e.getMessage());
        }

        try {
            jdbcTemplate.execute("""
        CREATE TRIGGER trg_match_reg_delete
        AFTER DELETE ON match_registrations
        FOR EACH ROW
                BEGIN
        INSERT INTO match_registration_history
                (match_registration_id, match_id, player_id, status, excuse_reason,
                        excuse_note, admin_note, jersey_color, original_timestamp, created_by,
                        action, changed_at)
        VALUES
                (OLD.id, OLD.match_id, OLD.player_id, OLD.status, OLD.excuse_reason,
                        OLD.excuse_note, OLD.admin_note, OLD.jersey_color, OLD.timestamp, OLD.created_by,
                        'DELETE', NOW());
        END
        """);
            System.out.println("Trigger created successfully.");
                } catch (Exception e) {
                    System.out.println("Trigger already exists or error: " + e.getMessage());
                }
        
        System.out.println("Data initialization completed.");
    

    }
}





# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\GlobalExceptionHandler.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.exceptions.ApiError;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import jakarta.servlet.http.HttpServletRequest;

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ApiError> handleAccessDenied(AccessDeniedException ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.FORBIDDEN.value(),
                "Forbidden",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // ‚Üê IP klienta);
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(error);
    }

    // --- Nenalezen√© zdroje (404) ---
    @ExceptionHandler({
            MatchNotFoundException.class,
            PlayerNotFoundException.class,
            RegistrationNotFoundException.class
    })
    public ResponseEntity<ApiError> handleNotFound(RuntimeException ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.NOT_FOUND.value(),
                "Not Found",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // ‚Üê IP klienta
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    // --- Konflikty (409) ---
    @ExceptionHandler(DuplicateRegistrationException.class)
    public ResponseEntity<ApiError> handleConflict(DuplicateRegistrationException ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.CONFLICT.value(),
                "Conflict",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // ‚Üê IP klienta);
        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
    }

    // --- Obecn√© chyby (500) ---
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiError> handleAll(Exception ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // ‚Üê IP klienta);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\SecurityConfig.java


package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;



import java.util.List;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;

    @Value("${app.test-mode:false}")
    private boolean isTestMode;

    public SecurityConfig(CustomUserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    // Password encoder
    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    // Authentication provider
    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    // AuthenticationManager
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    // Security filter chain
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http, AuthenticationManager authManager) throws Exception {

        http.csrf(csrf -> csrf.disable())
                .cors(cors -> {});

        if (isTestMode) {
            // üîπ Test mode - v≈°echno povoleno a HTTP Basic pro Postman
            http.authorizeHttpRequests(auth -> auth.anyRequest().permitAll())
                    .httpBasic();
        } else {
            // üîπ Produkce - REST login p≈ôes CustomJsonLoginFilter
            http.authorizeHttpRequests(auth -> auth
                            .requestMatchers("/api/matches").hasAnyRole("ADMIN","MANAGER")
                            .requestMatchers("/api/matches/upcoming", "/api/matches/past").hasAnyRole("ADMIN","MANAGER")
                            .requestMatchers("/api/matches/**").authenticated()
                            .requestMatchers("/api/players").hasAnyRole("ADMIN","MANAGER")
                            .requestMatchers("/api/players/**").authenticated()
                            .requestMatchers("/api/registrations/all",
                                    "/api/registrations/for-match/**",
                                    "/api/registrations/no-response/**").hasAnyRole("ADMIN","MANAGER")
                            .requestMatchers("/api/registrations/**").authenticated()
                            .requestMatchers("/api/inactivity/All",
                                    "/api/inactivity/**").hasAnyRole("ADMIN","MANAGER")
                            .requestMatchers("/api/inactivity/player/**").authenticated()
                            .anyRequest().authenticated()
                    )
                    //  TADY P≈òESNƒö
                    .sessionManagement(sm ->
                            sm.sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
                    )
                    //  a TEPRVE PAK login filter
                    .addFilterAt(
                            new CustomJsonLoginFilter("/api/login", authManager),
                            UsernamePasswordAuthenticationFilter.class
                    )
                    .logout(logout -> logout
                            .logoutUrl("/logout")
                            .deleteCookies("JSESSIONID")
                            .logoutSuccessHandler((request, response, auth) -> {
                                response.setContentType("application/json");
                                response.setCharacterEncoding("UTF-8");
                                response.getWriter().write("{\"status\":\"ok\",\"message\":\"Odhl√°≈°eno\"}");
                            })
                    );
        }

        return http.build();
    }

    // CORS pro React dev server a cookies
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(List.of("http://localhost:5173"));
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\DebugController.java


package cz.phsoft.hokej.controllers;

import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class DebugController {

    @GetMapping("/api/debug/me")
    public Object me(Authentication auth) {
        return auth;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\MatchController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;
import cz.phsoft.hokej.models.dto.MatchOverviewDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.services.MatchService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;


@RestController
@RequestMapping("/api/matches")
@CrossOrigin(origins = "*")
public class MatchController {

    private final MatchService matchService;


    public MatchController(MatchService matchService) {
        this.matchService = matchService;

    }

    // Detail z√°pasu
    @GetMapping("/matchDetail/{id}")
    public MatchDetailDTO getMatchDetail(@PathVariable Long id) {
        return matchService.getMatchDetail(id);
    }

    // V≈°echny z√°pasy
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getAllMatches() {
        return matchService.getAllMatches();
    }

    // Nadch√°zej√≠c√≠ z√°pas
    @PreAuthorize("isAuthenticated()")
    @GetMapping("/next")
    public MatchDTO getNextMatch() {
        return matchService.getNextMatch();
    }

    // V≈°echny nadch√°zej√≠c√≠ z√°pasy
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #playerId)")
    @GetMapping("/upcoming")
    public List<MatchDTO> getUpcomingMatches() {
        return matchService.getUpcomingMatches();
    }

    // Nadch√°zej√≠c√≠ z√°pasy pro p≈ôihl√°≈°en√©ho hr√°ƒçe
    @GetMapping("/me/upcoming")
    @PreAuthorize("isAuthenticated()")
    public List<MatchDTO> getUpcomingMatchesForMe(Authentication authentication) {
        // z UserDetails z√≠sk√°me username
        String email = authentication.getName();
        // najdeme hr√°ƒçe podle emailu
        Long playerId = matchService.getPlayerIdByEmail(email);
        return matchService.getUpcomingMatchesForPlayer(playerId);
    }

    @GetMapping("/me/upcoming-overview")
    @PreAuthorize("isAuthenticated()")
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForMe(Authentication authentication) {
        String email = authentication.getName();
        Long playerId = matchService.getPlayerIdByEmail(email);
        return matchService.getUpcomingMatchesOverviewForPlayer(playerId);
    }

    // Nadch√°zej√≠c√≠ z√°pasy pro konkr√©tn√≠ho hr√°ƒçe
    @GetMapping("/player/{playerId}/upcoming")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #playerId)")
    public List<MatchDTO> getUpcomingMatchesForPlayer(@PathVariable Long playerId) {
        return matchService.getUpcomingMatchesForPlayer(playerId);
    }

    // U≈æ uskuteƒçnƒõn√© z√°pasy
    @GetMapping("/past")
    public List<MatchDTO> getPastMatches() {
        return matchService.getPastMatches();
    }

    // Vytvo≈ôen√≠ z√°pasu
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public MatchDTO createMatch(@Valid @RequestBody MatchDTO matchDTO) {
        return matchService.createMatch(matchDTO);
    }

    // Z√≠sk√°n√≠ z√°pasu podle ID
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO getMatch(@PathVariable Long id) {
        return matchService.getMatchById(id);
    }

    // Editace z√°pasu
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO updateMatch(@PathVariable Long id, @Valid @RequestBody MatchDTO dto) {
        return matchService.updateMatch(id, dto);
    }

    // Smaz√°n√≠ z√°pasu
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SuccessResponseDTO> deleteMatch(@PathVariable Long id) {
        SuccessResponseDTO response = matchService.deleteMatch(id);
        return ResponseEntity.ok(response);
    }

    // Dostupn√© z√°pasy pro hr√°ƒçe
    @GetMapping("/available-for-player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #playerId)")
    public List<MatchDTO> getAvailableMatchesForPlayer(@PathVariable Long playerId) {
        return matchService.getAvailableMatchesForPlayer(playerId);
    }

}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\MatchRegistrationController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import cz.phsoft.hokej.security.PlayerSecurity;
import org.springframework.web.bind.annotation.*;
import org.springframework.security.access.prepost.PreAuthorize;

import java.util.List;

@RestController
@RequestMapping("/api/registrations")
@CrossOrigin(origins = "*")
public class MatchRegistrationController {

    private final MatchRegistrationService service;
    private final PlayerSecurity playerSecurity;

    public MatchRegistrationController(MatchRegistrationService service,
                                       PlayerSecurity playerSecurity) {
        this.service = service;
        this.playerSecurity = playerSecurity;
    }

    // -----------------------------------------------------
    // üî• JEDIN√ù UNIVERZ√ÅLN√ç ENDPOINT PRO REGISTRACE
    // -----------------------------------------------------
    @PostMapping("/upsert")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #request.playerId)")
    public MatchRegistrationDTO upsert(@RequestBody MatchRegistrationRequest request) {
        return service.upsertRegistration(
                request.getMatchId(),
                request.getPlayerId(),
                request.getJerseyColor(),
                request.getAdminNote(),
                request.getExcuseReason(),
                request.getExcuseNote(),
                request.isUnregister()
        );
    }

    // -----------------------------------------------------
    // GET ENDPOINTY
    // -----------------------------------------------------

    @GetMapping("/all")
    public List<MatchRegistrationDTO> getAllRegistrations() {
        return service.getAllRegistrations();
    }

    @GetMapping("/for-player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #playerId)")
    public List<MatchRegistrationDTO> forPlayer(@PathVariable Long playerId) {
        return service.getRegistrationsForPlayer(playerId);
    }

    @GetMapping("/for-match/{matchId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> forMatch(@PathVariable Long matchId) {
        return service.getRegistrationsForMatch(matchId);
    }

    @GetMapping("/no-response/{matchId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getNoResponse(@PathVariable Long matchId) {
        return service.getNoResponsePlayers(matchId);
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.PlayerService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/players")
@CrossOrigin(origins = "*")
public class PlayerController {

    private final PlayerService playerService;

    public PlayerController(PlayerService playerService) {
        this.playerService = playerService;
    }

    // v≈°ichni hr√°ƒçi
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getAllPlayers() {
        return playerService.getAllPlayers();
    }

    // hr√°ƒç dle id

    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER') or @playerSecurity.isOwner(authentication, #id)")
    public PlayerDTO getPlayerById(@PathVariable Long id) {
        return playerService.getPlayerById(id);
    }

    // vytvo≈ôen√≠ hr√°ƒçe
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    @PostMapping
    public PlayerDTO createPlayer(@RequestBody PlayerDTO playerDTO) {
        return playerService.createPlayer(playerDTO);

    }

    // aktualizace hr√°ƒçe dle id hr√°ƒçe
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    @PutMapping("/{id}")
    public PlayerDTO updatePlayer(@PathVariable Long id, @RequestBody PlayerDTO dto) {
        return playerService.updatePlayer(id, dto);
    }

    // odstran√≠ hr√°ƒçe
    @PreAuthorize("hasRole('ADMIN')")
    @DeleteMapping("/{id}")
    public ResponseEntity<SuccessResponseDTO> deletePlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.deletePlayer(id);
        return ResponseEntity.ok(response);
    }


}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerInactivityPeriodController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import cz.phsoft.hokej.models.services.PlayerInactivityPeriodService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/inactivity")
@CrossOrigin(origins = "*")
public class PlayerInactivityPeriodController {

    private final PlayerInactivityPeriodService service;

    public PlayerInactivityPeriodController(PlayerInactivityPeriodService service) {
        this.service = service;
    }

    // v≈°echny z√°znamy o neaktivitƒõ hr√°ƒç≈Ø
    @GetMapping("/all")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getAll() {
        return service.getAll();
    }

    // neaktivita hr√°ƒç≈Ø dle id neaktivity
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<PlayerInactivityPeriodDTO> getById(@PathVariable Long id) {
        PlayerInactivityPeriodDTO dto = service.getById(id);
        return ResponseEntity.ok(dto);
    }

    // z√≠sk√° z√°znamy o periodƒõ neaktivity dle id hr√°ƒçe
    @GetMapping("/player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getByPlayer(@PathVariable Long playerId) {
        return service.getByPlayer(playerId);
    }

    // vytvo≈ô√≠ z√°znam o neaktivitƒõ hr√°ƒçe
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<PlayerInactivityPeriodDTO> create(@RequestBody PlayerInactivityPeriodDTO dto) {
        PlayerInactivityPeriodDTO created = service.create(dto);
        return ResponseEntity.ok(created);
    }

    // zmƒõn√≠ z√°znam o neaktivitƒõ hr√°ƒçe dle id
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<PlayerInactivityPeriodDTO> update(
            @PathVariable Long id,
            @RequestBody PlayerInactivityPeriodDTO dto) {

        PlayerInactivityPeriodDTO updated = service.update(id, dto);
        return ResponseEntity.ok(updated);
    }

    // vyma≈æe z√°znam o neaktivitƒõ hr√°ƒçe dle id z√°znamu
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        service.delete(id);
        return ResponseEntity.noContent().build();
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestController.java


package cz.phsoft.hokej.controllers;

import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/test")
@CrossOrigin(origins = "*")
public class TestController {

    @GetMapping
    public String hello() {
        return "Backend je online!";
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestSmsController.java


/*
package cz.phsoft.hokej.controllers;


import cz.phsoft.hokej.models.services.sms.SmsTextBeeService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TestSmsController {

    private final SmsTextBeeService smsTextBeeService;

    public TestSmsController(SmsTextBeeService smsTextBeeService) {
        this.smsTextBeeService = smsTextBeeService;
    }

    /**
     * Testovac√≠ endpoint pro odesl√°n√≠ SMS na testovac√≠ ƒç√≠slo.
     * Zavolej: GET /api/test-sms
     */
/*
    @GetMapping("/api/test-sms")
    public String sendTestSms() {
        smsTextBeeService.sendSms("+420776609956", "testovac√≠ sms app-sg");
        return "SMS byla odesl√°na na testovac√≠ ƒç√≠slo +420776609956";
    }
}

        */


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\AppUserEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.Role;
import jakarta.persistence.*;

import java.util.Set;

@Entity
@Table(name = "app_users")
public class AppUserEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role;

    // One-to-Many: jeden u≈æivatel ‚Üí v√≠ce hr√°ƒç≈Ø
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<PlayerEntity> players;

    // gettery/settery


    public Long getId() {return id;    }
    public void setId(Long id) {        this.id = id;    }

    public String getEmail() {        return email;    }
    public void setEmail(String email) {        this.email = email;    }

    public String getPassword() {        return password;    }
    public void setPassword(String password) {        this.password = password;    }

    public Role getRole() {        return role;    }
    public void setRole(Role role) {        this.role = role;    }

    public Set<PlayerEntity> getPlayers() {        return players;    }
    public void setPlayers(Set<PlayerEntity> players) {        this.players = players;    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchEntity.java


package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;
import java.time.LocalDateTime;

/**
 * t≈ô√≠da pro vkl√°d√°n√≠ Entity z√°pasu do db
 */
@Entity
@Table(name = "matches")
public class MatchEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private LocalDateTime dateTime;

    @Column(nullable = false)
    private String location;

    private String description;

    // maxim√°ln√≠ poƒçet hr√°ƒç≈Ø - vyu≈æ√≠v√° se pro ovƒõ≈ôen√≠ kapacity p≈ôi p≈ôihl√°≈°en√≠
    @Column(nullable = false)
    private Integer maxPlayers;

    @Column(nullable = false)
    private Integer price;

    public MatchEntity() {}

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }

    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() { return price; }

    public void setPrice(Integer price) { this.price = price; }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * t≈ô√≠da reprezentuje registracei hr√°ƒçe k z√°pasu
 */
@Entity
@Table(name = "match_registrations")
public class MatchRegistrationEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "match_id", nullable = false)
    private MatchEntity match;

    @ManyToOne
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerMatchStatus status;

    @Enumerated(EnumType.STRING)
    private ExcuseReason excuseReason;

    private String excuseNote;

    // admin m≈Ø≈æe vlo≈æit pozn√°mku, nap≈ô. kdy≈æ se nƒõkdo zaregistruje a pot√© nep≈ô√≠jde
    private String adminNote;

    @Enumerated(EnumType.STRING)
    @Column(name = "jersey_color")
    private Team jerseyColor;

    // datƒças vytvo≈ôen√≠ registrace - mus√≠ se mƒõnit aby nebyl hr√°ƒç i po zru≈°en√≠ registrace
    // v po≈ôad√≠ p≈ôed hr√°ƒçi kte≈ô√≠ se registrovali po zru≈°en√≠ registrace
    @Column(nullable = false, updatable = true)
    private LocalDateTime timestamp = LocalDateTime.now();

    // syst√©m automaticky vytv√°≈ô√≠ reserved/registered dle kapacity - maxPlayers
    @Column(nullable = false, updatable = true)
    private String createdBy; // "user" nebo "system"

    public MatchRegistrationEntity() {
    }

    // Gettery a Settery


    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public MatchEntity getMatch() {
        return match;
    }

    public void setMatch(MatchEntity match) {
        this.match = match;
    }

    public PlayerEntity getPlayer() {
        return player;
    }

    public void setPlayer(PlayerEntity player) {
        this.player = player;
    }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }

    public ExcuseReason getExcuseReason() {
        return excuseReason;
    }

    public void setExcuseReason(ExcuseReason excuseReason) {
        this.excuseReason = excuseReason;
    }

    public String getExcuseNote() {
        return excuseNote;
    }

    public void setExcuseNote(String excuseNote) {
        this.excuseNote = excuseNote;
    }

    public String getAdminNote() {
        return adminNote;
    }

    public void setAdminNote(String adminNote) {
        this.adminNote = adminNote;
    }

    public Team getJerseyColor() {
        return jerseyColor;
    }

    public void setJerseyColor(Team jerseyColor) {
        this.jerseyColor = jerseyColor;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }
}





# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationHistoryEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.persistence.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "match_registration_history")
public class MatchRegistrationHistoryEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // ID z p≈Øvodn√≠ hlavn√≠ tabulky
    @Column(name = "match_registration_id", nullable = false)
    private Long matchRegistrationId;

    @Column(name = "match_id", nullable = false)
    private Long matchId;

    @Column(name = "player_id", nullable = false)
    private Long playerId;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerMatchStatus status;

    @Enumerated(EnumType.STRING)
    @Column(name = "excuse_reason")
    private ExcuseReason excuseReason;

    @Column(name = "excuse_note")
    private String excuseNote;

    @Column(name = "admin_note")
    private String adminNote;

    @Enumerated(EnumType.STRING)
    @Column(name = "jersey_color")
    private Team jerseyColor;

    // p≈Øvodn√≠ timestamp
    @Column(name = "original_timestamp", nullable = false)
    private LocalDateTime originalTimestamp;

    @Column(name = "created_by", nullable = false)
    private String createdBy;

    @Column(nullable = false)
    private String action; // INSERT / UPDATE / DELETE

    @Column(name = "changed_at", nullable = false)
    private LocalDateTime changedAt;

    public MatchRegistrationHistoryEntity() {
    }

    // Gettery a settery


    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getMatchRegistrationId() {
        return matchRegistrationId;
    }

    public void setMatchRegistrationId(Long matchRegistrationId) {
        this.matchRegistrationId = matchRegistrationId;
    }

    public Long getMatchId() {
        return matchId;
    }

    public void setMatchId(Long matchId) {
        this.matchId = matchId;
    }

    public Long getPlayerId() {
        return playerId;
    }

    public void setPlayerId(Long playerId) {
        this.playerId = playerId;
    }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }

    public ExcuseReason getExcuseReason() {
        return excuseReason;
    }

    public void setExcuseReason(ExcuseReason excuseReason) {
        this.excuseReason = excuseReason;
    }

    public String getExcuseNote() {
        return excuseNote;
    }

    public void setExcuseNote(String excuseNote) {
        this.excuseNote = excuseNote;
    }

    public String getAdminNote() {
        return adminNote;
    }

    public void setAdminNote(String adminNote) {
        this.adminNote = adminNote;
    }

    public Team getJerseyColor() {
        return jerseyColor;
    }

    public void setJerseyColor(Team jerseyColor) {
        this.jerseyColor = jerseyColor;
    }

    public LocalDateTime getOriginalTimestamp() {
        return originalTimestamp;
    }

    public void setOriginalTimestamp(LocalDateTime originalTimestamp) {
        this.originalTimestamp = originalTimestamp;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }

    public String getAction() {
        return action;
    }

    public void setAction(String action) {
        this.action = action;
    }

    public LocalDateTime getChangedAt() {
        return changedAt;
    }

    public void setChangedAt(LocalDateTime changedAt) {
        this.changedAt = changedAt;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerType;
import jakarta.persistence.*;

@Entity
@Table(name = "player_entity")
public class PlayerEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String surname;

    private String nickName;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerType type; // VIP, STANDARD, BASIC

    private String fullName;
    private String phoneNumber;

    @Enumerated(EnumType.STRING)
    private Team team;

    // Many-to-One: ka≈æd√Ω hr√°ƒç pat≈ô√≠ jednomu u≈æivateli
    @ManyToOne
    @JoinColumn(name = "user_id")
    private AppUserEntity user;

    // ----------------- Konstruktor -----------------
    public PlayerEntity() {
        this.type = PlayerType.BASIC;
    }

    public PlayerEntity(String name, String surname, String nickName, PlayerType type, String phoneNumber, Team team) {
        this.name = name;
        this.surname = surname;
        this.nickName = nickName;
        this.type = type;
        this.fullName = name + " " + surname;
        this.phoneNumber = phoneNumber;
        this.team = team;
    }

    // ----------------- Gettery a Settery -----------------
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
        updateFullName();
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
        updateFullName();
    }

    public String getNickname() { return nickName;}
    public void setNickname(String nickName) { this.nickName = nickName; }

    public String getFullName() {
        return fullName;
    }

    public PlayerType getType() {
        return type;
    }
    public void setType(PlayerType type) {
        this.type = type;
    }

    private void updateFullName() {
        this.fullName = name + " " + surname;
    }

    public String getPhoneNumber() {
        return phoneNumber;
    }
    public void setPhoneNumber(String phoneNumber) {
        this.phoneNumber = phoneNumber;
    }

    public Team getTeam() {
        return team;
    }
    public void setTeam(Team team) {
        this.team = team;
    }

    public AppUserEntity getUser() {
        return user;
    }
    public void setUser(AppUserEntity user) {
        this.user = user;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerInactivityPeriodEntity.java


package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "player_inactivity_period")
public class PlayerInactivityPeriodEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    // neaktivn√≠ od
    @Column(name = "inactive_from", nullable = false)
    private LocalDateTime inactiveFrom;

    // neaktivn√≠ do
    @Column(name = "inactive_to", nullable = false)
    private LocalDateTime inactiveTo;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public PlayerEntity getPlayer() {
        return player;
    }

    public void setPlayer(PlayerEntity player) {
        this.player = player;
    }

    public LocalDateTime getInactiveFrom() {
        return inactiveFrom;
    }

    public void setInactiveFrom(LocalDateTime inactiveFrom) {
        this.inactiveFrom = inactiveFrom;
    }

    public LocalDateTime getInactiveTo() {
        return inactiveTo;
    }

    public void setInactiveTo(LocalDateTime inactiveTo) {
        this.inactiveTo = inactiveTo;
    }

}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\ExcuseReason.java


package cz.phsoft.hokej.data.enums;

public enum ExcuseReason {
    NEMOC,
    PRACE,
    NECHE_SE_MI,
    JINE
}



# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\PlayerMatchStatus.java


package cz.phsoft.hokej.data.enums;

public enum PlayerMatchStatus {
    REGISTERED,
    UNREGISTERED,
    EXCUSED,  // omluven
    RESERVED, // n√°hradn√≠k

}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\PlayerType.java


package cz.phsoft.hokej.data.enums;

public enum PlayerType {
    VIP,
    STANDARD,
    BASIC
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\Role.java


package cz.phsoft.hokej.data.enums;

public enum Role {
    ROLE_PLAYER,
    ROLE_MANAGER,
    ROLE_ADMIN
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\Team.java


package cz.phsoft.hokej.data.enums;

public enum Team {
    DARK,
    LIGHT

}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\AppUserRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface AppUserRepository extends JpaRepository<AppUserEntity, Long> {
    Optional<AppUserEntity> findByEmail(String email);
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRegistrationHistoryRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchRegistrationHistoryEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface MatchRegistrationHistoryRepository extends JpaRepository<MatchRegistrationHistoryEntity, Long> {

    // v≈°echny registrace na z√°pas
    List<MatchRegistrationHistoryEntity> findByMatchRegistrationIdOrderByChangedAtDesc(Long matchRegistrationId);

    // Historie pro konkr√©tn√≠ z√°pas
    List<MatchRegistrationHistoryEntity> findByMatchIdOrderByChangedAtDesc(Long matchId);

    // Historie zmƒõn hr√°ƒçe
    List<MatchRegistrationHistoryEntity> findByPlayerIdOrderByChangedAtDesc(Long playerId);

}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRegistrationRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

    @Repository
    public interface MatchRegistrationRepository extends JpaRepository<MatchRegistrationEntity, Long> {

        // Vr√°t√≠ posledn√≠ status pro dan√©ho hr√°ƒçe a z√°pas
        Boolean existsByPlayerIdAndMatchId(Long playerId, Long matchId);

        // Volitelnƒõ: v≈°echny registrace pro urƒçit√Ω z√°pas
        List<MatchRegistrationEntity> findByMatchId(Long matchId);

        // Volitelnƒõ: v≈°echny registrace pro urƒçit√©ho hr√°ƒçe
        List<MatchRegistrationEntity> findByPlayerId(Long playerId);

        // --- Nov√° metoda pro hled√°n√≠ konkr√©tn√≠ registrace ---
        Optional<MatchRegistrationEntity> findByPlayerIdAndMatchId(Long playerId, Long matchId);

        long countByMatchIdAndStatus(Long matchId, PlayerMatchStatus status);
    }


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import java.time.LocalDateTime;
import java.util.List;

public interface MatchRepository extends JpaRepository<MatchEntity, Long> {
    List<MatchEntity> findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime dateTime);
    List<MatchEntity> findByDateTimeBeforeOrderByDateTimeDesc(LocalDateTime dateTime);
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\PlayerInactivityPeriodRepository.java



package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface PlayerInactivityPeriodRepository extends JpaRepository<PlayerInactivityPeriodEntity, Long> {

    // zjist√≠, zda hr√°ƒç je aktu√°lnƒõ neaktivn√≠
    boolean existsByPlayerAndInactiveFromLessThanEqualAndInactiveToGreaterThanEqual(
            PlayerEntity player, LocalDateTime from, LocalDateTime to);

    // z√≠sk√° v≈°echny neaktivn√≠ obdob√≠ hr√°ƒçe, kter√© spadaj√≠ do intervalu
    List<PlayerInactivityPeriodEntity> findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
            PlayerEntity player, LocalDateTime from, LocalDateTime to);

    List<PlayerInactivityPeriodEntity> findByPlayerOrderByInactiveFromAsc(PlayerEntity player);
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\PlayerRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface PlayerRepository extends JpaRepository<PlayerEntity, Long> {
    Optional<PlayerEntity> findById(Long id);

    List<PlayerEntity> findByIdNotIn(List<Long> ids);
    boolean existsByNameAndSurname(String name, String surname);

    Optional<PlayerEntity> findByNameAndSurname(String name, String surname);
    Optional<PlayerEntity> findByUserEmail(String email);

}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\ApiError.java


package cz.phsoft.hokej.exceptions;

import com.fasterxml.jackson.annotation.JsonFormat;
import java.time.LocalDateTime;

public class ApiError {

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime timestamp;
    private int status;
    private String error;
    private String message;
    private String path;
    private String clientIp; // ‚Üê novƒõ

    public ApiError(int status, String error, String message, String path, String clientIp) {
        this.timestamp = LocalDateTime.now();
        this.status = status;
        this.error = error;
        this.message = message;
        this.path = path;
        this.clientIp = clientIp;
    }

    public LocalDateTime getTimestamp() { return timestamp; }
    public int getStatus() { return status; }
    public String getError() { return error; }
    public String getMessage() { return message; }
    public String getPath() { return path; }
    public String getClientIp() { return clientIp; }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\DuplicateRegistrationException.java


package cz.phsoft.hokej.exceptions;

public class DuplicateRegistrationException extends RuntimeException {
    public DuplicateRegistrationException(Long matchId, Long playerId) {
        super("Hr√°ƒç " + playerId + " ji≈æ m√° aktivn√≠ registraci na z√°pas " + matchId);
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\MatchNotFoundException.java


package cz.phsoft.hokej.exceptions;

public class MatchNotFoundException extends RuntimeException {
    public MatchNotFoundException(Long matchId) {
        super("Z√°pas s ID " + matchId + " nenalezen.");;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\PlayerNotFoundException.java


package cz.phsoft.hokej.exceptions;

public class PlayerNotFoundException extends RuntimeException {
    public PlayerNotFoundException(Long playerId) {
        super("Hr√°ƒç s ID " + playerId + " nenalezen.");}
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\RegistrationNotFoundException.java


package cz.phsoft.hokej.exceptions;

public class RegistrationNotFoundException extends RuntimeException {
    public RegistrationNotFoundException(Long matchId, Long playerId) {
        super("Hr√°ƒç " + playerId + " nem√° registraci na z√°pas " + matchId);
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\AppUserMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.PlayerSummaryDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

import java.util.List;

@Mapper(componentModel = "spring")
public interface AppUserMapper {
    @Mapping(target = "players", source = "players")
    AppUserDTO toDto(AppUserEntity entity);

    List<AppUserDTO> toDtoList(List<AppUserEntity> entities);

    PlayerSummaryDTO toPlayerSummary(PlayerEntity entity);
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\MatchMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;

@Mapper(componentModel = "spring")
public interface MatchMapper {

    MatchDTO toDTO(MatchEntity entity);

    MatchEntity toEntity(MatchDTO dto);

    void updateEntity(MatchDTO dto, @MappingTarget MatchEntity entity);
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\MatchRegistrationMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

import java.util.List;

@Mapper(componentModel = "spring")
public interface MatchRegistrationMapper {

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "match", source = "match")
    @Mapping(target = "player", source = "player")
    @Mapping(target = "status", source = "status")
    @Mapping(target = "excuseReason", source = "excuseReason")
    @Mapping(target = "excuseNote", source = "note")
    @Mapping(target = "jerseyColor", source = "jerseyColor")
    @Mapping(target = "adminNote", source = "adminNote")
    @Mapping(target = "createdBy", source = "createdBy")
    @Mapping(target = "timestamp", expression = "java(java.time.LocalDateTime.now())")
    MatchRegistrationEntity toEntity(
            MatchEntity match,
            PlayerEntity player,
            PlayerMatchStatus status,
            ExcuseReason excuseReason,
            String note,
            Team jerseyColor,
            String adminNote,
            String createdBy
    );

    // entity ‚Üí DTO (voliteln√©)
    @Mapping(target = "matchId", source = "match.id")
    @Mapping(target = "playerId", source = "player.id")
    MatchRegistrationDTO toDTO(MatchRegistrationEntity entity);

    List<MatchRegistrationDTO> toDTOList(List<MatchRegistrationEntity> entities);
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\PlayerInactivityPeriodMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import org.mapstruct.*;

@Mapper(componentModel = "spring")
public interface PlayerInactivityPeriodMapper {

    // Entity -> DTO (OK)
    @Mapping(target = "playerId", source = "player.id")
    PlayerInactivityPeriodDTO toDTO(PlayerInactivityPeriodEntity entity);

    // DTO -> Entity (player ≈ôe≈°√≠ @ObjectFactory)
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "player", ignore = true)
    PlayerInactivityPeriodEntity toEntity(PlayerInactivityPeriodDTO dto, @Context PlayerEntity player);

    // UPDATE DTO -> existuj√≠c√≠ entity (bez zmƒõny player)
    @Mapping(target = "player", ignore = true)
    void updateEntityFromDto(PlayerInactivityPeriodDTO dto, @MappingTarget PlayerInactivityPeriodEntity entity);

    // FACTORY ‚Äì jedin√Ω spr√°vn√Ω zp≈Øsob, jak nastavit player z @Context
    @ObjectFactory
    default PlayerInactivityPeriodEntity createEntity(PlayerInactivityPeriodDTO dto, @Context PlayerEntity player) {
        PlayerInactivityPeriodEntity entity = new PlayerInactivityPeriodEntity();
        entity.setPlayer(player);
        return entity;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\PlayerMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

import java.util.List;

@Mapper(componentModel = "spring")
public interface PlayerMapper {

        // Entity ‚Üí DTO (heslo se nepos√≠l√°)
        @Mapping(target = "fullName", ignore = true) // generuje se v DTO
        PlayerDTO toDTO(PlayerEntity entity);

        // DTO ‚Üí Entity (heslo se mapuje, pokud existuje)
        PlayerEntity toEntity(PlayerDTO dto);

        // Aktualizace existuj√≠c√≠ho DTO (ignorujeme fullName)
        @Mapping(target = "fullName", ignore = true)
        void updatePlayerDTO(PlayerDTO source, @MappingTarget PlayerDTO target);

        // Aktualizace existuj√≠c√≠ Entity (heslo se mapuje, fullName nen√≠ pole v Entity)
        void updatePlayerEntity(PlayerDTO source, @MappingTarget PlayerEntity target);

    List<PlayerDTO> toDTOList(List<PlayerEntity> players);


}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\requests\MatchRegistrationRequest.java


package cz.phsoft.hokej.models.dto.requests;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.validation.constraints.*;


public class MatchRegistrationRequest {
    @NotNull
    @Positive
    private Long matchId;

    @NotNull
    @Positive
    private Long playerId;

    private Team jerseyColor;
    private ExcuseReason excuseReason;
    private String excuseNote;
    private String adminNote;
    private boolean unregister;

    public Long getMatchId() { return matchId; }
    public Long getPlayerId() { return playerId; }
    public Team getJerseyColor() { return jerseyColor; }
    public ExcuseReason getExcuseReason() { return excuseReason; }
    public String getExcuseNote() { return excuseNote; }
    public String getAdminNote() { return adminNote; }
    public boolean isUnregister() { return unregister; }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\AppUserDTO.java


package cz.phsoft.hokej.models.dto;

import java.util.Set;

public class AppUserDTO {
    private Long id;
    private String email;
    private String role;
    private Set<PlayerSummaryDTO> players; // jednostrann√©

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getRole() {
        return role;
    }

    public void setRole(String role) {
        this.role = role;
    }

    public Set<PlayerSummaryDTO> getPlayers() {
        return players;
    }

    public void setPlayers(Set<PlayerSummaryDTO> players) {
        this.players = players;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchDetailDTO.java


package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;

import java.time.LocalDateTime;
import java.util.List;

public class MatchDetailDTO {
    private Long id;
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime dateTime;
    private int maxPlayers;
    private int inGamePlayers;
    private int outGamePlayers;
    private int waitingPlayers;
    private int noActionPlayers;
    private double pricePerRegisteredPlayer;
    private int remainingSlots;

    List<PlayerDTO> registeredPlayers;
    List<PlayerDTO> reservedPlayers;
    List<PlayerDTO> unregisteredPlayers;
    List<PlayerDTO> excusedPlayers;
    List<PlayerDTO> noResponsePlayers;

    // Gettery a settery

    public Long getId() {       return id;    }
    public void setId(Long id) {
        this.id = id;
    }
    public LocalDateTime getDateTime() {
        return dateTime;
    }

    public void setDateTime(LocalDateTime dateTime) {
        this.dateTime = dateTime;
    }

    public int getMaxPlayers() {
        return maxPlayers;
    }
    public void setMaxPlayers(int maxPlayers) {
        this.maxPlayers = maxPlayers;
    }

    public int getInGamePlayers() {
        return inGamePlayers;
    }
    public void setInGamePlayers(int inGamePlayers) {
        this.inGamePlayers = inGamePlayers;
    }

    public void setOutGamePlayers(int outGamePlayers) {
        this.outGamePlayers = outGamePlayers;
    }

    public int getWaitingPlayers() {
        return waitingPlayers;
    }
    public void setWaitingPlayers(int waitingPlayers) {
        this.waitingPlayers = waitingPlayers;
    }

    public int getNoActionPlayers() {
        return noActionPlayers;
    }
    public void setNoActionPlayers(int noActionPlayers) {
        this.noActionPlayers = noActionPlayers;
    }

    public double getPricePerRegisteredPlayer() {
        return pricePerRegisteredPlayer;
    }
    public void setPricePerRegisteredPlayer(double pricePerRegisteredPlayer) {
        this.pricePerRegisteredPlayer = pricePerRegisteredPlayer;
    }

    public int getRemainingSlots() {
        return remainingSlots;
    }
    public void setRemainingSlots(int remainingSlots) {
        this.remainingSlots = remainingSlots;
    }

    public List<PlayerDTO> getRegisteredPlayers() {
        return registeredPlayers;
    }
    public void setRegisteredPlayers(List<PlayerDTO> registeredPlayers) {
        this.registeredPlayers = registeredPlayers;
    }

    public List<PlayerDTO> getReservedPlayers() {
        return reservedPlayers;
    }
    public void setReservedPlayers(List<PlayerDTO> reservedPlayers) {
        this.reservedPlayers = reservedPlayers;
    }

    public List<PlayerDTO> getUnregisteredPlayers() {
        return unregisteredPlayers;
    }

    public void setUnregisteredPlayers(List<PlayerDTO> unregisteredPlayers) {
        this.unregisteredPlayers = unregisteredPlayers;
    }
    public List<PlayerDTO> getExcusedPlayers() {
        return excusedPlayers;
    }
    public void setExcusedPlayers(List<PlayerDTO> excusedPlayers) {
        this.excusedPlayers = excusedPlayers;
    }

    public List<PlayerDTO> getNoResponsePlayers() {
        return noResponsePlayers;
    }
    public void setNoResponsePlayers(List<PlayerDTO> noResponsePlayers) {
        this.noResponsePlayers = noResponsePlayers;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchDTO.java


package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import jakarta.validation.constraints.FutureOrPresent;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

import java.time.LocalDateTime;

public class MatchDTO {

    private Long id;
    @NotNull(message = "Datum a ƒças z√°pasu je povinn√©.")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime dateTime;

    @NotBlank(message = "M√≠sto z√°pasu je povinn√©.")
    @Size(min = 3, max = 100)
    private String location;

    @Size(max = 255, message = "Popis m≈Ø≈æe m√≠t max 255 znak≈Ø.")
    private String description;

    @NotNull(message = "Maxim√°ln√≠ poƒçet hr√°ƒç≈Ø je povinn√Ω")
    private Integer maxPlayers;

    @NotNull(message = "Cena je povinn√°")
    private Integer price;

    // gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }
    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() {
        return price;
    }

    public void setPrice(Integer price) {
        this.price = price;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchOverviewDTO.java


package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import java.time.LocalDateTime;

public class MatchOverviewDTO {

    private Long id;

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime dateTime;

    private String location;
    private String description;
    private Integer price;
    private int maxPlayers;
    private int inGamePlayers;
    private double pricePerRegisteredPlayer;

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getPrice() { return price; }
    public void setPrice(Integer price) { this.price = price; }

    public int getMaxPlayers() { return maxPlayers; }
    public void setMaxPlayers(int maxPlayers) { this.maxPlayers = maxPlayers; }

    public int getInGamePlayers() { return inGamePlayers; }
    public void setInGamePlayers(int inGamePlayers) { this.inGamePlayers = inGamePlayers; }

    public double getPricePerRegisteredPlayer() { return pricePerRegisteredPlayer; }
    public void setPricePerRegisteredPlayer(double pricePerRegisteredPlayer) { this.pricePerRegisteredPlayer = pricePerRegisteredPlayer; }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchRegistrationDTO.java


package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;

public class MatchRegistrationDTO {
    private Long id; // voliteln√©, p≈ôi GET

    @NotNull(message = "ID z√°pasu je povinn√©.")
    @Positive(message = "ID z√°pasu mus√≠ b√Ωt kladn√©.")
    private Long matchId;

    @NotNull(message = "ID hr√°ƒçe je povinn√©.")
    @Positive(message = "ID hr√°ƒçe mus√≠ b√Ωt kladn√©.")
    private Long playerId;

    private PlayerMatchStatus status;
    private ExcuseReason excuseReason; // pouze pokud status = EXCUSED
    private String excuseNote;
    private String adminNote;
    private Team jerseyColor;

    @NotNull
    private String createdBy; // "user" nebo "system"

    private PlayerDTO playerDTO;

    public MatchRegistrationDTO() {}

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public Long getMatchId() { return matchId; }
    public void setMatchId(Long matchId) { this.matchId = matchId; }

    public Long getPlayerId() { return playerId; }
    public void setPlayerId(Long playerId) { this.playerId = playerId; }

    public PlayerMatchStatus getStatus() { return status; }
    public void setStatus(PlayerMatchStatus status) { this.status = status; }

    public ExcuseReason getExcuseReason() { return excuseReason; }
    public void setExcuseReason(ExcuseReason excuseReason) { this.excuseReason = excuseReason; }

    public String getExcuseNote() { return excuseNote; }
    public void setExcuseNote(String excuseNote) { this.excuseNote = excuseNote; }

    public String getAdminNote() { return adminNote; }
    public void setAdminNote(String adminNote) { this.adminNote = adminNote; }

    public Team getJerseyColor() { return jerseyColor; }
    public void setJerseyColor(Team jerseyColor) { this.jerseyColor = jerseyColor; }

    public String getCreatedBy() { return createdBy; }
    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }
}



# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerDTO.java


package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerType;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class PlayerDTO {


    private Long id; // autogenerated, nullable p≈ôi create

    @NotBlank(message = "K≈ôestn√≠ jm√©no je povinn√©.")
    @Size(min = 2, max = 50)
    private String name; // not null

    @NotBlank(message = "P≈ô√≠jmen√≠ je povinn√©.")
    @Size(min = 2, max = 50)
    private String surname; // not null
    private String nickName;
    private String fullName; // derived
    private String phoneNumber;
    private PlayerType type; // not null, default BASIC
    private Team team;


    public PlayerDTO() {
        this.type = PlayerType.BASIC;
   }

    public PlayerDTO(Long id, String name, String surname, String nickName, PlayerType type, Team team) {
        this.id = id;
        this.name = name;
        this.surname = surname;
        this.nickName = nickName;
        this.type = type != null ? type : PlayerType.BASIC;
        this.updateFullName();
        this.team = team;
    }

    // --- Gettery a Settery ---

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; updateFullName(); }

    public String getSurname() { return surname; }
    public void setSurname(String surname) { this.surname = surname; updateFullName(); }

    public String getNickName() { return nickName; }

    public void setNickName(String nickName) { this.nickName = nickName; }

    public String getFullName() { return fullName; }

    public PlayerType getType() { return type; }
    public void setType(PlayerType type) { this.type = type != null ? type : PlayerType.BASIC; }

    private void updateFullName() { this.fullName = name + " " + surname; }

    public Team getTeam() { return team; }
    public void setTeam(Team team) { this.team = team; }

    public String getPhoneNumber() { return phoneNumber; }
    public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerInactivityPeriodDTO.java


package cz.phsoft.hokej.models.dto;

import java.time.LocalDateTime;

public class PlayerInactivityPeriodDTO {

    private Long id;
    private Long playerId;
    private LocalDateTime inactiveFrom;
    private LocalDateTime inactiveTo;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getPlayerId() {
        return playerId;
    }

    public void setPlayerId(Long playerId) {
        this.playerId = playerId;
    }

    public LocalDateTime getInactiveFrom() {
        return inactiveFrom;
    }

    public void setInactiveFrom(LocalDateTime inactiveFrom) {
        this.inactiveFrom = inactiveFrom;
    }

    public LocalDateTime getInactiveTo() {
        return inactiveTo;
    }

    public void setInactiveTo(LocalDateTime inactiveTo) {
        this.inactiveTo = inactiveTo;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerSummaryDTO.java


package cz.phsoft.hokej.models.dto;

public class PlayerSummaryDTO {
    private Long id;
    private String name;
    private String jerseyColor;
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\SuccessResponseDTO.java


package cz.phsoft.hokej.models.dto;

public class SuccessResponseDTO {
    private  String message;
    private Long id;
    private String timestamp;

    public SuccessResponseDTO(String message, Long id, String timestamp) {
        this.message = message;
        this.id = id;
        this.timestamp = timestamp;
    }

    public String getMessage() { return message; }
    public Long getId() { return id; }
    public String getTimestamp() { return timestamp; }

}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsMessageBuilder.java


package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import org.springframework.stereotype.Component;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;

import java.time.format.DateTimeFormatter;

@Component
public class SmsMessageBuilder {

    private final MatchRegistrationRepository matchRegistrationRepository;
    private final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");

    public SmsMessageBuilder(MatchRegistrationRepository matchRegistrationRepository) {
        this.matchRegistrationRepository = matchRegistrationRepository;
    }

    // --------------------------
    // zpr√°va po registraci/odhl√°≈°en√≠/omluven√≠
    // --------------------------
    public String buildMessageRegistration(MatchRegistrationEntity registration) {
        PlayerMatchStatus status = registration.getStatus();
        String statusText = switch (status) {
            case REGISTERED -> "p≈ôihl√°sil se k z√°pasu";
            case UNREGISTERED -> "odhl√°sil se ze z√°pasu";
            case EXCUSED -> "omluven";
            default -> "nezn√°m√Ω stav";
        };

        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(registration.getMatch().getId(), PlayerMatchStatus.REGISTERED);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - datum: ")
                .append(registration.getMatch().getDateTime().toLocalDate());

        if (status != PlayerMatchStatus.EXCUSED) {
            sb.append(", ").append(registeredCount)
                    .append("/").append(registration.getMatch().getMaxPlayers());
        }

        sb.append(", hr√°ƒç: ").append(registration.getPlayer().getFullName())
                .append(", status: ").append(statusText);

        return sb.toString();
    }

    // --------------------------
    // zpr√°va pro hr√°ƒçe, kte≈ô√≠ je≈°tƒõ nereagovali
    // --------------------------
    public String buildMessageNoResponse(PlayerDTO player, MatchEntity match) {
        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - upozornƒõn√≠: z√°pas ")
                .append(match.getDateTime().format(dateFormatter))
                .append(" - voln√° m√≠sta: ")
                .append(match.getMaxPlayers() - registeredCount)
                .append(". Je≈°tƒõ jste nereagoval.");

        return sb.toString();
    }

    // --------------------------
    // fin√°ln√≠ p≈ôipom√≠nka pro p≈ôihl√°≈°en√© hr√°ƒçe v den z√°pasu
    // --------------------------
    public String buildMessageFinal(MatchRegistrationEntity registration) {
        MatchEntity match = registration.getMatch();
        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);

        double pricePerPlayer = match.getPrice() / Math.max(registeredCount, 1);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - p≈ôipom√≠nka z√°pasu ")
                .append(match.getDateTime().format(dateFormatter))
                .append(", p≈ôihl√°≈°eno: ").append(registeredCount).append("/").append(match.getMaxPlayers())
                .append(", cena na hr√°ƒçe: ").append(String.format("%.2f Kƒç", pricePerPlayer));

        return sb.toString();
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsSchedulerService.java


package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import jakarta.transaction.Transactional;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.List;

@Service
public class SmsSchedulerService {

    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository registrationRepository;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;
    private final MatchRegistrationService matchRegistrationService;

    public SmsSchedulerService(
            MatchRepository matchRepository,
            MatchRegistrationRepository registrationRepository,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder,
            MatchRegistrationService matchRegistrationService) {

        this.matchRepository = matchRepository;
        this.registrationRepository = registrationRepository;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
        this.matchRegistrationService = matchRegistrationService;
    }

    // Posl√°n√≠ SMS v den z√°pasu
    // Spust√≠ se ka≈æd√Ω den v 12:30
    @Scheduled(cron = "0 30 12 * * *")
    @Transactional
    public void sendFinalSmsForTodayMatches() {

        LocalDate today = LocalDate.now();

        // najdeme v≈°echny dne≈°n√≠ z√°pasy
        List<MatchEntity> todaysMatches = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().toLocalDate().isEqual(today))
                .toList();

        for (MatchEntity match : todaysMatches) {

            // naƒçteme v≈°echny registrace k dan√©mu z√°pasu (BEZ zmƒõn entit)
            List<MatchRegistrationEntity> registrations =
                    registrationRepository.findByMatchId(match.getId());

            for (MatchRegistrationEntity reg : registrations) {

                // pou≈æije≈° sv≈Øj p≈Øvodn√≠ builder
                String smsMsg = smsMessageBuilder.buildMessageFinal(reg);

                try {
                    smsService.sendSms(reg.getPlayer().getPhoneNumber(), smsMsg);
                    System.out.println("Fin√°ln√≠ SMS posl√°na hr√°ƒçi "
                            + reg.getPlayer().getFullName() + ": " + smsMsg);

                } catch (Exception e) {
                    System.err.println("Chyba SMS pro hr√°ƒçe "
                            + reg.getPlayer().getFullName() + ": " + e.getMessage());
                }
            }
        }
    }

    // posl√°n√≠ SMS 3 dny p≈ôed z√°pasem - noresponse player
    @Scheduled(cron = "0 40 14 * * *") // ka≈æd√Ω den ve 12:30
    @Transactional
    public void sendNoResponseSmsForMatchesIn3Days() {

        LocalDate targetDate = LocalDate.now().plusDays(3);

        // v≈°echny z√°pasy, kter√© jsou za 3 dny
        List<MatchEntity> matchesInThreeDays = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().toLocalDate().isEqual(targetDate))
                .toList();

        for (MatchEntity match : matchesInThreeDays) {

            // pou≈æijeme tv≈Øj existuj√≠c√≠ helper
            List<PlayerDTO> noResponsePlayers =
                    matchRegistrationService.getNoResponsePlayers(match.getId());

            for (PlayerDTO player : noResponsePlayers) {

                String smsMsg = smsMessageBuilder.buildMessageNoResponse(player, match);

                try {
                    smsService.sendSms(player.getPhoneNumber(), smsMsg);
                    System.out.println("NORESPONSE SMS posl√°na hr√°ƒçi "
                            + player.getFullName() + ": " + smsMsg);
                } catch (Exception e) {
                    System.err.println("Chyba NORESPONSE SMS pro hr√°ƒçe "
                            + player.getFullName() + ": " + e.getMessage());
                }
            }
        }
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsService.java


package cz.phsoft.hokej.models.services.sms;

public interface SmsService {
    void sendSms(String phoneNumber, String message);
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsServiceImpl.java


/* package cz.phsoft.hokej.models.services.sms;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;

@Service
public class SmsServiceImpl {

   // private final RestTemplate restTemplate = new RestTemplate();

    @Value("${textbee.api-url}")
    private String apiUrl;

    @Value("${textbee.api-key}")
    private String apiKey;

    // testovac√≠ ƒç√≠slo
    //private final String testNumber = "+420776609956";

    /**
     * Ode≈°le SMS na testovac√≠ ƒç√≠slo.
     * @param message text zpr√°vy
     */

/*
    public void sendSms(String phoneNumber, String message) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("x-api-key", apiKey);

        Map<String, Object> body = Map.of(
                "recipients", List.of(phoneNumber),
                "message", message
        );

        HttpEntity<Map<String,Object>> request = new HttpEntity<>(body, headers);

        try {
            ResponseEntity<String> response = restTemplate.postForEntity(apiUrl, request, String.class);
            System.out.println("SMS posl√°na na testovac√≠ ƒç√≠slo  xxx   : " + response.getBody());
        } catch (Exception e) {
            System.err.println("Chyba p≈ôi odes√≠l√°n√≠ SMS: " + e.getMessage());
        }
    }

*/


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsTextBeeService.java


package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.models.services.sms.SmsService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;

// textbee - free s omezen√≠m na 50 sms / den
@Service
public class SmsTextBeeService implements SmsService {

    @Value("${sms.enabled:true}")
    private boolean smsEnabled;

    @Value("${textbee.api-url}")
    private String apiUrl;

    @Value("${textbee.api-key}")
    private String apiKey;

    private final RestTemplate restTemplate = new RestTemplate();

    @Override
    public void sendSms(String phoneNumber, String message) {
        if (!smsEnabled) {
            System.out.println("SMS disabled, message not sent: " + message);
            return;
        }

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("x-api-key", apiKey);

        Map<String, Object> body = Map.of(
                "recipients", List.of(phoneNumber),
                "message", message
        );

        HttpEntity<Map<String,Object>> request = new HttpEntity<>(body, headers);

        try {
            ResponseEntity<String> response = restTemplate.postForEntity(apiUrl, request, String.class);
            System.out.println("SMS odesl√°na hr√°ƒçi: " + phoneNumber + ", response: " + response.getBody());
        } catch (Exception e) {
            System.err.println("Chyba p≈ôi odes√≠l√°n√≠ SMS: " + e.getMessage());
        }
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;

import java.util.List;

public interface MatchRegistrationService {

    // üî• Vrac√≠ DTO m√≠sto entity
    MatchRegistrationDTO upsertRegistration(
            Long matchId,
            Long playerId,
            Team jerseyColor,
            String adminNote,
            ExcuseReason excuseReason,
            String excuseNote,
            boolean unregister
    );

    List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId);

    List<MatchRegistrationDTO> getAllRegistrations();

    List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId);

    List<PlayerDTO> getNoResponsePlayers(Long matchId);

    void recalcStatusesForMatch(Long matchId);
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.DuplicateRegistrationException;
import cz.phsoft.hokej.exceptions.MatchNotFoundException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.exceptions.RegistrationNotFoundException;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.mappers.MatchRegistrationMapper;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.sms.SmsMessageBuilder;
import cz.phsoft.hokej.models.services.sms.SmsService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
public class MatchRegistrationServiceImpl implements MatchRegistrationService {

    Logger logger = LoggerFactory.getLogger(MatchServiceImpl.class);
    private final MatchRegistrationRepository registrationRepository;
    private final MatchRepository matchRepository;
    private final PlayerRepository playerRepository;
    private final MatchRegistrationMapper matchRegistrationMapper;
    private final PlayerMapper playerMapper;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;

    public MatchRegistrationServiceImpl(
            MatchRegistrationRepository registrationRepository,
            MatchRepository matchRepository,
            PlayerRepository playerRepository,
            MatchRegistrationMapper matchRegistrationMapper,
            PlayerMapper playerMapper,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder) {
        this.registrationRepository = registrationRepository;
        this.matchRepository = matchRepository;
        this.playerRepository = playerRepository;
        this.matchRegistrationMapper = matchRegistrationMapper;
        this.playerMapper = playerMapper;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
    }
    private MatchEntity getMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }
    private PlayerEntity getPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }
    private boolean isSlotAvailable(MatchEntity match) {
        long registeredCount = registrationRepository.countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);
        return registeredCount < match.getMaxPlayers();
    }
    private void sendSms(MatchRegistrationEntity registration, String message) {
        if (registration == null || registration.getPlayer() == null) return;
        try {
            smsService.sendSms(registration.getPlayer().getPhoneNumber(), message);
        } catch (Exception e) {
            System.err.println("Chyba SMS: " + e.getMessage());
        }
    }
    private MatchRegistrationEntity updateRegistrationStatus(
            MatchRegistrationEntity registration, PlayerMatchStatus status, String updatedBy, boolean updateTimestamp) {

        registration.setStatus(PlayerMatchStatus.valueOf(status.name()));
        registration.setCreatedBy(updatedBy);
        if (updateTimestamp) {
            registration.setTimestamp(LocalDateTime.now());
        }
        return registrationRepository.saveAndFlush(registration);
    }
    // -------------------- REGISTRATION --------------------
    @Transactional
    @Override
    public MatchRegistrationDTO upsertRegistration(
            Long matchId,
            Long playerId,
            Team jerseyColor,
            String adminNote,
            ExcuseReason excuseReason,
            String excuseNote,
            boolean unregister) {

        // TEST: po≈°li ERROR zpr√°vu pro otestov√°n√≠ emailu
        logger.error("Test ERROR zpr√°va pro email");

        MatchEntity match = getMatchOrThrow(matchId);
        PlayerEntity player = getPlayerOrThrow(playerId);

        MatchRegistrationEntity registration = registrationRepository
                .findByPlayerIdAndMatchId(playerId, matchId)
                .orElse(null);

        PlayerMatchStatus newStatus;

        // UNREGISTER: lze pouze kdy≈æ hr√°ƒç m√° aktu√°lnƒõ REGISTERED
        if (unregister) {
            if (registration == null || registration.getStatus() != PlayerMatchStatus.REGISTERED) {
                throw new RegistrationNotFoundException(matchId, playerId);
            }
            registration.setExcuseReason(null);
            newStatus = PlayerMatchStatus.UNREGISTERED;

            // EXCUSE: lze vytvo≈ôit pouze pokud hr√°ƒç NEM√Å status REGISTERED
        } else if (excuseReason != null) {
            if (registration != null && registration.getStatus() == PlayerMatchStatus.REGISTERED) {
                throw new DuplicateRegistrationException(matchId, playerId);
            }
            // pokud neexistuje, vytvo≈ô√≠me pozici; pokud existuje a nen√≠ REGISTERED, povol√≠me EXCUSED
            if (registration == null) {
                registration = new MatchRegistrationEntity();
                registration.setMatch(match);
                registration.setPlayer(player);
            }
            registration.setExcuseReason(excuseReason);
            newStatus = PlayerMatchStatus.EXCUSED;

            // REGISTER / RESERVE: lze vytvo≈ôit pokud hr√°ƒç NEM√Å status REGISTERED (tedy i kdy≈æ m√° EXCUSED)
        } else {
            // pokud u≈æ je registrov√°n, nepovol√≠me duplicitu
            if (registration != null && registration.getStatus() == PlayerMatchStatus.REGISTERED) {
                throw new DuplicateRegistrationException(matchId, playerId);
            }

            newStatus = isSlotAvailable(match) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;

            if (registration == null) {
                registration = new MatchRegistrationEntity();
                registration.setMatch(match);
                registration.setPlayer(player);
            } else {
                // p≈ôi p≈ôechodu na register/reserve zru≈°√≠me p≈ô√≠padnou v√Ωmluvu
                registration.setExcuseReason(null);
            }
        }

        registration.setStatus(newStatus);
        registration.setTimestamp(LocalDateTime.now());
        registration.setCreatedBy("user");

        if (jerseyColor != null) registration.setJerseyColor(jerseyColor);
        if (adminNote != null) registration.setAdminNote(adminNote);
        // excuseReason u≈æ jsme nastavili v√Ω≈°e (pokud to byl EXCUSED p≈ô√≠pad)
        if (excuseReason != null) registration.setExcuseReason(excuseReason);

        registration = registrationRepository.save(registration);

        if (unregister) recalcStatusesForMatch(matchId);

        sendSms(registration, smsMessageBuilder.buildMessageRegistration(registration));

        return matchRegistrationMapper.toDTO(registration);
    }
    // -------------------- FETCH --------------------
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId) {
        return matchRegistrationMapper.toDTOList(registrationRepository.findByMatchId(matchId));
    }

    @Override
    public List<MatchRegistrationDTO> getAllRegistrations() {
        return matchRegistrationMapper.toDTOList(registrationRepository.findAll());
    }

    @Override
    public List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId) {
        return matchRegistrationMapper.toDTOList(registrationRepository.findByPlayerId(playerId));
    }

    @Override
    public List<PlayerDTO> getNoResponsePlayers(Long matchId) {
        List<Long> responded = registrationRepository.findByMatchId(matchId).stream()
                .map(r -> r.getPlayer().getId())
                .toList();

        List<PlayerEntity> noResponsePlayers = playerRepository.findAll().stream()
                .filter(p -> !responded.contains(p.getId()))
                .toList();

        return noResponsePlayers.stream()
                .map(playerMapper::toDTO)
                .toList();
    }
    // -------------------- RECALC --------------------
    @Override
    @Transactional
    public void recalcStatusesForMatch(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);
        int maxPlayers = match.getMaxPlayers();

        List<MatchRegistrationEntity> regs = registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED
                        || r.getStatus() == PlayerMatchStatus.RESERVED)
                .sorted((a, b) -> a.getTimestamp().compareTo(b.getTimestamp()))
                .toList();

        for (int i = 0; i < regs.size(); i++) {
            MatchRegistrationEntity reg = regs.get(i);
            PlayerMatchStatus newStatus = (i < maxPlayers) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;
            if (reg.getStatus() != newStatus) updateRegistrationStatus(reg, newStatus, "system", false);
        }
    }

    // -------------------- SMS --------------------
    @Transactional
    public void sendSmsToRegisteredPlayers(Long matchId) {
        registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .forEach(r -> sendSms(r, smsMessageBuilder.buildMessageFinal(r)));
    }

    public void sendNoResponseSmsForMatch(Long matchId) {
        var match = getMatchOrThrow(matchId);

        getNoResponsePlayers(matchId).forEach(player -> {
            String smsMsg = smsMessageBuilder.buildMessageNoResponse(player, match);

            try {
                smsService.sendSms(player.getPhoneNumber(), smsMsg);
            } catch (Exception e) {
                System.err.println("Chyba SMS pro hr√°ƒçe "
                        + player.getFullName() + ": " + e.getMessage());
                logger.error("Chyba p≈ôi odesl√°n√≠ SMS hr√°ƒçi {}: {}", player.getFullName(), e.getMessage());
            }
        });
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;
import cz.phsoft.hokej.models.dto.MatchOverviewDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;

import java.util.List;

public interface MatchService {
    List<MatchDTO> getAllMatches();
    List<MatchDTO> getUpcomingMatches();
    List<MatchDTO> getPastMatches();
    MatchDTO getNextMatch();
    MatchDTO getMatchById(Long id);
    MatchDTO createMatch(MatchDTO dto);
    MatchDTO updateMatch(Long id, MatchDTO dto);
    SuccessResponseDTO deleteMatch(Long id);
    MatchDetailDTO getMatchDetail(Long id);
    List<MatchDTO> getAvailableMatchesForPlayer(Long playerId);
    List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId);
    Long getPlayerIdByEmail(String email);
    List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId);


}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.MatchNotFoundException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.models.dto.*;
import cz.phsoft.hokej.models.dto.mappers.MatchMapper;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class MatchServiceImpl implements MatchService {

    private final MatchRepository matchRepository;
    private final MatchMapper matchMapper;
    private final MatchRegistrationService registrationService;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodService playerInactivityPeriodService;
    private final PlayerMapper playerMapper;
    private static final String ROLE_ADMIN = "ROLE_ADMIN";
    private static final String ROLE_MANAGER = "ROLE_MANAGER";

    public MatchServiceImpl(MatchRepository matchRepository,
                            MatchMapper matchMapper,
                            MatchRegistrationService registrationService,
                            PlayerRepository playerRepository,
                            PlayerInactivityPeriodService playerInactivityPeriodService,
                            PlayerMapper playerMapper) {
        this.matchRepository = matchRepository;
        this.matchMapper = matchMapper;
        this.registrationService = registrationService;
        this.playerRepository = playerRepository;
        this.playerInactivityPeriodService = playerInactivityPeriodService;
        this.playerMapper = playerMapper;
    }
    // metoda pro z√≠sk√°n√≠ v≈°ech z√°pas≈Ø
    @Override
    public List<MatchDTO> getAllMatches() {
        return matchRepository.findAll().stream()
                .map(matchMapper::toDTO)
                .toList();
    }
    // metoda pro z√≠sk√°n√≠ v≈°ech nadch√°zej√≠c√≠ch z√°pas≈Ø
    @Override
    public List<MatchDTO> getUpcomingMatches() {
        return matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now())
                .stream()
                .map(matchMapper::toDTO)
                .toList();
    }
    // metoda pro z√≠sk√°n√≠ uplynul√Ωch z√°pas≈Ø
    public List<MatchDTO> getPastMatches() {
        return matchRepository.findByDateTimeBeforeOrderByDateTimeDesc(LocalDateTime.now())
                .stream()
                .map(matchMapper::toDTO)
                .toList();
    }
    // metoda pro z√≠sk√°n√≠ prvn√≠ho nadch√°zej√≠c√≠ho z√°pasu
    @Override
    public MatchDTO getNextMatch() {
        return matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now())
                .stream()
                .findFirst()
                .map(matchMapper::toDTO)
                .orElse(null);
    }
    // metoda pro z√°pas dle ID
    @Override
    public MatchDTO getMatchById(Long id) {
        return matchMapper.toDTO(findMatchOrThrow(id));
    }

    // metoda pro vytvo≈ôen√≠ z√°pasu
    @Override
    public MatchDTO createMatch(MatchDTO dto) {
        MatchEntity entity = matchMapper.toEntity(dto);
        return matchMapper.toDTO(matchRepository.save(entity));
    }

    // metoda pro √∫pravu z√°pasu
    @Override
    public MatchDTO updateMatch(Long id, MatchDTO dto) {
        MatchEntity match = findMatchOrThrow(id);

        int oldMaxPlayers = match.getMaxPlayers();
        matchMapper.updateEntity(dto, match);
        MatchEntity saved = matchRepository.save(match);

        // P≈ôepoƒçet registrac√≠ pokud do≈°lo ke zmƒõnƒõ maxPlayers
        if (saved.getMaxPlayers() != oldMaxPlayers) {
            registrationService.recalcStatusesForMatch(saved.getId());
        }

        return matchMapper.toDTO(saved);
    }

    // metoda pro odstranƒõn√≠ z√°pasu
    @Override
    public SuccessResponseDTO deleteMatch(Long id) {
        MatchEntity match = findMatchOrThrow(id);

        // 2) Pokud existuje, sma≈æeme ho
        matchRepository.delete(match);

        return new SuccessResponseDTO(
                "Z√°pas " + match.getId() + match.getDateTime() + " byl √∫spƒõ≈°nƒõ smaz√°n",
                id,
                LocalDateTime.now().toString()
        );
    }

    // metoda pro detail z√°pasu - omezen v√Ωpis pro ADMIN, MANAGER, PLAYER
    @Override
    public MatchDetailDTO getMatchDetail(Long id) {
        MatchEntity match = findMatchOrThrow(id);
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();

        boolean isAdminOrManager = auth != null && auth.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals(ROLE_ADMIN) || a.getAuthority().equals(ROLE_MANAGER));

        // oddƒõlena logika p≈ô√≠stupu hr√°ƒçe do priv√°tn√≠ metody
        checkAccessForPlayer(match, auth);

        // sbƒõr statistik hr√°ƒç≈Ø p≈ôes priv√°tn√≠ metodu
        return collectPlayerStatus(match, isAdminOrManager);
    }

    // priv√°tn√≠ metoda pro kontrolu p≈ô√≠stupu hr√°ƒçe - jen pokud byl registrov√°n na z√°pas
    private void checkAccessForPlayer(MatchEntity match, Authentication auth) {
        if (auth == null || !auth.isAuthenticated()) return;

        boolean isAdminOrManager = auth.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals(ROLE_ADMIN) || a.getAuthority().equals(ROLE_MANAGER));

        if (isAdminOrManager) return;

        Object principal = auth.getPrincipal();
        if (!(principal instanceof org.springframework.security.core.userdetails.UserDetails userDetails)) return;

        List<PlayerEntity> ownedPlayers = playerRepository.findAll().stream()
                .filter(p -> p.getUser() != null && p.getUser().getEmail().equals(userDetails.getUsername()))
                .toList();

        boolean hasRestrictedPlayer = ownedPlayers.stream()
                .anyMatch(p -> {
                    List<MatchRegistrationDTO> registrations = registrationService.getRegistrationsForMatch(match.getId());

                    boolean noResponse = registrations.stream()
                            .noneMatch(r -> r.getPlayerId().equals(p.getId()));

                    boolean inactiveForMatch = !playerInactivityPeriodService.isActive(p, match.getDateTime());

                    return noResponse || inactiveForMatch;
                });

        if (hasRestrictedPlayer) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "Nem√°te p≈ô√≠stup k detailu tohoto z√°pasu."
            );
        }
    }

    // priv√°tn√≠ metoda pro sbƒõr statistik hr√°ƒç≈Ø
    private MatchDetailDTO collectPlayerStatus(MatchEntity match, boolean isAdminOrManager) {
        List<MatchRegistrationDTO> registrations = registrationService.getRegistrationsForMatch(match.getId());

        // P≈ôevod v≈°ech registrac√≠ na Map<PlayerMatchStatus, List<PlayerDTO>>
        var statusToPlayersMap = registrations.stream()
                .map(r -> playerRepository.findById(r.getPlayerId())
                        .map(playerMapper::toDTO)
                        .map(dto -> new java.util.AbstractMap.SimpleEntry<>(r.getStatus(), dto))
                )
                .filter(java.util.Optional::isPresent) // odstran√≠me chybƒõj√≠c√≠ hr√°ƒçe
                .map(java.util.Optional::get)
                .collect(Collectors.groupingBy(
                        java.util.Map.Entry::getKey,
                        Collectors.mapping(java.util.Map.Entry::getValue, Collectors.toList())
                ));

        List<PlayerEntity> allPlayers = playerRepository.findAll();
        Set<Long> respondedIds = registrations.stream()
                .map(MatchRegistrationDTO::getPlayerId)
                .collect(Collectors.toSet());

        List<PlayerDTO> noResponsePlayers = allPlayers.stream()
                .filter(p -> !respondedIds.contains(p.getId()))
                .map(playerMapper::toDTO)
                .toList();

        // Poƒçty hr√°ƒç≈Ø podle statusu
        int inGamePlayers = statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()).size();
        int outGamePlayers = statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()).size()
                + statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()).size();
        int waitingPlayers = statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()).size();
        int noActionPlayers = noResponsePlayers.size();
        int remainingSlots = match.getMaxPlayers() - inGamePlayers;
        double pricePerRegistered = inGamePlayers > 0 ? match.getPrice() / (double) inGamePlayers : 0;

        MatchDetailDTO dto = new MatchDetailDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setMaxPlayers(match.getMaxPlayers());
        dto.setInGamePlayers(inGamePlayers);
        dto.setOutGamePlayers(outGamePlayers);
        dto.setWaitingPlayers(waitingPlayers);
        dto.setNoActionPlayers(noActionPlayers);
        dto.setPricePerRegisteredPlayer(pricePerRegistered);
        dto.setRemainingSlots(remainingSlots);

        // Nastaven√≠ hr√°ƒç≈Ø podle statusu z mapy
        dto.setRegisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()));
        dto.setReservedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()));
        dto.setUnregisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()));
        dto.setExcusedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()));

        // pouze admin/manager uvid√≠ no-response hr√°ƒçe
        dto.setNoResponsePlayers(isAdminOrManager ? noResponsePlayers : null);

        return dto;
    }


    // dostupn√© z√°pasy pro hr√°ƒçe - byl nebo je aktivn√≠
    @Override
    public List<MatchDTO> getAvailableMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        // Filtrace p≈ôes stream bez meziv√Ωsledk≈Ø
        return matchRepository.findAll().stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .map(matchMapper::toDTO)
                .toList();
    }

    // z√≠sk√°n√≠ hr√°ƒçe dle emailu
    public Long getPlayerIdByEmail(String email) {
        return playerRepository.findByUserEmail(email)
                .map(PlayerEntity::getId)
                .orElseThrow(() -> new RuntimeException("Hr√°ƒç s emailem " + email + " nenalezen"));
    }

    // n√°hled nadch√°zej√≠c√≠ch z√°pasu pro hr√°ƒçe - dle PlayerType
    @Override
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        // 1) Nejbli≈æ≈°√≠ nadch√°zej√≠c√≠ z√°pasy podle data
        List<MatchEntity> upcomingAll = matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now());

        // 2) Omezen√≠ podle typu hr√°ƒçe
        List<MatchEntity> limited = switch (type) {
            case VIP -> upcomingAll;
            case STANDARD -> upcomingAll.stream().limit(2).toList();
            case BASIC -> upcomingAll.isEmpty() ? List.of() : List.of(upcomingAll.get(0));
        };

        // 3) Filtrov√°n√≠ podle aktivity hr√°ƒçe a mapov√°n√≠ na MatchOverviewDTO
        return limited.stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .map(this::toOverviewDTO)   // mapujeme p≈ô√≠mo ve slu≈æbƒõ
                .toList();
    }
    // nadch√°zej√≠c√≠ z√°pasy pro hr√°ƒçe
    @Override
    public List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        // 1) Nejbli≈æ≈°√≠ nadch√°zej√≠c√≠ z√°pasy podle data
        List<MatchEntity> upcomingAll = matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now());

        List<MatchEntity> limited = switch (type) {
            case VIP -> upcomingAll;
            case STANDARD -> upcomingAll.stream().limit(2).toList();
            case BASIC -> upcomingAll.isEmpty() ? List.of() : List.of(upcomingAll.get(0));
        };

        // 2) Filtrov√°n√≠ podle aktivity hr√°ƒçe
        return limited.stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .map(matchMapper::toDTO)
                .toList();
    }

    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    private MatchEntity findMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }

    private MatchOverviewDTO toOverviewDTO(MatchEntity match) {
        MatchOverviewDTO dto = new MatchOverviewDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setLocation(match.getLocation());
        dto.setDescription(match.getDescription());
        dto.setPrice(match.getPrice());
        dto.setMaxPlayers(match.getMaxPlayers());

        // poƒçet registrovan√Ωch hr√°ƒç≈Ø
        int inGamePlayers = registrationService.getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .mapToInt(r -> 1)
                .sum();
        dto.setInGamePlayers(inGamePlayers);

        // cena na registrovan√©ho hr√°ƒçe
        double pricePerPlayer = inGamePlayers > 0 && match.getPrice() != null
                ? match.getPrice() / (double) inGamePlayers : 0;
        dto.setPricePerRegisteredPlayer(pricePerPlayer);

        return dto;
    }


}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;

import java.time.LocalDateTime;
import java.util.List;

public interface PlayerInactivityPeriodService {

    List<PlayerInactivityPeriodDTO> getAll();

    PlayerInactivityPeriodDTO getById(Long id);

    List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId);

    PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto);

    PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto);

    void delete(Long id);

    public boolean isActive(PlayerEntity player, LocalDateTime dateTime);
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.data.repositories.PlayerInactivityPeriodRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.dto.mappers.PlayerInactivityPeriodMapper;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import java.util.List;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

@Service
public class PlayerInactivityPeriodServiceImpl implements PlayerInactivityPeriodService {

    private final PlayerInactivityPeriodRepository inactivityRepository;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodMapper mapper;

    public PlayerInactivityPeriodServiceImpl(PlayerInactivityPeriodRepository inactivityRepository,
                                             PlayerRepository playerRepository,
                                             PlayerInactivityPeriodMapper mapper) {
        this.inactivityRepository = inactivityRepository;
        this.playerRepository = playerRepository;
        this.mapper = mapper;
    }

    @Override
    public List<PlayerInactivityPeriodDTO> getAll() {
        return inactivityRepository.findAll().stream()
                .map(mapper::toDTO)
                .toList();
    }

    @Override
    public PlayerInactivityPeriodDTO getById(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException(
                        "Obdob√≠ neaktivity s ID " + id + " neexistuje."
                ));
        return mapper.toDTO(entity);
    }

    @Override
    public List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId) {
        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new RuntimeException("Player not found"));

        return inactivityRepository.findByPlayerOrderByInactiveFromAsc(player)
                .stream()
                .map(mapper::toDTO)
                .toList();
    }

    // --- TRANSACTIONAL pro z√°pis dat ---
    @Override
    @Transactional
    public PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto) {
        PlayerEntity player = playerRepository.findById(dto.getPlayerId())
                .orElseThrow(() -> new IllegalArgumentException("Hr√°ƒç s ID " + dto.getPlayerId() + " neexistuje."));

        validateDates(dto);

        // kontrola p≈ôekryvu existuj√≠c√≠ch obdob√≠
        boolean overlaps = !inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        player, dto.getInactiveFrom(), dto.getInactiveTo()
                ).isEmpty();

        if (overlaps) {
            throw new IllegalStateException("Nov√© obdob√≠ se p≈ôekr√Ωv√° s existuj√≠c√≠m obdob√≠m neaktivity hr√°ƒçe.");
        }

        PlayerInactivityPeriodEntity entity = mapper.toEntity(dto, player);
        return mapper.toDTO(inactivityRepository.save(entity));
    }

    @Override
    @Transactional
    public PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Obdob√≠ neaktivity s ID " + id + " neexistuje."));

        validateDates(dto);

        // kontrola p≈ôekryvu, ignoruje aktu√°ln√≠ z√°znam
        boolean overlaps = inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        entity.getPlayer(), dto.getInactiveFrom(), dto.getInactiveTo()
                ).stream()
                .anyMatch(p -> !p.getId().equals(id));

        if (overlaps) {
            throw new IllegalStateException("Upraven√© obdob√≠ se p≈ôekr√Ωv√° s jin√Ωm obdob√≠m neaktivity hr√°ƒçe.");
        }

        mapper.updateEntityFromDto(dto, entity);
        return mapper.toDTO(inactivityRepository.save(entity));
    }

    @Override
    @Transactional
    public void delete(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Obdob√≠ neaktivity s ID " + id + " neexistuje."));
        inactivityRepository.delete(entity);
    }

    // --- true = aktivn√≠, false = neaktivn√≠ ---
    public boolean isActive(PlayerEntity player, LocalDateTime dateTime) {
        return !inactivityRepository.existsByPlayerAndInactiveFromLessThanEqualAndInactiveToGreaterThanEqual(
                player, dateTime, dateTime);
    }

    // --- priv√°tn√≠ metoda pro validaci dat ---
    private void validateDates(PlayerInactivityPeriodDTO dto) {
        if (dto.getInactiveFrom() == null || dto.getInactiveTo() == null) {
            throw new IllegalArgumentException("Datum od a do nesm√≠ b√Ωt null.");
        }
        if (!dto.getInactiveFrom().isBefore(dto.getInactiveTo())) {
            throw new IllegalArgumentException("inactiveFrom mus√≠ b√Ωt p≈ôed inactiveTo.");
        }
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;

import java.util.List;


public interface PlayerService {
    List<PlayerDTO> getAllPlayers();
    PlayerDTO getPlayerById(Long id);
    PlayerDTO createPlayer(PlayerDTO player);
    PlayerDTO updatePlayer(Long id, PlayerDTO player);
    SuccessResponseDTO deletePlayer(Long id);
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;
import cz.phsoft.hokej.models.dto.PlayerDTO;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
public class PlayerServiceImpl implements PlayerService {

    private final PlayerRepository playerRepository;
    private final PlayerMapper playerMapper;

    public PlayerServiceImpl(PlayerRepository playerRepository, PlayerMapper playerMapper) {
        this.playerRepository = playerRepository;
        this.playerMapper = playerMapper;
    }

    @Override
    public List<PlayerDTO> getAllPlayers() {
        return playerRepository.findAll().stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    @Override
    public PlayerDTO getPlayerById(Long id) {
        PlayerEntity player = playerRepository.findById(id)
                .orElseThrow(() -> new PlayerNotFoundException(id)); // m√≠sto RuntimeException
        return playerMapper.toDTO(player);
    }

    // --- TRANSACTIONAL pro z√°pis dat ---
    @Override
    @Transactional
    public PlayerDTO createPlayer(PlayerDTO dto) {
        checkDuplicateNameSurname(dto.getName(), dto.getSurname(), null);

        PlayerEntity entity = playerMapper.toEntity(dto);
        PlayerEntity saved = playerRepository.save(entity);
        return playerMapper.toDTO(saved);
    }

    @Override
    @Transactional
    public PlayerDTO updatePlayer(Long id, PlayerDTO dto) {
        PlayerEntity existing = findPlayerOrThrow(id);

        // pokud se jm√©no/p≈ô√≠jmen√≠ mƒõn√≠, ovƒõ≈ô duplicitu
        if (!existing.getName().equals(dto.getName()) || !existing.getSurname().equals(dto.getSurname())) {
            checkDuplicateNameSurname(dto.getName(), dto.getSurname(), id);
        }

        existing.setName(dto.getName());
        existing.setSurname(dto.getSurname());
        existing.setType(dto.getType());
        existing.setTeam(dto.getTeam());

        PlayerEntity saved = playerRepository.save(existing);
        return playerMapper.toDTO(saved);
    }

    @Override
    @Transactional
    public SuccessResponseDTO deletePlayer(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);
        playerRepository.delete(player);

        return new SuccessResponseDTO(
                "Hr√°ƒç " + player.getFullName() + " byl √∫spƒõ≈°nƒõ smaz√°n",
                id,
                LocalDateTime.now().toString()
        );
    }

    // --- priv√°tn√≠ metoda pro kontrolu duplicity jm√©na a p≈ô√≠jmen√≠ ---
    private void checkDuplicateNameSurname(String name, String surname, Long ignoreId) {
        Optional<PlayerEntity> duplicateOpt = playerRepository.findByNameAndSurname(name, surname);

        if (duplicateOpt.isPresent()) {
            if (ignoreId == null || !duplicateOpt.get().getId().equals(ignoreId)) {
                throw new RuntimeException("Hr√°ƒç se jm√©nem " + name + " " + surname + " ji≈æ existuje.");
            }
        }
    }

    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\PlayerSecurity.java


package cz.phsoft.hokej.security;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

@Component("playerSecurity") // n√°zev pro pou≈æit√≠ v SpEL (@PreAuthorize)
public class PlayerSecurity {

    private static final Logger logger = LoggerFactory.getLogger(PlayerSecurity.class);

    private final PlayerRepository playerRepository;

    public PlayerSecurity(PlayerRepository playerRepository) {
        this.playerRepository = playerRepository;
    }

    /**
     * Zjist√≠, zda je aktu√°lnƒõ p≈ôihl√°≈°en√Ω u≈æivatel vlastn√≠kem hr√°ƒçe
     *
     * @param authentication aktu√°ln√≠ authentication objekt
     * @param playerId       ID hr√°ƒçe
     * @return true pokud je vlastn√≠kem, jinak false
     */
    public boolean isOwner(Authentication authentication, Long playerId) {
        try {
            if (authentication == null || !authentication.isAuthenticated()) {
                logger.warn("Neautorizovan√Ω p≈ô√≠stup: ≈æ√°dn√° autentizace pro playerId {}", playerId);
                return false;
            }

            Object principal = authentication.getPrincipal();
            if (!(principal instanceof UserDetails userDetails)) {
                logger.warn("Neautorizovan√Ω p≈ô√≠stup: principal nen√≠ UserDetails pro playerId {}", playerId);
                return false;
            }

            boolean isOwner = playerRepository.findById(playerId)
                    .map(player -> player.getUser() != null &&
                            player.getUser().getEmail().equals(userDetails.getUsername()))
                    .orElse(false);

            if (!isOwner) {
                logger.warn("Neautorizovan√Ω p≈ô√≠stup: u≈æivatel {} nen√≠ vlastn√≠kem hr√°ƒçe {}", userDetails.getUsername(), playerId);
            }

            return isOwner;

        } catch (Exception e) {
            logger.error("Chyba p≈ôi kontrole vlastn√≠ka hr√°ƒçe {}: {}", playerId, e.getMessage(), e);
            // nikdy nepropustit v√Ωjimku do SpEL
            return false;
        }
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\StaraGardaApplication.java


package cz.phsoft.hokej;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableJpaRepositories // JPA v na≈°em Spring Boot projektu
@EnableScheduling
public class StaraGardaApplication {
    public static void main(String[] args) {
        SpringApplication.run(StaraGardaApplication.class, args);


        }
    }


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\src\test\java\cz\phsoft\hokej\controllers\MatchControllerTest.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.StaraGardaApplication;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.security.test.context.support.WithAnonymousUser;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest(
        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
        classes = StaraGardaApplication.class
)
@AutoConfigureMockMvc
public class MatchControllerTest {

    @Autowired
    private MockMvc mockMvc;

    // ---------------------------------------------------------
    // GET /api/matches ‚Äì pouze MANAGER + ADMIN
    // ---------------------------------------------------------

    @Test
    @WithMockUser(roles = {"ADMIN"})
    void getAllMatches_asAdmin_shouldReturn200() throws Exception {
        mockMvc.perform(get("/api/matches"))
                .andExpect(status().isOk());
    }

    @Test
    @WithMockUser(roles = {"MANAGER"})
    void getAllMatches_asManager_shouldReturn200() throws Exception {
        mockMvc.perform(get("/api/matches"))
                .andExpect(status().isOk());
    }

    @Test
    @WithMockUser(roles = {"PLAYER"})
    void getAllMatches_asPlayer_shouldReturn403() throws Exception {
        mockMvc.perform(get("/api/matches"))
                .andExpect(status().isForbidden());
    }

    @Test
    @WithAnonymousUser
    void getAllMatches_unauthenticated_shouldReturn401() throws Exception {
        mockMvc.perform(get("/api/matches"))
                .andExpect(status().isUnauthorized());
    }

    // ---------------------------------------------------------
    // GET /api/matches/next ‚Äì mus√≠ b√Ωt p≈ôihl√°≈°en√Ω kdokoliv
    // ---------------------------------------------------------

    @Test
    @WithMockUser
    void getNextMatch_authenticated_shouldReturn200() throws Exception {
        mockMvc.perform(get("/api/matches/next"))
                .andExpect(status().isOk());
    }

    @Test
    @WithAnonymousUser
    void getNextMatch_unauthenticated_shouldReturn401() throws Exception {
        mockMvc.perform(get("/api/matches/next"))
                .andExpect(status().isUnauthorized());
    }

    // ---------------------------------------------------------
    // POST /api/matches ‚Äì ADMIN
    // ---------------------------------------------------------

    @Test
    @WithMockUser(roles = {"ADMIN"})
    void createMatch_asAdmin_shouldReturn200() throws Exception {

        String json = """
                {
                    "dateTime": "2030-01-01T18:00:00",
                    "location": "Brno",
                    "description": "Testovac√≠ z√°pas",
                    "maxPlayers": 20,
                    "price": 150
                }
                """;

        mockMvc.perform(post("/api/matches")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(json))
                .andExpect(status().isOk());
    }

    @Test
    @WithMockUser(roles = {"MANAGER"})
    void createMatch_asManager_shouldReturn403() throws Exception {

        String json = """
                {
                    "dateTime": "2030-01-01T18:00:00",
                    "location": "Brno",
                    "description": "Testovac√≠ z√°pas",
                    "maxPlayers": 20,
                    "price": 150
                }
                """;

        mockMvc.perform(post("/api/matches")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(json))
                .andExpect(status().isForbidden());
    }

    @Test
    @WithAnonymousUser
    void createMatch_unauthenticated_shouldReturn401() throws Exception {
        mockMvc.perform(post("/api/matches")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{}"))
                .andExpect(status().isUnauthorized());
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\AppUserMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.PlayerSummaryDTO;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-15T14:57:09+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class AppUserMapperImpl implements AppUserMapper {

    @Override
    public AppUserDTO toDto(AppUserEntity entity) {
        if ( entity == null ) {
            return null;
        }

        AppUserDTO appUserDTO = new AppUserDTO();

        appUserDTO.setPlayers( playerEntitySetToPlayerSummaryDTOSet( entity.getPlayers() ) );
        appUserDTO.setId( entity.getId() );
        appUserDTO.setEmail( entity.getEmail() );
        if ( entity.getRole() != null ) {
            appUserDTO.setRole( entity.getRole().name() );
        }

        return appUserDTO;
    }

    @Override
    public List<AppUserDTO> toDtoList(List<AppUserEntity> entities) {
        if ( entities == null ) {
            return null;
        }

        List<AppUserDTO> list = new ArrayList<AppUserDTO>( entities.size() );
        for ( AppUserEntity appUserEntity : entities ) {
            list.add( toDto( appUserEntity ) );
        }

        return list;
    }

    @Override
    public PlayerSummaryDTO toPlayerSummary(PlayerEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerSummaryDTO playerSummaryDTO = new PlayerSummaryDTO();

        return playerSummaryDTO;
    }

    protected Set<PlayerSummaryDTO> playerEntitySetToPlayerSummaryDTOSet(Set<PlayerEntity> set) {
        if ( set == null ) {
            return null;
        }

        Set<PlayerSummaryDTO> set1 = new LinkedHashSet<PlayerSummaryDTO>( Math.max( (int) ( set.size() / .75f ) + 1, 16 ) );
        for ( PlayerEntity playerEntity : set ) {
            set1.add( toPlayerSummary( playerEntity ) );
        }

        return set1;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-15T14:57:10+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchMapperImpl implements MatchMapper {

    @Override
    public MatchDTO toDTO(MatchEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchDTO matchDTO = new MatchDTO();

        matchDTO.setId( entity.getId() );
        matchDTO.setDateTime( entity.getDateTime() );
        matchDTO.setLocation( entity.getLocation() );
        matchDTO.setDescription( entity.getDescription() );
        matchDTO.setMaxPlayers( entity.getMaxPlayers() );
        matchDTO.setPrice( entity.getPrice() );

        return matchDTO;
    }

    @Override
    public MatchEntity toEntity(MatchDTO dto) {
        if ( dto == null ) {
            return null;
        }

        MatchEntity matchEntity = new MatchEntity();

        matchEntity.setId( dto.getId() );
        matchEntity.setDateTime( dto.getDateTime() );
        matchEntity.setLocation( dto.getLocation() );
        matchEntity.setDescription( dto.getDescription() );
        matchEntity.setMaxPlayers( dto.getMaxPlayers() );
        matchEntity.setPrice( dto.getPrice() );

        return matchEntity;
    }

    @Override
    public void updateEntity(MatchDTO dto, MatchEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setDateTime( dto.getDateTime() );
        entity.setLocation( dto.getLocation() );
        entity.setDescription( dto.getDescription() );
        entity.setMaxPlayers( dto.getMaxPlayers() );
        entity.setPrice( dto.getPrice() );
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchRegistrationMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-15T14:57:09+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchRegistrationMapperImpl implements MatchRegistrationMapper {

    @Override
    public MatchRegistrationEntity toEntity(MatchEntity match, PlayerEntity player, PlayerMatchStatus status, ExcuseReason excuseReason, String note, Team jerseyColor, String adminNote, String createdBy) {
        if ( match == null && player == null && status == null && excuseReason == null && note == null && jerseyColor == null && adminNote == null && createdBy == null ) {
            return null;
        }

        MatchRegistrationEntity matchRegistrationEntity = new MatchRegistrationEntity();

        matchRegistrationEntity.setMatch( match );
        matchRegistrationEntity.setPlayer( player );
        matchRegistrationEntity.setStatus( status );
        matchRegistrationEntity.setExcuseReason( excuseReason );
        matchRegistrationEntity.setExcuseNote( note );
        matchRegistrationEntity.setJerseyColor( jerseyColor );
        matchRegistrationEntity.setAdminNote( adminNote );
        matchRegistrationEntity.setCreatedBy( createdBy );
        matchRegistrationEntity.setTimestamp( java.time.LocalDateTime.now() );

        return matchRegistrationEntity;
    }

    @Override
    public MatchRegistrationDTO toDTO(MatchRegistrationEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchRegistrationDTO matchRegistrationDTO = new MatchRegistrationDTO();

        matchRegistrationDTO.setMatchId( entityMatchId( entity ) );
        matchRegistrationDTO.setPlayerId( entityPlayerId( entity ) );
        matchRegistrationDTO.setId( entity.getId() );
        matchRegistrationDTO.setStatus( entity.getStatus() );
        matchRegistrationDTO.setExcuseReason( entity.getExcuseReason() );
        matchRegistrationDTO.setExcuseNote( entity.getExcuseNote() );
        matchRegistrationDTO.setAdminNote( entity.getAdminNote() );
        matchRegistrationDTO.setJerseyColor( entity.getJerseyColor() );
        matchRegistrationDTO.setCreatedBy( entity.getCreatedBy() );

        return matchRegistrationDTO;
    }

    @Override
    public List<MatchRegistrationDTO> toDTOList(List<MatchRegistrationEntity> entities) {
        if ( entities == null ) {
            return null;
        }

        List<MatchRegistrationDTO> list = new ArrayList<MatchRegistrationDTO>( entities.size() );
        for ( MatchRegistrationEntity matchRegistrationEntity : entities ) {
            list.add( toDTO( matchRegistrationEntity ) );
        }

        return list;
    }

    private Long entityMatchId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        MatchEntity match = matchRegistrationEntity.getMatch();
        if ( match == null ) {
            return null;
        }
        Long id = match.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }

    private Long entityPlayerId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        PlayerEntity player = matchRegistrationEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerInactivityPeriodMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-15T14:57:09+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerInactivityPeriodMapperImpl implements PlayerInactivityPeriodMapper {

    @Override
    public PlayerInactivityPeriodDTO toDTO(PlayerInactivityPeriodEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerInactivityPeriodDTO playerInactivityPeriodDTO = new PlayerInactivityPeriodDTO();

        playerInactivityPeriodDTO.setPlayerId( entityPlayerId( entity ) );
        playerInactivityPeriodDTO.setId( entity.getId() );
        playerInactivityPeriodDTO.setInactiveFrom( entity.getInactiveFrom() );
        playerInactivityPeriodDTO.setInactiveTo( entity.getInactiveTo() );

        return playerInactivityPeriodDTO;
    }

    @Override
    public PlayerInactivityPeriodEntity toEntity(PlayerInactivityPeriodDTO dto, PlayerEntity player) {
        if ( dto == null ) {
            return null;
        }

        PlayerInactivityPeriodEntity playerInactivityPeriodEntity = createEntity( dto, player );

        playerInactivityPeriodEntity.setInactiveFrom( dto.getInactiveFrom() );
        playerInactivityPeriodEntity.setInactiveTo( dto.getInactiveTo() );

        return playerInactivityPeriodEntity;
    }

    @Override
    public void updateEntityFromDto(PlayerInactivityPeriodDTO dto, PlayerInactivityPeriodEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setInactiveFrom( dto.getInactiveFrom() );
        entity.setInactiveTo( dto.getInactiveTo() );
    }

    private Long entityPlayerId(PlayerInactivityPeriodEntity playerInactivityPeriodEntity) {
        if ( playerInactivityPeriodEntity == null ) {
            return null;
        }
        PlayerEntity player = playerInactivityPeriodEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}


# Soubor: C:\Projekty Pr·ce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-15T14:57:09+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerMapperImpl implements PlayerMapper {

    @Override
    public PlayerDTO toDTO(PlayerEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerDTO playerDTO = new PlayerDTO();

        playerDTO.setId( entity.getId() );
        playerDTO.setName( entity.getName() );
        playerDTO.setSurname( entity.getSurname() );
        playerDTO.setType( entity.getType() );
        playerDTO.setTeam( entity.getTeam() );
        playerDTO.setPhoneNumber( entity.getPhoneNumber() );

        return playerDTO;
    }

    @Override
    public PlayerEntity toEntity(PlayerDTO dto) {
        if ( dto == null ) {
            return null;
        }

        PlayerEntity playerEntity = new PlayerEntity();

        playerEntity.setId( dto.getId() );
        playerEntity.setName( dto.getName() );
        playerEntity.setSurname( dto.getSurname() );
        playerEntity.setType( dto.getType() );
        playerEntity.setPhoneNumber( dto.getPhoneNumber() );
        playerEntity.setTeam( dto.getTeam() );

        return playerEntity;
    }

    @Override
    public void updatePlayerDTO(PlayerDTO source, PlayerDTO target) {
        if ( source == null ) {
            return;
        }

        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setNickName( source.getNickName() );
        target.setType( source.getType() );
        target.setTeam( source.getTeam() );
        target.setPhoneNumber( source.getPhoneNumber() );
    }

    @Override
    public void updatePlayerEntity(PlayerDTO source, PlayerEntity target) {
        if ( source == null ) {
            return;
        }

        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setType( source.getType() );
        target.setPhoneNumber( source.getPhoneNumber() );
        target.setTeam( source.getTeam() );
    }

    @Override
    public List<PlayerDTO> toDTOList(List<PlayerEntity> players) {
        if ( players == null ) {
            return null;
        }

        List<PlayerDTO> list = new ArrayList<PlayerDTO>( players.size() );
        for ( PlayerEntity playerEntity : players ) {
            list.add( toDTO( playerEntity ) );
        }

        return list;
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\AppConfig.java


package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class AppConfig {

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\AuditAspect.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

@Component
@Aspect
public class AuditAspect {

    private static final Logger logger = LoggerFactory.getLogger("AUDIT_LOGGER");

    // Pointcut pro vƒπÀáechny metody ve sluƒπƒæbƒÇÀách
    @Pointcut("within(cz.phsoft.hokej.models.services..*)")
    public void serviceMethods() {}

    // SpustƒÇ¬≠ se pƒπ‚Ñ¢ed metodou
    @Before("serviceMethods()")
    public void logBefore(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().toShortString();
        String args = java.util.Arrays.toString(joinPoint.getArgs());
        logger.info("START {} at {} with args {}", methodName, LocalDateTime.now(), args);
    }

    // SpustƒÇ¬≠ se po ƒÇ≈üsp√Ñ‚Ä∫ƒπÀánƒÇ¬©m dokon√Ñ≈§enƒÇ¬≠ metody
    @AfterReturning(pointcut = "serviceMethods()", returning = "result")
    public void logAfterReturning(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();

        Long userId = null;
        Long playerId = null;

        for (Object arg : args) {
            if (arg instanceof PlayerEntity player) {
                playerId = player.getId();
            } else if (arg instanceof MatchRegistrationEntity registration) {
                playerId = registration.getPlayer().getId();
            } else if (arg instanceof Long id) {
                // pokud mƒÇÀá metoda Long parametry, mƒπ≈ªƒπƒæeƒπÀá ur√Ñ≈§it podle poƒπ‚Ñ¢adƒÇ¬≠
                // tƒπ‚Ñ¢eba prvnƒÇ¬≠ Long = matchId, druhƒÇÀù = playerId
            }
        }

        // logovƒÇÀánƒÇ¬≠
        logger.info("END {} - userId={} playerId={} returned [{}] at {}",
                methodName, userId, playerId, result, LocalDateTime.now());
    }
}



# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\CustomJsonLoginFilter.java


package cz.phsoft.hokej.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.context.HttpSessionSecurityContextRepository;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

// filtr pro REST login
public class CustomJsonLoginFilter extends UsernamePasswordAuthenticationFilter {

    private final ObjectMapper objectMapper = new ObjectMapper();

    public CustomJsonLoginFilter(String loginUrl, AuthenticationManager authManager) {
        setFilterProcessesUrl(loginUrl);
        setAuthenticationManager(authManager);
    }

    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        try {
            // x-www-form-urlencoded i JSON
            String email = null;
            String password = null;

// x-www-form-urlencoded
            if (request.getContentType() != null &&
                    request.getContentType().contains("application/x-www-form-urlencoded")) {
                email = request.getParameter("username");
                password = request.getParameter("password");
            }

// JSON
            if ((email == null || password == null) &&
                    request.getContentType() != null &&
                    request.getContentType().contains("application/json")) {
                Map<String, String> json = objectMapper.readValue(request.getInputStream(), Map.class);
                email = json.get("email");
                password = json.get("password");
            }

            if (email == null || password == null || email.isBlank() || password.isBlank()) {
                throw new BadCredentialsException("ChybƒÇ¬≠ pƒπ‚Ñ¢ihlaƒπÀáovacƒÇ¬≠ ƒÇ≈üdaje");
            }

            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(email, password);
            setDetails(request, authRequest);

            return this.getAuthenticationManager().authenticate(authRequest);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    // ƒÇ≈°sp√Ñ‚Ä∫ƒπÀánƒÇÀù login
    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
                                            FilterChain chain, Authentication authResult)
            throws IOException, ServletException {

        // UloƒπƒæenƒÇ¬≠ do SecurityContextHolder
        SecurityContextHolder.getContext().setAuthentication(authResult);

        // Vytvoƒπ‚Ñ¢enƒÇ¬≠ session a uloƒπƒæenƒÇ¬≠ SPRING_SECURITY_CONTEXT
        request.getSession(true).setAttribute(
                HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY,
                SecurityContextHolder.getContext()
        );

        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");

        Map<String, Object> result = new HashMap<>();
        result.put("status", "ok");
        result.put("user", authResult.getName());

        objectMapper.writeValue(response.getWriter(), result);
    }

    // NeƒÇ≈üsp√Ñ‚Ä∫ƒπÀánƒÇÀù login
    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException {
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");

        Map<String, Object> result = new HashMap<>();
        result.put("status", "error");

        // RozliƒπÀáenƒÇ¬≠ neaktivovanƒÇ¬©ho ƒÇ≈ü√Ñ≈§tu
        if (failed.getCause() instanceof cz.phsoft.hokej.exceptions.AccountNotActivatedException) {
            result.put("message", failed.getCause().getMessage()); // napƒπ‚Ñ¢. "ƒÇ≈°√Ñ≈§et nenƒÇ¬≠ aktivovƒÇÀán. Zkontrolujte email."
        } else if (failed instanceof BadCredentialsException) {
            result.put("message", "NeplatnƒÇ¬© pƒπ‚Ñ¢ihlaƒπÀáovacƒÇ¬≠ ƒÇ≈üdaje");
        } else {
            result.put("message", "Chyba pƒπ‚Ñ¢i pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬≠");
        }

        objectMapper.writeValue(response.getWriter(), result);
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\CustomUserDetailsService.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import cz.phsoft.hokej.exceptions.AccountNotActivatedException;

import java.util.Set;
import java.util.stream.Collectors;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final AppUserRepository appUserRepository;

    public CustomUserDetailsService(AppUserRepository appUserRepository) {
        this.appUserRepository = appUserRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        AppUserEntity user = appUserRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("Uƒπƒæivatel nenalezen"));

        if (!user.isEnabled()) { // nebo podle status == PENDING
            throw new AccountNotActivatedException();
        }

        return org.springframework.security.core.userdetails.User.builder()
                .username(user.getEmail())
                .password(user.getPassword())
                .roles(user.getRole().name().replace("ROLE_", "")) // "ADMIN", "PLAYER", ...
                .disabled(!user.isEnabled()) // neaktivnƒÇ¬≠ - nelze se pƒπ‚Ñ¢ƒÇ¬≠hlƒÇÀásit
                .build();
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\DataInitializer.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.*;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import jakarta.annotation.PostConstruct;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Component;
import org.springframework.jdbc.core.JdbcTemplate;


import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Component
public class DataInitializer {

    private final PlayerRepository playerRepository;
    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository matchRegistrationRepository;
    private final AppUserRepository appUserRepository;
    private final JdbcTemplate jdbcTemplate;

    public DataInitializer(PlayerRepository playerRepository,
                           MatchRepository matchRepository,
                           MatchRegistrationRepository matchRegistrationRepository,
                           AppUserRepository appUserRepository,
                           JdbcTemplate jdbcTemplate) {
        this.playerRepository = playerRepository;
        this.matchRepository = matchRepository;
        this.matchRegistrationRepository = matchRegistrationRepository;
        this.appUserRepository = appUserRepository;
        this.jdbcTemplate = jdbcTemplate;
    }

    @PostConstruct
    public void init() {
        // Pokud existuje alespoƒπ¬à 1 hrƒÇÀá√Ñ≈§, DB uƒπƒæ byla inicializovanƒÇÀá
        if (playerRepository.count() > 0) {
            System.out.println("Data already initialized √¢‚Ç¨‚Äú skipping DataInitializer.");
            return;
        }
        System.out.println("Initializing default data...");

        // --- Seznam hrƒÇÀá√Ñ≈§ƒπ≈ª ---
        List<PlayerEntity> players = new ArrayList<>(List.of(
                new PlayerEntity("HrƒÇÀá√Ñ≈§_1", "Jedna", "", PlayerType.VIP, "+420776609956", Team.DARK, PlayerStatus.APPROVED),
                new PlayerEntity("HrƒÇÀá√Ñ≈§_2", "Dva", "", PlayerType.VIP, "+420776609956", Team.LIGHT, PlayerStatus.APPROVED),
                new PlayerEntity("HrƒÇÀá√Ñ≈§_3", "Tƒπ‚Ñ¢i", "", PlayerType.VIP, "+420776609956", Team.LIGHT, PlayerStatus.APPROVED),
                new PlayerEntity("HrƒÇÀá√Ñ≈§_4", "√Ñ≈ötyƒπ‚Ñ¢i", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT, PlayerStatus.APPROVED),
                new PlayerEntity("HrƒÇÀá√Ñ≈§_5", "P√Ñ‚Ä∫t", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT, PlayerStatus.PENDING),
                new PlayerEntity("HrƒÇÀá√Ñ≈§_6", "ƒπ¬†est", "", PlayerType.STANDARD, "+420776609956", Team.DARK, PlayerStatus.PENDING),
                new PlayerEntity("HrƒÇÀá√Ñ≈§_7", "Sedm", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT, PlayerStatus.PENDING),
                new PlayerEntity("HrƒÇÀá√Ñ≈§_8", "Osum", "", PlayerType.BASIC, "+420776609956", Team.DARK, PlayerStatus.PENDING),
                new PlayerEntity("HrƒÇÀá√Ñ≈§_9", "Dev√Ñ‚Ä∫t", "", PlayerType.BASIC, "+420776609956", Team.DARK, PlayerStatus.PENDING),
                new PlayerEntity("HrƒÇÀá√Ñ≈§_10", "Deset", "", PlayerType.BASIC, "+420776609956", Team.DARK, PlayerStatus.PENDING)
                // ... pƒπ‚Ñ¢ƒÇ¬≠padn√Ñ‚Ä∫ dalƒπÀáƒÇ¬≠ hrƒÇÀá√Ñ≈§i
        ));

        // --- Vytvoƒπ‚Ñ¢enƒÇ¬≠ uƒπƒæivatelƒπ≈ª ke kaƒπƒædƒÇ¬©mu hrƒÇÀá√Ñ≈§i ---

        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();

        // --- Default admin ---
        if (appUserRepository.findByEmail("admin@example.com").isEmpty()) {
            AppUserEntity admin = new AppUserEntity();
            admin.setName("admin");
            admin.setSurname("admin");
            admin.setEmail("admin@example.com");
            admin.setPassword(encoder.encode("Administrator123"));
            admin.setRole(Role.ROLE_ADMIN);
            admin.setEnabled(true);
            appUserRepository.save(admin);
            System.out.println("Default admin user created.");
        } else {
            System.out.println("Admin user already exists √¢‚Ç¨‚Äú skipping.");
        }

        System.out.println("Data initialization completed.");

        int playerCounter = 1;
        for (PlayerEntity player : players) {
            // vytvoƒπ‚Ñ¢enƒÇ¬≠ uƒπƒæivatele
            String email = "player" + playerCounter + "@example.com";
            String password = "Player123";

            AppUserEntity user = new AppUserEntity();
            user.setName("HrƒÇÀá√Ñ≈§" + playerCounter);
            user.setSurname("√Ñ≈öƒÇ¬≠slo_" + playerCounter);
            user.setEmail(email);
            user.setPassword(encoder.encode(password));

            switch (playerCounter){
                case 1:
                    user.setRole(Role.ROLE_ADMIN);
                    System.out.println("Nastavena role: admin");
                    break;
                case 2:
                    user.setRole(Role.ROLE_MANAGER);
                    System.out.println("Nastavena role: manager");
                    break;
                default:
                    user.setRole(Role.ROLE_PLAYER);
                    System.out.println("Nastavena role: player");
            }
            user.setEnabled(true);
            // pƒπ‚Ñ¢iƒπ‚Ñ¢adit hrƒÇÀá√Ñ≈§e k uƒπƒæivateli
            System.out.println("VytvƒÇÀáƒπ‚Ñ¢ƒÇ¬≠m uƒπƒæivatele √Ñ≈§. " + playerCounter);
            player.setUser(user);

            // uloƒπƒæit uƒπƒæivatele (cascade uloƒπƒæƒÇ¬≠ i hrƒÇÀá√Ñ≈§e, pokud je sprƒÇÀávn√Ñ‚Ä∫ nastaven)
            appUserRepository.save(user);

            playerCounter++;
        }

        // --- Uloƒπƒæit hrƒÇÀá√Ñ≈§e (uƒπƒæ uloƒπƒæen pƒπ‚Ñ¢i cascade, ale pro jistotu) ---
        playerRepository.saveAll(players);

        // --- Vytvoƒπ‚Ñ¢enƒÇ¬≠ zƒÇÀápasƒπ≈ª ---
        LocalDateTime startDate = LocalDateTime.of(2025, 11, 21, 18, 45);
        for (int i = 0; i < 10; i++) {
            MatchEntity match = new MatchEntity();
            match.setDateTime(startDate.plusWeeks(i));
            match.setLocation("Ostravice");
            match.setDescription("");
            match.setMaxPlayers(12);
            match.setPrice(2200);
            matchRepository.save(match);
        }

        // --- Registrace hrƒÇÀá√Ñ≈§ƒπ≈ª na zƒÇÀápas id 3 ---
        MatchEntity match3 = matchRepository.findById(3L)
                .orElseThrow(() -> new RuntimeException("Match with id 3 not found"));

        for (long playerId = 1; playerId <= 6; playerId++) {
            final long pid = playerId;
            PlayerEntity player = playerRepository.findById(playerId)
                    .orElseThrow(() -> new RuntimeException("Player with id " + pid + " not found"));

            MatchRegistrationEntity reg = new MatchRegistrationEntity();
            reg.setMatch(match3);
            reg.setPlayer(player);
            reg.setStatus(PlayerMatchStatus.REGISTERED);
            if (playerId <=3){
                reg.setTeam(Team.DARK);
            }else {
                reg.setTeam(Team.LIGHT);
            }
            reg.setTimestamp(LocalDateTime.now());
            reg.setCreatedBy("user");
            matchRegistrationRepository.save(reg);
        }

        // --- Default admin ---
        if (appUserRepository.findByEmail("admin@example.com").isEmpty()) {
            AppUserEntity admin = new AppUserEntity();
            admin.setEmail("admin@example.com");
            admin.setPassword(encoder.encode("Administrator123"));
            admin.setRole(Role.ROLE_ADMIN);
            appUserRepository.save(admin);
            System.out.println("Default admin user created.");
        } else {
            System.out.println("Admin user already exists √¢‚Ç¨‚Äú skipping.");
        }

        // --- vytvoƒπ‚Ñ¢enƒÇ¬≠ triggeru ---
        try {
            jdbcTemplate.execute("""
                           CREATE TRIGGER trg_match_reg_insert
                           AFTER INSERT ON match_registrations
                           FOR EACH ROW
                           BEGIN
                               INSERT INTO match_registration_history
                               (match_registration_id, match_id, player_id, status, excuse_reason,
                                excuse_note, admin_note, team, original_timestamp, created_by,
                                action, changed_at)
                               VALUES
                               (NEW.id, NEW.match_id, NEW.player_id, NEW.status, NEW.excuse_reason,
                                NEW.excuse_note, NEW.admin_note, NEW.team, NEW.timestamp, NEW.created_by,
                                'INSERT', NOW());
                           END
                    """);
            System.out.println("Trigger created successfully.");
        } catch (Exception e) {
            System.out.println("Trigger already exists or error: " + e.getMessage());
        }

        try {
            jdbcTemplate.execute("""
                    CREATE TRIGGER trg_match_reg_update
                    AFTER UPDATE ON match_registrations
                    FOR EACH ROW
                    BEGIN
                        INSERT INTO match_registration_history
                        (match_registration_id, match_id, player_id, status, excuse_reason,
                         excuse_note, admin_note, team, original_timestamp, created_by,
                         action, changed_at)
                        VALUES
                        (NEW.id, NEW.match_id, NEW.player_id, NEW.status, NEW.excuse_reason,
                         NEW.excuse_note, NEW.admin_note, NEW.team, NEW.timestamp, NEW.created_by,
                         'UPDATE', NOW());
                    END
                    """);
            System.out.println("Trigger created successfully.");
        } catch (Exception e) {
            System.out.println("Trigger already exists or error: " + e.getMessage());
        }

        try {
            jdbcTemplate.execute("""
        CREATE TRIGGER trg_match_reg_delete
        AFTER DELETE ON match_registrations
        FOR EACH ROW
                BEGIN
        INSERT INTO match_registration_history
                (match_registration_id, match_id, player_id, status, excuse_reason,
                        excuse_note, admin_note, team, original_timestamp, created_by,
                        action, changed_at)
        VALUES
                (OLD.id, OLD.match_id, OLD.player_id, OLD.status, OLD.excuse_reason,
                        OLD.excuse_note, OLD.admin_note, OLD.team, OLD.timestamp, OLD.created_by,
                        'DELETE', NOW());
        END
        """);
            System.out.println("Trigger created successfully.");
                } catch (Exception e) {
                    System.out.println("Trigger already exists or error: " + e.getMessage());
                }
        
        System.out.println("Data initialization completed.");
    

    }
}





# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\GlobalExceptionHandler.java


package cz.phsoft.hokej.config;

import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.exceptions.ApiError;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import jakarta.servlet.http.HttpServletRequest;

@ControllerAdvice
public class GlobalExceptionHandler {

    // VlastnƒÇ¬≠ business vyjƒÇ¬≠mky - BusinessException
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ApiError> handleBusinessException(
            BusinessException ex,
            HttpServletRequest request) {

        ApiError error = new ApiError(
                ex.getStatus().value(),
                ex.getStatus().getReasonPhrase(),
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()
        );
        return ResponseEntity.status(ex.getStatus()).body(error);
    }

    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ApiError> handleAccessDenied(AccessDeniedException ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.FORBIDDEN.value(),
                "Forbidden",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // √¢‚Ä†¬ê IP klienta);
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(error);
    }

    // --- NenalezenƒÇ¬© zdroje (404) ---
    @ExceptionHandler({
            MatchNotFoundException.class,
            PlayerNotFoundException.class,
            RegistrationNotFoundException.class
    })
    public ResponseEntity<ApiError> handleNotFound(RuntimeException ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.NOT_FOUND.value(),
                "Not Found",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // √¢‚Ä†¬ê IP klienta
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    // --- Konflikty (409) ---
    @ExceptionHandler(DuplicateRegistrationException.class)
    public ResponseEntity<ApiError> handleConflict(DuplicateRegistrationException ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.CONFLICT.value(),
                "Conflict",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // √¢‚Ä†¬ê IP klienta);
        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
    }

    // --- ObecnƒÇ¬© chyby (500) ---
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiError> handleAll(Exception ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // √¢‚Ä†¬ê IP klienta);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\SecurityConfig.java


package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.security.config.http.SessionCreationPolicy;


import java.util.List;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;

    @Value("${app.test-mode:false}")
    private boolean isTestMode;

    public SecurityConfig(CustomUserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    // Password encoder
    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    // Authentication provider
    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    // AuthenticationManager
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    // Security filter chain
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http, AuthenticationManager authManager) throws Exception {

        http.csrf(csrf -> csrf.disable())
                .cors(cors -> {
                });

        if (isTestMode) {
            // Test mode - vƒπÀáechno povoleno a HTTP Basic pro Postman
            http.authorizeHttpRequests(auth -> auth.anyRequest().permitAll())
                    .httpBasic();
        } else {
            // Produkce - REST login pƒπ‚Ñ¢es CustomJsonLoginFilter
            http
                    .authenticationProvider(authenticationProvider())
                    .authorizeHttpRequests(auth -> auth
                            .requestMatchers("/api/auth/register", "/api/auth/verify").permitAll()
                            .requestMatchers("/api/login").permitAll()
                            .requestMatchers("/api/logout").permitAll()
                            .requestMatchers("/api/matches").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/matches/upcoming", "/api/matches/past").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/matches/**").authenticated()
                            .requestMatchers("/api/players").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/players/**").authenticated()
                            .requestMatchers("/api/registrations/all",
                                    "/api/registrations/for-match/**",
                                    "/api/registrations/no-response/**").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/registrations/**").authenticated()
                            .requestMatchers("/api/inactivity/All",
                                    "/api/inactivity/**").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/inactivity/player/**").authenticated()
                            .anyRequest().authenticated()
                    )
                    //  TADY Pƒπ¬òESN√Ñ≈°
                    .sessionManagement(sm ->
                            sm.sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
                    )
                    //  a TEPRVE PAK login filter
                    .addFilterAt(
                            new CustomJsonLoginFilter("/api/login", authManager),
                            UsernamePasswordAuthenticationFilter.class
                    )
                    .logout(logout -> logout
                            .logoutUrl("/api/logout")
                            .deleteCookies("JSESSIONID")
                            .logoutSuccessHandler((request, response, auth) -> {
                                request.getSession().removeAttribute("CURRENT_PLAYER_ID");
                                response.setContentType("application/json");
                                response.setCharacterEncoding("UTF-8");
                                response.getWriter().write("{\"status\":\"ok\",\"message\":\"OdhlƒÇÀáƒπÀáeno\"}");
                            })
                    );
        }

        return http.build();
    }

    // CORS pro React dev server a cookies
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(List.of("http://localhost:5173"));
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AdminMatchController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.services.MatchService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/matches/admin")
@CrossOrigin(origins = "*")
public class AdminMatchController {
    private final MatchService matchService;
    private final CurrentPlayerService currentPlayerService;


    public AdminMatchController(MatchService matchService,
                           CurrentPlayerService currentPlayerService) {
        this.matchService = matchService;
        this.currentPlayerService = currentPlayerService;
    }

    // VƒπÀáechny zƒÇÀápasy
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getAllMatches() {
        return matchService.getAllMatches();
    }

    // VƒπÀáechny nadchƒÇÀázejƒÇ¬≠cƒÇ¬≠ zƒÇÀápasy
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    @GetMapping("/upcoming")
    public List<MatchDTO> getUpcomingMatches() {
        return matchService.getUpcomingMatches();
    }

    // Uƒπƒæ uskute√Ñ≈§n√Ñ‚Ä∫nƒÇ¬© zƒÇÀápasy
    @GetMapping("/past")
    public List<MatchDTO> getPastMatches() {
        return matchService.getPastMatches();
    }

    // Vytvoƒπ‚Ñ¢enƒÇ¬≠ zƒÇÀápasu
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public MatchDTO createMatch(@Valid @RequestBody MatchDTO matchDTO) {
        return matchService.createMatch(matchDTO);
    }

    // ZƒÇ¬≠skƒÇÀánƒÇ¬≠ zƒÇÀápasu podle ID
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO getMatch(@PathVariable Long id) {
        return matchService.getMatchById(id);
    }

    // Editace zƒÇÀápasu
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO updateMatch(@PathVariable Long id, @Valid @RequestBody MatchDTO dto) {
        return matchService.updateMatch(id, dto);
    }

    // SmazƒÇÀánƒÇ¬≠ zƒÇÀápasu
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SuccessResponseDTO> deleteMatch(@PathVariable Long id) {
        SuccessResponseDTO response = matchService.deleteMatch(id);
        return ResponseEntity.ok(response);
    }

    // DostupnƒÇ¬© zƒÇÀápasy pro hrƒÇÀá√Ñ≈§e
    @GetMapping("/available-for-player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getAvailableMatchesForPlayer(@PathVariable Long playerId) {
        return matchService.getAvailableMatchesForPlayer(playerId);
    }

}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AdminMatchRegistrationController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/registrations/admin")
@CrossOrigin(origins = "*")
public class AdminMatchRegistrationController {
    private final MatchRegistrationService service;
    private final CurrentPlayerService currentPlayerService;

    public AdminMatchRegistrationController(MatchRegistrationService service,
                                       CurrentPlayerService currentPlayerService) {
        this.service = service;
        this.currentPlayerService = currentPlayerService;
    }

    @GetMapping("/all")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> getAllRegistrations() {
        return service.getAllRegistrations();
    }
    @GetMapping("/for-match/{matchId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> forMatch(@PathVariable Long matchId) {
        return service.getRegistrationsForMatch(matchId);
    }

    @GetMapping("/for-player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> forPlayer(@PathVariable Long playerId) {
        return service.getRegistrationsForPlayer(playerId);
    }
    @GetMapping("/no-response/{matchId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getNoResponse(@PathVariable Long matchId) {
        return service.getNoResponsePlayers(matchId);
    }


    // UNIVERZƒÇ¬ÅLNƒÇ≈§ ENDPOINT PRO REGISTRACE - za hrƒÇÀá√Ñ≈§e


    @PostMapping("/upsert/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchRegistrationDTO upsert(@PathVariable Long playerId, @RequestBody MatchRegistrationRequest request) {

        return service.upsertRegistration(
                request.getMatchId(),
                request.getPlayerId(), // vybranƒÇÀù hrƒÇÀá√Ñ≈§
                request.getTeam(),
                request.getAdminNote(),
                request.getExcuseReason(),
                request.getExcuseNote(),
                request.isUnregister()
        );
    }

}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AdminPlayerController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.services.PlayerService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/players/admin")
@CrossOrigin(origins = "*")
public class AdminPlayerController {

    private final PlayerService playerService;
    private final CurrentPlayerService currentPlayerService;

    public AdminPlayerController(PlayerService playerService, CurrentPlayerService currentPlayerService) {
        this.playerService = playerService;
        this.currentPlayerService = currentPlayerService;
    }
    // vƒπÀáichni hrƒÇÀá√Ñ≈§i
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getAllPlayers() {
        return playerService.getAllPlayers();
    }

    // hrƒÇÀá√Ñ≈§ dle id

    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public PlayerDTO getPlayerById(@PathVariable Long id) {
        return playerService.getPlayerById(id);
    }

    // vytvoƒπ‚Ñ¢enƒÇ¬≠ hrƒÇÀá√Ñ≈§e
    @PostMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
        public PlayerDTO createPlayer(@RequestBody PlayerDTO playerDTO) {
        return playerService.createPlayer(playerDTO);
    }

    // ƒÇ≈üprava hrƒÇÀá√Ñ≈§e administrƒÇÀátorem dle id hrƒÇÀá√Ñ≈§e
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public PlayerDTO upatePlayerAdmin(@PathVariable Long id,  @RequestBody PlayerDTO dto) {

        return playerService.updatePlayer(id, dto);
    }
    // odstranƒÇ¬≠ hrƒÇÀá√Ñ≈§e
    @PreAuthorize("hasRole('ADMIN')")
    @DeleteMapping("/{id}")
    public ResponseEntity<SuccessResponseDTO> deletePlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.deletePlayer(id);
        return ResponseEntity.ok(response);
    }

    //
    // SCHVƒÇ¬ÅLENƒÇ≈§ HRƒÇ¬Å√Ñ≈öE
    @PreAuthorize("hasRole('ADMIN')")
    @PutMapping("/approve/{id}")
    public ResponseEntity<SuccessResponseDTO> approvePlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.approvePlayer(id);
        return ResponseEntity.ok(response);

    }
    // ZAMƒÇ≈§TNUTƒÇ≈§ HRƒÇ¬Å√Ñ≈öE
    @PreAuthorize("hasRole('ADMIN')")
    @PutMapping("/reject/{id}")
    public ResponseEntity<SuccessResponseDTO> rejectPlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.rejectPlayer(id);
        return ResponseEntity.ok(response);

    }





}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AppUserController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.ChangePasswordDTO;
import cz.phsoft.hokej.models.services.AppUserService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/users")
@CrossOrigin(origins = "*")
public class AppUserController {

    private final AppUserService appUserService;

    public AppUserController(AppUserService appUserService) {
        this.appUserService = appUserService;
    }

    // Pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇÀù uƒπƒæivatel √¢‚Ç¨‚Äú bezpe√Ñ≈§nƒÇ¬©
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public AppUserDTO getCurrentUser(Authentication authentication) {
        return appUserService.getCurrentUser(authentication.getName());
    }

    // Zm√Ñ‚Ä∫na hesla pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬©ho uƒπƒæivatele
    @PostMapping("/me/change-password")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> changePassword(Authentication authentication,
                                                 @RequestBody ChangePasswordDTO dto) {
        String email = authentication.getName();
        appUserService.changePassword(email, dto.getOldPassword(), dto.getNewPassword(), dto.getNewPasswordConfirm());
        return ResponseEntity.ok("Heslo ƒÇ≈üsp√Ñ‚Ä∫ƒπÀán√Ñ‚Ä∫ zm√Ñ‚Ä∫n√Ñ‚Ä∫no");
    }

    // Zm√Ñ‚Ä∫na pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬©ho uƒπƒæivatele
    @PutMapping("/me/update")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> updateUser(Authentication authentication,
                                                 @RequestBody AppUserDTO dto) {
        String email = authentication.getName();
        appUserService.updateUser(email, dto);

        return ResponseEntity.ok("uƒπƒæivatel byl zm√Ñ‚Ä∫n√Ñ‚Ä∫n");
    }


    // reset hesla uƒπƒæivatele
    @PostMapping("/{id}/reset-password")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<String> resetPassword(@PathVariable Long id) {
        appUserService.resetPassword(id);
        return ResponseEntity.ok("Heslo resetovƒÇÀáno na 'Player123'");
    }

    // Seznam vƒπÀáech uƒπƒæivatelƒπ≈ª √¢‚Ç¨‚Äú jen ADMIN
    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    public List<AppUserDTO> getAllUsers() {
        return appUserService.getAllUsers();
    }


}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AuthController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.EmailVerificationTokenEntity;
import cz.phsoft.hokej.data.repositories.EmailVerificationTokenRepository;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;
import cz.phsoft.hokej.models.services.AppUserService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/api/auth")
@CrossOrigin(origins = "*")
public class AuthController {

    private final AppUserService appUserService;
    private final AppUserRepository userRepository;
    private final EmailVerificationTokenRepository tokenRepository;

    public AuthController(AppUserService appUserService,
                          AppUserRepository userRepository,
                          EmailVerificationTokenRepository tokenRepository) {
        this.appUserService = appUserService;
        this.userRepository = userRepository;
        this.tokenRepository = tokenRepository;
    }

    // ===== Registrace =====
    @PostMapping("/register")
    public ResponseEntity<?> register(@Valid @RequestBody RegisterUserDTO dto) {
        appUserService.register(dto);
        return ResponseEntity.ok(
                Map.of("status", "ok", "message", "Registrace ƒÇ≈üsp√Ñ‚Ä∫ƒπÀánƒÇÀá. Zkontrolujte email pro aktivaci ƒÇ≈ü√Ñ≈§tu.")
        );
    }

    // ===== ZƒÇ¬≠skƒÇÀánƒÇ¬≠ aktuƒÇÀálnƒÇ¬≠ho uƒπƒæivatele =====
    @GetMapping("/me")
    public ResponseEntity<AppUserDTO> getCurrentUser(Authentication authentication) {
        AppUserDTO dto = appUserService.getCurrentUser(authentication.getName());
        return ResponseEntity.ok(dto);
    }

    // ===== Aktivace ƒÇ≈ü√Ñ≈§tu =====
    @GetMapping("/verify")
    public ResponseEntity<String> verifyEmail(@RequestParam String token) {
        Optional<EmailVerificationTokenEntity> optionalToken = tokenRepository.findByToken(token);

        if (optionalToken.isEmpty()) {
            return ResponseEntity.badRequest().body("NeplatnƒÇÀù aktiva√Ñ≈§nƒÇ¬≠ odkaz.");
        }

        EmailVerificationTokenEntity verificationToken = optionalToken.get();

        if (verificationToken.getExpiresAt().isBefore(LocalDateTime.now())) {
            return ResponseEntity.badRequest().body("Aktiva√Ñ≈§nƒÇ¬≠ odkaz vyprƒπÀáel.");
        }

        AppUserEntity user = verificationToken.getUser();
        user.setEnabled(true);
        userRepository.save(user);

        tokenRepository.delete(verificationToken);

        return ResponseEntity.ok("ƒÇ≈°√Ñ≈§et byl ƒÇ≈üsp√Ñ‚Ä∫ƒπÀán√Ñ‚Ä∫ aktivovƒÇÀán.");
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\CurrentPlayerController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.services.PlayerService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import jakarta.servlet.http.HttpSession;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

// aktuƒÇÀálnƒÇ¬≠ hrƒÇÀá√Ñ≈§
@RestController
@RequestMapping("/api/current-player")
public class CurrentPlayerController {

    private final PlayerRepository playerRepository;
    private final AppUserRepository appUserRepository;
    private final CurrentPlayerService currentPlayerService;
    private final PlayerService playerService;

    public CurrentPlayerController(PlayerRepository playerRepository,
                                   AppUserRepository appUserRepository,
                                   CurrentPlayerService currentPlayerService,
                                   PlayerService playerService) {
        this.playerRepository = playerRepository;
        this.appUserRepository = appUserRepository;
        this.currentPlayerService = currentPlayerService;
        this.playerService = playerService;
    }

    // -----------------------------------------------------
    // NastavenƒÇ¬≠ aktuƒÇÀálnƒÇ¬≠ho hrƒÇÀá√Ñ≈§e √¢‚Ç¨‚Äú pokud uƒπƒæivatel mƒÇÀá jen jednoho, vybere se automaticky
    // -----------------------------------------------------
    @PostMapping("/{playerId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> setCurrentPlayer(@PathVariable Long playerId,
                                 Authentication auth,
                                 HttpSession session) {

        AppUserEntity user = appUserRepository.findByEmail(auth.getName())
                .orElseThrow(() -> new RuntimeException("User not found"));

        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new RuntimeException("Player not found"));

        if (!player.getUser().getId().equals(user.getId())) {
            throw new RuntimeException("Player does not belong to user");
        }

        currentPlayerService.setCurrentPlayerId(player.getId());
        return ResponseEntity.ok("AktuƒÇÀálnƒÇ¬≠ hrƒÇÀá√Ñ≈§ nastaven na ID: " + player.getId());
    }

    // -----------------------------------------------------
    // AutomatickƒÇÀù vƒÇÀùb√Ñ‚Ä∫r aktuƒÇÀálnƒÇ¬≠ho hrƒÇÀá√Ñ≈§e po loginu
    // Zavolat z frontendu /api/current-player/auto-select po pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬≠
    // -----------------------------------------------------
    @PostMapping("/auto-select")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> autoSelectCurrentPlayer(Authentication auth) {
        AppUserEntity user = appUserRepository.findByEmail(auth.getName())
                .orElseThrow(() -> new RuntimeException("User not found"));

        List<PlayerDTO> players = playerService.getPlayersByUser(user.getEmail());

        if (players.size() == 1) {
            PlayerDTO player = players.get(0);
            currentPlayerService.setCurrentPlayerId(player.getId());
            return ResponseEntity.ok("Automaticky nastaven hrƒÇÀá√Ñ≈§ nastaven na ID: " + player.getId());
        } else {
            return ResponseEntity.ok("Uƒπƒæivatel mƒÇÀá vƒÇ¬≠ce hrƒÇÀá√Ñ≈§ƒπ≈ª, vƒÇÀùb√Ñ‚Ä∫r nutnƒÇÀù ru√Ñ≈§n√Ñ‚Ä∫");
        }
    }

    // -----------------------------------------------------
    // ZƒÇ¬≠skƒÇÀánƒÇ¬≠ aktuƒÇÀálnƒÇ¬≠ho hrƒÇÀá√Ñ≈§e
    // -----------------------------------------------------
    @GetMapping
    @PreAuthorize("isAuthenticated()")
    public PlayerDTO getCurrentPlayer(HttpSession session) {

        Long playerId = currentPlayerService.getCurrentPlayerId();
        if (playerId == null) {
            System.out.println("ƒπÀùƒÇÀádnƒÇÀù aktuƒÇÀálnƒÇ¬≠ hrƒÇÀá√Ñ≈§");
            return null;
        }

        PlayerDTO player = playerService.getPlayerById(playerId);
        System.out.println("AktuƒÇÀálnƒÇ¬≠ hrƒÇÀá√Ñ≈§ ID: " + playerId);
        return player;
    }

    // -----------------------------------------------------
    // PomocnƒÇÀù endpoint √¢‚Ç¨‚Äú seznam hrƒÇÀá√Ñ≈§ƒπ≈ª aktuƒÇÀálnƒÇ¬≠ho uƒπƒæivatele
    // -----------------------------------------------------
    @GetMapping("/my-players")
    @PreAuthorize("isAuthenticated()")
    public List<PlayerDTO> getMyPlayers(Authentication auth, HttpSession session) {
        AppUserEntity user = appUserRepository.findByEmail(auth.getName())
                .orElseThrow(() -> new RuntimeException("User not found"));

        List<PlayerDTO> players = playerService.getPlayersByUser(user.getEmail());

        System.out.println("Seznam hrƒÇÀá√Ñ≈§ƒπ≈ª uƒπƒæivatele " + user.getEmail() + ": " +
                players.stream().map(PlayerDTO::getId).toList());

        return players;
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\DebugController.java


package cz.phsoft.hokej.controllers;

import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class DebugController {

    @GetMapping("/api/debug/me")
    public Object me(Authentication auth) {
        return auth;
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\MatchController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;
import cz.phsoft.hokej.models.dto.MatchOverviewDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.services.MatchService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;


@RestController
@RequestMapping("/api/matches")
@CrossOrigin(origins = "*")
public class MatchController {

    private final MatchService matchService;
    private final CurrentPlayerService currentPlayerService;


    public MatchController(MatchService matchService,
                           CurrentPlayerService currentPlayerService) {
        this.matchService = matchService;
        this.currentPlayerService = currentPlayerService;
    }

    // Detail zƒÇÀápasu
    @PreAuthorize("isAuthenticated()")
    @GetMapping("/matchDetail/{id}")
    public MatchDetailDTO getMatchDetail(@PathVariable Long id) {
        return matchService.getMatchDetail(id);
    }

    // NadchƒÇÀázejƒÇ¬≠cƒÇ¬≠ zƒÇÀápas - NEPOUƒπÀùƒÇ≈§VAT - NENƒÇ≈§ TAM PLAYER TYPE
    @PreAuthorize("isAuthenticated()")
    @GetMapping("/next")
    public MatchDTO getNextMatch() {
        return matchService.getNextMatch();
    }

    // NadchƒÇÀázejƒÇ¬≠cƒÇ¬≠ zƒÇÀápasy pro pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬©ho hrƒÇÀá√Ñ≈§e
    @GetMapping("/me/upcoming")
    @PreAuthorize("isAuthenticated()")
    public List<MatchDTO> getUpcomingMatchesForMe(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getUpcomingMatchesForPlayer(currentPlayerId);
    }

    @GetMapping("/me/upcoming-overview")
    @PreAuthorize("isAuthenticated()")
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForMe(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getUpcomingMatchesOverviewForPlayer(currentPlayerId);
    }

    @GetMapping("/me/all-passed")
    @PreAuthorize("isAuthenticated()")
    public List<MatchOverviewDTO> getAllMatchesForPlayer(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getAllPassedMatchesForPlayer(currentPlayerId);
    }





}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\MatchRegistrationController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import org.springframework.web.bind.annotation.*;
import org.springframework.security.access.prepost.PreAuthorize;

import java.util.List;

@RestController
@RequestMapping("/api/registrations")
@CrossOrigin(origins = "*")
public class MatchRegistrationController {

    private final MatchRegistrationService service;
    private final CurrentPlayerService currentPlayerService;

    public MatchRegistrationController(MatchRegistrationService service,
                                       CurrentPlayerService currentPlayerService) {
        this.service = service;
        this.currentPlayerService = currentPlayerService;
    }


    // UNIVERZƒÇ¬ÅLNƒÇ≈§ ENDPOINT PRO REGISTRACE


    @PostMapping("/me/upsert")
    @PreAuthorize("isAuthenticated()")
    public MatchRegistrationDTO upsert(@RequestBody MatchRegistrationRequest request) {
        // automaticky bere vybranƒÇ¬©ho hrƒÇÀá√Ñ≈§e
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        return service.upsertRegistration(
                request.getMatchId(),
                currentPlayerId, // vƒπƒædy aktuƒÇÀálnƒÇ¬≠ hrƒÇÀá√Ñ≈§
                request.getTeam(),
                request.getAdminNote(),
                request.getExcuseReason(),
                request.getExcuseNote(),
                request.isUnregister()
        );
    }

    // registrace na zƒÇÀápasy pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬©ho hrƒÇÀá√Ñ≈§e
    @GetMapping("/me/for-current-player")
    @PreAuthorize("isAuthenticated()")
    public List<MatchRegistrationDTO> forCurrentPlayer() {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return service.getRegistrationsForPlayer(currentPlayerId);
    }


}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.PlayerService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/players")
@CrossOrigin(origins = "*")
public class PlayerController {

    private final PlayerService playerService;
    private final CurrentPlayerService currentPlayerService;

    public PlayerController(PlayerService playerService, CurrentPlayerService currentPlayerService) {
        this.playerService = playerService;
        this.currentPlayerService = currentPlayerService;
    }

    // vytvoƒπ‚Ñ¢enƒÇ¬≠ hrƒÇÀá√Ñ≈§e pro pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬©ho uƒπƒæivatele
    @PostMapping("/me")
    @PreAuthorize("isAuthenticated()") // kaƒπƒædƒÇÀù pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇÀù uƒπƒæivatel
    public PlayerDTO createMyPlayer(@RequestBody PlayerDTO playerDTO, Authentication authentication) {
        String email = authentication.getName(); // email pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬©ho uƒπƒæivatele
        return playerService.createPlayerForUser(playerDTO, email);
    }

    // zƒÇ¬≠skƒÇÀánƒÇ¬≠ hrƒÇÀá√Ñ≈§ƒπ≈ª pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬©ho uƒπƒæivatele
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public List<PlayerDTO> getMyPlayers(Authentication authentication) {
        String email = authentication.getName();
        return playerService.getPlayersByUser(email);
    }

    // ƒÇ≈üprava hrƒÇÀá√Ñ≈§e pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬©ho uƒπƒæivatele
    @PutMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public PlayerDTO updatePlayer(@RequestBody PlayerDTO dto) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        return playerService.updatePlayer(currentPlayerId, dto);
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerInactivityPeriodController.java


package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import cz.phsoft.hokej.models.services.PlayerInactivityPeriodService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/inactivity/Admin")
@CrossOrigin(origins = "*")
public class PlayerInactivityPeriodController {

    private final PlayerInactivityPeriodService service;

    public PlayerInactivityPeriodController(PlayerInactivityPeriodService service) {
        this.service = service;
    }

    // vƒπÀáechny zƒÇÀáznamy o neaktivit√Ñ‚Ä∫ hrƒÇÀá√Ñ≈§ƒπ≈ª
    @GetMapping("/all")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getAll() {
        return service.getAll();
    }

    // neaktivita hrƒÇÀá√Ñ≈§ƒπ≈ª dle id neaktivity
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<PlayerInactivityPeriodDTO> getById(@PathVariable Long id) {
        PlayerInactivityPeriodDTO dto = service.getById(id);
        return ResponseEntity.ok(dto);
    }

    // zƒÇ¬≠skƒÇÀá zƒÇÀáznamy o period√Ñ‚Ä∫ neaktivity dle id hrƒÇÀá√Ñ≈§e
    @GetMapping("/player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getByPlayer(@PathVariable Long playerId) {
        return service.getByPlayer(playerId);
    }

    // vytvoƒπ‚Ñ¢ƒÇ¬≠ zƒÇÀáznam o neaktivit√Ñ‚Ä∫ hrƒÇÀá√Ñ≈§e
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<PlayerInactivityPeriodDTO> create(@RequestBody PlayerInactivityPeriodDTO dto) {
        PlayerInactivityPeriodDTO created = service.create(dto);
        return ResponseEntity.ok(created);
    }

    // zm√Ñ‚Ä∫nƒÇ¬≠ zƒÇÀáznam o neaktivit√Ñ‚Ä∫ hrƒÇÀá√Ñ≈§e dle id
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<PlayerInactivityPeriodDTO> update(
            @PathVariable Long id,
            @RequestBody PlayerInactivityPeriodDTO dto) {

        PlayerInactivityPeriodDTO updated = service.update(id, dto);
        return ResponseEntity.ok(updated);
    }

    // vymaƒπƒæe zƒÇÀáznam o neaktivit√Ñ‚Ä∫ hrƒÇÀá√Ñ≈§e dle id zƒÇÀáznamu
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        service.delete(id);
        return ResponseEntity.noContent().build();
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestController.java


package cz.phsoft.hokej.controllers;

import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/test")
@CrossOrigin(origins = "*")
public class TestController {

    @GetMapping
    public String hello() {
        return "Backend je online!";
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestEmailController.java


package cz.phsoft.hokej.controllers;


import cz.phsoft.hokej.models.services.email.EmailService;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/email/test")
public class TestEmailController {
    private final EmailService emailService;

    public TestEmailController(EmailService emailService) {
        this.emailService = emailService;
    }

    @PostMapping("/send-mail")
    public String sendTestMail() {
        emailService.sendSimpleEmail(
                "petrhlista@seznam.cz",
                "APP - TestovacƒÇ¬≠ email",
                "Ahoj, toto je test z backendu."
        );
        return "Email odeslƒÇÀán";
    }

}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestSmsController.java


/*
package cz.phsoft.hokej.controllers;


import cz.phsoft.hokej.models.services.sms.SmsTextBeeService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TestSmsController {

    private final SmsTextBeeService smsTextBeeService;

    public TestSmsController(SmsTextBeeService smsTextBeeService) {
        this.smsTextBeeService = smsTextBeeService;
    }

    /**
     * TestovacƒÇ¬≠ endpoint pro odeslƒÇÀánƒÇ¬≠ SMS na testovacƒÇ¬≠ √Ñ≈§ƒÇ¬≠slo.
     * Zavolej: GET /api/test-sms
     */
/*
    @GetMapping("/api/test-sms")
    public String sendTestSms() {
        smsTextBeeService.sendSms("+420776609956", "testovacƒÇ¬≠ sms app-sg");
        return "SMS byla odeslƒÇÀána na testovacƒÇ¬≠ √Ñ≈§ƒÇ¬≠slo +420776609956";
    }
}

        */


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\AppUserEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.Role;
import jakarta.persistence.*;

import java.util.Set;

@Entity
@Table(name = "app_users")
public class AppUserEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String surname;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role;

    @Column(nullable = false)
    private boolean enabled = false; // vƒÇÀùchozƒÇ¬≠ hodnota false


    // One-to-Many: jeden uƒπƒæivatel √¢‚Ä†‚Äô vƒÇ¬≠ce hrƒÇÀá√Ñ≈§ƒπ≈ª
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<PlayerEntity> players;

    // gettery/settery


    public Long getId() {return id;}

    public void setId(Long id) {this.id = id;}

    public String getName() {return name;}

    public void setName(String name) {this.name = name;}

    public String getSurname() { return surname; }

    public void setSurname(String surname) { this.surname = surname; }

    public String getEmail() {return email;}

    public void setEmail(String email) {this.email = email;}

    public String getPassword() {return password;}

    public void setPassword(String password) {this.password = password;}

    public Role getRole() {return role;}

    public void setRole(Role role) {this.role = role;}

    public boolean isEnabled() {    return enabled;    }

    public void setEnabled(boolean enabled) {  this.enabled = enabled;    }

    public Set<PlayerEntity> getPlayers() {return players;}

    public void setPlayers(Set<PlayerEntity> players) {this.players = players;}
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\EmailVerificationTokenEntity.java


package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDateTime;


@Entity
@Table(name = "email_verification_tokens")
public class EmailVerificationTokenEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 64)
    private String token;

    @Column(nullable = false)
    private LocalDateTime expiresAt;

    @OneToOne
    @JoinColumn(name = "user_id", nullable = false)
    private AppUserEntity user;

    // gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getToken() { return token; }
    public void setToken(String token) { this.token = token; }

    public LocalDateTime getExpiresAt() { return expiresAt; }
    public void setExpiresAt(LocalDateTime expiresAt) { this.expiresAt = expiresAt; }

    public AppUserEntity getUser() { return user; }
    public void setUser(AppUserEntity user) { this.user = user; }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchEntity.java


package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;
import java.time.LocalDateTime;

/**
 * tƒπ‚Ñ¢ƒÇ¬≠da pro vklƒÇÀádƒÇÀánƒÇ¬≠ Entity zƒÇÀápasu do db
 */
@Entity
@Table(name = "matches")
public class MatchEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private LocalDateTime dateTime;

    @Column(nullable = false)
    private String location;

    private String description;

    // maximƒÇÀálnƒÇ¬≠ po√Ñ≈§et hrƒÇÀá√Ñ≈§ƒπ≈ª - vyuƒπƒæƒÇ¬≠vƒÇÀá se pro ov√Ñ‚Ä∫ƒπ‚Ñ¢enƒÇ¬≠ kapacity pƒπ‚Ñ¢i pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬≠
    @Column(nullable = false)
    private Integer maxPlayers;

    @Column(nullable = false)
    private Integer price;

    public MatchEntity() {}

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }

    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() { return price; }

    public void setPrice(Integer price) { this.price = price; }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * tƒπ‚Ñ¢ƒÇ¬≠da reprezentuje registracei hrƒÇÀá√Ñ≈§e k zƒÇÀápasu
 */
@Entity
@Table(name = "match_registrations")
public class MatchRegistrationEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "match_id", nullable = false)
    private MatchEntity match;

    @ManyToOne
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerMatchStatus status;

    @Enumerated(EnumType.STRING)
    private ExcuseReason excuseReason;

    private String excuseNote;

    // admin mƒπ≈ªƒπƒæe vloƒπƒæit poznƒÇÀámku, napƒπ‚Ñ¢. kdyƒπƒæ se n√Ñ‚Ä∫kdo zaregistruje a potƒÇ¬© nepƒπ‚Ñ¢ƒÇ¬≠jde
    private String adminNote;

    @Enumerated(EnumType.STRING)
    @Column(name = "team")
    private Team team;

    // dat√Ñ≈§as vytvoƒπ‚Ñ¢enƒÇ¬≠ registrace - musƒÇ¬≠ se m√Ñ‚Ä∫nit aby nebyl hrƒÇÀá√Ñ≈§ i po zruƒπÀáenƒÇ¬≠ registrace
    // v poƒπ‚Ñ¢adƒÇ¬≠ pƒπ‚Ñ¢ed hrƒÇÀá√Ñ≈§i kteƒπ‚Ñ¢ƒÇ¬≠ se registrovali po zruƒπÀáenƒÇ¬≠ registrace
    @Column(nullable = false, updatable = true)
    private LocalDateTime timestamp = LocalDateTime.now();

    // systƒÇ¬©m automaticky vytvƒÇÀáƒπ‚Ñ¢ƒÇ¬≠ reserved/registered dle kapacity - maxPlayers
    @Column(nullable = false, updatable = true)
    private String createdBy; // "user" nebo "system"

    public MatchRegistrationEntity() {
    }

    // Gettery a Settery


    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public MatchEntity getMatch() {
        return match;
    }

    public void setMatch(MatchEntity match) {
        this.match = match;
    }

    public PlayerEntity getPlayer() {
        return player;
    }

    public void setPlayer(PlayerEntity player) {
        this.player = player;
    }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }

    public ExcuseReason getExcuseReason() {
        return excuseReason;
    }

    public void setExcuseReason(ExcuseReason excuseReason) {
        this.excuseReason = excuseReason;
    }

    public String getExcuseNote() {
        return excuseNote;
    }

    public void setExcuseNote(String excuseNote) {
        this.excuseNote = excuseNote;
    }

    public String getAdminNote() {
        return adminNote;
    }

    public void setAdminNote(String adminNote) {
        this.adminNote = adminNote;
    }

    public Team getTeam() {
        return team;
    }

    public void setTeam(Team team) {
        this.team = team;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }
}





# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationHistoryEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.persistence.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "match_registration_history")
public class MatchRegistrationHistoryEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // ID z pƒπ≈ªvodnƒÇ¬≠ hlavnƒÇ¬≠ tabulky
    @Column(name = "match_registration_id", nullable = false)
    private Long matchRegistrationId;

    @Column(name = "match_id", nullable = false)
    private Long matchId;

    @Column(name = "player_id", nullable = false)
    private Long playerId;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerMatchStatus status;

    @Enumerated(EnumType.STRING)
    @Column(name = "excuse_reason")
    private ExcuseReason excuseReason;

    @Column(name = "excuse_note")
    private String excuseNote;

    @Column(name = "admin_note")
    private String adminNote;

    @Enumerated(EnumType.STRING)
    @Column(name = "team")
    private Team team;

    // pƒπ≈ªvodnƒÇ¬≠ timestamp
    @Column(name = "original_timestamp", nullable = false)
    private LocalDateTime originalTimestamp;

    @Column(name = "created_by", nullable = false)
    private String createdBy;

    @Column(nullable = false)
    private String action; // INSERT / UPDATE / DELETE

    @Column(name = "changed_at", nullable = false)
    private LocalDateTime changedAt;

    public MatchRegistrationHistoryEntity() {
    }

    // Gettery a settery


    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getMatchRegistrationId() {
        return matchRegistrationId;
    }

    public void setMatchRegistrationId(Long matchRegistrationId) {
        this.matchRegistrationId = matchRegistrationId;
    }

    public Long getMatchId() {
        return matchId;
    }

    public void setMatchId(Long matchId) {
        this.matchId = matchId;
    }

    public Long getPlayerId() {
        return playerId;
    }

    public void setPlayerId(Long playerId) {
        this.playerId = playerId;
    }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }

    public ExcuseReason getExcuseReason() {
        return excuseReason;
    }

    public void setExcuseReason(ExcuseReason excuseReason) {
        this.excuseReason = excuseReason;
    }

    public String getExcuseNote() {
        return excuseNote;
    }

    public void setExcuseNote(String excuseNote) {
        this.excuseNote = excuseNote;
    }

    public String getAdminNote() {
        return adminNote;
    }

    public void setAdminNote(String adminNote) {
        this.adminNote = adminNote;
    }

    public Team getTeam() {
        return team;
    }

    public void setTeam(Team team) {
        this.team = team;
    }

    public LocalDateTime getOriginalTimestamp() {
        return originalTimestamp;
    }

    public void setOriginalTimestamp(LocalDateTime originalTimestamp) {
        this.originalTimestamp = originalTimestamp;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }

    public String getAction() {
        return action;
    }

    public void setAction(String action) {
        this.action = action;
    }

    public LocalDateTime getChangedAt() {
        return changedAt;
    }

    public void setChangedAt(LocalDateTime changedAt) {
        this.changedAt = changedAt;
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerEntity.java


package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerType;
import jakarta.persistence.*;

@Entity
@Table(name = "player_entity")
public class PlayerEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String surname;

    private String nickName;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerType type; // VIP, STANDARD, BASIC

    private String fullName;
    private String phoneNumber;

    @Enumerated(EnumType.STRING)
    private Team team;

    @Enumerated(EnumType.STRING)
    private PlayerStatus status = PlayerStatus.PENDING;


    // Many-to-One: kaƒπƒædƒÇÀù hrƒÇÀá√Ñ≈§ patƒπ‚Ñ¢ƒÇ¬≠ jednomu uƒπƒæivateli
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private AppUserEntity user;

    // ----------------- Konstruktor -----------------
    public PlayerEntity() {
        this.type = PlayerType.BASIC;
    }

    public PlayerEntity(String name, String surname, String nickName, PlayerType type, String phoneNumber, Team team, PlayerStatus status) {
        this.name = name;
        this.surname = surname;
        this.nickName = nickName;
        this.type = type;
        this.fullName = name + " " + surname;
        this.phoneNumber = phoneNumber;
        this.team = team;
        this.status = status;
    }

    // ----------------- Gettery a Settery -----------------
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
        updateFullName();
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
        updateFullName();
    }

    public String getNickname() { return nickName;}
    public void setNickname(String nickName) { this.nickName = nickName; }

    public String getFullName() {
        return fullName;
    }

    public PlayerType getType() {
        return type;
    }
    public void setType(PlayerType type) {
        this.type = type;
    }

    private void updateFullName() {
        this.fullName = name + " " + surname;
    }

    public String getPhoneNumber() {
        return phoneNumber;
    }
    public void setPhoneNumber(String phoneNumber) {
        this.phoneNumber = phoneNumber;
    }

    public Team getTeam() {
        return team;
    }
    public void setTeam(Team team) {
        this.team = team;
    }

    public AppUserEntity getUser() {
        return user;
    }
    public void setUser(AppUserEntity user) {
        this.user = user;
    }

    public PlayerStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerStatus status) {
        this.status = status;
    }

    public String getNickName() {
        return nickName;
    }

    public void setNickName(String nickName) {
        this.nickName = nickName;
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerInactivityPeriodEntity.java


package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "player_inactivity_period")
public class PlayerInactivityPeriodEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    // neaktivnƒÇ¬≠ od
    @Column(name = "inactive_from", nullable = false)
    private LocalDateTime inactiveFrom;

    // neaktivnƒÇ¬≠ do
    @Column(name = "inactive_to", nullable = false)
    private LocalDateTime inactiveTo;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public PlayerEntity getPlayer() {
        return player;
    }

    public void setPlayer(PlayerEntity player) {
        this.player = player;
    }

    public LocalDateTime getInactiveFrom() {
        return inactiveFrom;
    }

    public void setInactiveFrom(LocalDateTime inactiveFrom) {
        this.inactiveFrom = inactiveFrom;
    }

    public LocalDateTime getInactiveTo() {
        return inactiveTo;
    }

    public void setInactiveTo(LocalDateTime inactiveTo) {
        this.inactiveTo = inactiveTo;
    }

}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\ExcuseReason.java


package cz.phsoft.hokej.data.enums;

public enum ExcuseReason {
    NEMOC,
    PRACE,
    NECHE_SE_MI,
    JINE
}



# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\PlayerMatchStatus.java


package cz.phsoft.hokej.data.enums;

public enum PlayerMatchStatus {
    REGISTERED, // registrovƒÇÀán
    UNREGISTERED, // odhlƒÇÀáƒπÀáen
    EXCUSED,  // omluven
    RESERVED, // nƒÇÀáhradnƒÇ¬≠k
    NO_RESPONSE, // bez odpov√Ñ‚Ä∫di
    NO_EXCUSED, // neomluven - byl registrovƒÇÀán a nepƒπ‚Ñ¢iƒπÀáel

}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\PlayerStatus.java


package cz.phsoft.hokej.data.enums;

public enum PlayerStatus {
    PENDING, // √Ñ≈§ekƒÇÀá na schvƒÇÀálenƒÇ¬≠
    APPROVED, // schvƒÇÀáleno administrƒÇÀátorem
    REJECTED // zamƒÇ¬≠tnuto
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\PlayerType.java


package cz.phsoft.hokej.data.enums;

public enum PlayerType {
    VIP,
    STANDARD,
    BASIC
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\Role.java


package cz.phsoft.hokej.data.enums;

public enum Role {
    ROLE_PLAYER,
    ROLE_MANAGER,
    ROLE_ADMIN
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\Team.java


package cz.phsoft.hokej.data.enums;

public enum Team {
    DARK,
    LIGHT

}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\AppUserRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface AppUserRepository extends JpaRepository<AppUserEntity, Long> {
    Optional<AppUserEntity> findByEmail(String email);
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\EmailVerificationTokenRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.EmailVerificationTokenEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface EmailVerificationTokenRepository extends JpaRepository<EmailVerificationTokenEntity, Long> {
    Optional<EmailVerificationTokenEntity> findByToken(String token);
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRegistrationHistoryRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchRegistrationHistoryEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface MatchRegistrationHistoryRepository extends JpaRepository<MatchRegistrationHistoryEntity, Long> {

    // vƒπÀáechny registrace na zƒÇÀápas
    List<MatchRegistrationHistoryEntity> findByMatchRegistrationIdOrderByChangedAtDesc(Long matchRegistrationId);

    // Historie pro konkrƒÇ¬©tnƒÇ¬≠ zƒÇÀápas
    List<MatchRegistrationHistoryEntity> findByMatchIdOrderByChangedAtDesc(Long matchId);

    // Historie zm√Ñ‚Ä∫n hrƒÇÀá√Ñ≈§e
    List<MatchRegistrationHistoryEntity> findByPlayerIdOrderByChangedAtDesc(Long playerId);

}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRegistrationRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

    @Repository
    public interface MatchRegistrationRepository extends JpaRepository<MatchRegistrationEntity, Long> {

        // VrƒÇÀátƒÇ¬≠ poslednƒÇ¬≠ status pro danƒÇ¬©ho hrƒÇÀá√Ñ≈§e a zƒÇÀápas
        Boolean existsByPlayerIdAndMatchId(Long playerId, Long matchId);

        // Voliteln√Ñ‚Ä∫: vƒπÀáechny registrace pro ur√Ñ≈§itƒÇÀù zƒÇÀápas
        List<MatchRegistrationEntity> findByMatchId(Long matchId);

        // Voliteln√Ñ‚Ä∫: vƒπÀáechny registrace pro ur√Ñ≈§itƒÇ¬©ho hrƒÇÀá√Ñ≈§e
        List<MatchRegistrationEntity> findByPlayerId(Long playerId);

        // --- NovƒÇÀá metoda pro hledƒÇÀánƒÇ¬≠ konkrƒÇ¬©tnƒÇ¬≠ registrace ---
        Optional<MatchRegistrationEntity> findByPlayerIdAndMatchId(Long playerId, Long matchId);

        long countByMatchIdAndStatus(Long matchId, PlayerMatchStatus status);

        List<MatchRegistrationEntity> findByMatchIdIn(List<Long> matchIds);
    }


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import java.time.LocalDateTime;
import java.util.List;

public interface MatchRepository extends JpaRepository<MatchEntity, Long> {
    List<MatchEntity> findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime dateTime);
    List<MatchEntity> findByDateTimeBeforeOrderByDateTimeDesc(LocalDateTime dateTime);
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\PlayerInactivityPeriodRepository.java



package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface PlayerInactivityPeriodRepository extends JpaRepository<PlayerInactivityPeriodEntity, Long> {

    // zjistƒÇ¬≠, zda hrƒÇÀá√Ñ≈§ je aktuƒÇÀáln√Ñ‚Ä∫ neaktivnƒÇ¬≠
    boolean existsByPlayerAndInactiveFromLessThanEqualAndInactiveToGreaterThanEqual(
            PlayerEntity player, LocalDateTime from, LocalDateTime to);

    // zƒÇ¬≠skƒÇÀá vƒπÀáechny neaktivnƒÇ¬≠ obdobƒÇ¬≠ hrƒÇÀá√Ñ≈§e, kterƒÇ¬© spadajƒÇ¬≠ do intervalu
    List<PlayerInactivityPeriodEntity> findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
            PlayerEntity player, LocalDateTime from, LocalDateTime to);

    List<PlayerInactivityPeriodEntity> findByPlayerOrderByInactiveFromAsc(PlayerEntity player);
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\PlayerRepository.java


package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface PlayerRepository extends JpaRepository<PlayerEntity, Long> {
    Optional<PlayerEntity> findById(Long id);

    List<PlayerEntity> findByIdNotIn(List<Long> ids);
    boolean existsByNameAndSurname(String name, String surname);

    Optional<PlayerEntity> findByNameAndSurname(String name, String surname);
    Optional<PlayerEntity> findByUserEmail(String email);
    List<PlayerEntity> findAllByUserEmail(String email);
    List<PlayerEntity> findByUser_EmailOrderByIdAsc(String email);
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\AccountNotActivatedException.java


package cz.phsoft.hokej.exceptions;

import org.springframework.http.HttpStatus;

public class AccountNotActivatedException extends BusinessException {

    public AccountNotActivatedException() {
        super("PrvnƒÇ¬≠ musƒÇ¬≠te aktivovat ƒÇ≈ü√Ñ≈§et pomocƒÇ¬≠ odkazu v emailu", HttpStatus.FORBIDDEN); // 403
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\ApiError.java


package cz.phsoft.hokej.exceptions;

import com.fasterxml.jackson.annotation.JsonFormat;
import java.time.LocalDateTime;
import java.util.Map;

public class ApiError {

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime timestamp;
    private int status;
    private String error;
    private String message;
    private String path;
    private String clientIp; // √¢‚Ä†¬ê nov√Ñ‚Ä∫

    // VolitelnƒÇ¬©: podrobnosti (validace, vƒÇ¬≠ce chyb, atd.)
    private Map<String, String> details;

    public ApiError(int status, String error, String message, String path,
                    String clientIp) {
        this.timestamp = LocalDateTime.now();
        this.status = status;
        this.error = error;
        this.message = message;
        this.path = path;
        this.clientIp = clientIp;
    }

    public ApiError(int status,
                            String error,
                            String message,
                            String path,
                            String clientIp,
                            Map<String, String> details) {
        this(status, error, message, path, clientIp);
        this.details = details;
    }

    public LocalDateTime getTimestamp() { return timestamp; }
    public int getStatus() { return status; }
    public String getError() { return error; }
    public String getMessage() { return message; }
    public String getPath() { return path; }
    public String getClientIp() { return clientIp; }
    public Map<String, String> getDetails() { return details; }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\BusinessException.java


package cz.phsoft.hokej.exceptions;

import org.springframework.http.HttpStatus;

public class BusinessException extends RuntimeException {

    private final HttpStatus status;

    protected BusinessException(String message, HttpStatus status) {
        super(message);
        this.status = status;
    }

    public HttpStatus getStatus() {
        return status;
    }
}



# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\DuplicateNameSurnameException.java


package cz.phsoft.hokej.exceptions;

public class DuplicateNameSurnameException extends RuntimeException {
    public DuplicateNameSurnameException(String message) {
        super(message);
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\DuplicateRegistrationException.java


package cz.phsoft.hokej.exceptions;

public class DuplicateRegistrationException extends RuntimeException {
    public DuplicateRegistrationException(Long matchId, Long playerId) {
        super("HrƒÇÀá√Ñ≈§ " + playerId + " jiƒπƒæ mƒÇÀá aktivnƒÇ¬≠ registraci na zƒÇÀápas " + matchId);
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\InvalidPlayerStatusException.java


package cz.phsoft.hokej.exceptions;

public class InvalidPlayerStatusException extends RuntimeException {
    public InvalidPlayerStatusException(String message) {
        super(message);
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\MatchNotFoundException.java


package cz.phsoft.hokej.exceptions;

public class MatchNotFoundException extends RuntimeException {
    public MatchNotFoundException(Long matchId) {
        super("ZƒÇÀápas s ID " + matchId + " nenalezen.");;
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\PlayerNotFoundException.java


package cz.phsoft.hokej.exceptions;

import org.springframework.http.HttpStatus;

public class PlayerNotFoundException extends BusinessException {
    public PlayerNotFoundException(Long playerId) {
        super("HrƒÇÀá√Ñ≈§ s ID " + playerId + " nenalezen.", HttpStatus.NOT_FOUND);}
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\RegistrationNotFoundException.java


package cz.phsoft.hokej.exceptions;

public class RegistrationNotFoundException extends RuntimeException {
    public RegistrationNotFoundException(Long matchId, Long playerId) {
        super("HrƒÇÀá√Ñ≈§ " + playerId + " nemƒÇÀá registraci na zƒÇÀápas " + matchId);
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\UserAlreadyExistsException.java


package cz.phsoft.hokej.exceptions;

import org.springframework.http.HttpStatus;

public class UserAlreadyExistsException extends BusinessException {

    public UserAlreadyExistsException(String message) {
        super(message, HttpStatus.CONFLICT); // 409
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\AppUserMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.PlayerSummaryDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

import java.util.List;

@Mapper(componentModel = "spring")
public interface AppUserMapper {
    @Mapping(target = "players", source = "players")
    AppUserDTO toDTO(AppUserEntity entity);

    List<AppUserDTO> toDtoList(List<AppUserEntity> entities);

    @Mapping(source = "nickname", target = "nickName")
    @Mapping(target = "fullName", ignore = true)
    PlayerDTO toPlayerDTO(PlayerEntity entity);
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\MatchMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchOverviewDTO;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;

@Mapper(componentModel = "spring")
public interface MatchMapper {

    MatchDTO toDTO(MatchEntity entity);

    MatchEntity toEntity(MatchDTO dto);

    void updateEntity(MatchDTO dto, @MappingTarget MatchEntity entity);
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\MatchRegistrationMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

import java.util.List;

@Mapper(componentModel = "spring")
public interface MatchRegistrationMapper {

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "match", source = "match")
    @Mapping(target = "player", source = "player")
    @Mapping(target = "status", source = "status")
    @Mapping(target = "excuseReason", source = "excuseReason")
    @Mapping(target = "excuseNote", source = "note")
    @Mapping(target = "team", source = "team")
    @Mapping(target = "adminNote", source = "adminNote")
    @Mapping(target = "createdBy", source = "createdBy")
    @Mapping(target = "timestamp", expression = "java(java.time.LocalDateTime.now())")
    MatchRegistrationEntity toEntity(
            MatchEntity match,
            PlayerEntity player,
            PlayerMatchStatus status,
            ExcuseReason excuseReason,
            String note,
            Team team,
            String adminNote,
            String createdBy
    );

    // entity √¢‚Ä†‚Äô DTO (volitelnƒÇ¬©)
    @Mapping(target = "matchId", source = "match.id")
    @Mapping(target = "playerId", source = "player.id")
    MatchRegistrationDTO toDTO(MatchRegistrationEntity entity);

    List<MatchRegistrationDTO> toDTOList(List<MatchRegistrationEntity> entities);
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\PlayerInactivityPeriodMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import org.mapstruct.*;

@Mapper(componentModel = "spring")
public interface PlayerInactivityPeriodMapper {

    // Entity -> DTO (OK)
    @Mapping(target = "playerId", source = "player.id")
    PlayerInactivityPeriodDTO toDTO(PlayerInactivityPeriodEntity entity);

    // DTO -> Entity (player ƒπ‚Ñ¢eƒπÀáƒÇ¬≠ @ObjectFactory)
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "player", ignore = true)
    PlayerInactivityPeriodEntity toEntity(PlayerInactivityPeriodDTO dto, @Context PlayerEntity player);

    // UPDATE DTO -> existujƒÇ¬≠cƒÇ¬≠ entity (bez zm√Ñ‚Ä∫ny player)
    @Mapping(target = "player", ignore = true)
    void updateEntityFromDto(PlayerInactivityPeriodDTO dto, @MappingTarget PlayerInactivityPeriodEntity entity);

    // FACTORY √¢‚Ç¨‚Äú jedinƒÇÀù sprƒÇÀávnƒÇÀù zpƒπ≈ªsob, jak nastavit player z @Context
    @ObjectFactory
    default PlayerInactivityPeriodEntity createEntity(PlayerInactivityPeriodDTO dto, @Context PlayerEntity player) {
        PlayerInactivityPeriodEntity entity = new PlayerInactivityPeriodEntity();
        entity.setPlayer(player);
        return entity;
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\PlayerMapper.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

import java.util.List;

@Mapper(componentModel = "spring")
public interface PlayerMapper {

        // Entity √¢‚Ä†‚Äô DTO (heslo se neposƒÇ¬≠lƒÇÀá)
        @Mapping(source = "nickname", target = "nickName")
        @Mapping(target = "fullName", ignore = true) // generuje se v DTO
        PlayerDTO toDTO(PlayerEntity entity);

        // DTO √¢‚Ä†‚Äô Entity (heslo se mapuje, pokud existuje)
        @Mapping(source = "nickName", target = "nickname")   // KLƒÇ≈§√Ñ≈öOVƒÇ‚Ä∞
        @Mapping(target = "fullName", ignore = true)         // generuje si Entity sama
        @Mapping(target = "user", ignore = true)             // nastavujeƒπÀá v service
        @Mapping(
                target = "status",
                expression = "java(dto.getStatus() != null ? dto.getStatus() : cz.phsoft.hokej.data.enums.PlayerStatus.PENDING)"
        )
        PlayerEntity toEntity(PlayerDTO dto);

        // Aktualizace existujƒÇ¬≠cƒÇ¬≠ho DTO (ignorujeme fullName)
        @Mapping(target = "fullName", ignore = true)
        @Mapping(target = "id", ignore = true)
        void updatePlayerDTO(PlayerDTO source, @MappingTarget PlayerDTO target);

        // Aktualizace existujƒÇ¬≠cƒÇ¬≠ Entity (heslo se mapuje, fullName nenƒÇ¬≠ pole v Entity)
        @Mapping(source = "nickName", target = "nickname")   // i tady je dƒπ≈ªleƒπƒæitƒÇ¬©
        @Mapping(target = "fullName", ignore = true)
        @Mapping(target = "user", ignore = true)
        @Mapping(
                target = "status",
                expression = "java(source.getStatus() != null ? source.getStatus() : target.getStatus())"
        )
        void updatePlayerEntity(PlayerDTO source, @MappingTarget PlayerEntity target);

    List<PlayerDTO> toDTOList(List<PlayerEntity> players);


}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\requests\MatchRegistrationRequest.java


package cz.phsoft.hokej.models.dto.requests;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.validation.constraints.*;


public class MatchRegistrationRequest {
    @NotNull
    @Positive
    private Long matchId;

    @NotNull
    @Positive
    private Long playerId;

    private Team team;
    private ExcuseReason excuseReason;
    private String excuseNote;
    private String adminNote;
    private boolean unregister;

    public Long getMatchId() { return matchId; }
    public Long getPlayerId() { return playerId; }
    public Team getTeam() { return team; }
    public ExcuseReason getExcuseReason() { return excuseReason; }
    public String getExcuseNote() { return excuseNote; }
    public String getAdminNote() { return adminNote; }
    public boolean isUnregister() { return unregister; }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\AppUserDTO.java


package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.util.Set;

public class AppUserDTO {
    private Long id;
    private String name; // not null
    private String surname;
    private String email;
    private Role role;
    private boolean enabled;
    private Set<PlayerDTO> players; // jednostrannƒÇ¬©


    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public Role getRole() {
        return role;
    }

    public void setRole(Role role) {
        this.role = role;
    }

    public boolean isEnabled() { return enabled; }

    public void setEnabled(boolean enabled) { this.enabled = enabled;}

    public Set<PlayerDTO> getPlayers() {
        return players;
    }

    public void setPlayers(Set<PlayerDTO> players) {
        this.players = players;
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\ChangePasswordDTO.java


package cz.phsoft.hokej.models.dto;

public class ChangePasswordDTO {
    private String oldPassword;
    private String newPassword;
    private String newPasswordConfirm;

    // gettery a settery
    public String getOldPassword() { return oldPassword; }
    public void setOldPassword(String oldPassword) { this.oldPassword = oldPassword; }
    public String getNewPassword() { return newPassword; }
    public void setNewPassword(String newPassword) { this.newPassword = newPassword; }
    public String getNewPasswordConfirm() { return newPasswordConfirm; }
    public void setNewPasswordConfirm(String newPasswordConfirm) { this.newPasswordConfirm = newPasswordConfirm; }
}



# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchDetailDTO.java


package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;

import java.time.LocalDateTime;
import java.util.List;

public class MatchDetailDTO {
    private Long id;
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime dateTime;
    private int maxPlayers;
    private int inGamePlayers;
    private int outGamePlayers;
    private int waitingPlayers;
    private int noActionPlayers;
    private double pricePerRegisteredPlayer;
    private int remainingSlots;

    List<PlayerDTO> registeredPlayers;
    List<PlayerDTO> reservedPlayers;
    List<PlayerDTO> unregisteredPlayers;
    List<PlayerDTO> excusedPlayers;
    List<PlayerDTO> noResponsePlayers;

    // Gettery a settery

    public Long getId() {       return id;    }
    public void setId(Long id) {
        this.id = id;
    }
    public LocalDateTime getDateTime() {
        return dateTime;
    }

    public void setDateTime(LocalDateTime dateTime) {
        this.dateTime = dateTime;
    }

    public int getMaxPlayers() {
        return maxPlayers;
    }
    public void setMaxPlayers(int maxPlayers) {
        this.maxPlayers = maxPlayers;
    }

    public int getInGamePlayers() {
        return inGamePlayers;
    }
    public void setInGamePlayers(int inGamePlayers) {
        this.inGamePlayers = inGamePlayers;
    }

    public void setOutGamePlayers(int outGamePlayers) {
        this.outGamePlayers = outGamePlayers;
    }

    public int getWaitingPlayers() {
        return waitingPlayers;
    }
    public void setWaitingPlayers(int waitingPlayers) {
        this.waitingPlayers = waitingPlayers;
    }

    public int getNoActionPlayers() {
        return noActionPlayers;
    }
    public void setNoActionPlayers(int noActionPlayers) {
        this.noActionPlayers = noActionPlayers;
    }

    public double getPricePerRegisteredPlayer() {
        return pricePerRegisteredPlayer;
    }
    public void setPricePerRegisteredPlayer(double pricePerRegisteredPlayer) {
        this.pricePerRegisteredPlayer = pricePerRegisteredPlayer;
    }

    public int getRemainingSlots() {
        return remainingSlots;
    }
    public void setRemainingSlots(int remainingSlots) {
        this.remainingSlots = remainingSlots;
    }

    public List<PlayerDTO> getRegisteredPlayers() {
        return registeredPlayers;
    }
    public void setRegisteredPlayers(List<PlayerDTO> registeredPlayers) {
        this.registeredPlayers = registeredPlayers;
    }

    public List<PlayerDTO> getReservedPlayers() {
        return reservedPlayers;
    }
    public void setReservedPlayers(List<PlayerDTO> reservedPlayers) {
        this.reservedPlayers = reservedPlayers;
    }

    public List<PlayerDTO> getUnregisteredPlayers() {
        return unregisteredPlayers;
    }

    public void setUnregisteredPlayers(List<PlayerDTO> unregisteredPlayers) {
        this.unregisteredPlayers = unregisteredPlayers;
    }
    public List<PlayerDTO> getExcusedPlayers() {
        return excusedPlayers;
    }
    public void setExcusedPlayers(List<PlayerDTO> excusedPlayers) {
        this.excusedPlayers = excusedPlayers;
    }

    public List<PlayerDTO> getNoResponsePlayers() {
        return noResponsePlayers;
    }
    public void setNoResponsePlayers(List<PlayerDTO> noResponsePlayers) {
        this.noResponsePlayers = noResponsePlayers;
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchDTO.java


package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import jakarta.validation.constraints.FutureOrPresent;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

import java.time.LocalDateTime;

public class MatchDTO {

    private Long id;
    @NotNull(message = "Datum a √Ñ≈§as zƒÇÀápasu je povinnƒÇ¬©.")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime dateTime;

    @NotBlank(message = "MƒÇ¬≠sto zƒÇÀápasu je povinnƒÇ¬©.")
    @Size(min = 3, max = 100)
    private String location;

    @Size(max = 255, message = "Popis mƒπ≈ªƒπƒæe mƒÇ¬≠t max 255 znakƒπ≈ª.")
    private String description;

    @NotNull(message = "MaximƒÇÀálnƒÇ¬≠ po√Ñ≈§et hrƒÇÀá√Ñ≈§ƒπ≈ª je povinnƒÇÀù")
    private Integer maxPlayers;

    @NotNull(message = "Cena je povinnƒÇÀá")
    private Integer price;

    // gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }
    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() {
        return price;
    }

    public void setPrice(Integer price) {
        this.price = price;
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchOverviewDTO.java


package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;

import java.time.LocalDateTime;

public class MatchOverviewDTO {

    private Long id;

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime dateTime;

    private String location;
    private String description;
    private Integer price;
    private int maxPlayers;
    private int inGamePlayers;
    private double pricePerRegisteredPlayer;
    private PlayerMatchStatus status;

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getPrice() { return price; }
    public void setPrice(Integer price) { this.price = price; }

    public int getMaxPlayers() { return maxPlayers; }
    public void setMaxPlayers(int maxPlayers) { this.maxPlayers = maxPlayers; }

    public int getInGamePlayers() { return inGamePlayers; }
    public void setInGamePlayers(int inGamePlayers) { this.inGamePlayers = inGamePlayers; }

    public double getPricePerRegisteredPlayer() { return pricePerRegisteredPlayer; }
    public void setPricePerRegisteredPlayer(double pricePerRegisteredPlayer) { this.pricePerRegisteredPlayer = pricePerRegisteredPlayer; }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchRegistrationDTO.java


package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;

public class MatchRegistrationDTO {
    private Long id; // volitelnƒÇ¬©, pƒπ‚Ñ¢i GET

    @NotNull(message = "ID zƒÇÀápasu je povinnƒÇ¬©.")
    @Positive(message = "ID zƒÇÀápasu musƒÇ¬≠ bƒÇÀùt kladnƒÇ¬©.")
    private Long matchId;

    @NotNull(message = "ID hrƒÇÀá√Ñ≈§e je povinnƒÇ¬©.")
    @Positive(message = "ID hrƒÇÀá√Ñ≈§e musƒÇ¬≠ bƒÇÀùt kladnƒÇ¬©.")
    private Long playerId;

    private PlayerMatchStatus status;
    private ExcuseReason excuseReason; // pouze pokud status = EXCUSED
    private String excuseNote;
    private String adminNote;
    private Team team;

    @NotNull
    private String createdBy; // "user" nebo "system"

    private PlayerDTO playerDTO;

    public MatchRegistrationDTO() {}

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public Long getMatchId() { return matchId; }
    public void setMatchId(Long matchId) { this.matchId = matchId; }

    public Long getPlayerId() { return playerId; }
    public void setPlayerId(Long playerId) { this.playerId = playerId; }

    public PlayerMatchStatus getStatus() { return status; }
    public void setStatus(PlayerMatchStatus status) { this.status = status; }

    public ExcuseReason getExcuseReason() { return excuseReason; }
    public void setExcuseReason(ExcuseReason excuseReason) { this.excuseReason = excuseReason; }

    public String getExcuseNote() { return excuseNote; }
    public void setExcuseNote(String excuseNote) { this.excuseNote = excuseNote; }

    public String getAdminNote() { return adminNote; }
    public void setAdminNote(String adminNote) { this.adminNote = adminNote; }

    public Team getTeam() { return team; }
    public void setTeam (Team team) { this.team = team; }

    public String getCreatedBy() { return createdBy; }
    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }
}



# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerDTO.java


package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerType;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class PlayerDTO {


    private Long id; // autogenerated, nullable pƒπ‚Ñ¢i create

    @NotBlank(message = "Kƒπ‚Ñ¢estnƒÇ¬≠ jmƒÇ¬©no je povinnƒÇ¬©.")
    @Size(min = 2, max = 50)
    private String name; // not null

    @NotBlank(message = "Pƒπ‚Ñ¢ƒÇ¬≠jmenƒÇ¬≠ je povinnƒÇ¬©.")
    @Size(min = 2, max = 50)
    private String surname; // not null
    private String nickName;
    private String fullName; // derived
    private String phoneNumber;
    private PlayerType type; // not null, default BASIC
    private Team team;
    private PlayerStatus status;


    public PlayerDTO() {
        this.type = PlayerType.BASIC;
   }

    public PlayerDTO(Long id, String name, String surname, String nickName, PlayerType type, Team team, PlayerStatus status) {
        this.id = id;
        this.name = name;
        this.surname = surname;
        this.nickName = nickName;
        this.type = type != null ? type : PlayerType.BASIC;
        this.updateFullName();
        this.team = team;
        this.status = status != null ? status : PlayerStatus.PENDING;
    }

    // --- Gettery a Settery ---

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; updateFullName(); }

    public String getSurname() { return surname; }
    public void setSurname(String surname) { this.surname = surname; updateFullName(); }

    public String getNickName() { return nickName; }

    public void setNickName(String nickName) { this.nickName = nickName; }

    public String getFullName() { return fullName; }

    private void updateFullName() { this.fullName = name + " " + surname; }

    public PlayerType getType() { return type; }
    public void setType(PlayerType type) { this.type = type != null ? type : PlayerType.BASIC; }

    public Team getTeam() { return team; }
    public void setTeam(Team team) { this.team = team; }

    public String getPhoneNumber() { return phoneNumber; }
    public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }

    public PlayerStatus getStatus() { return status; }
    public void setStatus(PlayerStatus status) { this.status = status != null ? status : PlayerStatus.PENDING;
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerInactivityPeriodDTO.java


package cz.phsoft.hokej.models.dto;

import java.time.LocalDateTime;

public class PlayerInactivityPeriodDTO {

    private Long id;
    private Long playerId;
    private LocalDateTime inactiveFrom;
    private LocalDateTime inactiveTo;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getPlayerId() {
        return playerId;
    }

    public void setPlayerId(Long playerId) {
        this.playerId = playerId;
    }

    public LocalDateTime getInactiveFrom() {
        return inactiveFrom;
    }

    public void setInactiveFrom(LocalDateTime inactiveFrom) {
        this.inactiveFrom = inactiveFrom;
    }

    public LocalDateTime getInactiveTo() {
        return inactiveTo;
    }

    public void setInactiveTo(LocalDateTime inactiveTo) {
        this.inactiveTo = inactiveTo;
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerSummaryDTO.java


package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.enums.Team;

public class PlayerSummaryDTO {
    private Long id;
    private String name;
    private String surname;
    private String fullName;
    private String nickName;
    private PlayerType type;
    private Team team;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public String getFullName() {
        return fullName;
    }

    public void setFullName(String fullName) {
        this.fullName = fullName;
    }

    public String getNickName() {
        return nickName;
    }

    public void setNickName(String nickName) {
        this.nickName = nickName;
    }

    public PlayerType getType() {
        return type;
    }

    public void setType(PlayerType type) {
        this.type = type;
    }

    public Team getTeam() {
        return team;
    }

    public void setTeam(Team team) {
        this.team = team;
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\RegisterUserDTO.java


package cz.phsoft.hokej.models.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class RegisterUserDTO {

    @NotBlank(message = "Kƒπ‚Ñ¢estnƒÇ¬≠ jmƒÇ¬©no je povinnƒÇ¬©.")
    @Size(min = 2, max = 50)
    private String name; // not null

    @NotBlank(message = "Pƒπ‚Ñ¢ƒÇ¬≠jmenƒÇ¬≠ je povinnƒÇ¬©.")
    @Size(min = 2, max = 50)
    private String surname;

    @NotBlank(message = "email je povinnƒÇÀù.")
    @Email
    private String email;

    @NotBlank
    @Size(min = 8, max = 64)
    private String password;

    @NotBlank
    private String passwordConfirm;


    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getPasswordConfirm() {
        return passwordConfirm;
    }

    public void setPasswordConfirm(String passwordConfirm) {
        this.passwordConfirm = passwordConfirm;
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\SuccessResponseDTO.java


package cz.phsoft.hokej.models.dto;

public class SuccessResponseDTO {
    private  String message;
    private Long id;
    private String timestamp;

    public SuccessResponseDTO(String message, Long id, String timestamp) {
        this.message = message;
        this.id = id;
        this.timestamp = timestamp;
    }

    public String getMessage() { return message; }
    public Long getId() { return id; }
    public String getTimestamp() { return timestamp; }

}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\email\EmailService.java


package cz.phsoft.hokej.models.services.email;

import jakarta.mail.MessagingException;
import jakarta.mail.internet.MimeMessage;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

@Service
public class EmailService {
    private final JavaMailSender mailSender;

    @Value("${spring.mail.from}")
    private String fromEmail;

    @Value("${email.enabled:true}")   //
    private boolean emailEnabled;

    public EmailService(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    // ===== 1) JEDNODUCHƒÇ≈• TEXTOVƒÇ≈• EMAIL =====
    @Async
    public void sendSimpleEmail(String to, String subject, String text) {

        if (!emailEnabled) {
            System.out.println("MAIL JE VYPNUTƒÇ≈• √¢‚Ç¨‚Äú email nebyl odeslƒÇÀán na: " + to);
            return;
        }


        try {
            SimpleMailMessage message = new SimpleMailMessage();
            message.setTo(to);
            message.setSubject(subject);
            message.setText(text);
            message.setFrom(fromEmail);

            mailSender.send(message);
        } catch (Exception e) {
            // Doporu√Ñ≈§eno: logovat do souboru
            throw new RuntimeException("Chyba pƒπ‚Ñ¢i odesƒÇ¬≠lƒÇÀánƒÇ¬≠ emailu: " + e.getMessage(), e);
        }
    }

    // ===== 2) HTML EMAIL (HEZ√Ñ≈öƒÇ≈§) =====
    @Async
    public void sendHtmlEmail(String to, String subject, String htmlContent) {

        if (!emailEnabled) {
            System.out.println("MAIL JE VYPNUTƒÇ≈• √¢‚Ç¨‚Äú email nebyl odeslƒÇÀán na: " + to);
            return;
        }

        try {
            MimeMessage mimeMessage = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true, "UTF-8");

            helper.setTo(to);
            helper.setSubject(subject);
            helper.setText(htmlContent, true); // true = HTML
            helper.setFrom(fromEmail);

            mailSender.send(mimeMessage);
        } catch (MessagingException e) {
            throw new RuntimeException("Chyba pƒπ‚Ñ¢i odesƒÇ¬≠lƒÇÀánƒÇ¬≠ HTML emailu: " + e.getMessage(), e);
        }
    }
    public void sendActivationEmail(String to, String activationLink) {
        String subject = "Potvr√Ñ≈πte svƒπ≈ªj ƒÇ≈ü√Ñ≈§et";
        String text = "DobrƒÇÀù den,\n\n"
                + "Klikn√Ñ‚Ä∫te na tento odkaz pro aktivaci ƒÇ≈ü√Ñ≈§tu:\n"
                + activationLink + "\n\n"
                + "Platnost odkazu: 24 hodin.\n\n"
                + "D√Ñ‚Ä∫kujeme!";
        sendSimpleEmail(to, subject, text);
    }

    @Async
    public void sendActivationEmailHTML(String to, String activationLink) {
        String subject = "PotvrzenƒÇ¬≠ registrace - App - Hokej StarƒÇÀá Garda";
        String html = "<p>D√Ñ‚Ä∫kujeme za registraci.</p>" +
                "<p>Klikn√Ñ‚Ä∫te na odkaz pro aktivaci ƒÇ≈ü√Ñ≈§tu:</p>" +
                "<a href=\"" + activationLink + "\">Aktivovat ƒÇ≈ü√Ñ≈§et</a>";

        sendHtmlEmail(to, subject, html);
    }

}



# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsMessageBuilder.java


package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import org.springframework.stereotype.Component;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;

import java.time.format.DateTimeFormatter;

@Component
public class SmsMessageBuilder {

    private final MatchRegistrationRepository matchRegistrationRepository;
    private final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");

    public SmsMessageBuilder(MatchRegistrationRepository matchRegistrationRepository) {
        this.matchRegistrationRepository = matchRegistrationRepository;
    }

    // --------------------------
    // zprƒÇÀáva po registraci/odhlƒÇÀáƒπÀáenƒÇ¬≠/omluvenƒÇ¬≠
    // --------------------------
    public String buildMessageRegistration(MatchRegistrationEntity registration) {
        PlayerMatchStatus status = registration.getStatus();
        String statusText = switch (status) {
            case REGISTERED -> "pƒπ‚Ñ¢ihlƒÇÀásil se k zƒÇÀápasu";
            case UNREGISTERED -> "odhlƒÇÀásil se ze zƒÇÀápasu";
            case EXCUSED -> "omluven";
            default -> "neznƒÇÀámƒÇÀù stav";
        };

        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(registration.getMatch().getId(), PlayerMatchStatus.REGISTERED);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - datum: ")
                .append(registration.getMatch().getDateTime().toLocalDate());

        if (status != PlayerMatchStatus.EXCUSED) {
            sb.append(", ").append(registeredCount)
                    .append("/").append(registration.getMatch().getMaxPlayers());
        }

        sb.append(", hrƒÇÀá√Ñ≈§: ").append(registration.getPlayer().getFullName())
                .append(", status: ").append(statusText);

        return sb.toString();
    }

    // --------------------------
    // zprƒÇÀáva pro hrƒÇÀá√Ñ≈§e, kteƒπ‚Ñ¢ƒÇ¬≠ jeƒπÀát√Ñ‚Ä∫ nereagovali
    // --------------------------
    public String buildMessageNoResponse(PlayerDTO player, MatchEntity match) {
        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - upozorn√Ñ‚Ä∫nƒÇ¬≠: zƒÇÀápas ")
                .append(match.getDateTime().format(dateFormatter))
                .append(" - volnƒÇÀá mƒÇ¬≠sta: ")
                .append(match.getMaxPlayers() - registeredCount)
                .append(". JeƒπÀát√Ñ‚Ä∫ jste nereagoval.");

        return sb.toString();
    }

    // --------------------------
    // finƒÇÀálnƒÇ¬≠ pƒπ‚Ñ¢ipomƒÇ¬≠nka pro pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬© hrƒÇÀá√Ñ≈§e v den zƒÇÀápasu
    // --------------------------
    public String buildMessageFinal(MatchRegistrationEntity registration) {
        MatchEntity match = registration.getMatch();
        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);

        double pricePerPlayer = match.getPrice() / Math.max(registeredCount, 1);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - pƒπ‚Ñ¢ipomƒÇ¬≠nka zƒÇÀápasu ")
                .append(match.getDateTime().format(dateFormatter))
                .append(", pƒπ‚Ñ¢ihlƒÇÀáƒπÀáeno: ").append(registeredCount).append("/").append(match.getMaxPlayers())
                .append(", cena na hrƒÇÀá√Ñ≈§e: ").append(String.format("%.2f K√Ñ≈§", pricePerPlayer));

        return sb.toString();
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsSchedulerService.java


package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import jakarta.transaction.Transactional;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.List;

@Service
public class SmsSchedulerService {

    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository registrationRepository;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;
    private final MatchRegistrationService matchRegistrationService;

    public SmsSchedulerService(
            MatchRepository matchRepository,
            MatchRegistrationRepository registrationRepository,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder,
            MatchRegistrationService matchRegistrationService) {

        this.matchRepository = matchRepository;
        this.registrationRepository = registrationRepository;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
        this.matchRegistrationService = matchRegistrationService;
    }

    // PoslƒÇÀánƒÇ¬≠ SMS v den zƒÇÀápasu
    // SpustƒÇ¬≠ se kaƒπƒædƒÇÀù den v 12:30
    @Scheduled(cron = "0 30 12 * * *")
    @Transactional
    public void sendFinalSmsForTodayMatches() {

        LocalDate today = LocalDate.now();

        // najdeme vƒπÀáechny dneƒπÀánƒÇ¬≠ zƒÇÀápasy
        List<MatchEntity> todaysMatches = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().toLocalDate().isEqual(today))
                .toList();

        for (MatchEntity match : todaysMatches) {

            // na√Ñ≈§teme vƒπÀáechny registrace k danƒÇ¬©mu zƒÇÀápasu (BEZ zm√Ñ‚Ä∫n entit)
            List<MatchRegistrationEntity> registrations =
                    registrationRepository.findByMatchId(match.getId());

            for (MatchRegistrationEntity reg : registrations) {

                // pouƒπƒæijeƒπÀá svƒπ≈ªj pƒπ≈ªvodnƒÇ¬≠ builder
                String smsMsg = smsMessageBuilder.buildMessageFinal(reg);

                try {
                    smsService.sendSms(reg.getPlayer().getPhoneNumber(), smsMsg);
                    System.out.println("FinƒÇÀálnƒÇ¬≠ SMS poslƒÇÀána hrƒÇÀá√Ñ≈§i "
                            + reg.getPlayer().getFullName() + ": " + smsMsg);

                } catch (Exception e) {
                    System.err.println("Chyba SMS pro hrƒÇÀá√Ñ≈§e "
                            + reg.getPlayer().getFullName() + ": " + e.getMessage());
                }
            }
        }
    }

    // poslƒÇÀánƒÇ¬≠ SMS 3 dny pƒπ‚Ñ¢ed zƒÇÀápasem - noresponse player
    @Scheduled(cron = "0 40 14 * * *") // kaƒπƒædƒÇÀù den ve 12:30
    @Transactional
    public void sendNoResponseSmsForMatchesIn3Days() {

        LocalDate targetDate = LocalDate.now().plusDays(3);

        // vƒπÀáechny zƒÇÀápasy, kterƒÇ¬© jsou za 3 dny
        List<MatchEntity> matchesInThreeDays = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().toLocalDate().isEqual(targetDate))
                .toList();

        for (MatchEntity match : matchesInThreeDays) {

            // pouƒπƒæijeme tvƒπ≈ªj existujƒÇ¬≠cƒÇ¬≠ helper
            List<PlayerDTO> noResponsePlayers =
                    matchRegistrationService.getNoResponsePlayers(match.getId());

            for (PlayerDTO player : noResponsePlayers) {

                String smsMsg = smsMessageBuilder.buildMessageNoResponse(player, match);

                try {
                    smsService.sendSms(player.getPhoneNumber(), smsMsg);
                    System.out.println("NORESPONSE SMS poslƒÇÀána hrƒÇÀá√Ñ≈§i "
                            + player.getFullName() + ": " + smsMsg);
                } catch (Exception e) {
                    System.err.println("Chyba NORESPONSE SMS pro hrƒÇÀá√Ñ≈§e "
                            + player.getFullName() + ": " + e.getMessage());
                }
            }
        }
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsService.java


package cz.phsoft.hokej.models.services.sms;

public interface SmsService {
    void sendSms(String phoneNumber, String message);
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsServiceImpl.java


/* package cz.phsoft.hokej.models.services.sms;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;

@Service
public class SmsServiceImpl {

   // private final RestTemplate restTemplate = new RestTemplate();

    @Value("${textbee.api-url}")
    private String apiUrl;

    @Value("${textbee.api-key}")
    private String apiKey;

    // testovacƒÇ¬≠ √Ñ≈§ƒÇ¬≠slo
    //private final String testNumber = "+420776609956";

    /**
     * OdeƒπÀále SMS na testovacƒÇ¬≠ √Ñ≈§ƒÇ¬≠slo.
     * @param message text zprƒÇÀávy
     */

/*
    public void sendSms(String phoneNumber, String message) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("x-api-key", apiKey);

        Map<String, Object> body = Map.of(
                "recipients", List.of(phoneNumber),
                "message", message
        );

        HttpEntity<Map<String,Object>> request = new HttpEntity<>(body, headers);

        try {
            ResponseEntity<String> response = restTemplate.postForEntity(apiUrl, request, String.class);
            System.out.println("SMS poslƒÇÀána na testovacƒÇ¬≠ √Ñ≈§ƒÇ¬≠slo  xxx   : " + response.getBody());
        } catch (Exception e) {
            System.err.println("Chyba pƒπ‚Ñ¢i odesƒÇ¬≠lƒÇÀánƒÇ¬≠ SMS: " + e.getMessage());
        }
    }

*/


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsTextBeeService.java


package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.models.services.sms.SmsService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;

// textbee - free s omezenƒÇ¬≠m na 50 sms / den
@Service
public class SmsTextBeeService implements SmsService {

    @Value("${sms.enabled:true}")
    private boolean smsEnabled;

    @Value("${textbee.api-url}")
    private String apiUrl;

    @Value("${textbee.api-key}")
    private String apiKey;

    private final RestTemplate restTemplate = new RestTemplate();

    @Override
    public void sendSms(String phoneNumber, String message) {
        if (!smsEnabled) {
            System.out.println("SMS disabled, message not sent: " + message);
            return;
        }

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("x-api-key", apiKey);

        Map<String, Object> body = Map.of(
                "recipients", List.of(phoneNumber),
                "message", message
        );

        HttpEntity<Map<String,Object>> request = new HttpEntity<>(body, headers);

        try {
            ResponseEntity<String> response = restTemplate.postForEntity(apiUrl, request, String.class);
            System.out.println("SMS odeslƒÇÀána hrƒÇÀá√Ñ≈§i: " + phoneNumber + ", response: " + response.getBody());
        } catch (Exception e) {
            System.err.println("Chyba pƒπ‚Ñ¢i odesƒÇ¬≠lƒÇÀánƒÇ¬≠ SMS: " + e.getMessage());
        }
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;

import java.util.List;

public interface AppUserService {
    /**
     * Registrace novƒÇ¬©ho uƒπƒæivatele
     *
     * @param registerUserDTO data pro registraci
     * @throws IllegalArgumentException pokud email existuje nebo hesla se neshodujƒÇ¬≠
     */
    void register(RegisterUserDTO registerUserDTO);

    AppUserDTO getCurrentUser(String email);

    List<AppUserDTO> getAllUsers();

    void changePassword(String email, String oldPassword, String newPassword, String newPasswordConfirm);

    void resetPassword(Long userId);

    void updateUser(String email, AppUserDTO dto);

    boolean activateUser(String token);
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.EmailVerificationTokenEntity;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.EmailVerificationTokenRepository;
import cz.phsoft.hokej.exceptions.UserAlreadyExistsException;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;
import cz.phsoft.hokej.models.dto.mappers.AppUserMapper;
import cz.phsoft.hokej.models.services.email.EmailService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class AppUserServiceImpl implements AppUserService {

    @Value("${app.base-url}")
    private String baseUrl;

    private final AppUserRepository userRepository;
    private final BCryptPasswordEncoder passwordEncoder;
    private final AppUserMapper appUserMapper;
    private final EmailService emailService;
    private final EmailVerificationTokenRepository tokenRepository;

    public AppUserServiceImpl(AppUserRepository userRepository,
                              BCryptPasswordEncoder passwordEncoder, AppUserMapper appUserMapper,
                              EmailService emailService, EmailVerificationTokenRepository tokenRepository) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
        this.appUserMapper = appUserMapper;
        this.emailService = emailService;
        this.tokenRepository = tokenRepository;
    }

    @Override
    public void register(RegisterUserDTO dto) {
        if (!dto.getPassword().equals(dto.getPasswordConfirm())) {
            throw new IllegalArgumentException("Hesla se neshodujƒÇ¬≠");
        }

        if (userRepository.findByEmail(dto.getEmail()).isPresent()) {
            throw new UserAlreadyExistsException("Uƒπƒæivatel s tƒÇ¬≠mto emailem jiƒπƒæ existuje");
        }

        AppUserEntity user = new AppUserEntity();
        user.setName(dto.getName());
        user.setSurname(dto.getSurname());
        user.setEmail(dto.getEmail());
        user.setPassword(passwordEncoder.encode(dto.getPassword()));
        user.setRole(Role.ROLE_PLAYER);
        user.setEnabled(false); // NEaktivnƒÇ¬≠ pƒπ‚Ñ¢i registraci

        AppUserEntity savedUser = userRepository.save(user);

        // GenerovƒÇÀánƒÇ¬≠ tokenu
        String token = java.util.UUID.randomUUID().toString();
        EmailVerificationTokenEntity verificationToken = new EmailVerificationTokenEntity();
        verificationToken.setToken(token);
        verificationToken.setUser(savedUser);
        verificationToken.setExpiresAt(java.time.LocalDateTime.now().plusHours(24));

        tokenRepository.save(verificationToken);


        // OdeslƒÇÀánƒÇ¬≠ aktiva√Ñ≈§nƒÇ¬≠ho emailu
        String activationLink = baseUrl + "/api/auth/verify?token=" + token;
        // Pro test lokƒÇÀáln√Ñ‚Ä∫: vypƒÇ¬≠ƒπÀáe odkaz do konzole
        System.out.println("Aktiva√Ñ≈§nƒÇ¬≠ odkaz: " + activationLink);

        emailService.sendActivationEmailHTML(savedUser.getEmail(), activationLink);
    }

    @Override
    public boolean activateUser(String token) {
        EmailVerificationTokenEntity verificationToken = tokenRepository.findByToken(token)
                .orElse(null);

        if (verificationToken == null || verificationToken.getExpiresAt().isBefore(java.time.LocalDateTime.now())) {
            return false; // neplatnƒÇÀù token nebo vyprƒπÀáel
        }

        AppUserEntity user = verificationToken.getUser();
        user.setEnabled(true); // aktivujeme uƒπƒæivatele
        userRepository.save(user);

        // Po aktivaci token smaƒπƒæeme (nenƒÇ¬≠ potƒπ‚Ñ¢eba jej uchovƒÇÀávat)
        tokenRepository.delete(verificationToken);

        return true;
    }

    @Override
    public void updateUser(String email, AppUserDTO dto) {

        AppUserEntity user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Uƒπƒæivatel nenalezen"));

        // NastavenƒÇ¬≠ novƒÇ¬©ho hesla
        user.setName(dto.getName());
        user.setSurname(dto.getSurname());
        user.setEmail(dto.getEmail());
        userRepository.save(user);
    }

    @Override
    public AppUserDTO getCurrentUser(String email) {
        AppUserEntity user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("User not found"));

        // √¢‚Ä†¬ê vyuƒπƒæitƒÇ¬≠ mapperu
        return appUserMapper.toDTO(user);
    }

    @Override
    public List<AppUserDTO> getAllUsers() {
        return userRepository.findAll().stream()
                .map(appUserMapper::toDTO)
                .toList();
    }

    @Override
    public void changePassword(String email, String oldPassword, String newPassword, String newPasswordConfirm) {
        if (!newPassword.equals(newPasswordConfirm)) {
            throw new IllegalArgumentException("NovƒÇÀá hesla se neshodujƒÇ¬≠");
        }

        AppUserEntity user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Uƒπƒæivatel nenalezen"));

        // Ov√Ñ‚Ä∫ƒπ‚Ñ¢enƒÇ¬≠ starƒÇ¬©ho hesla
        if (!passwordEncoder.matches(oldPassword, user.getPassword())) {
            throw new IllegalArgumentException("StarƒÇ¬© heslo je nesprƒÇÀávnƒÇ¬©");
        }

        // NastavenƒÇ¬≠ novƒÇ¬©ho hesla
        user.setPassword(passwordEncoder.encode(newPassword));
        userRepository.save(user);
    }

    // reset hesla
    @Override
    public void resetPassword(Long userId) {
        AppUserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("Uƒπƒæivatel nenalezen"));

        // NastavenƒÇ¬≠ novƒÇ¬©ho hesla na "Player123"
        user.setPassword(passwordEncoder.encode("Player123"));
        userRepository.save(user);
    }


}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;

import java.util.List;

public interface MatchRegistrationService {

    // ƒë≈∫‚ÄùƒÑ VracƒÇ¬≠ DTO mƒÇ¬≠sto entity
    MatchRegistrationDTO upsertRegistration(
            Long matchId,
            Long playerId,
            Team team,
            String adminNote,
            ExcuseReason excuseReason,
            String excuseNote,
            boolean unregister
    );

    List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId);

    List<MatchRegistrationDTO> getRegistrationsForMatches(List<Long> matchIds);

    List<MatchRegistrationDTO> getAllRegistrations();

    List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId);

    List<PlayerDTO> getNoResponsePlayers(Long matchId);

    void recalcStatusesForMatch(Long matchId);
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.DuplicateRegistrationException;
import cz.phsoft.hokej.exceptions.MatchNotFoundException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.exceptions.RegistrationNotFoundException;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.mappers.MatchRegistrationMapper;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.sms.SmsMessageBuilder;
import cz.phsoft.hokej.models.services.sms.SmsService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
public class MatchRegistrationServiceImpl implements MatchRegistrationService {

    Logger logger = LoggerFactory.getLogger(MatchServiceImpl.class);
    private final MatchRegistrationRepository registrationRepository;
    private final MatchRepository matchRepository;
    private final PlayerRepository playerRepository;
    private final MatchRegistrationMapper matchRegistrationMapper;
    private final PlayerMapper playerMapper;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;

    public MatchRegistrationServiceImpl(
            MatchRegistrationRepository registrationRepository,
            MatchRepository matchRepository,
            PlayerRepository playerRepository,
            MatchRegistrationMapper matchRegistrationMapper,
            PlayerMapper playerMapper,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder) {
        this.registrationRepository = registrationRepository;
        this.matchRepository = matchRepository;
        this.playerRepository = playerRepository;
        this.matchRegistrationMapper = matchRegistrationMapper;
        this.playerMapper = playerMapper;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
    }
    private MatchEntity getMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }
    private PlayerEntity getPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }
    private boolean isSlotAvailable(MatchEntity match) {
        long registeredCount = registrationRepository.countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);
        return registeredCount < match.getMaxPlayers();
    }
    private void sendSms(MatchRegistrationEntity registration, String message) {
        if (registration == null || registration.getPlayer() == null) return;
        try {
            smsService.sendSms(registration.getPlayer().getPhoneNumber(), message);
        } catch (Exception e) {
            System.err.println("Chyba SMS: " + e.getMessage());
        }
    }
    private MatchRegistrationEntity updateRegistrationStatus(
            MatchRegistrationEntity registration, PlayerMatchStatus status, String updatedBy, boolean updateTimestamp) {

        registration.setStatus(PlayerMatchStatus.valueOf(status.name()));
        registration.setCreatedBy(updatedBy);
        if (updateTimestamp) {
            registration.setTimestamp(LocalDateTime.now());
        }
        return registrationRepository.saveAndFlush(registration);
    }
    // -------------------- REGISTRATION --------------------
    @Transactional
    @Override
    public MatchRegistrationDTO upsertRegistration(
            Long matchId,
            Long playerId,
            Team team,
            String adminNote,
            ExcuseReason excuseReason,
            String excuseNote,
            boolean unregister) {

        // TEST: poƒπÀáli ERROR zprƒÇÀávu pro otestovƒÇÀánƒÇ¬≠ emailu
        logger.error("Test ERROR zprƒÇÀáva pro email");

        MatchEntity match = getMatchOrThrow(matchId);
        PlayerEntity player = getPlayerOrThrow(playerId);

        MatchRegistrationEntity registration = registrationRepository
                .findByPlayerIdAndMatchId(playerId, matchId)
                .orElse(null);

        PlayerMatchStatus newStatus;

        // UNREGISTER: lze pouze kdyƒπƒæ hrƒÇÀá√Ñ≈§ mƒÇÀá aktuƒÇÀáln√Ñ‚Ä∫ REGISTERED
        if (unregister) {
            if (registration == null || registration.getStatus() != PlayerMatchStatus.REGISTERED) {
                throw new RegistrationNotFoundException(matchId, playerId);
            }
            registration.setExcuseReason(null);
            newStatus = PlayerMatchStatus.UNREGISTERED;

            // EXCUSE: lze vytvoƒπ‚Ñ¢it pouze pokud hrƒÇÀá√Ñ≈§ NEMƒÇ¬Å status REGISTERED
        } else if (excuseReason != null) {
            if (registration != null && registration.getStatus() == PlayerMatchStatus.REGISTERED) {
                throw new DuplicateRegistrationException(matchId, playerId);
            }
            // pokud neexistuje, vytvoƒπ‚Ñ¢ƒÇ¬≠me pozici; pokud existuje a nenƒÇ¬≠ REGISTERED, povolƒÇ¬≠me EXCUSED
            if (registration == null) {
                registration = new MatchRegistrationEntity();
                registration.setMatch(match);
                registration.setPlayer(player);
            }
            registration.setExcuseReason(excuseReason);
            newStatus = PlayerMatchStatus.EXCUSED;

            // REGISTER / RESERVE: lze vytvoƒπ‚Ñ¢it pokud hrƒÇÀá√Ñ≈§ NEMƒÇ¬Å status REGISTERED (tedy i kdyƒπƒæ mƒÇÀá EXCUSED)
        } else {
            // pokud uƒπƒæ je registrovƒÇÀán, nepovolƒÇ¬≠me duplicitu
            if (registration != null && registration.getStatus() == PlayerMatchStatus.REGISTERED) {
                throw new DuplicateRegistrationException(matchId, playerId);
            }

            newStatus = isSlotAvailable(match) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;

            if (registration == null) {
                registration = new MatchRegistrationEntity();
                registration.setMatch(match);
                registration.setPlayer(player);
            } else {
                // pƒπ‚Ñ¢i pƒπ‚Ñ¢echodu na register/reserve zruƒπÀáƒÇ¬≠me pƒπ‚Ñ¢ƒÇ¬≠padnou vƒÇÀùmluvu
                registration.setExcuseReason(null);
            }
        }

        registration.setStatus(newStatus);
        registration.setTimestamp(LocalDateTime.now());
        registration.setCreatedBy("user");

        if (team != null) registration.setTeam(team);
        if (adminNote != null) registration.setAdminNote(adminNote);
        // excuseReason uƒπƒæ jsme nastavili vƒÇÀùƒπÀáe (pokud to byl EXCUSED pƒπ‚Ñ¢ƒÇ¬≠pad)
        if (excuseReason != null) registration.setExcuseReason(excuseReason);

        registration = registrationRepository.save(registration);

        if (unregister) recalcStatusesForMatch(matchId);

        sendSms(registration, smsMessageBuilder.buildMessageRegistration(registration));

        return matchRegistrationMapper.toDTO(registration);
    }
    // -------------------- FETCH --------------------
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId) {
        return matchRegistrationMapper.toDTOList(registrationRepository.findByMatchId(matchId));
    }

    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatches(List<Long> matchIds) {
        if (matchIds == null || matchIds.isEmpty()) {
            return List.of();
        }

        return matchRegistrationMapper.toDTOList(
                registrationRepository.findByMatchIdIn(matchIds)
        );
    }

    @Override
    public List<MatchRegistrationDTO> getAllRegistrations() {
        return matchRegistrationMapper.toDTOList(registrationRepository.findAll());
    }

    @Override
    public List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId) {
        return matchRegistrationMapper.toDTOList(registrationRepository.findByPlayerId(playerId));
    }

    @Override
    public List<PlayerDTO> getNoResponsePlayers(Long matchId) {
        List<Long> responded = registrationRepository.findByMatchId(matchId).stream()
                .map(r -> r.getPlayer().getId())
                .toList();

        List<PlayerEntity> noResponsePlayers = playerRepository.findAll().stream()
                .filter(p -> !responded.contains(p.getId()))
                .toList();

        return noResponsePlayers.stream()
                .map(playerMapper::toDTO)
                .toList();
    }
    // -------------------- RECALC --------------------
    @Override
    @Transactional
    public void recalcStatusesForMatch(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);
        int maxPlayers = match.getMaxPlayers();

        List<MatchRegistrationEntity> regs = registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED
                        || r.getStatus() == PlayerMatchStatus.RESERVED)
                .sorted((a, b) -> a.getTimestamp().compareTo(b.getTimestamp()))
                .toList();

        for (int i = 0; i < regs.size(); i++) {
            MatchRegistrationEntity reg = regs.get(i);
            PlayerMatchStatus newStatus = (i < maxPlayers) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;
            if (reg.getStatus() != newStatus) updateRegistrationStatus(reg, newStatus, "system", false);
        }
    }

    // -------------------- SMS --------------------
    @Transactional
    public void sendSmsToRegisteredPlayers(Long matchId) {
        registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .forEach(r -> sendSms(r, smsMessageBuilder.buildMessageFinal(r)));
    }

    public void sendNoResponseSmsForMatch(Long matchId) {
        var match = getMatchOrThrow(matchId);

        getNoResponsePlayers(matchId).forEach(player -> {
            String smsMsg = smsMessageBuilder.buildMessageNoResponse(player, match);

            try {
                smsService.sendSms(player.getPhoneNumber(), smsMsg);
            } catch (Exception e) {
                System.err.println("Chyba SMS pro hrƒÇÀá√Ñ≈§e "
                        + player.getFullName() + ": " + e.getMessage());
                logger.error("Chyba pƒπ‚Ñ¢i odeslƒÇÀánƒÇ¬≠ SMS hrƒÇÀá√Ñ≈§i {}: {}", player.getFullName(), e.getMessage());
            }
        });
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;
import cz.phsoft.hokej.models.dto.MatchOverviewDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;

import java.util.List;

public interface MatchService {
    List<MatchDTO> getAllMatches();
    List<MatchDTO> getUpcomingMatches();
    List<MatchDTO> getPastMatches();
    MatchDTO getNextMatch();
    MatchDTO getMatchById(Long id);
    MatchDTO createMatch(MatchDTO dto);
    MatchDTO updateMatch(Long id, MatchDTO dto);
    SuccessResponseDTO deleteMatch(Long id);
    MatchDetailDTO getMatchDetail(Long id);
    List<MatchDTO> getAvailableMatchesForPlayer(Long playerId);
    List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId);
    Long getPlayerIdByEmail(String email);
    List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId);
    public List<MatchOverviewDTO> getAllPassedMatchesForPlayer(Long playerId);


}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.MatchNotFoundException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.models.dto.*;
import cz.phsoft.hokej.models.dto.mappers.MatchMapper;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class MatchServiceImpl implements MatchService {

    private final MatchRepository matchRepository;
    private final MatchMapper matchMapper;
    private final MatchRegistrationService registrationService;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodService playerInactivityPeriodService;
    private final PlayerMapper playerMapper;
    private static final String ROLE_ADMIN = "ROLE_ADMIN";
    private static final String ROLE_MANAGER = "ROLE_MANAGER";

    public MatchServiceImpl(MatchRepository matchRepository,
                            MatchMapper matchMapper,
                            MatchRegistrationService registrationService,
                            PlayerRepository playerRepository,
                            PlayerInactivityPeriodService playerInactivityPeriodService,
                            PlayerMapper playerMapper) {
        this.matchRepository = matchRepository;
        this.matchMapper = matchMapper;
        this.registrationService = registrationService;
        this.playerRepository = playerRepository;
        this.playerInactivityPeriodService = playerInactivityPeriodService;
        this.playerMapper = playerMapper;
    }
    // metoda pro zƒÇ¬≠skƒÇÀánƒÇ¬≠ vƒπÀáech zƒÇÀápasƒπ≈ª
    @Override
    public List<MatchDTO> getAllMatches() {
        return matchRepository.findAll().stream()
                .map(matchMapper::toDTO)
                .toList();
    }
    // metoda pro zƒÇ¬≠skƒÇÀánƒÇ¬≠ vƒπÀáech nadchƒÇÀázejƒÇ¬≠cƒÇ¬≠ch zƒÇÀápasƒπ≈ª
    @Override
    public List<MatchDTO> getUpcomingMatches() {
        return matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now())
                .stream()
                .map(matchMapper::toDTO)
                .toList();
    }
    // metoda pro zƒÇ¬≠skƒÇÀánƒÇ¬≠ uplynulƒÇÀùch zƒÇÀápasƒπ≈ª
    public List<MatchDTO> getPastMatches() {
        return matchRepository.findByDateTimeBeforeOrderByDateTimeDesc(LocalDateTime.now())
                .stream()
                .map(matchMapper::toDTO)
                .toList();
    }
    // metoda pro zƒÇ¬≠skƒÇÀánƒÇ¬≠ prvnƒÇ¬≠ho nadchƒÇÀázejƒÇ¬≠cƒÇ¬≠ho zƒÇÀápasu
    @Override
    public MatchDTO getNextMatch() {
        return matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now())
                .stream()
                .findFirst()
                .map(matchMapper::toDTO)
                .orElse(null);
    }
    // metoda pro zƒÇÀápas dle ID
    @Override
    public MatchDTO getMatchById(Long id) {
        return matchMapper.toDTO(findMatchOrThrow(id));
    }

    // metoda pro vytvoƒπ‚Ñ¢enƒÇ¬≠ zƒÇÀápasu
    @Override
    public MatchDTO createMatch(MatchDTO dto) {
        MatchEntity entity = matchMapper.toEntity(dto);
        return matchMapper.toDTO(matchRepository.save(entity));
    }

    // metoda pro ƒÇ≈üpravu zƒÇÀápasu
    @Override
    public MatchDTO updateMatch(Long id, MatchDTO dto) {
        MatchEntity match = findMatchOrThrow(id);

        int oldMaxPlayers = match.getMaxPlayers();
        matchMapper.updateEntity(dto, match);
        MatchEntity saved = matchRepository.save(match);

        // Pƒπ‚Ñ¢epo√Ñ≈§et registracƒÇ¬≠ pokud doƒπÀálo ke zm√Ñ‚Ä∫n√Ñ‚Ä∫ maxPlayers
        if (saved.getMaxPlayers() != oldMaxPlayers) {
            registrationService.recalcStatusesForMatch(saved.getId());
        }

        return matchMapper.toDTO(saved);
    }

    // metoda pro odstran√Ñ‚Ä∫nƒÇ¬≠ zƒÇÀápasu
    @Override
    public SuccessResponseDTO deleteMatch(Long id) {
        MatchEntity match = findMatchOrThrow(id);

        // 2) Pokud existuje, smaƒπƒæeme ho
        matchRepository.delete(match);

        return new SuccessResponseDTO(
                "ZƒÇÀápas " + match.getId() + match.getDateTime() + " byl ƒÇ≈üsp√Ñ‚Ä∫ƒπÀán√Ñ‚Ä∫ smazƒÇÀán",
                id,
                LocalDateTime.now().toString()
        );
    }

    // metoda pro detail zƒÇÀápasu - omezen vƒÇÀùpis pro ADMIN, MANAGER, PLAYER
    @Override
    public MatchDetailDTO getMatchDetail(Long id) {
        MatchEntity match = findMatchOrThrow(id);
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();

        boolean isAdminOrManager = auth != null && auth.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals(ROLE_ADMIN) || a.getAuthority().equals(ROLE_MANAGER));

        // odd√Ñ‚Ä∫lena logika pƒπ‚Ñ¢ƒÇ¬≠stupu hrƒÇÀá√Ñ≈§e do privƒÇÀátnƒÇ¬≠ metody
        checkAccessForPlayer(match, auth);

        // sb√Ñ‚Ä∫r statistik hrƒÇÀá√Ñ≈§ƒπ≈ª pƒπ‚Ñ¢es privƒÇÀátnƒÇ¬≠ metodu
        return collectPlayerStatus(match, isAdminOrManager);
    }

    // privƒÇÀátnƒÇ¬≠ metoda pro kontrolu pƒπ‚Ñ¢ƒÇ¬≠stupu hrƒÇÀá√Ñ≈§e - jen pokud byl registrovƒÇÀán na zƒÇÀápas
    private void checkAccessForPlayer(MatchEntity match, Authentication auth) {
        if (auth == null || !auth.isAuthenticated()) return;

        boolean isAdminOrManager = auth.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals(ROLE_ADMIN) || a.getAuthority().equals(ROLE_MANAGER));

        if (isAdminOrManager) return;

        Object principal = auth.getPrincipal();
        if (!(principal instanceof org.springframework.security.core.userdetails.UserDetails userDetails)) return;

        List<PlayerEntity> ownedPlayers = playerRepository.findAll().stream()
                .filter(p -> p.getUser() != null && p.getUser().getEmail().equals(userDetails.getUsername()))
                .toList();

        boolean hasRestrictedPlayer = ownedPlayers.stream()
                .anyMatch(p -> {
                    List<MatchRegistrationDTO> registrations = registrationService.getRegistrationsForMatch(match.getId());

                    boolean noResponse = registrations.stream()
                            .noneMatch(r -> r.getPlayerId().equals(p.getId()));

                    boolean inactiveForMatch = !playerInactivityPeriodService.isActive(p, match.getDateTime());

                    return noResponse || inactiveForMatch;
                });

        if (hasRestrictedPlayer) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "NemƒÇÀáte pƒπ‚Ñ¢ƒÇ¬≠stup k detailu tohoto zƒÇÀápasu."
            );
        }
    }

    // privƒÇÀátnƒÇ¬≠ metoda pro sb√Ñ‚Ä∫r statistik hrƒÇÀá√Ñ≈§ƒπ≈ª
    private MatchDetailDTO collectPlayerStatus(MatchEntity match, boolean isAdminOrManager) {
        List<MatchRegistrationDTO> registrations = registrationService.getRegistrationsForMatch(match.getId());

        // Pƒπ‚Ñ¢evod vƒπÀáech registracƒÇ¬≠ na Map<PlayerMatchStatus, List<PlayerDTO>>
        var statusToPlayersMap = registrations.stream()
                .map(r -> playerRepository.findById(r.getPlayerId())
                        .map(playerMapper::toDTO)
                        .map(dto -> new java.util.AbstractMap.SimpleEntry<>(r.getStatus(), dto))
                )
                .filter(java.util.Optional::isPresent) // odstranƒÇ¬≠me chyb√Ñ‚Ä∫jƒÇ¬≠cƒÇ¬≠ hrƒÇÀá√Ñ≈§e
                .map(java.util.Optional::get)
                .collect(Collectors.groupingBy(
                        java.util.Map.Entry::getKey,
                        Collectors.mapping(java.util.Map.Entry::getValue, Collectors.toList())
                ));

        List<PlayerEntity> allPlayers = playerRepository.findAll();
        Set<Long> respondedIds = registrations.stream()
                .map(MatchRegistrationDTO::getPlayerId)
                .collect(Collectors.toSet());

        List<PlayerDTO> noResponsePlayers = allPlayers.stream()
                .filter(p -> !respondedIds.contains(p.getId()))
                .map(playerMapper::toDTO)
                .toList();

        // Po√Ñ≈§ty hrƒÇÀá√Ñ≈§ƒπ≈ª podle statusu
        int inGamePlayers = statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()).size();
        int outGamePlayers = statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()).size()
                + statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()).size();
        int waitingPlayers = statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()).size();
        int noActionPlayers = noResponsePlayers.size();
        int remainingSlots = match.getMaxPlayers() - inGamePlayers;
        double pricePerRegistered = inGamePlayers > 0 ? match.getPrice() / (double) inGamePlayers : 0;

        MatchDetailDTO dto = new MatchDetailDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setMaxPlayers(match.getMaxPlayers());
        dto.setInGamePlayers(inGamePlayers);
        dto.setOutGamePlayers(outGamePlayers);
        dto.setWaitingPlayers(waitingPlayers);
        dto.setNoActionPlayers(noActionPlayers);
        dto.setPricePerRegisteredPlayer(pricePerRegistered);
        dto.setRemainingSlots(remainingSlots);

        // NastavenƒÇ¬≠ hrƒÇÀá√Ñ≈§ƒπ≈ª podle statusu z mapy
        dto.setRegisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()));
        dto.setReservedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()));
        dto.setUnregisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()));
        dto.setExcusedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()));

        // pouze admin/manager uvidƒÇ¬≠ no-response hrƒÇÀá√Ñ≈§e
        dto.setNoResponsePlayers(isAdminOrManager ? noResponsePlayers : null);

        return dto;
    }

    // dostupnƒÇ¬© zƒÇÀápasy pro hrƒÇÀá√Ñ≈§e - byl nebo je aktivnƒÇ¬≠
    @Override
    public List<MatchDTO> getAvailableMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        // Filtrace pƒπ‚Ñ¢es stream bez mezivƒÇÀùsledkƒπ≈ª
        return matchRepository.findAll().stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .map(matchMapper::toDTO)
                .toList();
    }

    // zƒÇ¬≠skƒÇÀánƒÇ¬≠ hrƒÇÀá√Ñ≈§e dle emailu
    public Long getPlayerIdByEmail(String email) {
        return playerRepository.findByUserEmail(email)
                .map(PlayerEntity::getId)
                .orElseThrow(() -> new RuntimeException("HrƒÇÀá√Ñ≈§ s emailem " + email + " nenalezen"));
    }


    // nƒÇÀáhled nadchƒÇÀázejƒÇ¬≠cƒÇ¬≠ch zƒÇÀápasu pro hrƒÇÀá√Ñ≈§e - dle PlayerType
    @Override
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        // 1) NejbliƒπƒæƒπÀáƒÇ¬≠ nadchƒÇÀázejƒÇ¬≠cƒÇ¬≠ zƒÇÀápasy podle data
        List<MatchEntity> upcomingAll = matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now());

        // 2) OmezenƒÇ¬≠ podle typu hrƒÇÀá√Ñ≈§e
        List<MatchEntity> limited = switch (type) {
            case VIP -> upcomingAll;
            case STANDARD -> upcomingAll.stream().limit(2).toList();
            case BASIC -> upcomingAll.isEmpty() ? List.of() : List.of(upcomingAll.get(0));
        };

        // 3) FiltrovƒÇÀánƒÇ¬≠ podle aktivity hrƒÇÀá√Ñ≈§e a mapovƒÇÀánƒÇ¬≠ na MatchOverviewDTO
        return limited.stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .map(match -> toOverviewDTO(match, playerId))
                .toList();
    }

    // nadchƒÇÀázejƒÇ¬≠cƒÇ¬≠ zƒÇÀápas
    @Override
    public List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        // 1) NejbliƒπƒæƒπÀáƒÇ¬≠ nadchƒÇÀázejƒÇ¬≠cƒÇ¬≠ zƒÇÀápasy podle data
        List<MatchEntity> upcomingAll = matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now());

        List<MatchEntity> limited = switch (type) {
            case VIP -> upcomingAll;
            case STANDARD -> upcomingAll.stream().limit(2).toList();
            case BASIC -> upcomingAll.isEmpty() ? List.of() : List.of(upcomingAll.get(0));
        };

        // 2) FiltrovƒÇÀánƒÇ¬≠ podle aktivity hrƒÇÀá√Ñ≈§e
        return limited.stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .map(matchMapper::toDTO)
                .toList();
    }

    // pomocnƒÇ¬© metody
    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    private MatchEntity findMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }

    private MatchOverviewDTO toOverviewDTO(MatchEntity match) {
        MatchOverviewDTO dto = new MatchOverviewDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setLocation(match.getLocation());
        dto.setDescription(match.getDescription());
        dto.setPrice(match.getPrice());
        dto.setMaxPlayers(match.getMaxPlayers());


        // po√Ñ≈§et registrovanƒÇÀùch hrƒÇÀá√Ñ≈§ƒπ≈ª
        int inGamePlayers = registrationService.getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .mapToInt(r -> 1)
                .sum();
        dto.setInGamePlayers(inGamePlayers);

        // cena na registrovanƒÇ¬©ho hrƒÇÀá√Ñ≈§e
        double pricePerPlayer = inGamePlayers > 0 && match.getPrice() != null
                ? match.getPrice() / (double) inGamePlayers : 0;
        dto.setPricePerRegisteredPlayer(pricePerPlayer);



        return dto;
    }

    private MatchOverviewDTO toOverviewDTO(MatchEntity match, Long playerId) {

        MatchOverviewDTO dto = toOverviewDTO(match); // √¢‚Ä†¬ê znovupouƒπƒæitƒÇ¬≠ tvƒÇ¬© pƒπ≈ªvodnƒÇ¬≠ metody

        PlayerMatchStatus status = registrationService
                .getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getPlayerId().equals(playerId))
                .map(MatchRegistrationDTO::getStatus)
                .findFirst()
                .filter(s ->
                        s == PlayerMatchStatus.REGISTERED ||
                                s == PlayerMatchStatus.UNREGISTERED ||
                                s == PlayerMatchStatus.EXCUSED ||
                                s == PlayerMatchStatus.RESERVED
                )
                .orElse(PlayerMatchStatus.NO_RESPONSE);

        dto.setStatus(status);
        return dto;
    }

    @Override
    public List<MatchOverviewDTO> getAllPassedMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        // Vezmeme dostupnƒÇ¬© zƒÇÀápasy jako entity (bez DTO)
        List<MatchEntity> availableMatches = matchRepository.findAll().stream()
                .filter(match -> match.getDateTime().isBefore(LocalDateTime.now()) || match.getDateTime().isEqual(LocalDateTime.now()))
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .toList();

        if (availableMatches.isEmpty()) {
            return List.of();
        }

        // VƒπÀáechny ID zƒÇÀápasƒπ≈ª
        List<Long> matchIds = availableMatches.stream()
                .map(MatchEntity::getId)
                .toList();

        // Jeden jedinƒÇÀù dotaz na vƒπÀáechny registrace
        List<MatchRegistrationDTO> allRegistrations =
                registrationService.getRegistrationsForMatches(matchIds);

        // Mapa: matchId -> (playerId -> status)
        var statusMap = allRegistrations.stream()
                .collect(Collectors.groupingBy(
                        MatchRegistrationDTO::getMatchId,
                        Collectors.toMap(
                                MatchRegistrationDTO::getPlayerId,
                                MatchRegistrationDTO::getStatus,
                                (a, b) -> a
                        )
                ));

        // MapovƒÇÀánƒÇ¬≠ na MatchOverviewDTO + nastavenƒÇ¬≠ statusu
        return availableMatches.stream()
                .map(match -> {
                    MatchOverviewDTO overview = toOverviewDTO(match);

                    PlayerMatchStatus status = Optional.ofNullable(statusMap.get(match.getId()))
                            .map(m -> m.get(playerId))
                            .filter(s ->
                                    s == PlayerMatchStatus.REGISTERED ||
                                            s == PlayerMatchStatus.UNREGISTERED ||
                                            s == PlayerMatchStatus.EXCUSED ||
                                            s == PlayerMatchStatus.RESERVED
                            )
                            .orElse(PlayerMatchStatus.NO_RESPONSE);

                    overview.setStatus(status);
                    return overview;
                })
                .toList();
    }



}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;

import java.time.LocalDateTime;
import java.util.List;

public interface PlayerInactivityPeriodService {

    List<PlayerInactivityPeriodDTO> getAll();

    PlayerInactivityPeriodDTO getById(Long id);

    List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId);

    PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto);

    PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto);

    void delete(Long id);

    public boolean isActive(PlayerEntity player, LocalDateTime dateTime);
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.data.repositories.PlayerInactivityPeriodRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.dto.mappers.PlayerInactivityPeriodMapper;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import java.util.List;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

@Service
public class PlayerInactivityPeriodServiceImpl implements PlayerInactivityPeriodService {

    private final PlayerInactivityPeriodRepository inactivityRepository;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodMapper mapper;

    public PlayerInactivityPeriodServiceImpl(PlayerInactivityPeriodRepository inactivityRepository,
                                             PlayerRepository playerRepository,
                                             PlayerInactivityPeriodMapper mapper) {
        this.inactivityRepository = inactivityRepository;
        this.playerRepository = playerRepository;
        this.mapper = mapper;
    }

    @Override
    public List<PlayerInactivityPeriodDTO> getAll() {
        return inactivityRepository.findAll().stream()
                .map(mapper::toDTO)
                .toList();
    }

    @Override
    public PlayerInactivityPeriodDTO getById(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException(
                        "ObdobƒÇ¬≠ neaktivity s ID " + id + " neexistuje."
                ));
        return mapper.toDTO(entity);
    }

    @Override
    public List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId) {
        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new RuntimeException("Player not found"));

        return inactivityRepository.findByPlayerOrderByInactiveFromAsc(player)
                .stream()
                .map(mapper::toDTO)
                .toList();
    }

    // --- TRANSACTIONAL pro zƒÇÀápis dat ---
    @Override
    @Transactional
    public PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto) {
        PlayerEntity player = playerRepository.findById(dto.getPlayerId())
                .orElseThrow(() -> new IllegalArgumentException("HrƒÇÀá√Ñ≈§ s ID " + dto.getPlayerId() + " neexistuje."));

        validateDates(dto);

        // kontrola pƒπ‚Ñ¢ekryvu existujƒÇ¬≠cƒÇ¬≠ch obdobƒÇ¬≠
        boolean overlaps = !inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        player, dto.getInactiveFrom(), dto.getInactiveTo()
                ).isEmpty();

        if (overlaps) {
            throw new IllegalStateException("NovƒÇ¬© obdobƒÇ¬≠ se pƒπ‚Ñ¢ekrƒÇÀùvƒÇÀá s existujƒÇ¬≠cƒÇ¬≠m obdobƒÇ¬≠m neaktivity hrƒÇÀá√Ñ≈§e.");
        }

        PlayerInactivityPeriodEntity entity = mapper.toEntity(dto, player);
        return mapper.toDTO(inactivityRepository.save(entity));
    }

    @Override
    @Transactional
    public PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("ObdobƒÇ¬≠ neaktivity s ID " + id + " neexistuje."));

        validateDates(dto);

        // kontrola pƒπ‚Ñ¢ekryvu, ignoruje aktuƒÇÀálnƒÇ¬≠ zƒÇÀáznam
        boolean overlaps = inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        entity.getPlayer(), dto.getInactiveFrom(), dto.getInactiveTo()
                ).stream()
                .anyMatch(p -> !p.getId().equals(id));

        if (overlaps) {
            throw new IllegalStateException("UpravenƒÇ¬© obdobƒÇ¬≠ se pƒπ‚Ñ¢ekrƒÇÀùvƒÇÀá s jinƒÇÀùm obdobƒÇ¬≠m neaktivity hrƒÇÀá√Ñ≈§e.");
        }

        mapper.updateEntityFromDto(dto, entity);
        return mapper.toDTO(inactivityRepository.save(entity));
    }

    @Override
    @Transactional
    public void delete(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("ObdobƒÇ¬≠ neaktivity s ID " + id + " neexistuje."));
        inactivityRepository.delete(entity);
    }

    // --- true = aktivnƒÇ¬≠, false = neaktivnƒÇ¬≠ ---
    public boolean isActive(PlayerEntity player, LocalDateTime dateTime) {
        return !inactivityRepository.existsByPlayerAndInactiveFromLessThanEqualAndInactiveToGreaterThanEqual(
                player, dateTime, dateTime);
    }

    // --- privƒÇÀátnƒÇ¬≠ metoda pro validaci dat ---
    private void validateDates(PlayerInactivityPeriodDTO dto) {
        if (dto.getInactiveFrom() == null || dto.getInactiveTo() == null) {
            throw new IllegalArgumentException("Datum od a do nesmƒÇ¬≠ bƒÇÀùt null.");
        }
        if (!dto.getInactiveFrom().isBefore(dto.getInactiveTo())) {
            throw new IllegalArgumentException("inactiveFrom musƒÇ¬≠ bƒÇÀùt pƒπ‚Ñ¢ed inactiveTo.");
        }
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerService.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;

import java.util.List;


public interface PlayerService {
    List<PlayerDTO> getAllPlayers();
    PlayerDTO getPlayerById(Long id);
    PlayerDTO createPlayer(PlayerDTO player);
    PlayerDTO createPlayerForUser(PlayerDTO dto, String userEmail);
    PlayerDTO updatePlayer(Long id, PlayerDTO player);
    SuccessResponseDTO deletePlayer(Long id);
    public List<PlayerDTO> getPlayersByUser(String email);
    SuccessResponseDTO approvePlayer (Long id);
    SuccessResponseDTO rejectPlayer (Long id);
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerServiceImpl.java


package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.DuplicateNameSurnameException;
import cz.phsoft.hokej.exceptions.InvalidPlayerStatusException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;
import cz.phsoft.hokej.models.dto.PlayerDTO;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class PlayerServiceImpl implements PlayerService {

    private final PlayerRepository playerRepository;
    private final PlayerMapper playerMapper;
    private final AppUserRepository appUserRepository;

    public PlayerServiceImpl(PlayerRepository playerRepository, PlayerMapper playerMapper, AppUserRepository appUserRepository) {
        this.playerRepository = playerRepository;
        this.playerMapper = playerMapper;
        this.appUserRepository = appUserRepository;
    }

    @Override
    public List<PlayerDTO> getAllPlayers() {
        return playerRepository.findAll().stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    @Override
    public PlayerDTO getPlayerById(Long id) {
        PlayerEntity player = playerRepository.findById(id)
                .orElseThrow(() -> new PlayerNotFoundException(id)); // mƒÇ¬≠sto RuntimeException
        return playerMapper.toDTO(player);
    }


    // --- TRANSACTIONAL pro zƒÇÀápis dat ---
    @Override
    @Transactional
    public PlayerDTO createPlayer(PlayerDTO dto) {
        checkDuplicateNameSurname(dto.getName(), dto.getSurname(), null);

        PlayerEntity entity = playerMapper.toEntity(dto);
        PlayerEntity saved = playerRepository.save(entity);
        return playerMapper.toDTO(saved);
    }

    @Override
    @Transactional
    public PlayerDTO createPlayerForUser(PlayerDTO dto, String userEmail) {
        AppUserEntity user = appUserRepository.findByEmail(userEmail)
                .orElseThrow(() -> new RuntimeException("User not found"));

        PlayerEntity player = playerMapper.toEntity(dto);
        player.setUser(user); // pƒπ‚Ñ¢iƒπ‚Ñ¢azenƒÇ¬≠ hrƒÇÀá√Ñ≈§e k uƒπƒæivateli


        PlayerEntity saved = playerRepository.save(player);
        return playerMapper.toDTO(saved);
    }

    @Override
    public List<PlayerDTO> getPlayersByUser(String email) {
        return playerRepository.findByUser_EmailOrderByIdAsc(email).stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    @Override
    @Transactional
    public PlayerDTO updatePlayer(Long id, PlayerDTO dto) {
        PlayerEntity existing = findPlayerOrThrow(id);

        // pokud se jmƒÇ¬©no/pƒπ‚Ñ¢ƒÇ¬≠jmenƒÇ¬≠ m√Ñ‚Ä∫nƒÇ¬≠, ov√Ñ‚Ä∫ƒπ‚Ñ¢ duplicitu
        if (!existing.getName().equals(dto.getName())
                || !existing.getSurname().equals(dto.getSurname())) {
            checkDuplicateNameSurname(dto.getName(), dto.getSurname(), id);
        }

        existing.setName(dto.getName());
        existing.setSurname(dto.getSurname());
        existing.setNickname(dto.getNickName());
        existing.setPhoneNumber(dto.getPhoneNumber());
        existing.setType(dto.getType());
        existing.setTeam(dto.getTeam());
        existing.setStatus(dto.getStatus());

        PlayerEntity saved = playerRepository.save(existing);
        return playerMapper.toDTO(saved);
    }

    @Override
    @Transactional
    public SuccessResponseDTO deletePlayer(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);
        playerRepository.delete(player);

        return new SuccessResponseDTO(
                "HrƒÇÀá√Ñ≈§ " + player.getFullName() + " byl ƒÇ≈üsp√Ñ‚Ä∫ƒπÀán√Ñ‚Ä∫ smazƒÇÀán",
                id,
                LocalDateTime.now().toString()
        );
    }

    // --- privƒÇÀátnƒÇ¬≠ metoda pro kontrolu duplicity jmƒÇ¬©na a pƒπ‚Ñ¢ƒÇ¬≠jmenƒÇ¬≠ ---
    private void checkDuplicateNameSurname(String name, String surname, Long ignoreId) {
        Optional<PlayerEntity> duplicateOpt = playerRepository.findByNameAndSurname(name, surname);

        if (duplicateOpt.isPresent()) {
            if (ignoreId == null || !duplicateOpt.get().getId().equals(ignoreId)) {
                throw new DuplicateNameSurnameException("HrƒÇÀá√Ñ≈§ se jmƒÇ¬©nem " + name + " " + surname + " jiƒπƒæ existuje.");
            }
        }
    }

    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    @Override
    @Transactional
    public SuccessResponseDTO approvePlayer(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);

        if (player.getStatus() == PlayerStatus.APPROVED) {
            throw new InvalidPlayerStatusException("HrƒÇÀá√Ñ≈§ uƒπƒæ je schvƒÇÀálen.");
        }
        player.setStatus(PlayerStatus.APPROVED);
        playerRepository.save(player);
        return new SuccessResponseDTO(
                "HrƒÇÀá√Ñ≈§ " + player.getFullName() + " byl ƒÇ≈üsp√Ñ‚Ä∫ƒπÀán√Ñ‚Ä∫ aktivovƒÇÀán",
                id,
                LocalDateTime.now().toString()
        );
    }

    @Override
    @Transactional
    public SuccessResponseDTO rejectPlayer(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);

        if (player.getStatus() == PlayerStatus.REJECTED) {
            throw new InvalidPlayerStatusException("HrƒÇÀá√Ñ≈§ uƒπƒæ je zamƒÇ¬≠tnut.");
        }
        player.setStatus(PlayerStatus.REJECTED);
        playerRepository.save(player);

        return new SuccessResponseDTO(
                "HrƒÇÀá√Ñ≈§ " + player.getFullName() + " byl ƒÇ≈üsp√Ñ‚Ä∫ƒπÀán√Ñ‚Ä∫ zamƒÇ¬≠tnut",
                id,
                LocalDateTime.now().toString()
        );
    }


}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\CurrentPlayerContext.java


package cz.phsoft.hokej.security;


import cz.phsoft.hokej.data.entities.PlayerEntity;

// pro vƒÇÀùb√Ñ‚Ä∫r hrƒÇÀá√Ñ≈§e
public class CurrentPlayerContext {

        private static final ThreadLocal<PlayerEntity> currentPlayer = new ThreadLocal<>();

        public static void set(PlayerEntity player) {
            currentPlayer.set(player);
        }

        public static PlayerEntity get() {
            return currentPlayer.get();
        }

        public static void clear() {
            currentPlayer.remove();
        }
    }


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\CurrentPlayerFilter.java


package cz.phsoft.hokej.security;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;

@Component
public class CurrentPlayerFilter extends OncePerRequestFilter {

    private final PlayerRepository playerRepository;
    private final CurrentPlayerService currentPlayerService;

    public CurrentPlayerFilter(PlayerRepository playerRepository,
                               CurrentPlayerService currentPlayerService) {
        this.playerRepository = playerRepository;
        this.currentPlayerService = currentPlayerService;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {

        Long playerId = currentPlayerService.getCurrentPlayerId();

        if (playerId != null) {
            playerRepository.findById(playerId)
                    .ifPresent(CurrentPlayerContext::set);
        }

        try {
            filterChain.doFilter(request, response);
        } finally {
            CurrentPlayerContext.clear();
        }
    }
}



# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\CurrentPlayerService.java


package cz.phsoft.hokej.security;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import jakarta.servlet.http.HttpSession;
import org.springframework.stereotype.Service;

@Service
public class CurrentPlayerService {

    private final HttpSession session;
    private final PlayerRepository playerRepository;

    public CurrentPlayerService(HttpSession session, PlayerRepository playerRepository) {
        this.session = session;
        this.playerRepository = playerRepository;
    }

    public Long getCurrentPlayerId() {
        return (Long) session.getAttribute(SessionKeys.CURRENT_PLAYER_ID);
    }

    public void setCurrentPlayerId(Long playerId) {
        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));

        if (player.getStatus() != PlayerStatus.APPROVED) {
            throw new IllegalStateException(
                    "Nelze zvolit hrƒÇÀá√Ñ≈§e, kterƒÇÀù nenƒÇ¬≠ schvƒÇÀálen administrƒÇÀátorem."
            );
        }

        session.setAttribute(SessionKeys.CURRENT_PLAYER_ID, playerId);
    }

    public void requireCurrentPlayer() {
        if (getCurrentPlayerId() == null) {
            throw new IllegalStateException("NenƒÇ¬≠ zvolen aktuƒÇÀálnƒÇ¬≠ hrƒÇÀá√Ñ≈§");
        }
    }

    public void clear() {
        session.removeAttribute(SessionKeys.CURRENT_PLAYER_ID);
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\PlayerSecurity.java


package cz.phsoft.hokej.security;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;
// - ZatƒÇ¬≠m nepouƒπƒæƒÇ¬≠vƒÇÀám - pouƒπƒæƒÇ¬≠vƒÇÀám /me
@Component("playerSecurity") // nƒÇÀázev pro pouƒπƒæitƒÇ¬≠ v SpEL (@PreAuthorize)
public class PlayerSecurity {

    private static final Logger logger = LoggerFactory.getLogger(PlayerSecurity.class);

    private final PlayerRepository playerRepository;

    public PlayerSecurity(PlayerRepository playerRepository) {
        this.playerRepository = playerRepository;
    }

    /**
     * ZjistƒÇ¬≠, zda je aktuƒÇÀáln√Ñ‚Ä∫ pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇÀù uƒπƒæivatel vlastnƒÇ¬≠kem hrƒÇÀá√Ñ≈§e
     *
     * @param authentication aktuƒÇÀálnƒÇ¬≠ authentication objekt
     * @param playerId       ID hrƒÇÀá√Ñ≈§e
     * @return true pokud je vlastnƒÇ¬≠kem, jinak false
     */
    public boolean isOwner(Authentication authentication, Long playerId) {
        try {
            if (authentication == null || !authentication.isAuthenticated()) {
                logger.warn("NeautorizovanƒÇÀù pƒπ‚Ñ¢ƒÇ¬≠stup: ƒπƒæƒÇÀádnƒÇÀá autentizace pro playerId {}", playerId);
                return false;
            }

            Object principal = authentication.getPrincipal();
            if (!(principal instanceof UserDetails userDetails)) {
                logger.warn("NeautorizovanƒÇÀù pƒπ‚Ñ¢ƒÇ¬≠stup: principal nenƒÇ¬≠ UserDetails pro playerId {}", playerId);
                return false;
            }

            boolean isOwner = playerRepository.findById(playerId)
                    .map(player -> player.getUser() != null &&
                            player.getUser().getEmail().equals(userDetails.getUsername()))
                    .orElse(false);

            if (!isOwner) {
                logger.warn("NeautorizovanƒÇÀù pƒπ‚Ñ¢ƒÇ¬≠stup: uƒπƒæivatel {} nenƒÇ¬≠ vlastnƒÇ¬≠kem hrƒÇÀá√Ñ≈§e {}", userDetails.getUsername(), playerId);
            }

            return isOwner;

        } catch (Exception e) {
            logger.error("Chyba pƒπ‚Ñ¢i kontrole vlastnƒÇ¬≠ka hrƒÇÀá√Ñ≈§e {}: {}", playerId, e.getMessage(), e);
            // nikdy nepropustit vƒÇÀùjimku do SpEL
            return false;
        }
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\SessionKeys.java


package cz.phsoft.hokej.security;

public final class SessionKeys {
    private SessionKeys() {}

    public static final String CURRENT_PLAYER_ID = "CURRENT_PLAYER_ID";
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\StaraGardaApplication.java


package cz.phsoft.hokej;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableJpaRepositories // JPA v naƒπÀáem Spring Boot projektu
@EnableScheduling
@EnableAsync
public class StaraGardaApplication {
    public static void main(String[] args) {
        SpringApplication.run(StaraGardaApplication.class, args);


        }
    }


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\AppUserMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2026-01-20T13:10:47+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class AppUserMapperImpl implements AppUserMapper {

    @Override
    public AppUserDTO toDTO(AppUserEntity entity) {
        if ( entity == null ) {
            return null;
        }

        AppUserDTO appUserDTO = new AppUserDTO();

        appUserDTO.setPlayers( playerEntitySetToPlayerDTOSet( entity.getPlayers() ) );
        appUserDTO.setId( entity.getId() );
        appUserDTO.setName( entity.getName() );
        appUserDTO.setSurname( entity.getSurname() );
        appUserDTO.setEmail( entity.getEmail() );
        appUserDTO.setRole( entity.getRole() );
        appUserDTO.setEnabled( entity.isEnabled() );

        return appUserDTO;
    }

    @Override
    public List<AppUserDTO> toDtoList(List<AppUserEntity> entities) {
        if ( entities == null ) {
            return null;
        }

        List<AppUserDTO> list = new ArrayList<AppUserDTO>( entities.size() );
        for ( AppUserEntity appUserEntity : entities ) {
            list.add( toDTO( appUserEntity ) );
        }

        return list;
    }

    @Override
    public PlayerDTO toPlayerDTO(PlayerEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerDTO playerDTO = new PlayerDTO();

        playerDTO.setNickName( entity.getNickname() );
        playerDTO.setId( entity.getId() );
        playerDTO.setName( entity.getName() );
        playerDTO.setSurname( entity.getSurname() );
        playerDTO.setType( entity.getType() );
        playerDTO.setTeam( entity.getTeam() );
        playerDTO.setPhoneNumber( entity.getPhoneNumber() );
        playerDTO.setStatus( entity.getStatus() );

        return playerDTO;
    }

    protected Set<PlayerDTO> playerEntitySetToPlayerDTOSet(Set<PlayerEntity> set) {
        if ( set == null ) {
            return null;
        }

        Set<PlayerDTO> set1 = new LinkedHashSet<PlayerDTO>( Math.max( (int) ( set.size() / .75f ) + 1, 16 ) );
        for ( PlayerEntity playerEntity : set ) {
            set1.add( toPlayerDTO( playerEntity ) );
        }

        return set1;
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2026-01-20T13:10:46+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchMapperImpl implements MatchMapper {

    @Override
    public MatchDTO toDTO(MatchEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchDTO matchDTO = new MatchDTO();

        matchDTO.setId( entity.getId() );
        matchDTO.setDateTime( entity.getDateTime() );
        matchDTO.setLocation( entity.getLocation() );
        matchDTO.setDescription( entity.getDescription() );
        matchDTO.setMaxPlayers( entity.getMaxPlayers() );
        matchDTO.setPrice( entity.getPrice() );

        return matchDTO;
    }

    @Override
    public MatchEntity toEntity(MatchDTO dto) {
        if ( dto == null ) {
            return null;
        }

        MatchEntity matchEntity = new MatchEntity();

        matchEntity.setId( dto.getId() );
        matchEntity.setDateTime( dto.getDateTime() );
        matchEntity.setLocation( dto.getLocation() );
        matchEntity.setDescription( dto.getDescription() );
        matchEntity.setMaxPlayers( dto.getMaxPlayers() );
        matchEntity.setPrice( dto.getPrice() );

        return matchEntity;
    }

    @Override
    public void updateEntity(MatchDTO dto, MatchEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setDateTime( dto.getDateTime() );
        entity.setLocation( dto.getLocation() );
        entity.setDescription( dto.getDescription() );
        entity.setMaxPlayers( dto.getMaxPlayers() );
        entity.setPrice( dto.getPrice() );
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchRegistrationMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2026-01-20T13:10:47+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchRegistrationMapperImpl implements MatchRegistrationMapper {

    @Override
    public MatchRegistrationEntity toEntity(MatchEntity match, PlayerEntity player, PlayerMatchStatus status, ExcuseReason excuseReason, String note, Team team, String adminNote, String createdBy) {
        if ( match == null && player == null && status == null && excuseReason == null && note == null && team == null && adminNote == null && createdBy == null ) {
            return null;
        }

        MatchRegistrationEntity matchRegistrationEntity = new MatchRegistrationEntity();

        matchRegistrationEntity.setMatch( match );
        matchRegistrationEntity.setPlayer( player );
        matchRegistrationEntity.setStatus( status );
        matchRegistrationEntity.setExcuseReason( excuseReason );
        matchRegistrationEntity.setExcuseNote( note );
        matchRegistrationEntity.setTeam( team );
        matchRegistrationEntity.setAdminNote( adminNote );
        matchRegistrationEntity.setCreatedBy( createdBy );
        matchRegistrationEntity.setTimestamp( java.time.LocalDateTime.now() );

        return matchRegistrationEntity;
    }

    @Override
    public MatchRegistrationDTO toDTO(MatchRegistrationEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchRegistrationDTO matchRegistrationDTO = new MatchRegistrationDTO();

        matchRegistrationDTO.setMatchId( entityMatchId( entity ) );
        matchRegistrationDTO.setPlayerId( entityPlayerId( entity ) );
        matchRegistrationDTO.setId( entity.getId() );
        matchRegistrationDTO.setStatus( entity.getStatus() );
        matchRegistrationDTO.setExcuseReason( entity.getExcuseReason() );
        matchRegistrationDTO.setExcuseNote( entity.getExcuseNote() );
        matchRegistrationDTO.setAdminNote( entity.getAdminNote() );
        matchRegistrationDTO.setTeam( entity.getTeam() );
        matchRegistrationDTO.setCreatedBy( entity.getCreatedBy() );

        return matchRegistrationDTO;
    }

    @Override
    public List<MatchRegistrationDTO> toDTOList(List<MatchRegistrationEntity> entities) {
        if ( entities == null ) {
            return null;
        }

        List<MatchRegistrationDTO> list = new ArrayList<MatchRegistrationDTO>( entities.size() );
        for ( MatchRegistrationEntity matchRegistrationEntity : entities ) {
            list.add( toDTO( matchRegistrationEntity ) );
        }

        return list;
    }

    private Long entityMatchId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        MatchEntity match = matchRegistrationEntity.getMatch();
        if ( match == null ) {
            return null;
        }
        Long id = match.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }

    private Long entityPlayerId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        PlayerEntity player = matchRegistrationEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerInactivityPeriodMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2026-01-20T13:10:47+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerInactivityPeriodMapperImpl implements PlayerInactivityPeriodMapper {

    @Override
    public PlayerInactivityPeriodDTO toDTO(PlayerInactivityPeriodEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerInactivityPeriodDTO playerInactivityPeriodDTO = new PlayerInactivityPeriodDTO();

        playerInactivityPeriodDTO.setPlayerId( entityPlayerId( entity ) );
        playerInactivityPeriodDTO.setId( entity.getId() );
        playerInactivityPeriodDTO.setInactiveFrom( entity.getInactiveFrom() );
        playerInactivityPeriodDTO.setInactiveTo( entity.getInactiveTo() );

        return playerInactivityPeriodDTO;
    }

    @Override
    public PlayerInactivityPeriodEntity toEntity(PlayerInactivityPeriodDTO dto, PlayerEntity player) {
        if ( dto == null ) {
            return null;
        }

        PlayerInactivityPeriodEntity playerInactivityPeriodEntity = createEntity( dto, player );

        playerInactivityPeriodEntity.setInactiveFrom( dto.getInactiveFrom() );
        playerInactivityPeriodEntity.setInactiveTo( dto.getInactiveTo() );

        return playerInactivityPeriodEntity;
    }

    @Override
    public void updateEntityFromDto(PlayerInactivityPeriodDTO dto, PlayerInactivityPeriodEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setInactiveFrom( dto.getInactiveFrom() );
        entity.setInactiveTo( dto.getInactiveTo() );
    }

    private Long entityPlayerId(PlayerInactivityPeriodEntity playerInactivityPeriodEntity) {
        if ( playerInactivityPeriodEntity == null ) {
            return null;
        }
        PlayerEntity player = playerInactivityPeriodEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2026-01-20T13:10:47+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerMapperImpl implements PlayerMapper {

    @Override
    public PlayerDTO toDTO(PlayerEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerDTO playerDTO = new PlayerDTO();

        playerDTO.setNickName( entity.getNickname() );
        playerDTO.setId( entity.getId() );
        playerDTO.setName( entity.getName() );
        playerDTO.setSurname( entity.getSurname() );
        playerDTO.setType( entity.getType() );
        playerDTO.setTeam( entity.getTeam() );
        playerDTO.setPhoneNumber( entity.getPhoneNumber() );
        playerDTO.setStatus( entity.getStatus() );

        return playerDTO;
    }

    @Override
    public PlayerEntity toEntity(PlayerDTO dto) {
        if ( dto == null ) {
            return null;
        }

        PlayerEntity playerEntity = new PlayerEntity();

        playerEntity.setNickname( dto.getNickName() );
        playerEntity.setId( dto.getId() );
        playerEntity.setName( dto.getName() );
        playerEntity.setSurname( dto.getSurname() );
        playerEntity.setType( dto.getType() );
        playerEntity.setPhoneNumber( dto.getPhoneNumber() );
        playerEntity.setTeam( dto.getTeam() );
        playerEntity.setNickName( dto.getNickName() );

        playerEntity.setStatus( dto.getStatus() != null ? dto.getStatus() : cz.phsoft.hokej.data.enums.PlayerStatus.PENDING );

        return playerEntity;
    }

    @Override
    public void updatePlayerDTO(PlayerDTO source, PlayerDTO target) {
        if ( source == null ) {
            return;
        }

        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setNickName( source.getNickName() );
        target.setType( source.getType() );
        target.setTeam( source.getTeam() );
        target.setPhoneNumber( source.getPhoneNumber() );
        target.setStatus( source.getStatus() );
    }

    @Override
    public void updatePlayerEntity(PlayerDTO source, PlayerEntity target) {
        if ( source == null ) {
            return;
        }

        target.setNickname( source.getNickName() );
        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setType( source.getType() );
        target.setPhoneNumber( source.getPhoneNumber() );
        target.setTeam( source.getTeam() );
        target.setNickName( source.getNickName() );

        target.setStatus( source.getStatus() != null ? source.getStatus() : target.getStatus() );
    }

    @Override
    public List<PlayerDTO> toDTOList(List<PlayerEntity> players) {
        if ( players == null ) {
            return null;
        }

        List<PlayerDTO> list = new ArrayList<PlayerDTO>( players.size() );
        for ( PlayerEntity playerEntity : players ) {
            list.add( toDTO( playerEntity ) );
        }

        return list;
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-04T13:04:23+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchMapperImpl implements MatchMapper {

    @Override
    public MatchDTO toDTO(MatchEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchDTO matchDTO = new MatchDTO();

        matchDTO.setId( entity.getId() );
        matchDTO.setDateTime( entity.getDateTime() );
        matchDTO.setLocation( entity.getLocation() );
        matchDTO.setDescription( entity.getDescription() );
        matchDTO.setMaxPlayers( entity.getMaxPlayers() );
        matchDTO.setPrice( entity.getPrice() );

        return matchDTO;
    }

    @Override
    public MatchEntity toEntity(MatchDTO dto) {
        if ( dto == null ) {
            return null;
        }

        MatchEntity matchEntity = new MatchEntity();

        matchEntity.setId( dto.getId() );
        matchEntity.setDateTime( dto.getDateTime() );
        matchEntity.setLocation( dto.getLocation() );
        matchEntity.setDescription( dto.getDescription() );
        matchEntity.setMaxPlayers( dto.getMaxPlayers() );
        matchEntity.setPrice( dto.getPrice() );

        return matchEntity;
    }

    @Override
    public void updateEntity(MatchDTO dto, MatchEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setDateTime( dto.getDateTime() );
        entity.setLocation( dto.getLocation() );
        entity.setDescription( dto.getDescription() );
        entity.setMaxPlayers( dto.getMaxPlayers() );
        entity.setPrice( dto.getPrice() );
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchRegistrationMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.JerseyColor;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-04T13:04:22+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchRegistrationMapperImpl implements MatchRegistrationMapper {

    @Override
    public MatchRegistrationEntity toEntity(MatchEntity match, PlayerEntity player, PlayerMatchStatus status, ExcuseReason excuseReason, String note, JerseyColor jerseyColor, String adminNote, String createdBy) {
        if ( match == null && player == null && status == null && excuseReason == null && note == null && jerseyColor == null && adminNote == null && createdBy == null ) {
            return null;
        }

        MatchRegistrationEntity matchRegistrationEntity = new MatchRegistrationEntity();

        matchRegistrationEntity.setMatch( match );
        matchRegistrationEntity.setPlayer( player );
        matchRegistrationEntity.setStatus( status );
        matchRegistrationEntity.setExcuseReason( excuseReason );
        matchRegistrationEntity.setExcuseNote( note );
        matchRegistrationEntity.setJerseyColor( jerseyColor );
        matchRegistrationEntity.setAdminNote( adminNote );
        matchRegistrationEntity.setCreatedBy( createdBy );
        matchRegistrationEntity.setTimestamp( java.time.LocalDateTime.now() );

        return matchRegistrationEntity;
    }

    @Override
    public MatchRegistrationDTO toDTO(MatchRegistrationEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchRegistrationDTO matchRegistrationDTO = new MatchRegistrationDTO();

        matchRegistrationDTO.setMatchId( entityMatchId( entity ) );
        matchRegistrationDTO.setPlayerId( entityPlayerId( entity ) );
        matchRegistrationDTO.setId( entity.getId() );
        matchRegistrationDTO.setStatus( entity.getStatus() );
        matchRegistrationDTO.setExcuseReason( entity.getExcuseReason() );
        matchRegistrationDTO.setExcuseNote( entity.getExcuseNote() );
        matchRegistrationDTO.setAdminNote( entity.getAdminNote() );
        matchRegistrationDTO.setJerseyColor( entity.getJerseyColor() );
        matchRegistrationDTO.setCreatedBy( entity.getCreatedBy() );

        return matchRegistrationDTO;
    }

    private Long entityMatchId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        MatchEntity match = matchRegistrationEntity.getMatch();
        if ( match == null ) {
            return null;
        }
        Long id = match.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }

    private Long entityPlayerId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        PlayerEntity player = matchRegistrationEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerInactivityPeriodMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-04T13:04:23+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerInactivityPeriodMapperImpl implements PlayerInactivityPeriodMapper {

    @Override
    public PlayerInactivityPeriodDTO toDTO(PlayerInactivityPeriodEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerInactivityPeriodDTO playerInactivityPeriodDTO = new PlayerInactivityPeriodDTO();

        playerInactivityPeriodDTO.setPlayerId( entityPlayerId( entity ) );
        playerInactivityPeriodDTO.setId( entity.getId() );
        playerInactivityPeriodDTO.setInactiveFrom( entity.getInactiveFrom() );
        playerInactivityPeriodDTO.setInactiveTo( entity.getInactiveTo() );

        return playerInactivityPeriodDTO;
    }

    @Override
    public PlayerInactivityPeriodEntity toEntity(PlayerInactivityPeriodDTO dto, PlayerEntity player) {
        if ( dto == null ) {
            return null;
        }

        PlayerInactivityPeriodEntity playerInactivityPeriodEntity = createEntity( dto, player );

        playerInactivityPeriodEntity.setInactiveFrom( dto.getInactiveFrom() );
        playerInactivityPeriodEntity.setInactiveTo( dto.getInactiveTo() );

        return playerInactivityPeriodEntity;
    }

    @Override
    public void updateEntityFromDto(PlayerInactivityPeriodDTO dto, PlayerInactivityPeriodEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setInactiveFrom( dto.getInactiveFrom() );
        entity.setInactiveTo( dto.getInactiveTo() );
    }

    private Long entityPlayerId(PlayerInactivityPeriodEntity playerInactivityPeriodEntity) {
        if ( playerInactivityPeriodEntity == null ) {
            return null;
        }
        PlayerEntity player = playerInactivityPeriodEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}


# Soubor: C:\Projekty Pr√°ce\StaraGarda\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerMapperImpl.java


package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-04T13:04:23+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerMapperImpl implements PlayerMapper {

    @Override
    public PlayerDTO toDTO(PlayerEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerDTO playerDTO = new PlayerDTO();

        playerDTO.setId( entity.getId() );
        playerDTO.setName( entity.getName() );
        playerDTO.setSurname( entity.getSurname() );
        playerDTO.setType( entity.getType() );
        playerDTO.setJerseyColor( entity.getJerseyColor() );

        return playerDTO;
    }

    @Override
    public PlayerEntity toEntity(PlayerDTO dto) {
        if ( dto == null ) {
            return null;
        }

        PlayerEntity playerEntity = new PlayerEntity();

        playerEntity.setId( dto.getId() );
        playerEntity.setName( dto.getName() );
        playerEntity.setSurname( dto.getSurname() );
        playerEntity.setType( dto.getType() );
        playerEntity.setJerseyColor( dto.getJerseyColor() );

        return playerEntity;
    }

    @Override
    public void updatePlayerDTO(PlayerDTO source, PlayerDTO target) {
        if ( source == null ) {
            return;
        }

        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setType( source.getType() );
        target.setJerseyColor( source.getJerseyColor() );
    }

    @Override
    public void updatePlayerEntity(PlayerDTO source, PlayerEntity target) {
        if ( source == null ) {
            return;
        }

        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setType( source.getType() );
        target.setJerseyColor( source.getJerseyColor() );
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\AppConfig.java
--------------------
package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class AppConfig {

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\AuditAspect.java
--------------------
package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

@Component
@Aspect
public class AuditAspect {

    private static final Logger logger = LoggerFactory.getLogger("AUDIT_LOGGER");

    // Pointcut pro vƒπÀáechny metody ve sluƒπƒæbƒÇÀách
    @Pointcut("within(cz.phsoft.hokej.models.services..*)")
    public void serviceMethods() {}

    // SpustƒÇ¬≠ se pƒπ‚Ñ¢ed metodou
    @Before("serviceMethods()")
    public void logBefore(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().toShortString();
        String args = java.util.Arrays.toString(joinPoint.getArgs());
        logger.info("START {} at {} with args {}", methodName, LocalDateTime.now(), args);
    }

    // SpustƒÇ¬≠ se po ƒÇ≈üsp√Ñ‚Ä∫ƒπÀánƒÇ¬©m dokon√Ñ≈§enƒÇ¬≠ metody
    @AfterReturning(pointcut = "serviceMethods()", returning = "result")
    public void logAfterReturning(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();

        Long userId = null;
        Long playerId = null;

        for (Object arg : args) {
            if (arg instanceof PlayerEntity player) {
                playerId = player.getId();
            } else if (arg instanceof MatchRegistrationEntity registration) {
                playerId = registration.getPlayer().getId();
            } else if (arg instanceof Long id) {
                // pokud mƒÇÀá metoda Long parametry, mƒπ≈ªƒπƒæeƒπÀá ur√Ñ≈§it podle poƒπ‚Ñ¢adƒÇ¬≠
                // tƒπ‚Ñ¢eba prvnƒÇ¬≠ Long = matchId, druhƒÇÀù = playerId
            }
        }

        // logovƒÇÀánƒÇ¬≠
        logger.info("END {} - userId={} playerId={} returned [{}] at {}",
                methodName, userId, playerId, result, LocalDateTime.now());
    }
}

--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\CustomJsonLoginFilter.java
--------------------
package cz.phsoft.hokej.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.context.HttpSessionSecurityContextRepository;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

// filtr pro REST login
public class CustomJsonLoginFilter extends UsernamePasswordAuthenticationFilter {

    private final ObjectMapper objectMapper = new ObjectMapper();

    public CustomJsonLoginFilter(String loginUrl, AuthenticationManager authManager) {
        setFilterProcessesUrl(loginUrl);
        setAuthenticationManager(authManager);
    }

    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        try {
            // x-www-form-urlencoded i JSON
            String email = null;
            String password = null;

// x-www-form-urlencoded
            if (request.getContentType() != null &&
                    request.getContentType().contains("application/x-www-form-urlencoded")) {
                email = request.getParameter("username");
                password = request.getParameter("password");
            }

// JSON
            if ((email == null || password == null) &&
                    request.getContentType() != null &&
                    request.getContentType().contains("application/json")) {
                Map<String, String> json = objectMapper.readValue(request.getInputStream(), Map.class);
                email = json.get("email");
                password = json.get("password");
            }

            if (email == null || password == null || email.isBlank() || password.isBlank()) {
                throw new BadCredentialsException("ChybƒÇ¬≠ pƒπ‚Ñ¢ihlaƒπÀáovacƒÇ¬≠ ƒÇ≈üdaje");
            }

            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(email, password);
            setDetails(request, authRequest);

            return this.getAuthenticationManager().authenticate(authRequest);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    // ƒÇ≈°sp√Ñ‚Ä∫ƒπÀánƒÇÀù login
    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
                                            FilterChain chain, Authentication authResult)
            throws IOException, ServletException {

        // UloƒπƒæenƒÇ¬≠ do SecurityContextHolder
        SecurityContextHolder.getContext().setAuthentication(authResult);

        // Vytvoƒπ‚Ñ¢enƒÇ¬≠ session a uloƒπƒæenƒÇ¬≠ SPRING_SECURITY_CONTEXT
        request.getSession(true).setAttribute(
                HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY,
                SecurityContextHolder.getContext()
        );

        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");

        Map<String, Object> result = new HashMap<>();
        result.put("status", "ok");
        result.put("user", authResult.getName());

        objectMapper.writeValue(response.getWriter(), result);
    }

    // NeƒÇ≈üsp√Ñ‚Ä∫ƒπÀánƒÇÀù login
    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException {
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");

        Map<String, Object> result = new HashMap<>();
        result.put("status", "error");

        // RozliƒπÀáenƒÇ¬≠ neaktivovanƒÇ¬©ho ƒÇ≈ü√Ñ≈§tu
        if (failed.getCause() instanceof cz.phsoft.hokej.exceptions.AccountNotActivatedException) {
            result.put("message", failed.getCause().getMessage()); // napƒπ‚Ñ¢. "ƒÇ≈°√Ñ≈§et nenƒÇ¬≠ aktivovƒÇÀán. Zkontrolujte email."
        } else if (failed instanceof BadCredentialsException) {
            result.put("message", "NeplatnƒÇ¬© pƒπ‚Ñ¢ihlaƒπÀáovacƒÇ¬≠ ƒÇ≈üdaje");
        } else {
            result.put("message", "Chyba pƒπ‚Ñ¢i pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬≠");
        }

        objectMapper.writeValue(response.getWriter(), result);
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\CustomUserDetailsService.java
--------------------
package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import cz.phsoft.hokej.exceptions.AccountNotActivatedException;

import java.util.Set;
import java.util.stream.Collectors;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final AppUserRepository appUserRepository;

    public CustomUserDetailsService(AppUserRepository appUserRepository) {
        this.appUserRepository = appUserRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        AppUserEntity user = appUserRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("Uƒπƒæivatel nenalezen"));

        if (!user.isEnabled()) { // nebo podle status == PENDING
            throw new AccountNotActivatedException();
        }

        return org.springframework.security.core.userdetails.User.builder()
                .username(user.getEmail())
                .password(user.getPassword())
                .roles(user.getRole().name().replace("ROLE_", "")) // "ADMIN", "PLAYER", ...
                .disabled(!user.isEnabled()) // neaktivnƒÇ¬≠ - nelze se pƒπ‚Ñ¢ƒÇ¬≠hlƒÇÀásit
                .build();
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\DataInitializer.java
--------------------
package cz.phsoft.hokej.config;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.*;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import jakarta.annotation.PostConstruct;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Component;
import org.springframework.jdbc.core.JdbcTemplate;


import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Component
public class DataInitializer {

    private final PlayerRepository playerRepository;
    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository matchRegistrationRepository;
    private final AppUserRepository appUserRepository;
    private final JdbcTemplate jdbcTemplate;

    public DataInitializer(PlayerRepository playerRepository,
                           MatchRepository matchRepository,
                           MatchRegistrationRepository matchRegistrationRepository,
                           AppUserRepository appUserRepository,
                           JdbcTemplate jdbcTemplate) {
        this.playerRepository = playerRepository;
        this.matchRepository = matchRepository;
        this.matchRegistrationRepository = matchRegistrationRepository;
        this.appUserRepository = appUserRepository;
        this.jdbcTemplate = jdbcTemplate;
    }

    @PostConstruct
    public void init() {
        // Pokud existuje alespoƒπ¬à 1 hrƒÇÀá√Ñ≈§, DB uƒπƒæ byla inicializovanƒÇÀá
        if (playerRepository.count() > 0) {
            System.out.println("Data already initialized √¢‚Ç¨‚Äú skipping DataInitializer.");
            return;
        }
        System.out.println("Initializing default data...");

        // --- Seznam hrƒÇÀá√Ñ≈§ƒπ≈ª ---
        List<PlayerEntity> players = new ArrayList<>(List.of(
                new PlayerEntity("HrƒÇÀá√Ñ≈§_1", "Jedna", "", PlayerType.VIP, "+420776609956", Team.DARK, PlayerStatus.APPROVED),
                new PlayerEntity("HrƒÇÀá√Ñ≈§_2", "Dva", "", PlayerType.VIP, "+420776609956", Team.LIGHT, PlayerStatus.APPROVED),
                new PlayerEntity("HrƒÇÀá√Ñ≈§_3", "Tƒπ‚Ñ¢i", "", PlayerType.VIP, "+420776609956", Team.LIGHT, PlayerStatus.APPROVED),
                new PlayerEntity("HrƒÇÀá√Ñ≈§_4", "√Ñ≈ötyƒπ‚Ñ¢i", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT, PlayerStatus.APPROVED),
                new PlayerEntity("HrƒÇÀá√Ñ≈§_5", "P√Ñ‚Ä∫t", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT, PlayerStatus.PENDING),
                new PlayerEntity("HrƒÇÀá√Ñ≈§_6", "ƒπ¬†est", "", PlayerType.STANDARD, "+420776609956", Team.DARK, PlayerStatus.PENDING),
                new PlayerEntity("HrƒÇÀá√Ñ≈§_7", "Sedm", "", PlayerType.STANDARD, "+420776609956", Team.LIGHT, PlayerStatus.PENDING),
                new PlayerEntity("HrƒÇÀá√Ñ≈§_8", "Osum", "", PlayerType.BASIC, "+420776609956", Team.DARK, PlayerStatus.PENDING),
                new PlayerEntity("HrƒÇÀá√Ñ≈§_9", "Dev√Ñ‚Ä∫t", "", PlayerType.BASIC, "+420776609956", Team.DARK, PlayerStatus.PENDING),
                new PlayerEntity("HrƒÇÀá√Ñ≈§_10", "Deset", "", PlayerType.BASIC, "+420776609956", Team.DARK, PlayerStatus.PENDING)
                // ... pƒπ‚Ñ¢ƒÇ¬≠padn√Ñ‚Ä∫ dalƒπÀáƒÇ¬≠ hrƒÇÀá√Ñ≈§i
        ));

        // --- Vytvoƒπ‚Ñ¢enƒÇ¬≠ uƒπƒæivatelƒπ≈ª ke kaƒπƒædƒÇ¬©mu hrƒÇÀá√Ñ≈§i ---

        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();

        // --- Default admin ---
        if (appUserRepository.findByEmail("admin@example.com").isEmpty()) {
            AppUserEntity admin = new AppUserEntity();
            admin.setName("admin");
            admin.setSurname("admin");
            admin.setEmail("admin@example.com");
            admin.setPassword(encoder.encode("Administrator123"));
            admin.setRole(Role.ROLE_ADMIN);
            admin.setEnabled(true);
            appUserRepository.save(admin);
            System.out.println("Default admin user created.");
        } else {
            System.out.println("Admin user already exists √¢‚Ç¨‚Äú skipping.");
        }

        System.out.println("Data initialization completed.");

        int playerCounter = 1;
        for (PlayerEntity player : players) {
            // vytvoƒπ‚Ñ¢enƒÇ¬≠ uƒπƒæivatele
            String email = "player" + playerCounter + "@example.com";
            String password = "Player123";

            AppUserEntity user = new AppUserEntity();
            user.setName("HrƒÇÀá√Ñ≈§" + playerCounter);
            user.setSurname("√Ñ≈öƒÇ¬≠slo_" + playerCounter);
            user.setEmail(email);
            user.setPassword(encoder.encode(password));

            switch (playerCounter){
                case 1:
                    user.setRole(Role.ROLE_ADMIN);
                    System.out.println("Nastavena role: admin");
                    break;
                case 2:
                    user.setRole(Role.ROLE_MANAGER);
                    System.out.println("Nastavena role: manager");
                    break;
                default:
                    user.setRole(Role.ROLE_PLAYER);
                    System.out.println("Nastavena role: player");
            }
            user.setEnabled(true);
            // pƒπ‚Ñ¢iƒπ‚Ñ¢adit hrƒÇÀá√Ñ≈§e k uƒπƒæivateli
            System.out.println("VytvƒÇÀáƒπ‚Ñ¢ƒÇ¬≠m uƒπƒæivatele √Ñ≈§. " + playerCounter);
            player.setUser(user);

            // uloƒπƒæit uƒπƒæivatele (cascade uloƒπƒæƒÇ¬≠ i hrƒÇÀá√Ñ≈§e, pokud je sprƒÇÀávn√Ñ‚Ä∫ nastaven)
            appUserRepository.save(user);

            playerCounter++;
        }

        // --- Uloƒπƒæit hrƒÇÀá√Ñ≈§e (uƒπƒæ uloƒπƒæen pƒπ‚Ñ¢i cascade, ale pro jistotu) ---
        playerRepository.saveAll(players);

        // --- Vytvoƒπ‚Ñ¢enƒÇ¬≠ zƒÇÀápasƒπ≈ª ---
        LocalDateTime startDate = LocalDateTime.of(2025, 11, 21, 18, 45);
        for (int i = 0; i < 10; i++) {
            MatchEntity match = new MatchEntity();
            match.setDateTime(startDate.plusWeeks(i));
            match.setLocation("Ostravice");
            match.setDescription("");
            match.setMaxPlayers(12);
            match.setPrice(2200);
            matchRepository.save(match);
        }

        // --- Registrace hrƒÇÀá√Ñ≈§ƒπ≈ª na zƒÇÀápas id 3 ---
        MatchEntity match3 = matchRepository.findById(3L)
                .orElseThrow(() -> new RuntimeException("Match with id 3 not found"));

        for (long playerId = 1; playerId <= 6; playerId++) {
            final long pid = playerId;
            PlayerEntity player = playerRepository.findById(playerId)
                    .orElseThrow(() -> new RuntimeException("Player with id " + pid + " not found"));

            MatchRegistrationEntity reg = new MatchRegistrationEntity();
            reg.setMatch(match3);
            reg.setPlayer(player);
            reg.setStatus(PlayerMatchStatus.REGISTERED);
            if (playerId <=3){
                reg.setTeam(Team.DARK);
            }else {
                reg.setTeam(Team.LIGHT);
            }
            reg.setTimestamp(LocalDateTime.now());
            reg.setCreatedBy("user");
            matchRegistrationRepository.save(reg);
        }

        // --- Default admin ---
        if (appUserRepository.findByEmail("admin@example.com").isEmpty()) {
            AppUserEntity admin = new AppUserEntity();
            admin.setEmail("admin@example.com");
            admin.setPassword(encoder.encode("Administrator123"));
            admin.setRole(Role.ROLE_ADMIN);
            appUserRepository.save(admin);
            System.out.println("Default admin user created.");
        } else {
            System.out.println("Admin user already exists √¢‚Ç¨‚Äú skipping.");
        }

        // --- vytvoƒπ‚Ñ¢enƒÇ¬≠ triggeru ---
        try {
            jdbcTemplate.execute("""
                           CREATE TRIGGER trg_match_reg_insert
                           AFTER INSERT ON match_registrations
                           FOR EACH ROW
                           BEGIN
                               INSERT INTO match_registration_history
                               (match_registration_id, match_id, player_id, status, excuse_reason,
                                excuse_note, admin_note, team, original_timestamp, created_by,
                                action, changed_at)
                               VALUES
                               (NEW.id, NEW.match_id, NEW.player_id, NEW.status, NEW.excuse_reason,
                                NEW.excuse_note, NEW.admin_note, NEW.team, NEW.timestamp, NEW.created_by,
                                'INSERT', NOW());
                           END
                    """);
            System.out.println("Trigger created successfully.");
        } catch (Exception e) {
            System.out.println("Trigger already exists or error: " + e.getMessage());
        }

        try {
            jdbcTemplate.execute("""
                    CREATE TRIGGER trg_match_reg_update
                    AFTER UPDATE ON match_registrations
                    FOR EACH ROW
                    BEGIN
                        INSERT INTO match_registration_history
                        (match_registration_id, match_id, player_id, status, excuse_reason,
                         excuse_note, admin_note, team, original_timestamp, created_by,
                         action, changed_at)
                        VALUES
                        (NEW.id, NEW.match_id, NEW.player_id, NEW.status, NEW.excuse_reason,
                         NEW.excuse_note, NEW.admin_note, NEW.team, NEW.timestamp, NEW.created_by,
                         'UPDATE', NOW());
                    END
                    """);
            System.out.println("Trigger created successfully.");
        } catch (Exception e) {
            System.out.println("Trigger already exists or error: " + e.getMessage());
        }

        try {
            jdbcTemplate.execute("""
        CREATE TRIGGER trg_match_reg_delete
        AFTER DELETE ON match_registrations
        FOR EACH ROW
                BEGIN
        INSERT INTO match_registration_history
                (match_registration_id, match_id, player_id, status, excuse_reason,
                        excuse_note, admin_note, team, original_timestamp, created_by,
                        action, changed_at)
        VALUES
                (OLD.id, OLD.match_id, OLD.player_id, OLD.status, OLD.excuse_reason,
                        OLD.excuse_note, OLD.admin_note, OLD.team, OLD.timestamp, OLD.created_by,
                        'DELETE', NOW());
        END
        """);
            System.out.println("Trigger created successfully.");
                } catch (Exception e) {
                    System.out.println("Trigger already exists or error: " + e.getMessage());
                }
        
        System.out.println("Data initialization completed.");
    

    }
}



--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\GlobalExceptionHandler.java
--------------------
package cz.phsoft.hokej.config;

import cz.phsoft.hokej.exceptions.*;
import cz.phsoft.hokej.exceptions.ApiError;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import jakarta.servlet.http.HttpServletRequest;

@ControllerAdvice
public class GlobalExceptionHandler {

    // VlastnƒÇ¬≠ business vyjƒÇ¬≠mky - BusinessException
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ApiError> handleBusinessException(
            BusinessException ex,
            HttpServletRequest request) {

        ApiError error = new ApiError(
                ex.getStatus().value(),
                ex.getStatus().getReasonPhrase(),
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()
        );
        return ResponseEntity.status(ex.getStatus()).body(error);
    }

    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ApiError> handleAccessDenied(AccessDeniedException ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.FORBIDDEN.value(),
                "Forbidden",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // √¢‚Ä†¬ê IP klienta);
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(error);
    }

    // --- NenalezenƒÇ¬© zdroje (404) ---
    @ExceptionHandler({
            MatchNotFoundException.class,
            PlayerNotFoundException.class,
            RegistrationNotFoundException.class
    })
    public ResponseEntity<ApiError> handleNotFound(RuntimeException ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.NOT_FOUND.value(),
                "Not Found",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // √¢‚Ä†¬ê IP klienta
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    // --- Konflikty (409) ---
    @ExceptionHandler(DuplicateRegistrationException.class)
    public ResponseEntity<ApiError> handleConflict(DuplicateRegistrationException ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.CONFLICT.value(),
                "Conflict",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // √¢‚Ä†¬ê IP klienta);
        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
    }

    // --- ObecnƒÇ¬© chyby (500) ---
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiError> handleAll(Exception ex, HttpServletRequest request) {
        ApiError error = new ApiError(HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error",
                ex.getMessage(),
                request.getRequestURI(),
                request.getRemoteAddr()); // √¢‚Ä†¬ê IP klienta);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\config\SecurityConfig.java
--------------------
package cz.phsoft.hokej.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.security.config.http.SessionCreationPolicy;


import java.util.List;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;

    @Value("${app.test-mode:false}")
    private boolean isTestMode;

    public SecurityConfig(CustomUserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    // Password encoder
    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    // Authentication provider
    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    // AuthenticationManager
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    // Security filter chain
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http, AuthenticationManager authManager) throws Exception {

        http.csrf(csrf -> csrf.disable())
                .cors(cors -> {
                });

        if (isTestMode) {
            // Test mode - vƒπÀáechno povoleno a HTTP Basic pro Postman
            http.authorizeHttpRequests(auth -> auth.anyRequest().permitAll())
                    .httpBasic();
        } else {
            // Produkce - REST login pƒπ‚Ñ¢es CustomJsonLoginFilter
            http
                    .authenticationProvider(authenticationProvider())
                    .authorizeHttpRequests(auth -> auth
                            .requestMatchers("/api/auth/register", "/api/auth/verify").permitAll()
                            .requestMatchers("/api/login").permitAll()
                            .requestMatchers("/api/logout").permitAll()
                            .requestMatchers("/api/matches").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/matches/upcoming", "/api/matches/past").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/matches/**").authenticated()
                            .requestMatchers("/api/players").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/players/**").authenticated()
                            .requestMatchers("/api/registrations/all",
                                    "/api/registrations/for-match/**",
                                    "/api/registrations/no-response/**").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/registrations/**").authenticated()
                            .requestMatchers("/api/inactivity/All",
                                    "/api/inactivity/**").hasAnyRole("ADMIN", "MANAGER")
                            .requestMatchers("/api/inactivity/player/**").authenticated()
                            .anyRequest().authenticated()
                    )
                    //  TADY Pƒπ¬òESN√Ñ≈°
                    .sessionManagement(sm ->
                            sm.sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
                    )
                    //  a TEPRVE PAK login filter
                    .addFilterAt(
                            new CustomJsonLoginFilter("/api/login", authManager),
                            UsernamePasswordAuthenticationFilter.class
                    )
                    .logout(logout -> logout
                            .logoutUrl("/api/logout")
                            .deleteCookies("JSESSIONID")
                            .logoutSuccessHandler((request, response, auth) -> {
                                request.getSession().removeAttribute("CURRENT_PLAYER_ID");
                                response.setContentType("application/json");
                                response.setCharacterEncoding("UTF-8");
                                response.getWriter().write("{\"status\":\"ok\",\"message\":\"OdhlƒÇÀáƒπÀáeno\"}");
                            })
                    );
        }

        return http.build();
    }

    // CORS pro React dev server a cookies
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(List.of("http://localhost:5173"));
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AdminMatchController.java
--------------------
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.services.MatchService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/matches/admin")
@CrossOrigin(origins = "*")
public class AdminMatchController {
    private final MatchService matchService;
    private final CurrentPlayerService currentPlayerService;


    public AdminMatchController(MatchService matchService,
                           CurrentPlayerService currentPlayerService) {
        this.matchService = matchService;
        this.currentPlayerService = currentPlayerService;
    }

    // VƒπÀáechny zƒÇÀápasy
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getAllMatches() {
        return matchService.getAllMatches();
    }

    // VƒπÀáechny nadchƒÇÀázejƒÇ¬≠cƒÇ¬≠ zƒÇÀápasy
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    @GetMapping("/upcoming")
    public List<MatchDTO> getUpcomingMatches() {
        return matchService.getUpcomingMatches();
    }

    // Uƒπƒæ uskute√Ñ≈§n√Ñ‚Ä∫nƒÇ¬© zƒÇÀápasy
    @GetMapping("/past")
    public List<MatchDTO> getPastMatches() {
        return matchService.getPastMatches();
    }

    // Vytvoƒπ‚Ñ¢enƒÇ¬≠ zƒÇÀápasu
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public MatchDTO createMatch(@Valid @RequestBody MatchDTO matchDTO) {
        return matchService.createMatch(matchDTO);
    }

    // ZƒÇ¬≠skƒÇÀánƒÇ¬≠ zƒÇÀápasu podle ID
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO getMatch(@PathVariable Long id) {
        return matchService.getMatchById(id);
    }

    // Editace zƒÇÀápasu
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchDTO updateMatch(@PathVariable Long id, @Valid @RequestBody MatchDTO dto) {
        return matchService.updateMatch(id, dto);
    }

    // SmazƒÇÀánƒÇ¬≠ zƒÇÀápasu
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SuccessResponseDTO> deleteMatch(@PathVariable Long id) {
        SuccessResponseDTO response = matchService.deleteMatch(id);
        return ResponseEntity.ok(response);
    }

    // DostupnƒÇ¬© zƒÇÀápasy pro hrƒÇÀá√Ñ≈§e
    @GetMapping("/available-for-player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchDTO> getAvailableMatchesForPlayer(@PathVariable Long playerId) {
        return matchService.getAvailableMatchesForPlayer(playerId);
    }

}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AdminMatchRegistrationController.java
--------------------
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/registrations/admin")
@CrossOrigin(origins = "*")
public class AdminMatchRegistrationController {
    private final MatchRegistrationService service;
    private final CurrentPlayerService currentPlayerService;

    public AdminMatchRegistrationController(MatchRegistrationService service,
                                       CurrentPlayerService currentPlayerService) {
        this.service = service;
        this.currentPlayerService = currentPlayerService;
    }

    @GetMapping("/all")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> getAllRegistrations() {
        return service.getAllRegistrations();
    }
    @GetMapping("/for-match/{matchId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> forMatch(@PathVariable Long matchId) {
        return service.getRegistrationsForMatch(matchId);
    }

    @GetMapping("/for-player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<MatchRegistrationDTO> forPlayer(@PathVariable Long playerId) {
        return service.getRegistrationsForPlayer(playerId);
    }
    @GetMapping("/no-response/{matchId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getNoResponse(@PathVariable Long matchId) {
        return service.getNoResponsePlayers(matchId);
    }


    // UNIVERZƒÇ¬ÅLNƒÇ≈§ ENDPOINT PRO REGISTRACE - za hrƒÇÀá√Ñ≈§e


    @PostMapping("/upsert/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public MatchRegistrationDTO upsert(@PathVariable Long playerId, @RequestBody MatchRegistrationRequest request) {

        return service.upsertRegistration(
                request.getMatchId(),
                request.getPlayerId(), // vybranƒÇÀù hrƒÇÀá√Ñ≈§
                request.getTeam(),
                request.getAdminNote(),
                request.getExcuseReason(),
                request.getExcuseNote(),
                request.isUnregister()
        );
    }

}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AdminPlayerController.java
--------------------
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.services.PlayerService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/players/admin")
@CrossOrigin(origins = "*")
public class AdminPlayerController {

    private final PlayerService playerService;
    private final CurrentPlayerService currentPlayerService;

    public AdminPlayerController(PlayerService playerService, CurrentPlayerService currentPlayerService) {
        this.playerService = playerService;
        this.currentPlayerService = currentPlayerService;
    }
    // vƒπÀáichni hrƒÇÀá√Ñ≈§i
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerDTO> getAllPlayers() {
        return playerService.getAllPlayers();
    }

    // hrƒÇÀá√Ñ≈§ dle id

    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public PlayerDTO getPlayerById(@PathVariable Long id) {
        return playerService.getPlayerById(id);
    }

    // vytvoƒπ‚Ñ¢enƒÇ¬≠ hrƒÇÀá√Ñ≈§e
    @PostMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
        public PlayerDTO createPlayer(@RequestBody PlayerDTO playerDTO) {
        return playerService.createPlayer(playerDTO);
    }

    // ƒÇ≈üprava hrƒÇÀá√Ñ≈§e administrƒÇÀátorem dle id hrƒÇÀá√Ñ≈§e
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public PlayerDTO upatePlayerAdmin(@PathVariable Long id,  @RequestBody PlayerDTO dto) {

        return playerService.updatePlayer(id, dto);
    }
    // odstranƒÇ¬≠ hrƒÇÀá√Ñ≈§e
    @PreAuthorize("hasRole('ADMIN')")
    @DeleteMapping("/{id}")
    public ResponseEntity<SuccessResponseDTO> deletePlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.deletePlayer(id);
        return ResponseEntity.ok(response);
    }

    //
    // SCHVƒÇ¬ÅLENƒÇ≈§ HRƒÇ¬Å√Ñ≈öE
    @PreAuthorize("hasRole('ADMIN')")
    @PutMapping("/approve/{id}")
    public ResponseEntity<SuccessResponseDTO> approvePlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.approvePlayer(id);
        return ResponseEntity.ok(response);

    }
    // ZAMƒÇ≈§TNUTƒÇ≈§ HRƒÇ¬Å√Ñ≈öE
    @PreAuthorize("hasRole('ADMIN')")
    @PutMapping("/reject/{id}")
    public ResponseEntity<SuccessResponseDTO> rejectPlayer(@PathVariable Long id) {
        SuccessResponseDTO response = playerService.rejectPlayer(id);
        return ResponseEntity.ok(response);

    }





}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AppUserController.java
--------------------
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.ChangePasswordDTO;
import cz.phsoft.hokej.models.services.AppUserService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/users")
@CrossOrigin(origins = "*")
public class AppUserController {

    private final AppUserService appUserService;

    public AppUserController(AppUserService appUserService) {
        this.appUserService = appUserService;
    }

    // Pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇÀù uƒπƒæivatel √¢‚Ç¨‚Äú bezpe√Ñ≈§nƒÇ¬©
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public AppUserDTO getCurrentUser(Authentication authentication) {
        return appUserService.getCurrentUser(authentication.getName());
    }

    // Zm√Ñ‚Ä∫na hesla pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬©ho uƒπƒæivatele
    @PostMapping("/me/change-password")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> changePassword(Authentication authentication,
                                                 @RequestBody ChangePasswordDTO dto) {
        String email = authentication.getName();
        appUserService.changePassword(email, dto.getOldPassword(), dto.getNewPassword(), dto.getNewPasswordConfirm());
        return ResponseEntity.ok("Heslo ƒÇ≈üsp√Ñ‚Ä∫ƒπÀán√Ñ‚Ä∫ zm√Ñ‚Ä∫n√Ñ‚Ä∫no");
    }

    // Zm√Ñ‚Ä∫na pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬©ho uƒπƒæivatele
    @PutMapping("/me/update")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> updateUser(Authentication authentication,
                                                 @RequestBody AppUserDTO dto) {
        String email = authentication.getName();
        appUserService.updateUser(email, dto);

        return ResponseEntity.ok("uƒπƒæivatel byl zm√Ñ‚Ä∫n√Ñ‚Ä∫n");
    }


    // reset hesla uƒπƒæivatele
    @PostMapping("/{id}/reset-password")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<String> resetPassword(@PathVariable Long id) {
        appUserService.resetPassword(id);
        return ResponseEntity.ok("Heslo resetovƒÇÀáno na 'Player123'");
    }

    // Seznam vƒπÀáech uƒπƒæivatelƒπ≈ª √¢‚Ç¨‚Äú jen ADMIN
    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    public List<AppUserDTO> getAllUsers() {
        return appUserService.getAllUsers();
    }


}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\AuthController.java
--------------------
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.EmailVerificationTokenEntity;
import cz.phsoft.hokej.data.repositories.EmailVerificationTokenRepository;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;
import cz.phsoft.hokej.models.services.AppUserService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/api/auth")
@CrossOrigin(origins = "*")
public class AuthController {

    private final AppUserService appUserService;
    private final AppUserRepository userRepository;
    private final EmailVerificationTokenRepository tokenRepository;

    public AuthController(AppUserService appUserService,
                          AppUserRepository userRepository,
                          EmailVerificationTokenRepository tokenRepository) {
        this.appUserService = appUserService;
        this.userRepository = userRepository;
        this.tokenRepository = tokenRepository;
    }

    // ===== Registrace =====
    @PostMapping("/register")
    public ResponseEntity<?> register(@Valid @RequestBody RegisterUserDTO dto) {
        appUserService.register(dto);
        return ResponseEntity.ok(
                Map.of("status", "ok", "message", "Registrace ƒÇ≈üsp√Ñ‚Ä∫ƒπÀánƒÇÀá. Zkontrolujte email pro aktivaci ƒÇ≈ü√Ñ≈§tu.")
        );
    }

    // ===== ZƒÇ¬≠skƒÇÀánƒÇ¬≠ aktuƒÇÀálnƒÇ¬≠ho uƒπƒæivatele =====
    @GetMapping("/me")
    public ResponseEntity<AppUserDTO> getCurrentUser(Authentication authentication) {
        AppUserDTO dto = appUserService.getCurrentUser(authentication.getName());
        return ResponseEntity.ok(dto);
    }

    // ===== Aktivace ƒÇ≈ü√Ñ≈§tu =====
    @GetMapping("/verify")
    public ResponseEntity<String> verifyEmail(@RequestParam String token) {
        Optional<EmailVerificationTokenEntity> optionalToken = tokenRepository.findByToken(token);

        if (optionalToken.isEmpty()) {
            return ResponseEntity.badRequest().body("NeplatnƒÇÀù aktiva√Ñ≈§nƒÇ¬≠ odkaz.");
        }

        EmailVerificationTokenEntity verificationToken = optionalToken.get();

        if (verificationToken.getExpiresAt().isBefore(LocalDateTime.now())) {
            return ResponseEntity.badRequest().body("Aktiva√Ñ≈§nƒÇ¬≠ odkaz vyprƒπÀáel.");
        }

        AppUserEntity user = verificationToken.getUser();
        user.setEnabled(true);
        userRepository.save(user);

        tokenRepository.delete(verificationToken);

        return ResponseEntity.ok("ƒÇ≈°√Ñ≈§et byl ƒÇ≈üsp√Ñ‚Ä∫ƒπÀán√Ñ‚Ä∫ aktivovƒÇÀán.");
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\CurrentPlayerController.java
--------------------
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.services.PlayerService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import jakarta.servlet.http.HttpSession;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

// aktuƒÇÀálnƒÇ¬≠ hrƒÇÀá√Ñ≈§
@RestController
@RequestMapping("/api/current-player")
public class CurrentPlayerController {

    private final PlayerRepository playerRepository;
    private final AppUserRepository appUserRepository;
    private final CurrentPlayerService currentPlayerService;
    private final PlayerService playerService;

    public CurrentPlayerController(PlayerRepository playerRepository,
                                   AppUserRepository appUserRepository,
                                   CurrentPlayerService currentPlayerService,
                                   PlayerService playerService) {
        this.playerRepository = playerRepository;
        this.appUserRepository = appUserRepository;
        this.currentPlayerService = currentPlayerService;
        this.playerService = playerService;
    }

    // -----------------------------------------------------
    // NastavenƒÇ¬≠ aktuƒÇÀálnƒÇ¬≠ho hrƒÇÀá√Ñ≈§e √¢‚Ç¨‚Äú pokud uƒπƒæivatel mƒÇÀá jen jednoho, vybere se automaticky
    // -----------------------------------------------------
    @PostMapping("/{playerId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> setCurrentPlayer(@PathVariable Long playerId,
                                 Authentication auth,
                                 HttpSession session) {

        AppUserEntity user = appUserRepository.findByEmail(auth.getName())
                .orElseThrow(() -> new RuntimeException("User not found"));

        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new RuntimeException("Player not found"));

        if (!player.getUser().getId().equals(user.getId())) {
            throw new RuntimeException("Player does not belong to user");
        }

        currentPlayerService.setCurrentPlayerId(player.getId());
        return ResponseEntity.ok("AktuƒÇÀálnƒÇ¬≠ hrƒÇÀá√Ñ≈§ nastaven na ID: " + player.getId());
    }

    // -----------------------------------------------------
    // AutomatickƒÇÀù vƒÇÀùb√Ñ‚Ä∫r aktuƒÇÀálnƒÇ¬≠ho hrƒÇÀá√Ñ≈§e po loginu
    // Zavolat z frontendu /api/current-player/auto-select po pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬≠
    // -----------------------------------------------------
    @PostMapping("/auto-select")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> autoSelectCurrentPlayer(Authentication auth) {
        AppUserEntity user = appUserRepository.findByEmail(auth.getName())
                .orElseThrow(() -> new RuntimeException("User not found"));

        List<PlayerDTO> players = playerService.getPlayersByUser(user.getEmail());

        if (players.size() == 1) {
            PlayerDTO player = players.get(0);
            currentPlayerService.setCurrentPlayerId(player.getId());
            return ResponseEntity.ok("Automaticky nastaven hrƒÇÀá√Ñ≈§ nastaven na ID: " + player.getId());
        } else {
            return ResponseEntity.ok("Uƒπƒæivatel mƒÇÀá vƒÇ¬≠ce hrƒÇÀá√Ñ≈§ƒπ≈ª, vƒÇÀùb√Ñ‚Ä∫r nutnƒÇÀù ru√Ñ≈§n√Ñ‚Ä∫");
        }
    }

    // -----------------------------------------------------
    // ZƒÇ¬≠skƒÇÀánƒÇ¬≠ aktuƒÇÀálnƒÇ¬≠ho hrƒÇÀá√Ñ≈§e
    // -----------------------------------------------------
    @GetMapping
    @PreAuthorize("isAuthenticated()")
    public PlayerDTO getCurrentPlayer(HttpSession session) {

        Long playerId = currentPlayerService.getCurrentPlayerId();
        if (playerId == null) {
            System.out.println("ƒπÀùƒÇÀádnƒÇÀù aktuƒÇÀálnƒÇ¬≠ hrƒÇÀá√Ñ≈§");
            return null;
        }

        PlayerDTO player = playerService.getPlayerById(playerId);
        System.out.println("AktuƒÇÀálnƒÇ¬≠ hrƒÇÀá√Ñ≈§ ID: " + playerId);
        return player;
    }

    // -----------------------------------------------------
    // PomocnƒÇÀù endpoint √¢‚Ç¨‚Äú seznam hrƒÇÀá√Ñ≈§ƒπ≈ª aktuƒÇÀálnƒÇ¬≠ho uƒπƒæivatele
    // -----------------------------------------------------
    @GetMapping("/my-players")
    @PreAuthorize("isAuthenticated()")
    public List<PlayerDTO> getMyPlayers(Authentication auth, HttpSession session) {
        AppUserEntity user = appUserRepository.findByEmail(auth.getName())
                .orElseThrow(() -> new RuntimeException("User not found"));

        List<PlayerDTO> players = playerService.getPlayersByUser(user.getEmail());

        System.out.println("Seznam hrƒÇÀá√Ñ≈§ƒπ≈ª uƒπƒæivatele " + user.getEmail() + ": " +
                players.stream().map(PlayerDTO::getId).toList());

        return players;
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\DebugController.java
--------------------
package cz.phsoft.hokej.controllers;

import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class DebugController {

    @GetMapping("/api/debug/me")
    public Object me(Authentication auth) {
        return auth;
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\MatchController.java
--------------------
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;
import cz.phsoft.hokej.models.dto.MatchOverviewDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.services.MatchService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;


@RestController
@RequestMapping("/api/matches")
@CrossOrigin(origins = "*")
public class MatchController {

    private final MatchService matchService;
    private final CurrentPlayerService currentPlayerService;


    public MatchController(MatchService matchService,
                           CurrentPlayerService currentPlayerService) {
        this.matchService = matchService;
        this.currentPlayerService = currentPlayerService;
    }

    // Detail zƒÇÀápasu
    @PreAuthorize("isAuthenticated()")
    @GetMapping("/matchDetail/{id}")
    public MatchDetailDTO getMatchDetail(@PathVariable Long id) {
        return matchService.getMatchDetail(id);
    }

    // NadchƒÇÀázejƒÇ¬≠cƒÇ¬≠ zƒÇÀápas - NEPOUƒπÀùƒÇ≈§VAT - NENƒÇ≈§ TAM PLAYER TYPE
    @PreAuthorize("isAuthenticated()")
    @GetMapping("/next")
    public MatchDTO getNextMatch() {
        return matchService.getNextMatch();
    }

    // NadchƒÇÀázejƒÇ¬≠cƒÇ¬≠ zƒÇÀápasy pro pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬©ho hrƒÇÀá√Ñ≈§e
    @GetMapping("/me/upcoming")
    @PreAuthorize("isAuthenticated()")
    public List<MatchDTO> getUpcomingMatchesForMe(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getUpcomingMatchesForPlayer(currentPlayerId);
    }

    @GetMapping("/me/upcoming-overview")
    @PreAuthorize("isAuthenticated()")
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForMe(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getUpcomingMatchesOverviewForPlayer(currentPlayerId);
    }

    @GetMapping("/me/all-passed")
    @PreAuthorize("isAuthenticated()")
    public List<MatchOverviewDTO> getAllMatchesForPlayer(Authentication authentication) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return matchService.getAllPassedMatchesForPlayer(currentPlayerId);
    }





}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\MatchRegistrationController.java
--------------------
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.requests.MatchRegistrationRequest;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import org.springframework.web.bind.annotation.*;
import org.springframework.security.access.prepost.PreAuthorize;

import java.util.List;

@RestController
@RequestMapping("/api/registrations")
@CrossOrigin(origins = "*")
public class MatchRegistrationController {

    private final MatchRegistrationService service;
    private final CurrentPlayerService currentPlayerService;

    public MatchRegistrationController(MatchRegistrationService service,
                                       CurrentPlayerService currentPlayerService) {
        this.service = service;
        this.currentPlayerService = currentPlayerService;
    }


    // UNIVERZƒÇ¬ÅLNƒÇ≈§ ENDPOINT PRO REGISTRACE


    @PostMapping("/me/upsert")
    @PreAuthorize("isAuthenticated()")
    public MatchRegistrationDTO upsert(@RequestBody MatchRegistrationRequest request) {
        // automaticky bere vybranƒÇ¬©ho hrƒÇÀá√Ñ≈§e
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        return service.upsertRegistration(
                request.getMatchId(),
                currentPlayerId, // vƒπƒædy aktuƒÇÀálnƒÇ¬≠ hrƒÇÀá√Ñ≈§
                request.getTeam(),
                request.getAdminNote(),
                request.getExcuseReason(),
                request.getExcuseNote(),
                request.isUnregister()
        );
    }

    // registrace na zƒÇÀápasy pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬©ho hrƒÇÀá√Ñ≈§e
    @GetMapping("/me/for-current-player")
    @PreAuthorize("isAuthenticated()")
    public List<MatchRegistrationDTO> forCurrentPlayer() {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();
        return service.getRegistrationsForPlayer(currentPlayerId);
    }


}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerController.java
--------------------
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.PlayerService;
import cz.phsoft.hokej.security.CurrentPlayerService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/players")
@CrossOrigin(origins = "*")
public class PlayerController {

    private final PlayerService playerService;
    private final CurrentPlayerService currentPlayerService;

    public PlayerController(PlayerService playerService, CurrentPlayerService currentPlayerService) {
        this.playerService = playerService;
        this.currentPlayerService = currentPlayerService;
    }

    // vytvoƒπ‚Ñ¢enƒÇ¬≠ hrƒÇÀá√Ñ≈§e pro pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬©ho uƒπƒæivatele
    @PostMapping("/me")
    @PreAuthorize("isAuthenticated()") // kaƒπƒædƒÇÀù pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇÀù uƒπƒæivatel
    public PlayerDTO createMyPlayer(@RequestBody PlayerDTO playerDTO, Authentication authentication) {
        String email = authentication.getName(); // email pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬©ho uƒπƒæivatele
        return playerService.createPlayerForUser(playerDTO, email);
    }

    // zƒÇ¬≠skƒÇÀánƒÇ¬≠ hrƒÇÀá√Ñ≈§ƒπ≈ª pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬©ho uƒπƒæivatele
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public List<PlayerDTO> getMyPlayers(Authentication authentication) {
        String email = authentication.getName();
        return playerService.getPlayersByUser(email);
    }

    // ƒÇ≈üprava hrƒÇÀá√Ñ≈§e pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬©ho uƒπƒæivatele
    @PutMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public PlayerDTO updatePlayer(@RequestBody PlayerDTO dto) {
        currentPlayerService.requireCurrentPlayer();
        Long currentPlayerId = currentPlayerService.getCurrentPlayerId();

        return playerService.updatePlayer(currentPlayerId, dto);
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\PlayerInactivityPeriodController.java
--------------------
package cz.phsoft.hokej.controllers;

import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import cz.phsoft.hokej.models.services.PlayerInactivityPeriodService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/inactivity/Admin")
@CrossOrigin(origins = "*")
public class PlayerInactivityPeriodController {

    private final PlayerInactivityPeriodService service;

    public PlayerInactivityPeriodController(PlayerInactivityPeriodService service) {
        this.service = service;
    }

    // vƒπÀáechny zƒÇÀáznamy o neaktivit√Ñ‚Ä∫ hrƒÇÀá√Ñ≈§ƒπ≈ª
    @GetMapping("/all")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getAll() {
        return service.getAll();
    }

    // neaktivita hrƒÇÀá√Ñ≈§ƒπ≈ª dle id neaktivity
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public ResponseEntity<PlayerInactivityPeriodDTO> getById(@PathVariable Long id) {
        PlayerInactivityPeriodDTO dto = service.getById(id);
        return ResponseEntity.ok(dto);
    }

    // zƒÇ¬≠skƒÇÀá zƒÇÀáznamy o period√Ñ‚Ä∫ neaktivity dle id hrƒÇÀá√Ñ≈§e
    @GetMapping("/player/{playerId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public List<PlayerInactivityPeriodDTO> getByPlayer(@PathVariable Long playerId) {
        return service.getByPlayer(playerId);
    }

    // vytvoƒπ‚Ñ¢ƒÇ¬≠ zƒÇÀáznam o neaktivit√Ñ‚Ä∫ hrƒÇÀá√Ñ≈§e
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<PlayerInactivityPeriodDTO> create(@RequestBody PlayerInactivityPeriodDTO dto) {
        PlayerInactivityPeriodDTO created = service.create(dto);
        return ResponseEntity.ok(created);
    }

    // zm√Ñ‚Ä∫nƒÇ¬≠ zƒÇÀáznam o neaktivit√Ñ‚Ä∫ hrƒÇÀá√Ñ≈§e dle id
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<PlayerInactivityPeriodDTO> update(
            @PathVariable Long id,
            @RequestBody PlayerInactivityPeriodDTO dto) {

        PlayerInactivityPeriodDTO updated = service.update(id, dto);
        return ResponseEntity.ok(updated);
    }

    // vymaƒπƒæe zƒÇÀáznam o neaktivit√Ñ‚Ä∫ hrƒÇÀá√Ñ≈§e dle id zƒÇÀáznamu
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        service.delete(id);
        return ResponseEntity.noContent().build();
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestController.java
--------------------
package cz.phsoft.hokej.controllers;

import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/test")
@CrossOrigin(origins = "*")
public class TestController {

    @GetMapping
    public String hello() {
        return "Backend je online!";
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestEmailController.java
--------------------
package cz.phsoft.hokej.controllers;


import cz.phsoft.hokej.models.services.email.EmailService;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/email/test")
public class TestEmailController {
    private final EmailService emailService;

    public TestEmailController(EmailService emailService) {
        this.emailService = emailService;
    }

    @PostMapping("/send-mail")
    public String sendTestMail() {
        emailService.sendSimpleEmail(
                "petrhlista@seznam.cz",
                "APP - TestovacƒÇ¬≠ email",
                "Ahoj, toto je test z backendu."
        );
        return "Email odeslƒÇÀán";
    }

}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\controllers\TestSmsController.java
--------------------
/*
package cz.phsoft.hokej.controllers;


import cz.phsoft.hokej.models.services.sms.SmsTextBeeService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TestSmsController {

    private final SmsTextBeeService smsTextBeeService;

    public TestSmsController(SmsTextBeeService smsTextBeeService) {
        this.smsTextBeeService = smsTextBeeService;
    }

    /**
     * TestovacƒÇ¬≠ endpoint pro odeslƒÇÀánƒÇ¬≠ SMS na testovacƒÇ¬≠ √Ñ≈§ƒÇ¬≠slo.
     * Zavolej: GET /api/test-sms
     */
/*
    @GetMapping("/api/test-sms")
    public String sendTestSms() {
        smsTextBeeService.sendSms("+420776609956", "testovacƒÇ¬≠ sms app-sg");
        return "SMS byla odeslƒÇÀána na testovacƒÇ¬≠ √Ñ≈§ƒÇ¬≠slo +420776609956";
    }
}

        */
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\AppUserEntity.java
--------------------
package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.Role;
import jakarta.persistence.*;

import java.util.Set;

@Entity
@Table(name = "app_users")
public class AppUserEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String surname;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role;

    @Column(nullable = false)
    private boolean enabled = false; // vƒÇÀùchozƒÇ¬≠ hodnota false


    // One-to-Many: jeden uƒπƒæivatel √¢‚Ä†‚Äô vƒÇ¬≠ce hrƒÇÀá√Ñ≈§ƒπ≈ª
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<PlayerEntity> players;

    // gettery/settery


    public Long getId() {return id;}

    public void setId(Long id) {this.id = id;}

    public String getName() {return name;}

    public void setName(String name) {this.name = name;}

    public String getSurname() { return surname; }

    public void setSurname(String surname) { this.surname = surname; }

    public String getEmail() {return email;}

    public void setEmail(String email) {this.email = email;}

    public String getPassword() {return password;}

    public void setPassword(String password) {this.password = password;}

    public Role getRole() {return role;}

    public void setRole(Role role) {this.role = role;}

    public boolean isEnabled() {    return enabled;    }

    public void setEnabled(boolean enabled) {  this.enabled = enabled;    }

    public Set<PlayerEntity> getPlayers() {return players;}

    public void setPlayers(Set<PlayerEntity> players) {this.players = players;}
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\EmailVerificationTokenEntity.java
--------------------
package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDateTime;


@Entity
@Table(name = "email_verification_tokens")
public class EmailVerificationTokenEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 64)
    private String token;

    @Column(nullable = false)
    private LocalDateTime expiresAt;

    @OneToOne
    @JoinColumn(name = "user_id", nullable = false)
    private AppUserEntity user;

    // gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getToken() { return token; }
    public void setToken(String token) { this.token = token; }

    public LocalDateTime getExpiresAt() { return expiresAt; }
    public void setExpiresAt(LocalDateTime expiresAt) { this.expiresAt = expiresAt; }

    public AppUserEntity getUser() { return user; }
    public void setUser(AppUserEntity user) { this.user = user; }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchEntity.java
--------------------
package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;
import java.time.LocalDateTime;

/**
 * tƒπ‚Ñ¢ƒÇ¬≠da pro vklƒÇÀádƒÇÀánƒÇ¬≠ Entity zƒÇÀápasu do db
 */
@Entity
@Table(name = "matches")
public class MatchEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private LocalDateTime dateTime;

    @Column(nullable = false)
    private String location;

    private String description;

    // maximƒÇÀálnƒÇ¬≠ po√Ñ≈§et hrƒÇÀá√Ñ≈§ƒπ≈ª - vyuƒπƒæƒÇ¬≠vƒÇÀá se pro ov√Ñ‚Ä∫ƒπ‚Ñ¢enƒÇ¬≠ kapacity pƒπ‚Ñ¢i pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬≠
    @Column(nullable = false)
    private Integer maxPlayers;

    @Column(nullable = false)
    private Integer price;

    public MatchEntity() {}

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }

    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() { return price; }

    public void setPrice(Integer price) { this.price = price; }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationEntity.java
--------------------
package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.persistence.*;

import java.time.LocalDateTime;

/**
 * tƒπ‚Ñ¢ƒÇ¬≠da reprezentuje registracei hrƒÇÀá√Ñ≈§e k zƒÇÀápasu
 */
@Entity
@Table(name = "match_registrations")
public class MatchRegistrationEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "match_id", nullable = false)
    private MatchEntity match;

    @ManyToOne
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerMatchStatus status;

    @Enumerated(EnumType.STRING)
    private ExcuseReason excuseReason;

    private String excuseNote;

    // admin mƒπ≈ªƒπƒæe vloƒπƒæit poznƒÇÀámku, napƒπ‚Ñ¢. kdyƒπƒæ se n√Ñ‚Ä∫kdo zaregistruje a potƒÇ¬© nepƒπ‚Ñ¢ƒÇ¬≠jde
    private String adminNote;

    @Enumerated(EnumType.STRING)
    @Column(name = "team")
    private Team team;

    // dat√Ñ≈§as vytvoƒπ‚Ñ¢enƒÇ¬≠ registrace - musƒÇ¬≠ se m√Ñ‚Ä∫nit aby nebyl hrƒÇÀá√Ñ≈§ i po zruƒπÀáenƒÇ¬≠ registrace
    // v poƒπ‚Ñ¢adƒÇ¬≠ pƒπ‚Ñ¢ed hrƒÇÀá√Ñ≈§i kteƒπ‚Ñ¢ƒÇ¬≠ se registrovali po zruƒπÀáenƒÇ¬≠ registrace
    @Column(nullable = false, updatable = true)
    private LocalDateTime timestamp = LocalDateTime.now();

    // systƒÇ¬©m automaticky vytvƒÇÀáƒπ‚Ñ¢ƒÇ¬≠ reserved/registered dle kapacity - maxPlayers
    @Column(nullable = false, updatable = true)
    private String createdBy; // "user" nebo "system"

    public MatchRegistrationEntity() {
    }

    // Gettery a Settery


    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public MatchEntity getMatch() {
        return match;
    }

    public void setMatch(MatchEntity match) {
        this.match = match;
    }

    public PlayerEntity getPlayer() {
        return player;
    }

    public void setPlayer(PlayerEntity player) {
        this.player = player;
    }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }

    public ExcuseReason getExcuseReason() {
        return excuseReason;
    }

    public void setExcuseReason(ExcuseReason excuseReason) {
        this.excuseReason = excuseReason;
    }

    public String getExcuseNote() {
        return excuseNote;
    }

    public void setExcuseNote(String excuseNote) {
        this.excuseNote = excuseNote;
    }

    public String getAdminNote() {
        return adminNote;
    }

    public void setAdminNote(String adminNote) {
        this.adminNote = adminNote;
    }

    public Team getTeam() {
        return team;
    }

    public void setTeam(Team team) {
        this.team = team;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }
}



--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\MatchRegistrationHistoryEntity.java
--------------------
package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.persistence.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "match_registration_history")
public class MatchRegistrationHistoryEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // ID z pƒπ≈ªvodnƒÇ¬≠ hlavnƒÇ¬≠ tabulky
    @Column(name = "match_registration_id", nullable = false)
    private Long matchRegistrationId;

    @Column(name = "match_id", nullable = false)
    private Long matchId;

    @Column(name = "player_id", nullable = false)
    private Long playerId;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerMatchStatus status;

    @Enumerated(EnumType.STRING)
    @Column(name = "excuse_reason")
    private ExcuseReason excuseReason;

    @Column(name = "excuse_note")
    private String excuseNote;

    @Column(name = "admin_note")
    private String adminNote;

    @Enumerated(EnumType.STRING)
    @Column(name = "team")
    private Team team;

    // pƒπ≈ªvodnƒÇ¬≠ timestamp
    @Column(name = "original_timestamp", nullable = false)
    private LocalDateTime originalTimestamp;

    @Column(name = "created_by", nullable = false)
    private String createdBy;

    @Column(nullable = false)
    private String action; // INSERT / UPDATE / DELETE

    @Column(name = "changed_at", nullable = false)
    private LocalDateTime changedAt;

    public MatchRegistrationHistoryEntity() {
    }

    // Gettery a settery


    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getMatchRegistrationId() {
        return matchRegistrationId;
    }

    public void setMatchRegistrationId(Long matchRegistrationId) {
        this.matchRegistrationId = matchRegistrationId;
    }

    public Long getMatchId() {
        return matchId;
    }

    public void setMatchId(Long matchId) {
        this.matchId = matchId;
    }

    public Long getPlayerId() {
        return playerId;
    }

    public void setPlayerId(Long playerId) {
        this.playerId = playerId;
    }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }

    public ExcuseReason getExcuseReason() {
        return excuseReason;
    }

    public void setExcuseReason(ExcuseReason excuseReason) {
        this.excuseReason = excuseReason;
    }

    public String getExcuseNote() {
        return excuseNote;
    }

    public void setExcuseNote(String excuseNote) {
        this.excuseNote = excuseNote;
    }

    public String getAdminNote() {
        return adminNote;
    }

    public void setAdminNote(String adminNote) {
        this.adminNote = adminNote;
    }

    public Team getTeam() {
        return team;
    }

    public void setTeam(Team team) {
        this.team = team;
    }

    public LocalDateTime getOriginalTimestamp() {
        return originalTimestamp;
    }

    public void setOriginalTimestamp(LocalDateTime originalTimestamp) {
        this.originalTimestamp = originalTimestamp;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }

    public String getAction() {
        return action;
    }

    public void setAction(String action) {
        this.action = action;
    }

    public LocalDateTime getChangedAt() {
        return changedAt;
    }

    public void setChangedAt(LocalDateTime changedAt) {
        this.changedAt = changedAt;
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerEntity.java
--------------------
package cz.phsoft.hokej.data.entities;

import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerType;
import jakarta.persistence.*;

@Entity
@Table(name = "player_entity")
public class PlayerEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String surname;

    private String nickName;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PlayerType type; // VIP, STANDARD, BASIC

    private String fullName;
    private String phoneNumber;

    @Enumerated(EnumType.STRING)
    private Team team;

    @Enumerated(EnumType.STRING)
    private PlayerStatus status = PlayerStatus.PENDING;


    // Many-to-One: kaƒπƒædƒÇÀù hrƒÇÀá√Ñ≈§ patƒπ‚Ñ¢ƒÇ¬≠ jednomu uƒπƒæivateli
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private AppUserEntity user;

    // ----------------- Konstruktor -----------------
    public PlayerEntity() {
        this.type = PlayerType.BASIC;
    }

    public PlayerEntity(String name, String surname, String nickName, PlayerType type, String phoneNumber, Team team, PlayerStatus status) {
        this.name = name;
        this.surname = surname;
        this.nickName = nickName;
        this.type = type;
        this.fullName = name + " " + surname;
        this.phoneNumber = phoneNumber;
        this.team = team;
        this.status = status;
    }

    // ----------------- Gettery a Settery -----------------
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
        updateFullName();
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
        updateFullName();
    }

    public String getNickname() { return nickName;}
    public void setNickname(String nickName) { this.nickName = nickName; }

    public String getFullName() {
        return fullName;
    }

    public PlayerType getType() {
        return type;
    }
    public void setType(PlayerType type) {
        this.type = type;
    }

    private void updateFullName() {
        this.fullName = name + " " + surname;
    }

    public String getPhoneNumber() {
        return phoneNumber;
    }
    public void setPhoneNumber(String phoneNumber) {
        this.phoneNumber = phoneNumber;
    }

    public Team getTeam() {
        return team;
    }
    public void setTeam(Team team) {
        this.team = team;
    }

    public AppUserEntity getUser() {
        return user;
    }
    public void setUser(AppUserEntity user) {
        this.user = user;
    }

    public PlayerStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerStatus status) {
        this.status = status;
    }

    public String getNickName() {
        return nickName;
    }

    public void setNickName(String nickName) {
        this.nickName = nickName;
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\entities\PlayerInactivityPeriodEntity.java
--------------------
package cz.phsoft.hokej.data.entities;

import jakarta.persistence.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "player_inactivity_period")
public class PlayerInactivityPeriodEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "player_id", nullable = false)
    private PlayerEntity player;

    // neaktivnƒÇ¬≠ od
    @Column(name = "inactive_from", nullable = false)
    private LocalDateTime inactiveFrom;

    // neaktivnƒÇ¬≠ do
    @Column(name = "inactive_to", nullable = false)
    private LocalDateTime inactiveTo;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public PlayerEntity getPlayer() {
        return player;
    }

    public void setPlayer(PlayerEntity player) {
        this.player = player;
    }

    public LocalDateTime getInactiveFrom() {
        return inactiveFrom;
    }

    public void setInactiveFrom(LocalDateTime inactiveFrom) {
        this.inactiveFrom = inactiveFrom;
    }

    public LocalDateTime getInactiveTo() {
        return inactiveTo;
    }

    public void setInactiveTo(LocalDateTime inactiveTo) {
        this.inactiveTo = inactiveTo;
    }

}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\ExcuseReason.java
--------------------
package cz.phsoft.hokej.data.enums;

public enum ExcuseReason {
    NEMOC,
    PRACE,
    NECHE_SE_MI,
    JINE
}

--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\PlayerMatchStatus.java
--------------------
package cz.phsoft.hokej.data.enums;

public enum PlayerMatchStatus {
    REGISTERED, // registrovƒÇÀán
    UNREGISTERED, // odhlƒÇÀáƒπÀáen
    EXCUSED,  // omluven
    RESERVED, // nƒÇÀáhradnƒÇ¬≠k
    NO_RESPONSE, // bez odpov√Ñ‚Ä∫di
    NO_EXCUSED, // neomluven - byl registrovƒÇÀán a nepƒπ‚Ñ¢iƒπÀáel

}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\PlayerStatus.java
--------------------
package cz.phsoft.hokej.data.enums;

public enum PlayerStatus {
    PENDING, // √Ñ≈§ekƒÇÀá na schvƒÇÀálenƒÇ¬≠
    APPROVED, // schvƒÇÀáleno administrƒÇÀátorem
    REJECTED // zamƒÇ¬≠tnuto
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\PlayerType.java
--------------------
package cz.phsoft.hokej.data.enums;

public enum PlayerType {
    VIP,
    STANDARD,
    BASIC
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\Role.java
--------------------
package cz.phsoft.hokej.data.enums;

public enum Role {
    ROLE_PLAYER,
    ROLE_MANAGER,
    ROLE_ADMIN
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\enums\Team.java
--------------------
package cz.phsoft.hokej.data.enums;

public enum Team {
    DARK,
    LIGHT

}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\AppUserRepository.java
--------------------
package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface AppUserRepository extends JpaRepository<AppUserEntity, Long> {
    Optional<AppUserEntity> findByEmail(String email);
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\EmailVerificationTokenRepository.java
--------------------
package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.EmailVerificationTokenEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface EmailVerificationTokenRepository extends JpaRepository<EmailVerificationTokenEntity, Long> {
    Optional<EmailVerificationTokenEntity> findByToken(String token);
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRegistrationHistoryRepository.java
--------------------
package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchRegistrationHistoryEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface MatchRegistrationHistoryRepository extends JpaRepository<MatchRegistrationHistoryEntity, Long> {

    // vƒπÀáechny registrace na zƒÇÀápas
    List<MatchRegistrationHistoryEntity> findByMatchRegistrationIdOrderByChangedAtDesc(Long matchRegistrationId);

    // Historie pro konkrƒÇ¬©tnƒÇ¬≠ zƒÇÀápas
    List<MatchRegistrationHistoryEntity> findByMatchIdOrderByChangedAtDesc(Long matchId);

    // Historie zm√Ñ‚Ä∫n hrƒÇÀá√Ñ≈§e
    List<MatchRegistrationHistoryEntity> findByPlayerIdOrderByChangedAtDesc(Long playerId);

}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRegistrationRepository.java
--------------------
package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

    @Repository
    public interface MatchRegistrationRepository extends JpaRepository<MatchRegistrationEntity, Long> {

        // VrƒÇÀátƒÇ¬≠ poslednƒÇ¬≠ status pro danƒÇ¬©ho hrƒÇÀá√Ñ≈§e a zƒÇÀápas
        Boolean existsByPlayerIdAndMatchId(Long playerId, Long matchId);

        // Voliteln√Ñ‚Ä∫: vƒπÀáechny registrace pro ur√Ñ≈§itƒÇÀù zƒÇÀápas
        List<MatchRegistrationEntity> findByMatchId(Long matchId);

        // Voliteln√Ñ‚Ä∫: vƒπÀáechny registrace pro ur√Ñ≈§itƒÇ¬©ho hrƒÇÀá√Ñ≈§e
        List<MatchRegistrationEntity> findByPlayerId(Long playerId);

        // --- NovƒÇÀá metoda pro hledƒÇÀánƒÇ¬≠ konkrƒÇ¬©tnƒÇ¬≠ registrace ---
        Optional<MatchRegistrationEntity> findByPlayerIdAndMatchId(Long playerId, Long matchId);

        long countByMatchIdAndStatus(Long matchId, PlayerMatchStatus status);

        List<MatchRegistrationEntity> findByMatchIdIn(List<Long> matchIds);
    }
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\MatchRepository.java
--------------------
package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.MatchEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import java.time.LocalDateTime;
import java.util.List;

public interface MatchRepository extends JpaRepository<MatchEntity, Long> {
    List<MatchEntity> findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime dateTime);
    List<MatchEntity> findByDateTimeBeforeOrderByDateTimeDesc(LocalDateTime dateTime);
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\PlayerInactivityPeriodRepository.java
--------------------

package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface PlayerInactivityPeriodRepository extends JpaRepository<PlayerInactivityPeriodEntity, Long> {

    // zjistƒÇ¬≠, zda hrƒÇÀá√Ñ≈§ je aktuƒÇÀáln√Ñ‚Ä∫ neaktivnƒÇ¬≠
    boolean existsByPlayerAndInactiveFromLessThanEqualAndInactiveToGreaterThanEqual(
            PlayerEntity player, LocalDateTime from, LocalDateTime to);

    // zƒÇ¬≠skƒÇÀá vƒπÀáechny neaktivnƒÇ¬≠ obdobƒÇ¬≠ hrƒÇÀá√Ñ≈§e, kterƒÇ¬© spadajƒÇ¬≠ do intervalu
    List<PlayerInactivityPeriodEntity> findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
            PlayerEntity player, LocalDateTime from, LocalDateTime to);

    List<PlayerInactivityPeriodEntity> findByPlayerOrderByInactiveFromAsc(PlayerEntity player);
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\data\repositories\PlayerRepository.java
--------------------
package cz.phsoft.hokej.data.repositories;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface PlayerRepository extends JpaRepository<PlayerEntity, Long> {
    Optional<PlayerEntity> findById(Long id);

    List<PlayerEntity> findByIdNotIn(List<Long> ids);
    boolean existsByNameAndSurname(String name, String surname);

    Optional<PlayerEntity> findByNameAndSurname(String name, String surname);
    Optional<PlayerEntity> findByUserEmail(String email);
    List<PlayerEntity> findAllByUserEmail(String email);
    List<PlayerEntity> findByUser_EmailOrderByIdAsc(String email);
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\AccountNotActivatedException.java
--------------------
package cz.phsoft.hokej.exceptions;

import org.springframework.http.HttpStatus;

public class AccountNotActivatedException extends BusinessException {

    public AccountNotActivatedException() {
        super("PrvnƒÇ¬≠ musƒÇ¬≠te aktivovat ƒÇ≈ü√Ñ≈§et pomocƒÇ¬≠ odkazu v emailu", HttpStatus.FORBIDDEN); // 403
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\ApiError.java
--------------------
package cz.phsoft.hokej.exceptions;

import com.fasterxml.jackson.annotation.JsonFormat;
import java.time.LocalDateTime;
import java.util.Map;

public class ApiError {

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime timestamp;
    private int status;
    private String error;
    private String message;
    private String path;
    private String clientIp; // √¢‚Ä†¬ê nov√Ñ‚Ä∫

    // VolitelnƒÇ¬©: podrobnosti (validace, vƒÇ¬≠ce chyb, atd.)
    private Map<String, String> details;

    public ApiError(int status, String error, String message, String path,
                    String clientIp) {
        this.timestamp = LocalDateTime.now();
        this.status = status;
        this.error = error;
        this.message = message;
        this.path = path;
        this.clientIp = clientIp;
    }

    public ApiError(int status,
                            String error,
                            String message,
                            String path,
                            String clientIp,
                            Map<String, String> details) {
        this(status, error, message, path, clientIp);
        this.details = details;
    }

    public LocalDateTime getTimestamp() { return timestamp; }
    public int getStatus() { return status; }
    public String getError() { return error; }
    public String getMessage() { return message; }
    public String getPath() { return path; }
    public String getClientIp() { return clientIp; }
    public Map<String, String> getDetails() { return details; }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\BusinessException.java
--------------------
package cz.phsoft.hokej.exceptions;

import org.springframework.http.HttpStatus;

public class BusinessException extends RuntimeException {

    private final HttpStatus status;

    protected BusinessException(String message, HttpStatus status) {
        super(message);
        this.status = status;
    }

    public HttpStatus getStatus() {
        return status;
    }
}

--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\DuplicateNameSurnameException.java
--------------------
package cz.phsoft.hokej.exceptions;

public class DuplicateNameSurnameException extends RuntimeException {
    public DuplicateNameSurnameException(String message) {
        super(message);
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\DuplicateRegistrationException.java
--------------------
package cz.phsoft.hokej.exceptions;

public class DuplicateRegistrationException extends RuntimeException {
    public DuplicateRegistrationException(Long matchId, Long playerId) {
        super("HrƒÇÀá√Ñ≈§ " + playerId + " jiƒπƒæ mƒÇÀá aktivnƒÇ¬≠ registraci na zƒÇÀápas " + matchId);
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\InvalidPlayerStatusException.java
--------------------
package cz.phsoft.hokej.exceptions;

public class InvalidPlayerStatusException extends RuntimeException {
    public InvalidPlayerStatusException(String message) {
        super(message);
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\MatchNotFoundException.java
--------------------
package cz.phsoft.hokej.exceptions;

public class MatchNotFoundException extends RuntimeException {
    public MatchNotFoundException(Long matchId) {
        super("ZƒÇÀápas s ID " + matchId + " nenalezen.");;
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\PlayerNotFoundException.java
--------------------
package cz.phsoft.hokej.exceptions;

import org.springframework.http.HttpStatus;

public class PlayerNotFoundException extends BusinessException {
    public PlayerNotFoundException(Long playerId) {
        super("HrƒÇÀá√Ñ≈§ s ID " + playerId + " nenalezen.", HttpStatus.NOT_FOUND);}
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\RegistrationNotFoundException.java
--------------------
package cz.phsoft.hokej.exceptions;

public class RegistrationNotFoundException extends RuntimeException {
    public RegistrationNotFoundException(Long matchId, Long playerId) {
        super("HrƒÇÀá√Ñ≈§ " + playerId + " nemƒÇÀá registraci na zƒÇÀápas " + matchId);
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\exceptions\UserAlreadyExistsException.java
--------------------
package cz.phsoft.hokej.exceptions;

import org.springframework.http.HttpStatus;

public class UserAlreadyExistsException extends BusinessException {

    public UserAlreadyExistsException(String message) {
        super(message, HttpStatus.CONFLICT); // 409
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\AppUserMapper.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.PlayerSummaryDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

import java.util.List;

@Mapper(componentModel = "spring")
public interface AppUserMapper {
    @Mapping(target = "players", source = "players")
    AppUserDTO toDTO(AppUserEntity entity);

    List<AppUserDTO> toDtoList(List<AppUserEntity> entities);

    @Mapping(source = "nickname", target = "nickName")
    @Mapping(target = "fullName", ignore = true)
    PlayerDTO toPlayerDTO(PlayerEntity entity);
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\MatchMapper.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchOverviewDTO;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;

@Mapper(componentModel = "spring")
public interface MatchMapper {

    MatchDTO toDTO(MatchEntity entity);

    MatchEntity toEntity(MatchDTO dto);

    void updateEntity(MatchDTO dto, @MappingTarget MatchEntity entity);
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\MatchRegistrationMapper.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

import java.util.List;

@Mapper(componentModel = "spring")
public interface MatchRegistrationMapper {

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "match", source = "match")
    @Mapping(target = "player", source = "player")
    @Mapping(target = "status", source = "status")
    @Mapping(target = "excuseReason", source = "excuseReason")
    @Mapping(target = "excuseNote", source = "note")
    @Mapping(target = "team", source = "team")
    @Mapping(target = "adminNote", source = "adminNote")
    @Mapping(target = "createdBy", source = "createdBy")
    @Mapping(target = "timestamp", expression = "java(java.time.LocalDateTime.now())")
    MatchRegistrationEntity toEntity(
            MatchEntity match,
            PlayerEntity player,
            PlayerMatchStatus status,
            ExcuseReason excuseReason,
            String note,
            Team team,
            String adminNote,
            String createdBy
    );

    // entity √¢‚Ä†‚Äô DTO (volitelnƒÇ¬©)
    @Mapping(target = "matchId", source = "match.id")
    @Mapping(target = "playerId", source = "player.id")
    MatchRegistrationDTO toDTO(MatchRegistrationEntity entity);

    List<MatchRegistrationDTO> toDTOList(List<MatchRegistrationEntity> entities);
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\PlayerInactivityPeriodMapper.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import org.mapstruct.*;

@Mapper(componentModel = "spring")
public interface PlayerInactivityPeriodMapper {

    // Entity -> DTO (OK)
    @Mapping(target = "playerId", source = "player.id")
    PlayerInactivityPeriodDTO toDTO(PlayerInactivityPeriodEntity entity);

    // DTO -> Entity (player ƒπ‚Ñ¢eƒπÀáƒÇ¬≠ @ObjectFactory)
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "player", ignore = true)
    PlayerInactivityPeriodEntity toEntity(PlayerInactivityPeriodDTO dto, @Context PlayerEntity player);

    // UPDATE DTO -> existujƒÇ¬≠cƒÇ¬≠ entity (bez zm√Ñ‚Ä∫ny player)
    @Mapping(target = "player", ignore = true)
    void updateEntityFromDto(PlayerInactivityPeriodDTO dto, @MappingTarget PlayerInactivityPeriodEntity entity);

    // FACTORY √¢‚Ç¨‚Äú jedinƒÇÀù sprƒÇÀávnƒÇÀù zpƒπ≈ªsob, jak nastavit player z @Context
    @ObjectFactory
    default PlayerInactivityPeriodEntity createEntity(PlayerInactivityPeriodDTO dto, @Context PlayerEntity player) {
        PlayerInactivityPeriodEntity entity = new PlayerInactivityPeriodEntity();
        entity.setPlayer(player);
        return entity;
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\mappers\PlayerMapper.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

import java.util.List;

@Mapper(componentModel = "spring")
public interface PlayerMapper {

        // Entity √¢‚Ä†‚Äô DTO (heslo se neposƒÇ¬≠lƒÇÀá)
        @Mapping(source = "nickname", target = "nickName")
        @Mapping(target = "fullName", ignore = true) // generuje se v DTO
        PlayerDTO toDTO(PlayerEntity entity);

        // DTO √¢‚Ä†‚Äô Entity (heslo se mapuje, pokud existuje)
        @Mapping(source = "nickName", target = "nickname")   // KLƒÇ≈§√Ñ≈öOVƒÇ‚Ä∞
        @Mapping(target = "fullName", ignore = true)         // generuje si Entity sama
        @Mapping(target = "user", ignore = true)             // nastavujeƒπÀá v service
        @Mapping(
                target = "status",
                expression = "java(dto.getStatus() != null ? dto.getStatus() : cz.phsoft.hokej.data.enums.PlayerStatus.PENDING)"
        )
        PlayerEntity toEntity(PlayerDTO dto);

        // Aktualizace existujƒÇ¬≠cƒÇ¬≠ho DTO (ignorujeme fullName)
        @Mapping(target = "fullName", ignore = true)
        @Mapping(target = "id", ignore = true)
        void updatePlayerDTO(PlayerDTO source, @MappingTarget PlayerDTO target);

        // Aktualizace existujƒÇ¬≠cƒÇ¬≠ Entity (heslo se mapuje, fullName nenƒÇ¬≠ pole v Entity)
        @Mapping(source = "nickName", target = "nickname")   // i tady je dƒπ≈ªleƒπƒæitƒÇ¬©
        @Mapping(target = "fullName", ignore = true)
        @Mapping(target = "user", ignore = true)
        @Mapping(
                target = "status",
                expression = "java(source.getStatus() != null ? source.getStatus() : target.getStatus())"
        )
        void updatePlayerEntity(PlayerDTO source, @MappingTarget PlayerEntity target);

    List<PlayerDTO> toDTOList(List<PlayerEntity> players);


}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\requests\MatchRegistrationRequest.java
--------------------
package cz.phsoft.hokej.models.dto.requests;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.validation.constraints.*;


public class MatchRegistrationRequest {
    @NotNull
    @Positive
    private Long matchId;

    @NotNull
    @Positive
    private Long playerId;

    private Team team;
    private ExcuseReason excuseReason;
    private String excuseNote;
    private String adminNote;
    private boolean unregister;

    public Long getMatchId() { return matchId; }
    public Long getPlayerId() { return playerId; }
    public Team getTeam() { return team; }
    public ExcuseReason getExcuseReason() { return excuseReason; }
    public String getExcuseNote() { return excuseNote; }
    public String getAdminNote() { return adminNote; }
    public boolean isUnregister() { return unregister; }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\AppUserDTO.java
--------------------
package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.enums.Team;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.util.Set;

public class AppUserDTO {
    private Long id;
    private String name; // not null
    private String surname;
    private String email;
    private Role role;
    private boolean enabled;
    private Set<PlayerDTO> players; // jednostrannƒÇ¬©


    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public Role getRole() {
        return role;
    }

    public void setRole(Role role) {
        this.role = role;
    }

    public boolean isEnabled() { return enabled; }

    public void setEnabled(boolean enabled) { this.enabled = enabled;}

    public Set<PlayerDTO> getPlayers() {
        return players;
    }

    public void setPlayers(Set<PlayerDTO> players) {
        this.players = players;
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\ChangePasswordDTO.java
--------------------
package cz.phsoft.hokej.models.dto;

public class ChangePasswordDTO {
    private String oldPassword;
    private String newPassword;
    private String newPasswordConfirm;

    // gettery a settery
    public String getOldPassword() { return oldPassword; }
    public void setOldPassword(String oldPassword) { this.oldPassword = oldPassword; }
    public String getNewPassword() { return newPassword; }
    public void setNewPassword(String newPassword) { this.newPassword = newPassword; }
    public String getNewPasswordConfirm() { return newPasswordConfirm; }
    public void setNewPasswordConfirm(String newPasswordConfirm) { this.newPasswordConfirm = newPasswordConfirm; }
}

--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchDetailDTO.java
--------------------
package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;

import java.time.LocalDateTime;
import java.util.List;

public class MatchDetailDTO {
    private Long id;
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime dateTime;
    private int maxPlayers;
    private int inGamePlayers;
    private int outGamePlayers;
    private int waitingPlayers;
    private int noActionPlayers;
    private double pricePerRegisteredPlayer;
    private int remainingSlots;

    List<PlayerDTO> registeredPlayers;
    List<PlayerDTO> reservedPlayers;
    List<PlayerDTO> unregisteredPlayers;
    List<PlayerDTO> excusedPlayers;
    List<PlayerDTO> noResponsePlayers;

    // Gettery a settery

    public Long getId() {       return id;    }
    public void setId(Long id) {
        this.id = id;
    }
    public LocalDateTime getDateTime() {
        return dateTime;
    }

    public void setDateTime(LocalDateTime dateTime) {
        this.dateTime = dateTime;
    }

    public int getMaxPlayers() {
        return maxPlayers;
    }
    public void setMaxPlayers(int maxPlayers) {
        this.maxPlayers = maxPlayers;
    }

    public int getInGamePlayers() {
        return inGamePlayers;
    }
    public void setInGamePlayers(int inGamePlayers) {
        this.inGamePlayers = inGamePlayers;
    }

    public void setOutGamePlayers(int outGamePlayers) {
        this.outGamePlayers = outGamePlayers;
    }

    public int getWaitingPlayers() {
        return waitingPlayers;
    }
    public void setWaitingPlayers(int waitingPlayers) {
        this.waitingPlayers = waitingPlayers;
    }

    public int getNoActionPlayers() {
        return noActionPlayers;
    }
    public void setNoActionPlayers(int noActionPlayers) {
        this.noActionPlayers = noActionPlayers;
    }

    public double getPricePerRegisteredPlayer() {
        return pricePerRegisteredPlayer;
    }
    public void setPricePerRegisteredPlayer(double pricePerRegisteredPlayer) {
        this.pricePerRegisteredPlayer = pricePerRegisteredPlayer;
    }

    public int getRemainingSlots() {
        return remainingSlots;
    }
    public void setRemainingSlots(int remainingSlots) {
        this.remainingSlots = remainingSlots;
    }

    public List<PlayerDTO> getRegisteredPlayers() {
        return registeredPlayers;
    }
    public void setRegisteredPlayers(List<PlayerDTO> registeredPlayers) {
        this.registeredPlayers = registeredPlayers;
    }

    public List<PlayerDTO> getReservedPlayers() {
        return reservedPlayers;
    }
    public void setReservedPlayers(List<PlayerDTO> reservedPlayers) {
        this.reservedPlayers = reservedPlayers;
    }

    public List<PlayerDTO> getUnregisteredPlayers() {
        return unregisteredPlayers;
    }

    public void setUnregisteredPlayers(List<PlayerDTO> unregisteredPlayers) {
        this.unregisteredPlayers = unregisteredPlayers;
    }
    public List<PlayerDTO> getExcusedPlayers() {
        return excusedPlayers;
    }
    public void setExcusedPlayers(List<PlayerDTO> excusedPlayers) {
        this.excusedPlayers = excusedPlayers;
    }

    public List<PlayerDTO> getNoResponsePlayers() {
        return noResponsePlayers;
    }
    public void setNoResponsePlayers(List<PlayerDTO> noResponsePlayers) {
        this.noResponsePlayers = noResponsePlayers;
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchDTO.java
--------------------
package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import jakarta.validation.constraints.FutureOrPresent;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

import java.time.LocalDateTime;

public class MatchDTO {

    private Long id;
    @NotNull(message = "Datum a √Ñ≈§as zƒÇÀápasu je povinnƒÇ¬©.")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime dateTime;

    @NotBlank(message = "MƒÇ¬≠sto zƒÇÀápasu je povinnƒÇ¬©.")
    @Size(min = 3, max = 100)
    private String location;

    @Size(max = 255, message = "Popis mƒπ≈ªƒπƒæe mƒÇ¬≠t max 255 znakƒπ≈ª.")
    private String description;

    @NotNull(message = "MaximƒÇÀálnƒÇ¬≠ po√Ñ≈§et hrƒÇÀá√Ñ≈§ƒπ≈ª je povinnƒÇÀù")
    private Integer maxPlayers;

    @NotNull(message = "Cena je povinnƒÇÀá")
    private Integer price;

    // gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getMaxPlayers() { return maxPlayers; }
    public void setMaxPlayers(Integer maxPlayers) { this.maxPlayers = maxPlayers; }

    public Integer getPrice() {
        return price;
    }

    public void setPrice(Integer price) {
        this.price = price;
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchOverviewDTO.java
--------------------
package cz.phsoft.hokej.models.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;

import java.time.LocalDateTime;

public class MatchOverviewDTO {

    private Long id;

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime dateTime;

    private String location;
    private String description;
    private Integer price;
    private int maxPlayers;
    private int inGamePlayers;
    private double pricePerRegisteredPlayer;
    private PlayerMatchStatus status;

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Integer getPrice() { return price; }
    public void setPrice(Integer price) { this.price = price; }

    public int getMaxPlayers() { return maxPlayers; }
    public void setMaxPlayers(int maxPlayers) { this.maxPlayers = maxPlayers; }

    public int getInGamePlayers() { return inGamePlayers; }
    public void setInGamePlayers(int inGamePlayers) { this.inGamePlayers = inGamePlayers; }

    public double getPricePerRegisteredPlayer() { return pricePerRegisteredPlayer; }
    public void setPricePerRegisteredPlayer(double pricePerRegisteredPlayer) { this.pricePerRegisteredPlayer = pricePerRegisteredPlayer; }

    public PlayerMatchStatus getStatus() {
        return status;
    }

    public void setStatus(PlayerMatchStatus status) {
        this.status = status;
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\MatchRegistrationDTO.java
--------------------
package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;

public class MatchRegistrationDTO {
    private Long id; // volitelnƒÇ¬©, pƒπ‚Ñ¢i GET

    @NotNull(message = "ID zƒÇÀápasu je povinnƒÇ¬©.")
    @Positive(message = "ID zƒÇÀápasu musƒÇ¬≠ bƒÇÀùt kladnƒÇ¬©.")
    private Long matchId;

    @NotNull(message = "ID hrƒÇÀá√Ñ≈§e je povinnƒÇ¬©.")
    @Positive(message = "ID hrƒÇÀá√Ñ≈§e musƒÇ¬≠ bƒÇÀùt kladnƒÇ¬©.")
    private Long playerId;

    private PlayerMatchStatus status;
    private ExcuseReason excuseReason; // pouze pokud status = EXCUSED
    private String excuseNote;
    private String adminNote;
    private Team team;

    @NotNull
    private String createdBy; // "user" nebo "system"

    private PlayerDTO playerDTO;

    public MatchRegistrationDTO() {}

    // Gettery a settery
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public Long getMatchId() { return matchId; }
    public void setMatchId(Long matchId) { this.matchId = matchId; }

    public Long getPlayerId() { return playerId; }
    public void setPlayerId(Long playerId) { this.playerId = playerId; }

    public PlayerMatchStatus getStatus() { return status; }
    public void setStatus(PlayerMatchStatus status) { this.status = status; }

    public ExcuseReason getExcuseReason() { return excuseReason; }
    public void setExcuseReason(ExcuseReason excuseReason) { this.excuseReason = excuseReason; }

    public String getExcuseNote() { return excuseNote; }
    public void setExcuseNote(String excuseNote) { this.excuseNote = excuseNote; }

    public String getAdminNote() { return adminNote; }
    public void setAdminNote(String adminNote) { this.adminNote = adminNote; }

    public Team getTeam() { return team; }
    public void setTeam (Team team) { this.team = team; }

    public String getCreatedBy() { return createdBy; }
    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }
}

--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerDTO.java
--------------------
package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerType;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class PlayerDTO {


    private Long id; // autogenerated, nullable pƒπ‚Ñ¢i create

    @NotBlank(message = "Kƒπ‚Ñ¢estnƒÇ¬≠ jmƒÇ¬©no je povinnƒÇ¬©.")
    @Size(min = 2, max = 50)
    private String name; // not null

    @NotBlank(message = "Pƒπ‚Ñ¢ƒÇ¬≠jmenƒÇ¬≠ je povinnƒÇ¬©.")
    @Size(min = 2, max = 50)
    private String surname; // not null
    private String nickName;
    private String fullName; // derived
    private String phoneNumber;
    private PlayerType type; // not null, default BASIC
    private Team team;
    private PlayerStatus status;


    public PlayerDTO() {
        this.type = PlayerType.BASIC;
   }

    public PlayerDTO(Long id, String name, String surname, String nickName, PlayerType type, Team team, PlayerStatus status) {
        this.id = id;
        this.name = name;
        this.surname = surname;
        this.nickName = nickName;
        this.type = type != null ? type : PlayerType.BASIC;
        this.updateFullName();
        this.team = team;
        this.status = status != null ? status : PlayerStatus.PENDING;
    }

    // --- Gettery a Settery ---

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; updateFullName(); }

    public String getSurname() { return surname; }
    public void setSurname(String surname) { this.surname = surname; updateFullName(); }

    public String getNickName() { return nickName; }

    public void setNickName(String nickName) { this.nickName = nickName; }

    public String getFullName() { return fullName; }

    private void updateFullName() { this.fullName = name + " " + surname; }

    public PlayerType getType() { return type; }
    public void setType(PlayerType type) { this.type = type != null ? type : PlayerType.BASIC; }

    public Team getTeam() { return team; }
    public void setTeam(Team team) { this.team = team; }

    public String getPhoneNumber() { return phoneNumber; }
    public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }

    public PlayerStatus getStatus() { return status; }
    public void setStatus(PlayerStatus status) { this.status = status != null ? status : PlayerStatus.PENDING;
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerInactivityPeriodDTO.java
--------------------
package cz.phsoft.hokej.models.dto;

import java.time.LocalDateTime;

public class PlayerInactivityPeriodDTO {

    private Long id;
    private Long playerId;
    private LocalDateTime inactiveFrom;
    private LocalDateTime inactiveTo;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getPlayerId() {
        return playerId;
    }

    public void setPlayerId(Long playerId) {
        this.playerId = playerId;
    }

    public LocalDateTime getInactiveFrom() {
        return inactiveFrom;
    }

    public void setInactiveFrom(LocalDateTime inactiveFrom) {
        this.inactiveFrom = inactiveFrom;
    }

    public LocalDateTime getInactiveTo() {
        return inactiveTo;
    }

    public void setInactiveTo(LocalDateTime inactiveTo) {
        this.inactiveTo = inactiveTo;
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\PlayerSummaryDTO.java
--------------------
package cz.phsoft.hokej.models.dto;

import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.enums.Team;

public class PlayerSummaryDTO {
    private Long id;
    private String name;
    private String surname;
    private String fullName;
    private String nickName;
    private PlayerType type;
    private Team team;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public String getFullName() {
        return fullName;
    }

    public void setFullName(String fullName) {
        this.fullName = fullName;
    }

    public String getNickName() {
        return nickName;
    }

    public void setNickName(String nickName) {
        this.nickName = nickName;
    }

    public PlayerType getType() {
        return type;
    }

    public void setType(PlayerType type) {
        this.type = type;
    }

    public Team getTeam() {
        return team;
    }

    public void setTeam(Team team) {
        this.team = team;
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\RegisterUserDTO.java
--------------------
package cz.phsoft.hokej.models.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class RegisterUserDTO {

    @NotBlank(message = "Kƒπ‚Ñ¢estnƒÇ¬≠ jmƒÇ¬©no je povinnƒÇ¬©.")
    @Size(min = 2, max = 50)
    private String name; // not null

    @NotBlank(message = "Pƒπ‚Ñ¢ƒÇ¬≠jmenƒÇ¬≠ je povinnƒÇ¬©.")
    @Size(min = 2, max = 50)
    private String surname;

    @NotBlank(message = "email je povinnƒÇÀù.")
    @Email
    private String email;

    @NotBlank
    @Size(min = 8, max = 64)
    private String password;

    @NotBlank
    private String passwordConfirm;


    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getPasswordConfirm() {
        return passwordConfirm;
    }

    public void setPasswordConfirm(String passwordConfirm) {
        this.passwordConfirm = passwordConfirm;
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\dto\SuccessResponseDTO.java
--------------------
package cz.phsoft.hokej.models.dto;

public class SuccessResponseDTO {
    private  String message;
    private Long id;
    private String timestamp;

    public SuccessResponseDTO(String message, Long id, String timestamp) {
        this.message = message;
        this.id = id;
        this.timestamp = timestamp;
    }

    public String getMessage() { return message; }
    public Long getId() { return id; }
    public String getTimestamp() { return timestamp; }

}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\email\EmailService.java
--------------------
package cz.phsoft.hokej.models.services.email;

import jakarta.mail.MessagingException;
import jakarta.mail.internet.MimeMessage;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

@Service
public class EmailService {
    private final JavaMailSender mailSender;

    @Value("${spring.mail.from}")
    private String fromEmail;

    @Value("${email.enabled:true}")   //
    private boolean emailEnabled;

    public EmailService(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    // ===== 1) JEDNODUCHƒÇ≈• TEXTOVƒÇ≈• EMAIL =====
    @Async
    public void sendSimpleEmail(String to, String subject, String text) {

        if (!emailEnabled) {
            System.out.println("MAIL JE VYPNUTƒÇ≈• √¢‚Ç¨‚Äú email nebyl odeslƒÇÀán na: " + to);
            return;
        }


        try {
            SimpleMailMessage message = new SimpleMailMessage();
            message.setTo(to);
            message.setSubject(subject);
            message.setText(text);
            message.setFrom(fromEmail);

            mailSender.send(message);
        } catch (Exception e) {
            // Doporu√Ñ≈§eno: logovat do souboru
            throw new RuntimeException("Chyba pƒπ‚Ñ¢i odesƒÇ¬≠lƒÇÀánƒÇ¬≠ emailu: " + e.getMessage(), e);
        }
    }

    // ===== 2) HTML EMAIL (HEZ√Ñ≈öƒÇ≈§) =====
    @Async
    public void sendHtmlEmail(String to, String subject, String htmlContent) {

        if (!emailEnabled) {
            System.out.println("MAIL JE VYPNUTƒÇ≈• √¢‚Ç¨‚Äú email nebyl odeslƒÇÀán na: " + to);
            return;
        }

        try {
            MimeMessage mimeMessage = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true, "UTF-8");

            helper.setTo(to);
            helper.setSubject(subject);
            helper.setText(htmlContent, true); // true = HTML
            helper.setFrom(fromEmail);

            mailSender.send(mimeMessage);
        } catch (MessagingException e) {
            throw new RuntimeException("Chyba pƒπ‚Ñ¢i odesƒÇ¬≠lƒÇÀánƒÇ¬≠ HTML emailu: " + e.getMessage(), e);
        }
    }
    public void sendActivationEmail(String to, String activationLink) {
        String subject = "Potvr√Ñ≈πte svƒπ≈ªj ƒÇ≈ü√Ñ≈§et";
        String text = "DobrƒÇÀù den,\n\n"
                + "Klikn√Ñ‚Ä∫te na tento odkaz pro aktivaci ƒÇ≈ü√Ñ≈§tu:\n"
                + activationLink + "\n\n"
                + "Platnost odkazu: 24 hodin.\n\n"
                + "D√Ñ‚Ä∫kujeme!";
        sendSimpleEmail(to, subject, text);
    }

    @Async
    public void sendActivationEmailHTML(String to, String activationLink) {
        String subject = "PotvrzenƒÇ¬≠ registrace - App - Hokej StarƒÇÀá Garda";
        String html = "<p>D√Ñ‚Ä∫kujeme za registraci.</p>" +
                "<p>Klikn√Ñ‚Ä∫te na odkaz pro aktivaci ƒÇ≈ü√Ñ≈§tu:</p>" +
                "<a href=\"" + activationLink + "\">Aktivovat ƒÇ≈ü√Ñ≈§et</a>";

        sendHtmlEmail(to, subject, html);
    }

}

--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsMessageBuilder.java
--------------------
package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.models.dto.PlayerDTO;
import org.springframework.stereotype.Component;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;

import java.time.format.DateTimeFormatter;

@Component
public class SmsMessageBuilder {

    private final MatchRegistrationRepository matchRegistrationRepository;
    private final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");

    public SmsMessageBuilder(MatchRegistrationRepository matchRegistrationRepository) {
        this.matchRegistrationRepository = matchRegistrationRepository;
    }

    // --------------------------
    // zprƒÇÀáva po registraci/odhlƒÇÀáƒπÀáenƒÇ¬≠/omluvenƒÇ¬≠
    // --------------------------
    public String buildMessageRegistration(MatchRegistrationEntity registration) {
        PlayerMatchStatus status = registration.getStatus();
        String statusText = switch (status) {
            case REGISTERED -> "pƒπ‚Ñ¢ihlƒÇÀásil se k zƒÇÀápasu";
            case UNREGISTERED -> "odhlƒÇÀásil se ze zƒÇÀápasu";
            case EXCUSED -> "omluven";
            default -> "neznƒÇÀámƒÇÀù stav";
        };

        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(registration.getMatch().getId(), PlayerMatchStatus.REGISTERED);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - datum: ")
                .append(registration.getMatch().getDateTime().toLocalDate());

        if (status != PlayerMatchStatus.EXCUSED) {
            sb.append(", ").append(registeredCount)
                    .append("/").append(registration.getMatch().getMaxPlayers());
        }

        sb.append(", hrƒÇÀá√Ñ≈§: ").append(registration.getPlayer().getFullName())
                .append(", status: ").append(statusText);

        return sb.toString();
    }

    // --------------------------
    // zprƒÇÀáva pro hrƒÇÀá√Ñ≈§e, kteƒπ‚Ñ¢ƒÇ¬≠ jeƒπÀát√Ñ‚Ä∫ nereagovali
    // --------------------------
    public String buildMessageNoResponse(PlayerDTO player, MatchEntity match) {
        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - upozorn√Ñ‚Ä∫nƒÇ¬≠: zƒÇÀápas ")
                .append(match.getDateTime().format(dateFormatter))
                .append(" - volnƒÇÀá mƒÇ¬≠sta: ")
                .append(match.getMaxPlayers() - registeredCount)
                .append(". JeƒπÀát√Ñ‚Ä∫ jste nereagoval.");

        return sb.toString();
    }

    // --------------------------
    // finƒÇÀálnƒÇ¬≠ pƒπ‚Ñ¢ipomƒÇ¬≠nka pro pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇ¬© hrƒÇÀá√Ñ≈§e v den zƒÇÀápasu
    // --------------------------
    public String buildMessageFinal(MatchRegistrationEntity registration) {
        MatchEntity match = registration.getMatch();
        Long registeredCount = matchRegistrationRepository
                .countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);

        double pricePerPlayer = match.getPrice() / Math.max(registeredCount, 1);

        StringBuilder sb = new StringBuilder();
        sb.append("app_hokej - pƒπ‚Ñ¢ipomƒÇ¬≠nka zƒÇÀápasu ")
                .append(match.getDateTime().format(dateFormatter))
                .append(", pƒπ‚Ñ¢ihlƒÇÀáƒπÀáeno: ").append(registeredCount).append("/").append(match.getMaxPlayers())
                .append(", cena na hrƒÇÀá√Ñ≈§e: ").append(String.format("%.2f K√Ñ≈§", pricePerPlayer));

        return sb.toString();
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsSchedulerService.java
--------------------
package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.services.MatchRegistrationService;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import jakarta.transaction.Transactional;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.List;

@Service
public class SmsSchedulerService {

    private final MatchRepository matchRepository;
    private final MatchRegistrationRepository registrationRepository;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;
    private final MatchRegistrationService matchRegistrationService;

    public SmsSchedulerService(
            MatchRepository matchRepository,
            MatchRegistrationRepository registrationRepository,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder,
            MatchRegistrationService matchRegistrationService) {

        this.matchRepository = matchRepository;
        this.registrationRepository = registrationRepository;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
        this.matchRegistrationService = matchRegistrationService;
    }

    // PoslƒÇÀánƒÇ¬≠ SMS v den zƒÇÀápasu
    // SpustƒÇ¬≠ se kaƒπƒædƒÇÀù den v 12:30
    @Scheduled(cron = "0 30 12 * * *")
    @Transactional
    public void sendFinalSmsForTodayMatches() {

        LocalDate today = LocalDate.now();

        // najdeme vƒπÀáechny dneƒπÀánƒÇ¬≠ zƒÇÀápasy
        List<MatchEntity> todaysMatches = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().toLocalDate().isEqual(today))
                .toList();

        for (MatchEntity match : todaysMatches) {

            // na√Ñ≈§teme vƒπÀáechny registrace k danƒÇ¬©mu zƒÇÀápasu (BEZ zm√Ñ‚Ä∫n entit)
            List<MatchRegistrationEntity> registrations =
                    registrationRepository.findByMatchId(match.getId());

            for (MatchRegistrationEntity reg : registrations) {

                // pouƒπƒæijeƒπÀá svƒπ≈ªj pƒπ≈ªvodnƒÇ¬≠ builder
                String smsMsg = smsMessageBuilder.buildMessageFinal(reg);

                try {
                    smsService.sendSms(reg.getPlayer().getPhoneNumber(), smsMsg);
                    System.out.println("FinƒÇÀálnƒÇ¬≠ SMS poslƒÇÀána hrƒÇÀá√Ñ≈§i "
                            + reg.getPlayer().getFullName() + ": " + smsMsg);

                } catch (Exception e) {
                    System.err.println("Chyba SMS pro hrƒÇÀá√Ñ≈§e "
                            + reg.getPlayer().getFullName() + ": " + e.getMessage());
                }
            }
        }
    }

    // poslƒÇÀánƒÇ¬≠ SMS 3 dny pƒπ‚Ñ¢ed zƒÇÀápasem - noresponse player
    @Scheduled(cron = "0 40 14 * * *") // kaƒπƒædƒÇÀù den ve 12:30
    @Transactional
    public void sendNoResponseSmsForMatchesIn3Days() {

        LocalDate targetDate = LocalDate.now().plusDays(3);

        // vƒπÀáechny zƒÇÀápasy, kterƒÇ¬© jsou za 3 dny
        List<MatchEntity> matchesInThreeDays = matchRepository.findAll().stream()
                .filter(m -> m.getDateTime().toLocalDate().isEqual(targetDate))
                .toList();

        for (MatchEntity match : matchesInThreeDays) {

            // pouƒπƒæijeme tvƒπ≈ªj existujƒÇ¬≠cƒÇ¬≠ helper
            List<PlayerDTO> noResponsePlayers =
                    matchRegistrationService.getNoResponsePlayers(match.getId());

            for (PlayerDTO player : noResponsePlayers) {

                String smsMsg = smsMessageBuilder.buildMessageNoResponse(player, match);

                try {
                    smsService.sendSms(player.getPhoneNumber(), smsMsg);
                    System.out.println("NORESPONSE SMS poslƒÇÀána hrƒÇÀá√Ñ≈§i "
                            + player.getFullName() + ": " + smsMsg);
                } catch (Exception e) {
                    System.err.println("Chyba NORESPONSE SMS pro hrƒÇÀá√Ñ≈§e "
                            + player.getFullName() + ": " + e.getMessage());
                }
            }
        }
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsService.java
--------------------
package cz.phsoft.hokej.models.services.sms;

public interface SmsService {
    void sendSms(String phoneNumber, String message);
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsServiceImpl.java
--------------------
/* package cz.phsoft.hokej.models.services.sms;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;

@Service
public class SmsServiceImpl {

   // private final RestTemplate restTemplate = new RestTemplate();

    @Value("${textbee.api-url}")
    private String apiUrl;

    @Value("${textbee.api-key}")
    private String apiKey;

    // testovacƒÇ¬≠ √Ñ≈§ƒÇ¬≠slo
    //private final String testNumber = "+420776609956";

    /**
     * OdeƒπÀále SMS na testovacƒÇ¬≠ √Ñ≈§ƒÇ¬≠slo.
     * @param message text zprƒÇÀávy
     */

/*
    public void sendSms(String phoneNumber, String message) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("x-api-key", apiKey);

        Map<String, Object> body = Map.of(
                "recipients", List.of(phoneNumber),
                "message", message
        );

        HttpEntity<Map<String,Object>> request = new HttpEntity<>(body, headers);

        try {
            ResponseEntity<String> response = restTemplate.postForEntity(apiUrl, request, String.class);
            System.out.println("SMS poslƒÇÀána na testovacƒÇ¬≠ √Ñ≈§ƒÇ¬≠slo  xxx   : " + response.getBody());
        } catch (Exception e) {
            System.err.println("Chyba pƒπ‚Ñ¢i odesƒÇ¬≠lƒÇÀánƒÇ¬≠ SMS: " + e.getMessage());
        }
    }

*/
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\sms\SmsTextBeeService.java
--------------------
package cz.phsoft.hokej.models.services.sms;

import cz.phsoft.hokej.models.services.sms.SmsService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;

// textbee - free s omezenƒÇ¬≠m na 50 sms / den
@Service
public class SmsTextBeeService implements SmsService {

    @Value("${sms.enabled:true}")
    private boolean smsEnabled;

    @Value("${textbee.api-url}")
    private String apiUrl;

    @Value("${textbee.api-key}")
    private String apiKey;

    private final RestTemplate restTemplate = new RestTemplate();

    @Override
    public void sendSms(String phoneNumber, String message) {
        if (!smsEnabled) {
            System.out.println("SMS disabled, message not sent: " + message);
            return;
        }

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("x-api-key", apiKey);

        Map<String, Object> body = Map.of(
                "recipients", List.of(phoneNumber),
                "message", message
        );

        HttpEntity<Map<String,Object>> request = new HttpEntity<>(body, headers);

        try {
            ResponseEntity<String> response = restTemplate.postForEntity(apiUrl, request, String.class);
            System.out.println("SMS odeslƒÇÀána hrƒÇÀá√Ñ≈§i: " + phoneNumber + ", response: " + response.getBody());
        } catch (Exception e) {
            System.err.println("Chyba pƒπ‚Ñ¢i odesƒÇ¬≠lƒÇÀánƒÇ¬≠ SMS: " + e.getMessage());
        }
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserService.java
--------------------
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;

import java.util.List;

public interface AppUserService {
    /**
     * Registrace novƒÇ¬©ho uƒπƒæivatele
     *
     * @param registerUserDTO data pro registraci
     * @throws IllegalArgumentException pokud email existuje nebo hesla se neshodujƒÇ¬≠
     */
    void register(RegisterUserDTO registerUserDTO);

    AppUserDTO getCurrentUser(String email);

    List<AppUserDTO> getAllUsers();

    void changePassword(String email, String oldPassword, String newPassword, String newPasswordConfirm);

    void resetPassword(Long userId);

    void updateUser(String email, AppUserDTO dto);

    boolean activateUser(String token);
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\AppUserServiceImpl.java
--------------------
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.EmailVerificationTokenEntity;
import cz.phsoft.hokej.data.enums.Role;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.EmailVerificationTokenRepository;
import cz.phsoft.hokej.exceptions.UserAlreadyExistsException;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.RegisterUserDTO;
import cz.phsoft.hokej.models.dto.mappers.AppUserMapper;
import cz.phsoft.hokej.models.services.email.EmailService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class AppUserServiceImpl implements AppUserService {

    @Value("${app.base-url}")
    private String baseUrl;

    private final AppUserRepository userRepository;
    private final BCryptPasswordEncoder passwordEncoder;
    private final AppUserMapper appUserMapper;
    private final EmailService emailService;
    private final EmailVerificationTokenRepository tokenRepository;

    public AppUserServiceImpl(AppUserRepository userRepository,
                              BCryptPasswordEncoder passwordEncoder, AppUserMapper appUserMapper,
                              EmailService emailService, EmailVerificationTokenRepository tokenRepository) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
        this.appUserMapper = appUserMapper;
        this.emailService = emailService;
        this.tokenRepository = tokenRepository;
    }

    @Override
    public void register(RegisterUserDTO dto) {
        if (!dto.getPassword().equals(dto.getPasswordConfirm())) {
            throw new IllegalArgumentException("Hesla se neshodujƒÇ¬≠");
        }

        if (userRepository.findByEmail(dto.getEmail()).isPresent()) {
            throw new UserAlreadyExistsException("Uƒπƒæivatel s tƒÇ¬≠mto emailem jiƒπƒæ existuje");
        }

        AppUserEntity user = new AppUserEntity();
        user.setName(dto.getName());
        user.setSurname(dto.getSurname());
        user.setEmail(dto.getEmail());
        user.setPassword(passwordEncoder.encode(dto.getPassword()));
        user.setRole(Role.ROLE_PLAYER);
        user.setEnabled(false); // NEaktivnƒÇ¬≠ pƒπ‚Ñ¢i registraci

        AppUserEntity savedUser = userRepository.save(user);

        // GenerovƒÇÀánƒÇ¬≠ tokenu
        String token = java.util.UUID.randomUUID().toString();
        EmailVerificationTokenEntity verificationToken = new EmailVerificationTokenEntity();
        verificationToken.setToken(token);
        verificationToken.setUser(savedUser);
        verificationToken.setExpiresAt(java.time.LocalDateTime.now().plusHours(24));

        tokenRepository.save(verificationToken);


        // OdeslƒÇÀánƒÇ¬≠ aktiva√Ñ≈§nƒÇ¬≠ho emailu
        String activationLink = baseUrl + "/api/auth/verify?token=" + token;
        // Pro test lokƒÇÀáln√Ñ‚Ä∫: vypƒÇ¬≠ƒπÀáe odkaz do konzole
        System.out.println("Aktiva√Ñ≈§nƒÇ¬≠ odkaz: " + activationLink);

        emailService.sendActivationEmailHTML(savedUser.getEmail(), activationLink);
    }

    @Override
    public boolean activateUser(String token) {
        EmailVerificationTokenEntity verificationToken = tokenRepository.findByToken(token)
                .orElse(null);

        if (verificationToken == null || verificationToken.getExpiresAt().isBefore(java.time.LocalDateTime.now())) {
            return false; // neplatnƒÇÀù token nebo vyprƒπÀáel
        }

        AppUserEntity user = verificationToken.getUser();
        user.setEnabled(true); // aktivujeme uƒπƒæivatele
        userRepository.save(user);

        // Po aktivaci token smaƒπƒæeme (nenƒÇ¬≠ potƒπ‚Ñ¢eba jej uchovƒÇÀávat)
        tokenRepository.delete(verificationToken);

        return true;
    }

    @Override
    public void updateUser(String email, AppUserDTO dto) {

        AppUserEntity user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Uƒπƒæivatel nenalezen"));

        // NastavenƒÇ¬≠ novƒÇ¬©ho hesla
        user.setName(dto.getName());
        user.setSurname(dto.getSurname());
        user.setEmail(dto.getEmail());
        userRepository.save(user);
    }

    @Override
    public AppUserDTO getCurrentUser(String email) {
        AppUserEntity user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("User not found"));

        // √¢‚Ä†¬ê vyuƒπƒæitƒÇ¬≠ mapperu
        return appUserMapper.toDTO(user);
    }

    @Override
    public List<AppUserDTO> getAllUsers() {
        return userRepository.findAll().stream()
                .map(appUserMapper::toDTO)
                .toList();
    }

    @Override
    public void changePassword(String email, String oldPassword, String newPassword, String newPasswordConfirm) {
        if (!newPassword.equals(newPasswordConfirm)) {
            throw new IllegalArgumentException("NovƒÇÀá hesla se neshodujƒÇ¬≠");
        }

        AppUserEntity user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Uƒπƒæivatel nenalezen"));

        // Ov√Ñ‚Ä∫ƒπ‚Ñ¢enƒÇ¬≠ starƒÇ¬©ho hesla
        if (!passwordEncoder.matches(oldPassword, user.getPassword())) {
            throw new IllegalArgumentException("StarƒÇ¬© heslo je nesprƒÇÀávnƒÇ¬©");
        }

        // NastavenƒÇ¬≠ novƒÇ¬©ho hesla
        user.setPassword(passwordEncoder.encode(newPassword));
        userRepository.save(user);
    }

    // reset hesla
    @Override
    public void resetPassword(Long userId) {
        AppUserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("Uƒπƒæivatel nenalezen"));

        // NastavenƒÇ¬≠ novƒÇ¬©ho hesla na "Player123"
        user.setPassword(passwordEncoder.encode("Player123"));
        userRepository.save(user);
    }


}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationService.java
--------------------
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;

import java.util.List;

public interface MatchRegistrationService {

    // ƒë≈∫‚ÄùƒÑ VracƒÇ¬≠ DTO mƒÇ¬≠sto entity
    MatchRegistrationDTO upsertRegistration(
            Long matchId,
            Long playerId,
            Team team,
            String adminNote,
            ExcuseReason excuseReason,
            String excuseNote,
            boolean unregister
    );

    List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId);

    List<MatchRegistrationDTO> getRegistrationsForMatches(List<Long> matchIds);

    List<MatchRegistrationDTO> getAllRegistrations();

    List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId);

    List<PlayerDTO> getNoResponsePlayers(Long matchId);

    void recalcStatusesForMatch(Long matchId);
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchRegistrationServiceImpl.java
--------------------
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.repositories.MatchRegistrationRepository;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.DuplicateRegistrationException;
import cz.phsoft.hokej.exceptions.MatchNotFoundException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.exceptions.RegistrationNotFoundException;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.mappers.MatchRegistrationMapper;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import cz.phsoft.hokej.models.services.sms.SmsMessageBuilder;
import cz.phsoft.hokej.models.services.sms.SmsService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
public class MatchRegistrationServiceImpl implements MatchRegistrationService {

    Logger logger = LoggerFactory.getLogger(MatchServiceImpl.class);
    private final MatchRegistrationRepository registrationRepository;
    private final MatchRepository matchRepository;
    private final PlayerRepository playerRepository;
    private final MatchRegistrationMapper matchRegistrationMapper;
    private final PlayerMapper playerMapper;
    private final SmsService smsService;
    private final SmsMessageBuilder smsMessageBuilder;

    public MatchRegistrationServiceImpl(
            MatchRegistrationRepository registrationRepository,
            MatchRepository matchRepository,
            PlayerRepository playerRepository,
            MatchRegistrationMapper matchRegistrationMapper,
            PlayerMapper playerMapper,
            SmsService smsService,
            SmsMessageBuilder smsMessageBuilder) {
        this.registrationRepository = registrationRepository;
        this.matchRepository = matchRepository;
        this.playerRepository = playerRepository;
        this.matchRegistrationMapper = matchRegistrationMapper;
        this.playerMapper = playerMapper;
        this.smsService = smsService;
        this.smsMessageBuilder = smsMessageBuilder;
    }
    private MatchEntity getMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }
    private PlayerEntity getPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }
    private boolean isSlotAvailable(MatchEntity match) {
        long registeredCount = registrationRepository.countByMatchIdAndStatus(match.getId(), PlayerMatchStatus.REGISTERED);
        return registeredCount < match.getMaxPlayers();
    }
    private void sendSms(MatchRegistrationEntity registration, String message) {
        if (registration == null || registration.getPlayer() == null) return;
        try {
            smsService.sendSms(registration.getPlayer().getPhoneNumber(), message);
        } catch (Exception e) {
            System.err.println("Chyba SMS: " + e.getMessage());
        }
    }
    private MatchRegistrationEntity updateRegistrationStatus(
            MatchRegistrationEntity registration, PlayerMatchStatus status, String updatedBy, boolean updateTimestamp) {

        registration.setStatus(PlayerMatchStatus.valueOf(status.name()));
        registration.setCreatedBy(updatedBy);
        if (updateTimestamp) {
            registration.setTimestamp(LocalDateTime.now());
        }
        return registrationRepository.saveAndFlush(registration);
    }
    // -------------------- REGISTRATION --------------------
    @Transactional
    @Override
    public MatchRegistrationDTO upsertRegistration(
            Long matchId,
            Long playerId,
            Team team,
            String adminNote,
            ExcuseReason excuseReason,
            String excuseNote,
            boolean unregister) {

        // TEST: poƒπÀáli ERROR zprƒÇÀávu pro otestovƒÇÀánƒÇ¬≠ emailu
        logger.error("Test ERROR zprƒÇÀáva pro email");

        MatchEntity match = getMatchOrThrow(matchId);
        PlayerEntity player = getPlayerOrThrow(playerId);

        MatchRegistrationEntity registration = registrationRepository
                .findByPlayerIdAndMatchId(playerId, matchId)
                .orElse(null);

        PlayerMatchStatus newStatus;

        // UNREGISTER: lze pouze kdyƒπƒæ hrƒÇÀá√Ñ≈§ mƒÇÀá aktuƒÇÀáln√Ñ‚Ä∫ REGISTERED
        if (unregister) {
            if (registration == null || registration.getStatus() != PlayerMatchStatus.REGISTERED) {
                throw new RegistrationNotFoundException(matchId, playerId);
            }
            registration.setExcuseReason(null);
            newStatus = PlayerMatchStatus.UNREGISTERED;

            // EXCUSE: lze vytvoƒπ‚Ñ¢it pouze pokud hrƒÇÀá√Ñ≈§ NEMƒÇ¬Å status REGISTERED
        } else if (excuseReason != null) {
            if (registration != null && registration.getStatus() == PlayerMatchStatus.REGISTERED) {
                throw new DuplicateRegistrationException(matchId, playerId);
            }
            // pokud neexistuje, vytvoƒπ‚Ñ¢ƒÇ¬≠me pozici; pokud existuje a nenƒÇ¬≠ REGISTERED, povolƒÇ¬≠me EXCUSED
            if (registration == null) {
                registration = new MatchRegistrationEntity();
                registration.setMatch(match);
                registration.setPlayer(player);
            }
            registration.setExcuseReason(excuseReason);
            newStatus = PlayerMatchStatus.EXCUSED;

            // REGISTER / RESERVE: lze vytvoƒπ‚Ñ¢it pokud hrƒÇÀá√Ñ≈§ NEMƒÇ¬Å status REGISTERED (tedy i kdyƒπƒæ mƒÇÀá EXCUSED)
        } else {
            // pokud uƒπƒæ je registrovƒÇÀán, nepovolƒÇ¬≠me duplicitu
            if (registration != null && registration.getStatus() == PlayerMatchStatus.REGISTERED) {
                throw new DuplicateRegistrationException(matchId, playerId);
            }

            newStatus = isSlotAvailable(match) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;

            if (registration == null) {
                registration = new MatchRegistrationEntity();
                registration.setMatch(match);
                registration.setPlayer(player);
            } else {
                // pƒπ‚Ñ¢i pƒπ‚Ñ¢echodu na register/reserve zruƒπÀáƒÇ¬≠me pƒπ‚Ñ¢ƒÇ¬≠padnou vƒÇÀùmluvu
                registration.setExcuseReason(null);
            }
        }

        registration.setStatus(newStatus);
        registration.setTimestamp(LocalDateTime.now());
        registration.setCreatedBy("user");

        if (team != null) registration.setTeam(team);
        if (adminNote != null) registration.setAdminNote(adminNote);
        // excuseReason uƒπƒæ jsme nastavili vƒÇÀùƒπÀáe (pokud to byl EXCUSED pƒπ‚Ñ¢ƒÇ¬≠pad)
        if (excuseReason != null) registration.setExcuseReason(excuseReason);

        registration = registrationRepository.save(registration);

        if (unregister) recalcStatusesForMatch(matchId);

        sendSms(registration, smsMessageBuilder.buildMessageRegistration(registration));

        return matchRegistrationMapper.toDTO(registration);
    }
    // -------------------- FETCH --------------------
    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatch(Long matchId) {
        return matchRegistrationMapper.toDTOList(registrationRepository.findByMatchId(matchId));
    }

    @Override
    public List<MatchRegistrationDTO> getRegistrationsForMatches(List<Long> matchIds) {
        if (matchIds == null || matchIds.isEmpty()) {
            return List.of();
        }

        return matchRegistrationMapper.toDTOList(
                registrationRepository.findByMatchIdIn(matchIds)
        );
    }

    @Override
    public List<MatchRegistrationDTO> getAllRegistrations() {
        return matchRegistrationMapper.toDTOList(registrationRepository.findAll());
    }

    @Override
    public List<MatchRegistrationDTO> getRegistrationsForPlayer(Long playerId) {
        return matchRegistrationMapper.toDTOList(registrationRepository.findByPlayerId(playerId));
    }

    @Override
    public List<PlayerDTO> getNoResponsePlayers(Long matchId) {
        List<Long> responded = registrationRepository.findByMatchId(matchId).stream()
                .map(r -> r.getPlayer().getId())
                .toList();

        List<PlayerEntity> noResponsePlayers = playerRepository.findAll().stream()
                .filter(p -> !responded.contains(p.getId()))
                .toList();

        return noResponsePlayers.stream()
                .map(playerMapper::toDTO)
                .toList();
    }
    // -------------------- RECALC --------------------
    @Override
    @Transactional
    public void recalcStatusesForMatch(Long matchId) {
        MatchEntity match = getMatchOrThrow(matchId);
        int maxPlayers = match.getMaxPlayers();

        List<MatchRegistrationEntity> regs = registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED
                        || r.getStatus() == PlayerMatchStatus.RESERVED)
                .sorted((a, b) -> a.getTimestamp().compareTo(b.getTimestamp()))
                .toList();

        for (int i = 0; i < regs.size(); i++) {
            MatchRegistrationEntity reg = regs.get(i);
            PlayerMatchStatus newStatus = (i < maxPlayers) ? PlayerMatchStatus.REGISTERED : PlayerMatchStatus.RESERVED;
            if (reg.getStatus() != newStatus) updateRegistrationStatus(reg, newStatus, "system", false);
        }
    }

    // -------------------- SMS --------------------
    @Transactional
    public void sendSmsToRegisteredPlayers(Long matchId) {
        registrationRepository.findByMatchId(matchId).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .forEach(r -> sendSms(r, smsMessageBuilder.buildMessageFinal(r)));
    }

    public void sendNoResponseSmsForMatch(Long matchId) {
        var match = getMatchOrThrow(matchId);

        getNoResponsePlayers(matchId).forEach(player -> {
            String smsMsg = smsMessageBuilder.buildMessageNoResponse(player, match);

            try {
                smsService.sendSms(player.getPhoneNumber(), smsMsg);
            } catch (Exception e) {
                System.err.println("Chyba SMS pro hrƒÇÀá√Ñ≈§e "
                        + player.getFullName() + ": " + e.getMessage());
                logger.error("Chyba pƒπ‚Ñ¢i odeslƒÇÀánƒÇ¬≠ SMS hrƒÇÀá√Ñ≈§i {}: {}", player.getFullName(), e.getMessage());
            }
        });
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchService.java
--------------------
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import cz.phsoft.hokej.models.dto.MatchDetailDTO;
import cz.phsoft.hokej.models.dto.MatchOverviewDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;

import java.util.List;

public interface MatchService {
    List<MatchDTO> getAllMatches();
    List<MatchDTO> getUpcomingMatches();
    List<MatchDTO> getPastMatches();
    MatchDTO getNextMatch();
    MatchDTO getMatchById(Long id);
    MatchDTO createMatch(MatchDTO dto);
    MatchDTO updateMatch(Long id, MatchDTO dto);
    SuccessResponseDTO deleteMatch(Long id);
    MatchDetailDTO getMatchDetail(Long id);
    List<MatchDTO> getAvailableMatchesForPlayer(Long playerId);
    List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId);
    Long getPlayerIdByEmail(String email);
    List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId);
    public List<MatchOverviewDTO> getAllPassedMatchesForPlayer(Long playerId);


}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\MatchServiceImpl.java
--------------------
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.PlayerType;
import cz.phsoft.hokej.data.repositories.MatchRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.MatchNotFoundException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.models.dto.*;
import cz.phsoft.hokej.models.dto.mappers.MatchMapper;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class MatchServiceImpl implements MatchService {

    private final MatchRepository matchRepository;
    private final MatchMapper matchMapper;
    private final MatchRegistrationService registrationService;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodService playerInactivityPeriodService;
    private final PlayerMapper playerMapper;
    private static final String ROLE_ADMIN = "ROLE_ADMIN";
    private static final String ROLE_MANAGER = "ROLE_MANAGER";

    public MatchServiceImpl(MatchRepository matchRepository,
                            MatchMapper matchMapper,
                            MatchRegistrationService registrationService,
                            PlayerRepository playerRepository,
                            PlayerInactivityPeriodService playerInactivityPeriodService,
                            PlayerMapper playerMapper) {
        this.matchRepository = matchRepository;
        this.matchMapper = matchMapper;
        this.registrationService = registrationService;
        this.playerRepository = playerRepository;
        this.playerInactivityPeriodService = playerInactivityPeriodService;
        this.playerMapper = playerMapper;
    }
    // metoda pro zƒÇ¬≠skƒÇÀánƒÇ¬≠ vƒπÀáech zƒÇÀápasƒπ≈ª
    @Override
    public List<MatchDTO> getAllMatches() {
        return matchRepository.findAll().stream()
                .map(matchMapper::toDTO)
                .toList();
    }
    // metoda pro zƒÇ¬≠skƒÇÀánƒÇ¬≠ vƒπÀáech nadchƒÇÀázejƒÇ¬≠cƒÇ¬≠ch zƒÇÀápasƒπ≈ª
    @Override
    public List<MatchDTO> getUpcomingMatches() {
        return matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now())
                .stream()
                .map(matchMapper::toDTO)
                .toList();
    }
    // metoda pro zƒÇ¬≠skƒÇÀánƒÇ¬≠ uplynulƒÇÀùch zƒÇÀápasƒπ≈ª
    public List<MatchDTO> getPastMatches() {
        return matchRepository.findByDateTimeBeforeOrderByDateTimeDesc(LocalDateTime.now())
                .stream()
                .map(matchMapper::toDTO)
                .toList();
    }
    // metoda pro zƒÇ¬≠skƒÇÀánƒÇ¬≠ prvnƒÇ¬≠ho nadchƒÇÀázejƒÇ¬≠cƒÇ¬≠ho zƒÇÀápasu
    @Override
    public MatchDTO getNextMatch() {
        return matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now())
                .stream()
                .findFirst()
                .map(matchMapper::toDTO)
                .orElse(null);
    }
    // metoda pro zƒÇÀápas dle ID
    @Override
    public MatchDTO getMatchById(Long id) {
        return matchMapper.toDTO(findMatchOrThrow(id));
    }

    // metoda pro vytvoƒπ‚Ñ¢enƒÇ¬≠ zƒÇÀápasu
    @Override
    public MatchDTO createMatch(MatchDTO dto) {
        MatchEntity entity = matchMapper.toEntity(dto);
        return matchMapper.toDTO(matchRepository.save(entity));
    }

    // metoda pro ƒÇ≈üpravu zƒÇÀápasu
    @Override
    public MatchDTO updateMatch(Long id, MatchDTO dto) {
        MatchEntity match = findMatchOrThrow(id);

        int oldMaxPlayers = match.getMaxPlayers();
        matchMapper.updateEntity(dto, match);
        MatchEntity saved = matchRepository.save(match);

        // Pƒπ‚Ñ¢epo√Ñ≈§et registracƒÇ¬≠ pokud doƒπÀálo ke zm√Ñ‚Ä∫n√Ñ‚Ä∫ maxPlayers
        if (saved.getMaxPlayers() != oldMaxPlayers) {
            registrationService.recalcStatusesForMatch(saved.getId());
        }

        return matchMapper.toDTO(saved);
    }

    // metoda pro odstran√Ñ‚Ä∫nƒÇ¬≠ zƒÇÀápasu
    @Override
    public SuccessResponseDTO deleteMatch(Long id) {
        MatchEntity match = findMatchOrThrow(id);

        // 2) Pokud existuje, smaƒπƒæeme ho
        matchRepository.delete(match);

        return new SuccessResponseDTO(
                "ZƒÇÀápas " + match.getId() + match.getDateTime() + " byl ƒÇ≈üsp√Ñ‚Ä∫ƒπÀán√Ñ‚Ä∫ smazƒÇÀán",
                id,
                LocalDateTime.now().toString()
        );
    }

    // metoda pro detail zƒÇÀápasu - omezen vƒÇÀùpis pro ADMIN, MANAGER, PLAYER
    @Override
    public MatchDetailDTO getMatchDetail(Long id) {
        MatchEntity match = findMatchOrThrow(id);
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();

        boolean isAdminOrManager = auth != null && auth.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals(ROLE_ADMIN) || a.getAuthority().equals(ROLE_MANAGER));

        // odd√Ñ‚Ä∫lena logika pƒπ‚Ñ¢ƒÇ¬≠stupu hrƒÇÀá√Ñ≈§e do privƒÇÀátnƒÇ¬≠ metody
        checkAccessForPlayer(match, auth);

        // sb√Ñ‚Ä∫r statistik hrƒÇÀá√Ñ≈§ƒπ≈ª pƒπ‚Ñ¢es privƒÇÀátnƒÇ¬≠ metodu
        return collectPlayerStatus(match, isAdminOrManager);
    }

    // privƒÇÀátnƒÇ¬≠ metoda pro kontrolu pƒπ‚Ñ¢ƒÇ¬≠stupu hrƒÇÀá√Ñ≈§e - jen pokud byl registrovƒÇÀán na zƒÇÀápas
    private void checkAccessForPlayer(MatchEntity match, Authentication auth) {
        if (auth == null || !auth.isAuthenticated()) return;

        boolean isAdminOrManager = auth.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals(ROLE_ADMIN) || a.getAuthority().equals(ROLE_MANAGER));

        if (isAdminOrManager) return;

        Object principal = auth.getPrincipal();
        if (!(principal instanceof org.springframework.security.core.userdetails.UserDetails userDetails)) return;

        List<PlayerEntity> ownedPlayers = playerRepository.findAll().stream()
                .filter(p -> p.getUser() != null && p.getUser().getEmail().equals(userDetails.getUsername()))
                .toList();

        boolean hasRestrictedPlayer = ownedPlayers.stream()
                .anyMatch(p -> {
                    List<MatchRegistrationDTO> registrations = registrationService.getRegistrationsForMatch(match.getId());

                    boolean noResponse = registrations.stream()
                            .noneMatch(r -> r.getPlayerId().equals(p.getId()));

                    boolean inactiveForMatch = !playerInactivityPeriodService.isActive(p, match.getDateTime());

                    return noResponse || inactiveForMatch;
                });

        if (hasRestrictedPlayer) {
            throw new org.springframework.security.access.AccessDeniedException(
                    "NemƒÇÀáte pƒπ‚Ñ¢ƒÇ¬≠stup k detailu tohoto zƒÇÀápasu."
            );
        }
    }

    // privƒÇÀátnƒÇ¬≠ metoda pro sb√Ñ‚Ä∫r statistik hrƒÇÀá√Ñ≈§ƒπ≈ª
    private MatchDetailDTO collectPlayerStatus(MatchEntity match, boolean isAdminOrManager) {
        List<MatchRegistrationDTO> registrations = registrationService.getRegistrationsForMatch(match.getId());

        // Pƒπ‚Ñ¢evod vƒπÀáech registracƒÇ¬≠ na Map<PlayerMatchStatus, List<PlayerDTO>>
        var statusToPlayersMap = registrations.stream()
                .map(r -> playerRepository.findById(r.getPlayerId())
                        .map(playerMapper::toDTO)
                        .map(dto -> new java.util.AbstractMap.SimpleEntry<>(r.getStatus(), dto))
                )
                .filter(java.util.Optional::isPresent) // odstranƒÇ¬≠me chyb√Ñ‚Ä∫jƒÇ¬≠cƒÇ¬≠ hrƒÇÀá√Ñ≈§e
                .map(java.util.Optional::get)
                .collect(Collectors.groupingBy(
                        java.util.Map.Entry::getKey,
                        Collectors.mapping(java.util.Map.Entry::getValue, Collectors.toList())
                ));

        List<PlayerEntity> allPlayers = playerRepository.findAll();
        Set<Long> respondedIds = registrations.stream()
                .map(MatchRegistrationDTO::getPlayerId)
                .collect(Collectors.toSet());

        List<PlayerDTO> noResponsePlayers = allPlayers.stream()
                .filter(p -> !respondedIds.contains(p.getId()))
                .map(playerMapper::toDTO)
                .toList();

        // Po√Ñ≈§ty hrƒÇÀá√Ñ≈§ƒπ≈ª podle statusu
        int inGamePlayers = statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()).size();
        int outGamePlayers = statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()).size()
                + statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()).size();
        int waitingPlayers = statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()).size();
        int noActionPlayers = noResponsePlayers.size();
        int remainingSlots = match.getMaxPlayers() - inGamePlayers;
        double pricePerRegistered = inGamePlayers > 0 ? match.getPrice() / (double) inGamePlayers : 0;

        MatchDetailDTO dto = new MatchDetailDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setMaxPlayers(match.getMaxPlayers());
        dto.setInGamePlayers(inGamePlayers);
        dto.setOutGamePlayers(outGamePlayers);
        dto.setWaitingPlayers(waitingPlayers);
        dto.setNoActionPlayers(noActionPlayers);
        dto.setPricePerRegisteredPlayer(pricePerRegistered);
        dto.setRemainingSlots(remainingSlots);

        // NastavenƒÇ¬≠ hrƒÇÀá√Ñ≈§ƒπ≈ª podle statusu z mapy
        dto.setRegisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.REGISTERED, List.of()));
        dto.setReservedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.RESERVED, List.of()));
        dto.setUnregisteredPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.UNREGISTERED, List.of()));
        dto.setExcusedPlayers(statusToPlayersMap.getOrDefault(PlayerMatchStatus.EXCUSED, List.of()));

        // pouze admin/manager uvidƒÇ¬≠ no-response hrƒÇÀá√Ñ≈§e
        dto.setNoResponsePlayers(isAdminOrManager ? noResponsePlayers : null);

        return dto;
    }

    // dostupnƒÇ¬© zƒÇÀápasy pro hrƒÇÀá√Ñ≈§e - byl nebo je aktivnƒÇ¬≠
    @Override
    public List<MatchDTO> getAvailableMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        // Filtrace pƒπ‚Ñ¢es stream bez mezivƒÇÀùsledkƒπ≈ª
        return matchRepository.findAll().stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .map(matchMapper::toDTO)
                .toList();
    }

    // zƒÇ¬≠skƒÇÀánƒÇ¬≠ hrƒÇÀá√Ñ≈§e dle emailu
    public Long getPlayerIdByEmail(String email) {
        return playerRepository.findByUserEmail(email)
                .map(PlayerEntity::getId)
                .orElseThrow(() -> new RuntimeException("HrƒÇÀá√Ñ≈§ s emailem " + email + " nenalezen"));
    }


    // nƒÇÀáhled nadchƒÇÀázejƒÇ¬≠cƒÇ¬≠ch zƒÇÀápasu pro hrƒÇÀá√Ñ≈§e - dle PlayerType
    @Override
    public List<MatchOverviewDTO> getUpcomingMatchesOverviewForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        // 1) NejbliƒπƒæƒπÀáƒÇ¬≠ nadchƒÇÀázejƒÇ¬≠cƒÇ¬≠ zƒÇÀápasy podle data
        List<MatchEntity> upcomingAll = matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now());

        // 2) OmezenƒÇ¬≠ podle typu hrƒÇÀá√Ñ≈§e
        List<MatchEntity> limited = switch (type) {
            case VIP -> upcomingAll;
            case STANDARD -> upcomingAll.stream().limit(2).toList();
            case BASIC -> upcomingAll.isEmpty() ? List.of() : List.of(upcomingAll.get(0));
        };

        // 3) FiltrovƒÇÀánƒÇ¬≠ podle aktivity hrƒÇÀá√Ñ≈§e a mapovƒÇÀánƒÇ¬≠ na MatchOverviewDTO
        return limited.stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .map(match -> toOverviewDTO(match, playerId))
                .toList();
    }

    // nadchƒÇÀázejƒÇ¬≠cƒÇ¬≠ zƒÇÀápas
    @Override
    public List<MatchDTO> getUpcomingMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);
        PlayerType type = player.getType();

        // 1) NejbliƒπƒæƒπÀáƒÇ¬≠ nadchƒÇÀázejƒÇ¬≠cƒÇ¬≠ zƒÇÀápasy podle data
        List<MatchEntity> upcomingAll = matchRepository.findByDateTimeAfterOrderByDateTimeAsc(LocalDateTime.now());

        List<MatchEntity> limited = switch (type) {
            case VIP -> upcomingAll;
            case STANDARD -> upcomingAll.stream().limit(2).toList();
            case BASIC -> upcomingAll.isEmpty() ? List.of() : List.of(upcomingAll.get(0));
        };

        // 2) FiltrovƒÇÀánƒÇ¬≠ podle aktivity hrƒÇÀá√Ñ≈§e
        return limited.stream()
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .map(matchMapper::toDTO)
                .toList();
    }

    // pomocnƒÇ¬© metody
    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    private MatchEntity findMatchOrThrow(Long matchId) {
        return matchRepository.findById(matchId)
                .orElseThrow(() -> new MatchNotFoundException(matchId));
    }

    private MatchOverviewDTO toOverviewDTO(MatchEntity match) {
        MatchOverviewDTO dto = new MatchOverviewDTO();
        dto.setId(match.getId());
        dto.setDateTime(match.getDateTime());
        dto.setLocation(match.getLocation());
        dto.setDescription(match.getDescription());
        dto.setPrice(match.getPrice());
        dto.setMaxPlayers(match.getMaxPlayers());


        // po√Ñ≈§et registrovanƒÇÀùch hrƒÇÀá√Ñ≈§ƒπ≈ª
        int inGamePlayers = registrationService.getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getStatus() == PlayerMatchStatus.REGISTERED)
                .mapToInt(r -> 1)
                .sum();
        dto.setInGamePlayers(inGamePlayers);

        // cena na registrovanƒÇ¬©ho hrƒÇÀá√Ñ≈§e
        double pricePerPlayer = inGamePlayers > 0 && match.getPrice() != null
                ? match.getPrice() / (double) inGamePlayers : 0;
        dto.setPricePerRegisteredPlayer(pricePerPlayer);



        return dto;
    }

    private MatchOverviewDTO toOverviewDTO(MatchEntity match, Long playerId) {

        MatchOverviewDTO dto = toOverviewDTO(match); // √¢‚Ä†¬ê znovupouƒπƒæitƒÇ¬≠ tvƒÇ¬© pƒπ≈ªvodnƒÇ¬≠ metody

        PlayerMatchStatus status = registrationService
                .getRegistrationsForMatch(match.getId()).stream()
                .filter(r -> r.getPlayerId().equals(playerId))
                .map(MatchRegistrationDTO::getStatus)
                .findFirst()
                .filter(s ->
                        s == PlayerMatchStatus.REGISTERED ||
                                s == PlayerMatchStatus.UNREGISTERED ||
                                s == PlayerMatchStatus.EXCUSED ||
                                s == PlayerMatchStatus.RESERVED
                )
                .orElse(PlayerMatchStatus.NO_RESPONSE);

        dto.setStatus(status);
        return dto;
    }

    @Override
    public List<MatchOverviewDTO> getAllPassedMatchesForPlayer(Long playerId) {
        PlayerEntity player = findPlayerOrThrow(playerId);

        // Vezmeme dostupnƒÇ¬© zƒÇÀápasy jako entity (bez DTO)
        List<MatchEntity> availableMatches = matchRepository.findAll().stream()
                .filter(match -> match.getDateTime().isBefore(LocalDateTime.now()) || match.getDateTime().isEqual(LocalDateTime.now()))
                .filter(match -> playerInactivityPeriodService.isActive(player, match.getDateTime()))
                .toList();

        if (availableMatches.isEmpty()) {
            return List.of();
        }

        // VƒπÀáechny ID zƒÇÀápasƒπ≈ª
        List<Long> matchIds = availableMatches.stream()
                .map(MatchEntity::getId)
                .toList();

        // Jeden jedinƒÇÀù dotaz na vƒπÀáechny registrace
        List<MatchRegistrationDTO> allRegistrations =
                registrationService.getRegistrationsForMatches(matchIds);

        // Mapa: matchId -> (playerId -> status)
        var statusMap = allRegistrations.stream()
                .collect(Collectors.groupingBy(
                        MatchRegistrationDTO::getMatchId,
                        Collectors.toMap(
                                MatchRegistrationDTO::getPlayerId,
                                MatchRegistrationDTO::getStatus,
                                (a, b) -> a
                        )
                ));

        // MapovƒÇÀánƒÇ¬≠ na MatchOverviewDTO + nastavenƒÇ¬≠ statusu
        return availableMatches.stream()
                .map(match -> {
                    MatchOverviewDTO overview = toOverviewDTO(match);

                    PlayerMatchStatus status = Optional.ofNullable(statusMap.get(match.getId()))
                            .map(m -> m.get(playerId))
                            .filter(s ->
                                    s == PlayerMatchStatus.REGISTERED ||
                                            s == PlayerMatchStatus.UNREGISTERED ||
                                            s == PlayerMatchStatus.EXCUSED ||
                                            s == PlayerMatchStatus.RESERVED
                            )
                            .orElse(PlayerMatchStatus.NO_RESPONSE);

                    overview.setStatus(status);
                    return overview;
                })
                .toList();
    }



}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodService.java
--------------------
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;

import java.time.LocalDateTime;
import java.util.List;

public interface PlayerInactivityPeriodService {

    List<PlayerInactivityPeriodDTO> getAll();

    PlayerInactivityPeriodDTO getById(Long id);

    List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId);

    PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto);

    PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto);

    void delete(Long id);

    public boolean isActive(PlayerEntity player, LocalDateTime dateTime);
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerInactivityPeriodServiceImpl.java
--------------------
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.data.repositories.PlayerInactivityPeriodRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.models.dto.mappers.PlayerInactivityPeriodMapper;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import java.util.List;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

@Service
public class PlayerInactivityPeriodServiceImpl implements PlayerInactivityPeriodService {

    private final PlayerInactivityPeriodRepository inactivityRepository;
    private final PlayerRepository playerRepository;
    private final PlayerInactivityPeriodMapper mapper;

    public PlayerInactivityPeriodServiceImpl(PlayerInactivityPeriodRepository inactivityRepository,
                                             PlayerRepository playerRepository,
                                             PlayerInactivityPeriodMapper mapper) {
        this.inactivityRepository = inactivityRepository;
        this.playerRepository = playerRepository;
        this.mapper = mapper;
    }

    @Override
    public List<PlayerInactivityPeriodDTO> getAll() {
        return inactivityRepository.findAll().stream()
                .map(mapper::toDTO)
                .toList();
    }

    @Override
    public PlayerInactivityPeriodDTO getById(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException(
                        "ObdobƒÇ¬≠ neaktivity s ID " + id + " neexistuje."
                ));
        return mapper.toDTO(entity);
    }

    @Override
    public List<PlayerInactivityPeriodDTO> getByPlayer(Long playerId) {
        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new RuntimeException("Player not found"));

        return inactivityRepository.findByPlayerOrderByInactiveFromAsc(player)
                .stream()
                .map(mapper::toDTO)
                .toList();
    }

    // --- TRANSACTIONAL pro zƒÇÀápis dat ---
    @Override
    @Transactional
    public PlayerInactivityPeriodDTO create(PlayerInactivityPeriodDTO dto) {
        PlayerEntity player = playerRepository.findById(dto.getPlayerId())
                .orElseThrow(() -> new IllegalArgumentException("HrƒÇÀá√Ñ≈§ s ID " + dto.getPlayerId() + " neexistuje."));

        validateDates(dto);

        // kontrola pƒπ‚Ñ¢ekryvu existujƒÇ¬≠cƒÇ¬≠ch obdobƒÇ¬≠
        boolean overlaps = !inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        player, dto.getInactiveFrom(), dto.getInactiveTo()
                ).isEmpty();

        if (overlaps) {
            throw new IllegalStateException("NovƒÇ¬© obdobƒÇ¬≠ se pƒπ‚Ñ¢ekrƒÇÀùvƒÇÀá s existujƒÇ¬≠cƒÇ¬≠m obdobƒÇ¬≠m neaktivity hrƒÇÀá√Ñ≈§e.");
        }

        PlayerInactivityPeriodEntity entity = mapper.toEntity(dto, player);
        return mapper.toDTO(inactivityRepository.save(entity));
    }

    @Override
    @Transactional
    public PlayerInactivityPeriodDTO update(Long id, PlayerInactivityPeriodDTO dto) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("ObdobƒÇ¬≠ neaktivity s ID " + id + " neexistuje."));

        validateDates(dto);

        // kontrola pƒπ‚Ñ¢ekryvu, ignoruje aktuƒÇÀálnƒÇ¬≠ zƒÇÀáznam
        boolean overlaps = inactivityRepository
                .findByPlayerAndInactiveToGreaterThanEqualAndInactiveFromLessThanEqual(
                        entity.getPlayer(), dto.getInactiveFrom(), dto.getInactiveTo()
                ).stream()
                .anyMatch(p -> !p.getId().equals(id));

        if (overlaps) {
            throw new IllegalStateException("UpravenƒÇ¬© obdobƒÇ¬≠ se pƒπ‚Ñ¢ekrƒÇÀùvƒÇÀá s jinƒÇÀùm obdobƒÇ¬≠m neaktivity hrƒÇÀá√Ñ≈§e.");
        }

        mapper.updateEntityFromDto(dto, entity);
        return mapper.toDTO(inactivityRepository.save(entity));
    }

    @Override
    @Transactional
    public void delete(Long id) {
        PlayerInactivityPeriodEntity entity = inactivityRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("ObdobƒÇ¬≠ neaktivity s ID " + id + " neexistuje."));
        inactivityRepository.delete(entity);
    }

    // --- true = aktivnƒÇ¬≠, false = neaktivnƒÇ¬≠ ---
    public boolean isActive(PlayerEntity player, LocalDateTime dateTime) {
        return !inactivityRepository.existsByPlayerAndInactiveFromLessThanEqualAndInactiveToGreaterThanEqual(
                player, dateTime, dateTime);
    }

    // --- privƒÇÀátnƒÇ¬≠ metoda pro validaci dat ---
    private void validateDates(PlayerInactivityPeriodDTO dto) {
        if (dto.getInactiveFrom() == null || dto.getInactiveTo() == null) {
            throw new IllegalArgumentException("Datum od a do nesmƒÇ¬≠ bƒÇÀùt null.");
        }
        if (!dto.getInactiveFrom().isBefore(dto.getInactiveTo())) {
            throw new IllegalArgumentException("inactiveFrom musƒÇ¬≠ bƒÇÀùt pƒπ‚Ñ¢ed inactiveTo.");
        }
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerService.java
--------------------
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;

import java.util.List;


public interface PlayerService {
    List<PlayerDTO> getAllPlayers();
    PlayerDTO getPlayerById(Long id);
    PlayerDTO createPlayer(PlayerDTO player);
    PlayerDTO createPlayerForUser(PlayerDTO dto, String userEmail);
    PlayerDTO updatePlayer(Long id, PlayerDTO player);
    SuccessResponseDTO deletePlayer(Long id);
    public List<PlayerDTO> getPlayersByUser(String email);
    SuccessResponseDTO approvePlayer (Long id);
    SuccessResponseDTO rejectPlayer (Long id);
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\models\services\PlayerServiceImpl.java
--------------------
package cz.phsoft.hokej.models.services;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.repositories.AppUserRepository;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.DuplicateNameSurnameException;
import cz.phsoft.hokej.exceptions.InvalidPlayerStatusException;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import cz.phsoft.hokej.models.dto.SuccessResponseDTO;
import cz.phsoft.hokej.models.dto.mappers.PlayerMapper;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;
import cz.phsoft.hokej.models.dto.PlayerDTO;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class PlayerServiceImpl implements PlayerService {

    private final PlayerRepository playerRepository;
    private final PlayerMapper playerMapper;
    private final AppUserRepository appUserRepository;

    public PlayerServiceImpl(PlayerRepository playerRepository, PlayerMapper playerMapper, AppUserRepository appUserRepository) {
        this.playerRepository = playerRepository;
        this.playerMapper = playerMapper;
        this.appUserRepository = appUserRepository;
    }

    @Override
    public List<PlayerDTO> getAllPlayers() {
        return playerRepository.findAll().stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    @Override
    public PlayerDTO getPlayerById(Long id) {
        PlayerEntity player = playerRepository.findById(id)
                .orElseThrow(() -> new PlayerNotFoundException(id)); // mƒÇ¬≠sto RuntimeException
        return playerMapper.toDTO(player);
    }


    // --- TRANSACTIONAL pro zƒÇÀápis dat ---
    @Override
    @Transactional
    public PlayerDTO createPlayer(PlayerDTO dto) {
        checkDuplicateNameSurname(dto.getName(), dto.getSurname(), null);

        PlayerEntity entity = playerMapper.toEntity(dto);
        PlayerEntity saved = playerRepository.save(entity);
        return playerMapper.toDTO(saved);
    }

    @Override
    @Transactional
    public PlayerDTO createPlayerForUser(PlayerDTO dto, String userEmail) {
        AppUserEntity user = appUserRepository.findByEmail(userEmail)
                .orElseThrow(() -> new RuntimeException("User not found"));

        PlayerEntity player = playerMapper.toEntity(dto);
        player.setUser(user); // pƒπ‚Ñ¢iƒπ‚Ñ¢azenƒÇ¬≠ hrƒÇÀá√Ñ≈§e k uƒπƒæivateli


        PlayerEntity saved = playerRepository.save(player);
        return playerMapper.toDTO(saved);
    }

    @Override
    public List<PlayerDTO> getPlayersByUser(String email) {
        return playerRepository.findByUser_EmailOrderByIdAsc(email).stream()
                .map(playerMapper::toDTO)
                .toList();
    }

    @Override
    @Transactional
    public PlayerDTO updatePlayer(Long id, PlayerDTO dto) {
        PlayerEntity existing = findPlayerOrThrow(id);

        // pokud se jmƒÇ¬©no/pƒπ‚Ñ¢ƒÇ¬≠jmenƒÇ¬≠ m√Ñ‚Ä∫nƒÇ¬≠, ov√Ñ‚Ä∫ƒπ‚Ñ¢ duplicitu
        if (!existing.getName().equals(dto.getName())
                || !existing.getSurname().equals(dto.getSurname())) {
            checkDuplicateNameSurname(dto.getName(), dto.getSurname(), id);
        }

        existing.setName(dto.getName());
        existing.setSurname(dto.getSurname());
        existing.setNickname(dto.getNickName());
        existing.setPhoneNumber(dto.getPhoneNumber());
        existing.setType(dto.getType());
        existing.setTeam(dto.getTeam());
        existing.setStatus(dto.getStatus());

        PlayerEntity saved = playerRepository.save(existing);
        return playerMapper.toDTO(saved);
    }

    @Override
    @Transactional
    public SuccessResponseDTO deletePlayer(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);
        playerRepository.delete(player);

        return new SuccessResponseDTO(
                "HrƒÇÀá√Ñ≈§ " + player.getFullName() + " byl ƒÇ≈üsp√Ñ‚Ä∫ƒπÀán√Ñ‚Ä∫ smazƒÇÀán",
                id,
                LocalDateTime.now().toString()
        );
    }

    // --- privƒÇÀátnƒÇ¬≠ metoda pro kontrolu duplicity jmƒÇ¬©na a pƒπ‚Ñ¢ƒÇ¬≠jmenƒÇ¬≠ ---
    private void checkDuplicateNameSurname(String name, String surname, Long ignoreId) {
        Optional<PlayerEntity> duplicateOpt = playerRepository.findByNameAndSurname(name, surname);

        if (duplicateOpt.isPresent()) {
            if (ignoreId == null || !duplicateOpt.get().getId().equals(ignoreId)) {
                throw new DuplicateNameSurnameException("HrƒÇÀá√Ñ≈§ se jmƒÇ¬©nem " + name + " " + surname + " jiƒπƒæ existuje.");
            }
        }
    }

    private PlayerEntity findPlayerOrThrow(Long playerId) {
        return playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));
    }

    @Override
    @Transactional
    public SuccessResponseDTO approvePlayer(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);

        if (player.getStatus() == PlayerStatus.APPROVED) {
            throw new InvalidPlayerStatusException("HrƒÇÀá√Ñ≈§ uƒπƒæ je schvƒÇÀálen.");
        }
        player.setStatus(PlayerStatus.APPROVED);
        playerRepository.save(player);
        return new SuccessResponseDTO(
                "HrƒÇÀá√Ñ≈§ " + player.getFullName() + " byl ƒÇ≈üsp√Ñ‚Ä∫ƒπÀán√Ñ‚Ä∫ aktivovƒÇÀán",
                id,
                LocalDateTime.now().toString()
        );
    }

    @Override
    @Transactional
    public SuccessResponseDTO rejectPlayer(Long id) {
        PlayerEntity player = findPlayerOrThrow(id);

        if (player.getStatus() == PlayerStatus.REJECTED) {
            throw new InvalidPlayerStatusException("HrƒÇÀá√Ñ≈§ uƒπƒæ je zamƒÇ¬≠tnut.");
        }
        player.setStatus(PlayerStatus.REJECTED);
        playerRepository.save(player);

        return new SuccessResponseDTO(
                "HrƒÇÀá√Ñ≈§ " + player.getFullName() + " byl ƒÇ≈üsp√Ñ‚Ä∫ƒπÀán√Ñ‚Ä∫ zamƒÇ¬≠tnut",
                id,
                LocalDateTime.now().toString()
        );
    }


}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\CurrentPlayerContext.java
--------------------
package cz.phsoft.hokej.security;


import cz.phsoft.hokej.data.entities.PlayerEntity;

// pro vƒÇÀùb√Ñ‚Ä∫r hrƒÇÀá√Ñ≈§e
public class CurrentPlayerContext {

        private static final ThreadLocal<PlayerEntity> currentPlayer = new ThreadLocal<>();

        public static void set(PlayerEntity player) {
            currentPlayer.set(player);
        }

        public static PlayerEntity get() {
            return currentPlayer.get();
        }

        public static void clear() {
            currentPlayer.remove();
        }
    }
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\CurrentPlayerFilter.java
--------------------
package cz.phsoft.hokej.security;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;

@Component
public class CurrentPlayerFilter extends OncePerRequestFilter {

    private final PlayerRepository playerRepository;
    private final CurrentPlayerService currentPlayerService;

    public CurrentPlayerFilter(PlayerRepository playerRepository,
                               CurrentPlayerService currentPlayerService) {
        this.playerRepository = playerRepository;
        this.currentPlayerService = currentPlayerService;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {

        Long playerId = currentPlayerService.getCurrentPlayerId();

        if (playerId != null) {
            playerRepository.findById(playerId)
                    .ifPresent(CurrentPlayerContext::set);
        }

        try {
            filterChain.doFilter(request, response);
        } finally {
            CurrentPlayerContext.clear();
        }
    }
}

--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\CurrentPlayerService.java
--------------------
package cz.phsoft.hokej.security;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.PlayerStatus;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import cz.phsoft.hokej.exceptions.PlayerNotFoundException;
import jakarta.servlet.http.HttpSession;
import org.springframework.stereotype.Service;

@Service
public class CurrentPlayerService {

    private final HttpSession session;
    private final PlayerRepository playerRepository;

    public CurrentPlayerService(HttpSession session, PlayerRepository playerRepository) {
        this.session = session;
        this.playerRepository = playerRepository;
    }

    public Long getCurrentPlayerId() {
        return (Long) session.getAttribute(SessionKeys.CURRENT_PLAYER_ID);
    }

    public void setCurrentPlayerId(Long playerId) {
        PlayerEntity player = playerRepository.findById(playerId)
                .orElseThrow(() -> new PlayerNotFoundException(playerId));

        if (player.getStatus() != PlayerStatus.APPROVED) {
            throw new IllegalStateException(
                    "Nelze zvolit hrƒÇÀá√Ñ≈§e, kterƒÇÀù nenƒÇ¬≠ schvƒÇÀálen administrƒÇÀátorem."
            );
        }

        session.setAttribute(SessionKeys.CURRENT_PLAYER_ID, playerId);
    }

    public void requireCurrentPlayer() {
        if (getCurrentPlayerId() == null) {
            throw new IllegalStateException("NenƒÇ¬≠ zvolen aktuƒÇÀálnƒÇ¬≠ hrƒÇÀá√Ñ≈§");
        }
    }

    public void clear() {
        session.removeAttribute(SessionKeys.CURRENT_PLAYER_ID);
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\PlayerSecurity.java
--------------------
package cz.phsoft.hokej.security;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.repositories.PlayerRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;
// - ZatƒÇ¬≠m nepouƒπƒæƒÇ¬≠vƒÇÀám - pouƒπƒæƒÇ¬≠vƒÇÀám /me
@Component("playerSecurity") // nƒÇÀázev pro pouƒπƒæitƒÇ¬≠ v SpEL (@PreAuthorize)
public class PlayerSecurity {

    private static final Logger logger = LoggerFactory.getLogger(PlayerSecurity.class);

    private final PlayerRepository playerRepository;

    public PlayerSecurity(PlayerRepository playerRepository) {
        this.playerRepository = playerRepository;
    }

    /**
     * ZjistƒÇ¬≠, zda je aktuƒÇÀáln√Ñ‚Ä∫ pƒπ‚Ñ¢ihlƒÇÀáƒπÀáenƒÇÀù uƒπƒæivatel vlastnƒÇ¬≠kem hrƒÇÀá√Ñ≈§e
     *
     * @param authentication aktuƒÇÀálnƒÇ¬≠ authentication objekt
     * @param playerId       ID hrƒÇÀá√Ñ≈§e
     * @return true pokud je vlastnƒÇ¬≠kem, jinak false
     */
    public boolean isOwner(Authentication authentication, Long playerId) {
        try {
            if (authentication == null || !authentication.isAuthenticated()) {
                logger.warn("NeautorizovanƒÇÀù pƒπ‚Ñ¢ƒÇ¬≠stup: ƒπƒæƒÇÀádnƒÇÀá autentizace pro playerId {}", playerId);
                return false;
            }

            Object principal = authentication.getPrincipal();
            if (!(principal instanceof UserDetails userDetails)) {
                logger.warn("NeautorizovanƒÇÀù pƒπ‚Ñ¢ƒÇ¬≠stup: principal nenƒÇ¬≠ UserDetails pro playerId {}", playerId);
                return false;
            }

            boolean isOwner = playerRepository.findById(playerId)
                    .map(player -> player.getUser() != null &&
                            player.getUser().getEmail().equals(userDetails.getUsername()))
                    .orElse(false);

            if (!isOwner) {
                logger.warn("NeautorizovanƒÇÀù pƒπ‚Ñ¢ƒÇ¬≠stup: uƒπƒæivatel {} nenƒÇ¬≠ vlastnƒÇ¬≠kem hrƒÇÀá√Ñ≈§e {}", userDetails.getUsername(), playerId);
            }

            return isOwner;

        } catch (Exception e) {
            logger.error("Chyba pƒπ‚Ñ¢i kontrole vlastnƒÇ¬≠ka hrƒÇÀá√Ñ≈§e {}: {}", playerId, e.getMessage(), e);
            // nikdy nepropustit vƒÇÀùjimku do SpEL
            return false;
        }
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\security\SessionKeys.java
--------------------
package cz.phsoft.hokej.security;

public final class SessionKeys {
    private SessionKeys() {}

    public static final String CURRENT_PLAYER_ID = "CURRENT_PLAYER_ID";
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\src\main\java\cz\phsoft\hokej\StaraGardaApplication.java
--------------------
package cz.phsoft.hokej;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableJpaRepositories // JPA v naƒπÀáem Spring Boot projektu
@EnableScheduling
@EnableAsync
public class StaraGardaApplication {
    public static void main(String[] args) {
        SpringApplication.run(StaraGardaApplication.class, args);


        }
    }
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\AppUserMapperImpl.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.AppUserEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.AppUserDTO;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2026-01-20T13:10:47+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class AppUserMapperImpl implements AppUserMapper {

    @Override
    public AppUserDTO toDTO(AppUserEntity entity) {
        if ( entity == null ) {
            return null;
        }

        AppUserDTO appUserDTO = new AppUserDTO();

        appUserDTO.setPlayers( playerEntitySetToPlayerDTOSet( entity.getPlayers() ) );
        appUserDTO.setId( entity.getId() );
        appUserDTO.setName( entity.getName() );
        appUserDTO.setSurname( entity.getSurname() );
        appUserDTO.setEmail( entity.getEmail() );
        appUserDTO.setRole( entity.getRole() );
        appUserDTO.setEnabled( entity.isEnabled() );

        return appUserDTO;
    }

    @Override
    public List<AppUserDTO> toDtoList(List<AppUserEntity> entities) {
        if ( entities == null ) {
            return null;
        }

        List<AppUserDTO> list = new ArrayList<AppUserDTO>( entities.size() );
        for ( AppUserEntity appUserEntity : entities ) {
            list.add( toDTO( appUserEntity ) );
        }

        return list;
    }

    @Override
    public PlayerDTO toPlayerDTO(PlayerEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerDTO playerDTO = new PlayerDTO();

        playerDTO.setNickName( entity.getNickname() );
        playerDTO.setId( entity.getId() );
        playerDTO.setName( entity.getName() );
        playerDTO.setSurname( entity.getSurname() );
        playerDTO.setType( entity.getType() );
        playerDTO.setTeam( entity.getTeam() );
        playerDTO.setPhoneNumber( entity.getPhoneNumber() );
        playerDTO.setStatus( entity.getStatus() );

        return playerDTO;
    }

    protected Set<PlayerDTO> playerEntitySetToPlayerDTOSet(Set<PlayerEntity> set) {
        if ( set == null ) {
            return null;
        }

        Set<PlayerDTO> set1 = new LinkedHashSet<PlayerDTO>( Math.max( (int) ( set.size() / .75f ) + 1, 16 ) );
        for ( PlayerEntity playerEntity : set ) {
            set1.add( toPlayerDTO( playerEntity ) );
        }

        return set1;
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchMapperImpl.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2026-01-20T13:10:46+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchMapperImpl implements MatchMapper {

    @Override
    public MatchDTO toDTO(MatchEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchDTO matchDTO = new MatchDTO();

        matchDTO.setId( entity.getId() );
        matchDTO.setDateTime( entity.getDateTime() );
        matchDTO.setLocation( entity.getLocation() );
        matchDTO.setDescription( entity.getDescription() );
        matchDTO.setMaxPlayers( entity.getMaxPlayers() );
        matchDTO.setPrice( entity.getPrice() );

        return matchDTO;
    }

    @Override
    public MatchEntity toEntity(MatchDTO dto) {
        if ( dto == null ) {
            return null;
        }

        MatchEntity matchEntity = new MatchEntity();

        matchEntity.setId( dto.getId() );
        matchEntity.setDateTime( dto.getDateTime() );
        matchEntity.setLocation( dto.getLocation() );
        matchEntity.setDescription( dto.getDescription() );
        matchEntity.setMaxPlayers( dto.getMaxPlayers() );
        matchEntity.setPrice( dto.getPrice() );

        return matchEntity;
    }

    @Override
    public void updateEntity(MatchDTO dto, MatchEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setDateTime( dto.getDateTime() );
        entity.setLocation( dto.getLocation() );
        entity.setDescription( dto.getDescription() );
        entity.setMaxPlayers( dto.getMaxPlayers() );
        entity.setPrice( dto.getPrice() );
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchRegistrationMapperImpl.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.data.enums.Team;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2026-01-20T13:10:47+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchRegistrationMapperImpl implements MatchRegistrationMapper {

    @Override
    public MatchRegistrationEntity toEntity(MatchEntity match, PlayerEntity player, PlayerMatchStatus status, ExcuseReason excuseReason, String note, Team team, String adminNote, String createdBy) {
        if ( match == null && player == null && status == null && excuseReason == null && note == null && team == null && adminNote == null && createdBy == null ) {
            return null;
        }

        MatchRegistrationEntity matchRegistrationEntity = new MatchRegistrationEntity();

        matchRegistrationEntity.setMatch( match );
        matchRegistrationEntity.setPlayer( player );
        matchRegistrationEntity.setStatus( status );
        matchRegistrationEntity.setExcuseReason( excuseReason );
        matchRegistrationEntity.setExcuseNote( note );
        matchRegistrationEntity.setTeam( team );
        matchRegistrationEntity.setAdminNote( adminNote );
        matchRegistrationEntity.setCreatedBy( createdBy );
        matchRegistrationEntity.setTimestamp( java.time.LocalDateTime.now() );

        return matchRegistrationEntity;
    }

    @Override
    public MatchRegistrationDTO toDTO(MatchRegistrationEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchRegistrationDTO matchRegistrationDTO = new MatchRegistrationDTO();

        matchRegistrationDTO.setMatchId( entityMatchId( entity ) );
        matchRegistrationDTO.setPlayerId( entityPlayerId( entity ) );
        matchRegistrationDTO.setId( entity.getId() );
        matchRegistrationDTO.setStatus( entity.getStatus() );
        matchRegistrationDTO.setExcuseReason( entity.getExcuseReason() );
        matchRegistrationDTO.setExcuseNote( entity.getExcuseNote() );
        matchRegistrationDTO.setAdminNote( entity.getAdminNote() );
        matchRegistrationDTO.setTeam( entity.getTeam() );
        matchRegistrationDTO.setCreatedBy( entity.getCreatedBy() );

        return matchRegistrationDTO;
    }

    @Override
    public List<MatchRegistrationDTO> toDTOList(List<MatchRegistrationEntity> entities) {
        if ( entities == null ) {
            return null;
        }

        List<MatchRegistrationDTO> list = new ArrayList<MatchRegistrationDTO>( entities.size() );
        for ( MatchRegistrationEntity matchRegistrationEntity : entities ) {
            list.add( toDTO( matchRegistrationEntity ) );
        }

        return list;
    }

    private Long entityMatchId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        MatchEntity match = matchRegistrationEntity.getMatch();
        if ( match == null ) {
            return null;
        }
        Long id = match.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }

    private Long entityPlayerId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        PlayerEntity player = matchRegistrationEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerInactivityPeriodMapperImpl.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2026-01-20T13:10:47+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerInactivityPeriodMapperImpl implements PlayerInactivityPeriodMapper {

    @Override
    public PlayerInactivityPeriodDTO toDTO(PlayerInactivityPeriodEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerInactivityPeriodDTO playerInactivityPeriodDTO = new PlayerInactivityPeriodDTO();

        playerInactivityPeriodDTO.setPlayerId( entityPlayerId( entity ) );
        playerInactivityPeriodDTO.setId( entity.getId() );
        playerInactivityPeriodDTO.setInactiveFrom( entity.getInactiveFrom() );
        playerInactivityPeriodDTO.setInactiveTo( entity.getInactiveTo() );

        return playerInactivityPeriodDTO;
    }

    @Override
    public PlayerInactivityPeriodEntity toEntity(PlayerInactivityPeriodDTO dto, PlayerEntity player) {
        if ( dto == null ) {
            return null;
        }

        PlayerInactivityPeriodEntity playerInactivityPeriodEntity = createEntity( dto, player );

        playerInactivityPeriodEntity.setInactiveFrom( dto.getInactiveFrom() );
        playerInactivityPeriodEntity.setInactiveTo( dto.getInactiveTo() );

        return playerInactivityPeriodEntity;
    }

    @Override
    public void updateEntityFromDto(PlayerInactivityPeriodDTO dto, PlayerInactivityPeriodEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setInactiveFrom( dto.getInactiveFrom() );
        entity.setInactiveTo( dto.getInactiveTo() );
    }

    private Long entityPlayerId(PlayerInactivityPeriodEntity playerInactivityPeriodEntity) {
        if ( playerInactivityPeriodEntity == null ) {
            return null;
        }
        PlayerEntity player = playerInactivityPeriodEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\backend\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerMapperImpl.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2026-01-20T13:10:47+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerMapperImpl implements PlayerMapper {

    @Override
    public PlayerDTO toDTO(PlayerEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerDTO playerDTO = new PlayerDTO();

        playerDTO.setNickName( entity.getNickname() );
        playerDTO.setId( entity.getId() );
        playerDTO.setName( entity.getName() );
        playerDTO.setSurname( entity.getSurname() );
        playerDTO.setType( entity.getType() );
        playerDTO.setTeam( entity.getTeam() );
        playerDTO.setPhoneNumber( entity.getPhoneNumber() );
        playerDTO.setStatus( entity.getStatus() );

        return playerDTO;
    }

    @Override
    public PlayerEntity toEntity(PlayerDTO dto) {
        if ( dto == null ) {
            return null;
        }

        PlayerEntity playerEntity = new PlayerEntity();

        playerEntity.setNickname( dto.getNickName() );
        playerEntity.setId( dto.getId() );
        playerEntity.setName( dto.getName() );
        playerEntity.setSurname( dto.getSurname() );
        playerEntity.setType( dto.getType() );
        playerEntity.setPhoneNumber( dto.getPhoneNumber() );
        playerEntity.setTeam( dto.getTeam() );
        playerEntity.setNickName( dto.getNickName() );

        playerEntity.setStatus( dto.getStatus() != null ? dto.getStatus() : cz.phsoft.hokej.data.enums.PlayerStatus.PENDING );

        return playerEntity;
    }

    @Override
    public void updatePlayerDTO(PlayerDTO source, PlayerDTO target) {
        if ( source == null ) {
            return;
        }

        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setNickName( source.getNickName() );
        target.setType( source.getType() );
        target.setTeam( source.getTeam() );
        target.setPhoneNumber( source.getPhoneNumber() );
        target.setStatus( source.getStatus() );
    }

    @Override
    public void updatePlayerEntity(PlayerDTO source, PlayerEntity target) {
        if ( source == null ) {
            return;
        }

        target.setNickname( source.getNickName() );
        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setType( source.getType() );
        target.setPhoneNumber( source.getPhoneNumber() );
        target.setTeam( source.getTeam() );
        target.setNickName( source.getNickName() );

        target.setStatus( source.getStatus() != null ? source.getStatus() : target.getStatus() );
    }

    @Override
    public List<PlayerDTO> toDTOList(List<PlayerEntity> players) {
        if ( players == null ) {
            return null;
        }

        List<PlayerDTO> list = new ArrayList<PlayerDTO>( players.size() );
        for ( PlayerEntity playerEntity : players ) {
            list.add( toDTO( playerEntity ) );
        }

        return list;
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchMapperImpl.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.models.dto.MatchDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-04T13:04:23+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchMapperImpl implements MatchMapper {

    @Override
    public MatchDTO toDTO(MatchEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchDTO matchDTO = new MatchDTO();

        matchDTO.setId( entity.getId() );
        matchDTO.setDateTime( entity.getDateTime() );
        matchDTO.setLocation( entity.getLocation() );
        matchDTO.setDescription( entity.getDescription() );
        matchDTO.setMaxPlayers( entity.getMaxPlayers() );
        matchDTO.setPrice( entity.getPrice() );

        return matchDTO;
    }

    @Override
    public MatchEntity toEntity(MatchDTO dto) {
        if ( dto == null ) {
            return null;
        }

        MatchEntity matchEntity = new MatchEntity();

        matchEntity.setId( dto.getId() );
        matchEntity.setDateTime( dto.getDateTime() );
        matchEntity.setLocation( dto.getLocation() );
        matchEntity.setDescription( dto.getDescription() );
        matchEntity.setMaxPlayers( dto.getMaxPlayers() );
        matchEntity.setPrice( dto.getPrice() );

        return matchEntity;
    }

    @Override
    public void updateEntity(MatchDTO dto, MatchEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setDateTime( dto.getDateTime() );
        entity.setLocation( dto.getLocation() );
        entity.setDescription( dto.getDescription() );
        entity.setMaxPlayers( dto.getMaxPlayers() );
        entity.setPrice( dto.getPrice() );
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\MatchRegistrationMapperImpl.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.MatchEntity;
import cz.phsoft.hokej.data.entities.MatchRegistrationEntity;
import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.enums.ExcuseReason;
import cz.phsoft.hokej.data.enums.JerseyColor;
import cz.phsoft.hokej.data.enums.PlayerMatchStatus;
import cz.phsoft.hokej.models.dto.MatchRegistrationDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-04T13:04:22+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class MatchRegistrationMapperImpl implements MatchRegistrationMapper {

    @Override
    public MatchRegistrationEntity toEntity(MatchEntity match, PlayerEntity player, PlayerMatchStatus status, ExcuseReason excuseReason, String note, JerseyColor jerseyColor, String adminNote, String createdBy) {
        if ( match == null && player == null && status == null && excuseReason == null && note == null && jerseyColor == null && adminNote == null && createdBy == null ) {
            return null;
        }

        MatchRegistrationEntity matchRegistrationEntity = new MatchRegistrationEntity();

        matchRegistrationEntity.setMatch( match );
        matchRegistrationEntity.setPlayer( player );
        matchRegistrationEntity.setStatus( status );
        matchRegistrationEntity.setExcuseReason( excuseReason );
        matchRegistrationEntity.setExcuseNote( note );
        matchRegistrationEntity.setJerseyColor( jerseyColor );
        matchRegistrationEntity.setAdminNote( adminNote );
        matchRegistrationEntity.setCreatedBy( createdBy );
        matchRegistrationEntity.setTimestamp( java.time.LocalDateTime.now() );

        return matchRegistrationEntity;
    }

    @Override
    public MatchRegistrationDTO toDTO(MatchRegistrationEntity entity) {
        if ( entity == null ) {
            return null;
        }

        MatchRegistrationDTO matchRegistrationDTO = new MatchRegistrationDTO();

        matchRegistrationDTO.setMatchId( entityMatchId( entity ) );
        matchRegistrationDTO.setPlayerId( entityPlayerId( entity ) );
        matchRegistrationDTO.setId( entity.getId() );
        matchRegistrationDTO.setStatus( entity.getStatus() );
        matchRegistrationDTO.setExcuseReason( entity.getExcuseReason() );
        matchRegistrationDTO.setExcuseNote( entity.getExcuseNote() );
        matchRegistrationDTO.setAdminNote( entity.getAdminNote() );
        matchRegistrationDTO.setJerseyColor( entity.getJerseyColor() );
        matchRegistrationDTO.setCreatedBy( entity.getCreatedBy() );

        return matchRegistrationDTO;
    }

    private Long entityMatchId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        MatchEntity match = matchRegistrationEntity.getMatch();
        if ( match == null ) {
            return null;
        }
        Long id = match.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }

    private Long entityPlayerId(MatchRegistrationEntity matchRegistrationEntity) {
        if ( matchRegistrationEntity == null ) {
            return null;
        }
        PlayerEntity player = matchRegistrationEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerInactivityPeriodMapperImpl.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.data.entities.PlayerInactivityPeriodEntity;
import cz.phsoft.hokej.models.dto.PlayerInactivityPeriodDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-04T13:04:23+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerInactivityPeriodMapperImpl implements PlayerInactivityPeriodMapper {

    @Override
    public PlayerInactivityPeriodDTO toDTO(PlayerInactivityPeriodEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerInactivityPeriodDTO playerInactivityPeriodDTO = new PlayerInactivityPeriodDTO();

        playerInactivityPeriodDTO.setPlayerId( entityPlayerId( entity ) );
        playerInactivityPeriodDTO.setId( entity.getId() );
        playerInactivityPeriodDTO.setInactiveFrom( entity.getInactiveFrom() );
        playerInactivityPeriodDTO.setInactiveTo( entity.getInactiveTo() );

        return playerInactivityPeriodDTO;
    }

    @Override
    public PlayerInactivityPeriodEntity toEntity(PlayerInactivityPeriodDTO dto, PlayerEntity player) {
        if ( dto == null ) {
            return null;
        }

        PlayerInactivityPeriodEntity playerInactivityPeriodEntity = createEntity( dto, player );

        playerInactivityPeriodEntity.setInactiveFrom( dto.getInactiveFrom() );
        playerInactivityPeriodEntity.setInactiveTo( dto.getInactiveTo() );

        return playerInactivityPeriodEntity;
    }

    @Override
    public void updateEntityFromDto(PlayerInactivityPeriodDTO dto, PlayerInactivityPeriodEntity entity) {
        if ( dto == null ) {
            return;
        }

        entity.setId( dto.getId() );
        entity.setInactiveFrom( dto.getInactiveFrom() );
        entity.setInactiveTo( dto.getInactiveTo() );
    }

    private Long entityPlayerId(PlayerInactivityPeriodEntity playerInactivityPeriodEntity) {
        if ( playerInactivityPeriodEntity == null ) {
            return null;
        }
        PlayerEntity player = playerInactivityPeriodEntity.getPlayer();
        if ( player == null ) {
            return null;
        }
        Long id = player.getId();
        if ( id == null ) {
            return null;
        }
        return id;
    }
}
--------------------
C:\Projekty Pr√°ce\StaraGarda\target\generated-sources\annotations\cz\phsoft\hokej\models\dto\mappers\PlayerMapperImpl.java
--------------------
package cz.phsoft.hokej.models.dto.mappers;

import cz.phsoft.hokej.data.entities.PlayerEntity;
import cz.phsoft.hokej.models.dto.PlayerDTO;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-12-04T13:04:23+0100",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 19.0.2 (Amazon.com Inc.)"
)
@Component
public class PlayerMapperImpl implements PlayerMapper {

    @Override
    public PlayerDTO toDTO(PlayerEntity entity) {
        if ( entity == null ) {
            return null;
        }

        PlayerDTO playerDTO = new PlayerDTO();

        playerDTO.setId( entity.getId() );
        playerDTO.setName( entity.getName() );
        playerDTO.setSurname( entity.getSurname() );
        playerDTO.setType( entity.getType() );
        playerDTO.setJerseyColor( entity.getJerseyColor() );

        return playerDTO;
    }

    @Override
    public PlayerEntity toEntity(PlayerDTO dto) {
        if ( dto == null ) {
            return null;
        }

        PlayerEntity playerEntity = new PlayerEntity();

        playerEntity.setId( dto.getId() );
        playerEntity.setName( dto.getName() );
        playerEntity.setSurname( dto.getSurname() );
        playerEntity.setType( dto.getType() );
        playerEntity.setJerseyColor( dto.getJerseyColor() );

        return playerEntity;
    }

    @Override
    public void updatePlayerDTO(PlayerDTO source, PlayerDTO target) {
        if ( source == null ) {
            return;
        }

        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setType( source.getType() );
        target.setJerseyColor( source.getJerseyColor() );
    }

    @Override
    public void updatePlayerEntity(PlayerDTO source, PlayerEntity target) {
        if ( source == null ) {
            return;
        }

        target.setId( source.getId() );
        target.setName( source.getName() );
        target.setSurname( source.getSurname() );
        target.setType( source.getType() );
        target.setJerseyColor( source.getJerseyColor() );
    }
}
